{
  "name": "nodetool-base",
  "description": "Nodetool Base nodes",
  "version": "0.6.0",
  "authors": [
    "Matthias Georgi <matti.georgi@gmail.com>"
  ],
  "repo_id": "",
  "nodes": [
    {
      "title": "Audio Classification",
      "description": "Audio classification node using HuggingFace Inference API. Assigns a label or class to audio data.\n    audio, classification, huggingface, inference",
      "namespace": "huggingface_hub",
      "node_type": "huggingface_hub.AudioClassification",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "inference_provider_audio_classification_model"
          },
          "default": {
            "type": "inference_provider_audio_classification_model",
            "provider": "fal-ai",
            "model_id": "superb/hubert-base-superb-er"
          },
          "title": "Model",
          "description": "The model to use for audio classification"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio to classify"
        },
        {
          "name": "function_to_apply",
          "type": {
            "type": "enum",
            "values": [
              "sigmoid",
              "softmax",
              "none"
            ],
            "type_name": "nodetool.nodes.huggingface_hub.AudioClassification.OutputTransform"
          },
          "default": "none",
          "title": "Function To Apply",
          "description": "The function to apply to the model outputs"
        },
        {
          "name": "top_k",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Top K",
          "description": "The number of top predictions to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "audio",
        "function_to_apply",
        "top_k"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Image Classification",
      "description": "Image classification node using HuggingFace Inference API. Assigns a label or class to image data.\n    image, classification, huggingface, inference",
      "namespace": "huggingface_hub",
      "node_type": "huggingface_hub.ImageClassification",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "inference_provider_image_classification_model"
          },
          "default": {
            "type": "inference_provider_image_classification_model",
            "provider": "hf-inference",
            "model_id": "google/vit-base-patch16-224"
          },
          "title": "Model",
          "description": "The model to use for image classification"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to classify"
        },
        {
          "name": "function_to_apply",
          "type": {
            "type": "enum",
            "values": [
              "sigmoid",
              "softmax",
              "none"
            ],
            "type_name": "nodetool.nodes.huggingface_hub.ImageClassification.OutputTransform"
          },
          "default": "none",
          "title": "Function To Apply",
          "description": "The function to apply to the model outputs"
        },
        {
          "name": "top_k",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Top K",
          "description": "The number of top predictions to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "image",
        "function_to_apply",
        "top_k"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Image Segmentation",
      "description": "Image segmentation node using HuggingFace Inference API. Divides an image into segments where each pixel is mapped to an object.\n    image, segmentation, huggingface, inference",
      "namespace": "huggingface_hub",
      "node_type": "huggingface_hub.ImageSegmentation",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "inference_provider_image_segmentation_model"
          },
          "default": {
            "type": "inference_provider_image_segmentation_model",
            "provider": "hf-inference",
            "model_id": "openmmlab/upernet-convnext-small"
          },
          "title": "Model",
          "description": "The model to use for image segmentation"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to segment"
        },
        {
          "name": "mask_threshold",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Mask Threshold",
          "description": "Threshold to use when turning the predicted masks into binary values"
        },
        {
          "name": "overlap_mask_area_threshold",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Overlap Mask Area Threshold",
          "description": "Mask overlap threshold to eliminate small, disconnected segments"
        },
        {
          "name": "subtask",
          "type": {
            "type": "enum",
            "values": [
              "instance",
              "panoptic",
              "semantic"
            ],
            "type_name": "nodetool.nodes.huggingface_hub.ImageSegmentation.Subtask"
          },
          "default": "semantic",
          "title": "Subtask",
          "description": "The segmentation subtask to perform"
        },
        {
          "name": "threshold",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Threshold",
          "description": "Probability threshold to filter out predicted masks"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image_segmentation_result"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "image",
        "mask_threshold",
        "overlap_mask_area_threshold",
        "subtask",
        "threshold"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Summarization",
      "description": "Summarization node using HuggingFace Inference API. Produces a shorter version of a document while preserving its important information. Some models can extract text from the original input, while others can generate entirely new text.\n    summarization, huggingface, inference",
      "namespace": "huggingface_hub",
      "node_type": "huggingface_hub.Summarization",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "inference_provider_summarization_model"
          },
          "default": {
            "type": "inference_provider_summarization_model",
            "provider": "hf-inference",
            "model_id": "facebook/bart-large-cnn"
          },
          "title": "Model",
          "description": "The model to use for summarization"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The input text to summarize"
        },
        {
          "name": "clean_up_tokenization_spaces",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Clean Up Tokenization Spaces",
          "description": "Whether to clean up the potential extra spaces in the text output"
        },
        {
          "name": "truncation",
          "type": {
            "type": "enum",
            "values": [
              "do_not_truncate",
              "longest_first",
              "only_first",
              "only_second"
            ],
            "type_name": "nodetool.nodes.huggingface_hub.Summarization.Truncation"
          },
          "default": "do_not_truncate",
          "title": "Truncation",
          "description": "Truncation strategy for the input text"
        },
        {
          "name": "max_length",
          "type": {
            "type": "int"
          },
          "default": 150,
          "title": "Max Length",
          "description": "Maximum length of the generated summary",
          "min": 1.0
        },
        {
          "name": "min_length",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Min Length",
          "description": "Minimum length of the generated summary",
          "min": 1.0
        },
        {
          "name": "num_beams",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Num Beams",
          "description": "Number of beams for beam search. 1 means no beam search",
          "min": 1.0
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Temperature",
          "description": "The value used to modulate the logits distribution",
          "min": 0.1,
          "max": 2.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "text",
        "clean_up_tokenization_spaces",
        "truncation",
        "max_length",
        "min_length",
        "num_beams",
        "temperature"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Text Classification",
      "description": "Text classification node using HuggingFace Inference API. Assigns a label or class to given text. Use cases include sentiment analysis, natural language inference, and assessing grammatical correctness.\n    text, sentiment, classification, natural language, inference, grammatical correctness, huggingface, inference",
      "namespace": "huggingface_hub",
      "node_type": "huggingface_hub.TextClassification",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "inference_provider_text_classification_model"
          },
          "default": {
            "type": "inference_provider_text_classification_model",
            "provider": "hf-inference",
            "model_id": "distilbert/distilbert-base-uncased-finetuned-sst-2-english"
          },
          "title": "Model",
          "description": "The model to use for text classification"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to classify"
        },
        {
          "name": "function_to_apply",
          "type": {
            "type": "enum",
            "values": [
              "sigmoid",
              "softmax",
              "none"
            ],
            "type_name": "nodetool.nodes.huggingface_hub.TextClassification.OutputTransform"
          },
          "default": "none",
          "title": "Function To Apply",
          "description": "The function to apply to the model outputs"
        },
        {
          "name": "top_k",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Top K",
          "description": "When specified, limits the output to the top K most probable classes"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "text",
        "function_to_apply",
        "top_k"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Translation",
      "description": "Translation node using HuggingFace Inference API. Converts text from one language to another.\n    translation, huggingface, inference",
      "namespace": "huggingface_hub",
      "node_type": "huggingface_hub.Translation",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "inference_provider_translation_model"
          },
          "default": {
            "type": "inference_provider_translation_model",
            "provider": "hf-inference",
            "model_id": "google-t5/t5-base"
          },
          "title": "Model",
          "description": "The model to use for translation"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to translate"
        },
        {
          "name": "src_lang",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Src Lang",
          "description": "The source language of the text. Required for models that can translate from multiple languages"
        },
        {
          "name": "tgt_lang",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Tgt Lang",
          "description": "Target language to translate to. Required for models that can translate to multiple languages"
        },
        {
          "name": "clean_up_tokenization_spaces",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Clean Up Tokenization Spaces",
          "description": "Whether to clean up the potential extra spaces in the text output"
        },
        {
          "name": "truncation",
          "type": {
            "type": "enum",
            "values": [
              "do_not_truncate",
              "longest_first",
              "only_first",
              "only_second"
            ],
            "type_name": "nodetool.nodes.huggingface_hub.Translation.Truncation"
          },
          "default": "do_not_truncate",
          "title": "Truncation",
          "description": "Truncation strategy for the input text"
        },
        {
          "name": "max_length",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Max Length",
          "description": "Maximum length of the generated translation",
          "min": 1.0
        },
        {
          "name": "num_beams",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Num Beams",
          "description": "Number of beams for beam search. 1 means no beam search",
          "min": 1.0
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Temperature",
          "description": "The value used to modulate the logits distribution",
          "min": 0.1,
          "max": 2.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "text",
        "src_lang",
        "tgt_lang",
        "clean_up_tokenization_spaces",
        "truncation",
        "max_length",
        "num_beams",
        "temperature"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Append",
      "description": "Adds a value to the end of a list.\n    list, add, insert, extend\n\n    Use cases:\n    - Grow a list dynamically\n    - Add new elements to an existing list\n    - Implement a stack-like structure",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Append",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "value"
      ]
    },
    {
      "title": "Average",
      "description": "Calculates the arithmetic mean of a list of numbers.\n    list, average, mean, aggregate, math\n\n    Use cases:\n    - Find average value\n    - Calculate mean of numeric data",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Average",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Chunk",
      "description": "Splits a list into smaller chunks of specified size.\n    list, chunk, split, group\n\n    Use cases:\n    - Batch processing\n    - Pagination\n    - Creating sublists of fixed size",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Chunk",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Chunk Size"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "list",
                "type_args": [
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "chunk_size"
      ]
    },
    {
      "title": "Dedupe",
      "description": "Removes duplicate elements from a list, ensuring uniqueness.\n    list, unique, distinct, deduplicate\n\n    Use cases:\n    - Remove redundant entries\n    - Create a set-like structure\n    - Ensure list elements are unique",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Dedupe",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Difference",
      "description": "Finds elements that exist in first list but not in second list.\n    list, set, difference, subtract\n\n    Use cases:\n    - Find unique elements in one list\n    - Remove items present in another list\n    - Identify distinct elements",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Difference",
      "properties": [
        {
          "name": "list1",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List1"
        },
        {
          "name": "list2",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List2"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "list1",
        "list2"
      ]
    },
    {
      "title": "Extend",
      "description": "Merges one list into another, extending the original list.\n    list, merge, concatenate, combine\n\n    Use cases:\n    - Combine multiple lists\n    - Add all elements from one list to another",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Extend",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "other_values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Other Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "other_values"
      ]
    },
    {
      "title": "Filter Dicts",
      "description": "Filter a list of dictionaries based on a condition.\n    list, filter, query, condition\n\n    Basic Operators:\n    - Comparison: >, <, >=, <=, ==, !=\n    - Logical: and, or, not\n    - Membership: in, not in\n\n    Example Conditions:\n    # Basic comparisons\n    age > 30\n    price <= 100\n    status == 'active'\n\n    # Multiple conditions\n    age > 30 and salary < 50000\n    (price >= 100) and (price <= 200)\n    department in ['Sales', 'Marketing']\n\n    # String operations\n    name.str.startswith('J')\n    email.str.contains('@company.com')\n\n    # Datetime conditions\n    date > '2024-01-01'\n    date.dt.year == 2024\n    date.dt.month >= 6\n    date.dt.day_name() == 'Monday'\n\n    # Date ranges\n    date.between('2024-01-01', '2024-12-31')\n    date >= '2024-01-01' and date < '2025-01-01'\n\n    # Complex datetime\n    date.dt.hour < 12\n    date.dt.dayofweek <= 4  # Weekdays only\n\n    # Numeric operations\n    price.between(100, 200)\n    quantity % 2 == 0  # Even numbers\n\n    # Special values\n    value.isna()  # Check for NULL/NaN\n    value.notna()  # Check for non-NULL/non-NaN\n\n    Note: Dates should be in ISO format (YYYY-MM-DD) or include time (YYYY-MM-DD HH:MM:SS)\n\n    Use cases:\n    - Filter list of dictionary objects based on criteria\n    - Extract subset of data meeting specific conditions\n    - Clean data by removing unwanted entries",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterDicts",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "condition",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Condition",
          "description": "\n        The filtering condition using pandas query syntax.\n\n        Basic Operators:\n        - Comparison: >, <, >=, <=, ==, !=\n        - Logical: and, or, not\n        - Membership: in, not in\n        \n        Example Conditions:\n        # Basic comparisons\n        age > 30\n        price <= 100\n        status == 'active'\n        \n        See node documentation for more examples.\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "condition"
      ]
    },
    {
      "title": "Filter Dicts By Number",
      "description": "Filters a list of dictionaries based on numeric values for a specified key.\n    list, filter, dictionary, numbers, numeric\n\n    Use cases:\n    - Filter dictionaries by numeric comparisons (greater than, less than, equal to)\n    - Filter records with even/odd numeric values\n    - Filter entries with positive/negative numbers",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterDictsByNumber",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key"
        },
        {
          "name": "filter_type",
          "type": {
            "type": "enum",
            "values": [
              "greater_than",
              "less_than",
              "equal_to",
              "even",
              "odd",
              "positive",
              "negative"
            ],
            "type_name": "nodetool.nodes.nodetool.list.FilterDictsByNumber.FilterDictNumberType"
          },
          "default": "greater_than",
          "title": "Filter Type"
        },
        {
          "name": "value",
          "type": {
            "type": "float",
            "optional": true
          },
          "default": null,
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "key",
        "filter_type",
        "value"
      ]
    },
    {
      "title": "Filter Dicts By Range",
      "description": "Filters a list of dictionaries based on a numeric range for a specified key.\n    list, filter, dictionary, range, between\n\n    Use cases:\n    - Filter records based on numeric ranges (e.g., price range, age range)\n    - Find entries with values within specified bounds\n    - Filter data sets based on numeric criteria",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterDictsByRange",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key",
          "description": "The dictionary key to check for the range"
        },
        {
          "name": "min_value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Min Value",
          "description": "The minimum value (inclusive) of the range"
        },
        {
          "name": "max_value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Max Value",
          "description": "The maximum value (inclusive) of the range"
        },
        {
          "name": "inclusive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Inclusive",
          "description": "If True, includes the min and max values in the results"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "key",
        "min_value",
        "max_value",
        "inclusive"
      ]
    },
    {
      "title": "Filter Dicts By Value",
      "description": "Filters a list of dictionaries based on their values using various criteria.\n    list, filter, dictionary, values\n\n    Use cases:\n    - Filter dictionaries by value content\n    - Filter dictionaries by value type\n    - Filter dictionaries by value patterns",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterDictsByValue",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key",
          "description": "The dictionary key to check"
        },
        {
          "name": "filter_type",
          "type": {
            "type": "enum",
            "values": [
              "contains",
              "starts_with",
              "ends_with",
              "equals",
              "type_is",
              "length_greater",
              "length_less",
              "exact_length"
            ],
            "type_name": "nodetool.nodes.nodetool.list.FilterDictsByValue.FilterType"
          },
          "default": "contains",
          "title": "Filter Type",
          "description": "The type of filter to apply"
        },
        {
          "name": "criteria",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Criteria",
          "description": "The filtering criteria (text to match, type name, or length as string)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "key",
        "filter_type",
        "criteria"
      ]
    },
    {
      "title": "Filter Dicts Regex",
      "description": "Filters a list of dictionaries using regular expressions on specified keys.\n    list, filter, regex, dictionary, pattern\n\n    Use cases:\n    - Filter dictionaries with values matching complex patterns\n    - Search for dictionaries containing emails, dates, or specific formats\n    - Advanced text pattern matching across dictionary values",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterDictsRegex",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern"
        },
        {
          "name": "full_match",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Full Match"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "key",
        "pattern",
        "full_match"
      ]
    },
    {
      "title": "Filter None",
      "description": "Filters out None values from a list.\n    list, filter, none, null\n\n    Use cases:\n    - Clean data by removing null values\n    - Get only valid entries\n    - Remove placeholder values",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterNone",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Filter Number Range",
      "description": "Filters a list of numbers to find values within a specified range.\n    list, filter, numbers, range, between\n\n    Use cases:\n    - Find numbers within a specific range\n    - Filter data points within bounds\n    - Implement range-based filtering",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterNumberRange",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "min_value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Min Value"
        },
        {
          "name": "max_value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Max Value"
        },
        {
          "name": "inclusive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Inclusive"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "min_value",
        "max_value",
        "inclusive"
      ]
    },
    {
      "title": "Filter Numbers",
      "description": "Filters a list of numbers based on various numerical conditions.\n    list, filter, numbers, numeric\n\n    Use cases:\n    - Filter numbers by comparison (greater than, less than, equal to)\n    - Filter even/odd numbers\n    - Filter positive/negative numbers",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterNumbers",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "filter_type",
          "type": {
            "type": "enum",
            "values": [
              "greater_than",
              "less_than",
              "equal_to",
              "even",
              "odd",
              "positive",
              "negative"
            ],
            "type_name": "nodetool.nodes.nodetool.list.FilterNumbers.FilterNumberType"
          },
          "default": "greater_than",
          "title": "Filter Type",
          "description": "The type of filter to apply"
        },
        {
          "name": "value",
          "type": {
            "type": "float",
            "optional": true
          },
          "default": null,
          "title": "Value",
          "description": "The comparison value (for greater_than, less_than, equal_to)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "filter_type",
        "value"
      ]
    },
    {
      "title": "Filter Regex",
      "description": "Filters a list of strings using regular expressions.\n    list, filter, regex, pattern, text\n\n    Use cases:\n    - Filter strings using complex patterns\n    - Extract strings matching specific formats (emails, dates, etc.)\n    - Advanced text pattern matching",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterRegex",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "The regular expression pattern to match against."
        },
        {
          "name": "full_match",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Full Match",
          "description": "Whether to match the entire string or find pattern anywhere in string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "pattern",
        "full_match"
      ]
    },
    {
      "title": "Filter Strings",
      "description": "Filters a list of strings based on various criteria.\n    list, filter, strings, text\n\n    Use cases:\n    - Filter strings by length\n    - Filter strings containing specific text\n    - Filter strings by prefix/suffix\n    - Filter strings using regex patterns",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterStrings",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "filter_type",
          "type": {
            "type": "enum",
            "values": [
              "contains",
              "starts_with",
              "ends_with",
              "length_greater",
              "length_less",
              "exact_length"
            ],
            "type_name": "nodetool.nodes.nodetool.list.FilterStrings.FilterType"
          },
          "default": "contains",
          "title": "Filter Type",
          "description": "The type of filter to apply"
        },
        {
          "name": "criteria",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Criteria",
          "description": "The filtering criteria (text to match or length as string)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "filter_type",
        "criteria"
      ]
    },
    {
      "title": "Flatten",
      "description": "Flattens a nested list structure into a single flat list.\n    list, flatten, nested, structure\n\n    Use cases:\n    - Convert nested lists into a single flat list\n    - Simplify complex list structures\n    - Process hierarchical data as a sequence\n\n    Examples:\n    [[1, 2], [3, 4]] -> [1, 2, 3, 4]\n    [[1, [2, 3]], [4, [5, 6]]] -> [1, 2, 3, 4, 5, 6]",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Flatten",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "max_depth",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Max Depth",
          "min": -1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "max_depth"
      ]
    },
    {
      "title": "Generate Sequence",
      "description": "Iterates over a sequence of numbers.\n    list, range, sequence, numbers",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.GenerateSequence",
      "properties": [
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start"
        },
        {
          "name": "stop",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Stop"
        },
        {
          "name": "step",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Step"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "start",
        "stop",
        "step"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Get Element",
      "description": "Retrieves a single value from a list at a specific index.\n    list, get, extract, value\n\n    Use cases:\n    - Access a specific element by position\n    - Implement array-like indexing\n    - Extract the first or last element",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.GetElement",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "index",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Index"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "index"
      ]
    },
    {
      "title": "Intersection",
      "description": "Finds common elements between two lists.\n    list, set, intersection, common\n\n    Use cases:\n    - Find elements present in both lists\n    - Identify shared items between collections\n    - Filter for matching elements",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Intersection",
      "properties": [
        {
          "name": "list1",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List1"
        },
        {
          "name": "list2",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List2"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "list1",
        "list2"
      ]
    },
    {
      "title": "Length",
      "description": "Calculates the length of a list.\n    list, count, size\n\n    Use cases:\n    - Determine the number of elements in a list\n    - Check if a list is empty\n    - Validate list size constraints",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Length",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "List Range",
      "description": "Generates a list of integers within a specified range.\n    list, range, sequence, numbers\n\n    Use cases:\n    - Create numbered lists\n    - Generate index sequences\n    - Produce arithmetic progressions",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.ListRange",
      "properties": [
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start"
        },
        {
          "name": "stop",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Stop"
        },
        {
          "name": "step",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Step"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "start",
        "stop",
        "step"
      ]
    },
    {
      "title": "Map Field",
      "description": "Extracts a specific field from a list of dictionaries or objects.\n    list, map, field, extract, pluck\n\n    Use cases:\n    - Extract specific fields from a list of objects\n    - Transform complex data structures into simple lists\n    - Collect values for a particular key across multiple dictionaries",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.MapField",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "union",
                "type_args": [
                  {
                    "type": "dict"
                  },
                  {
                    "type": "object"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "field",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Field"
        },
        {
          "name": "default",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "Default"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "field",
        "default"
      ]
    },
    {
      "title": "Maximum",
      "description": "Finds the largest value in a list of numbers.\n    list, max, maximum, aggregate, math\n\n    Use cases:\n    - Find highest value\n    - Get largest number in dataset",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Maximum",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Minimum",
      "description": "Finds the smallest value in a list of numbers.\n    list, min, minimum, aggregate, math\n\n    Use cases:\n    - Find lowest value\n    - Get smallest number in dataset",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Minimum",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Product",
      "description": "Calculates the product of all numbers in a list.\n    list, product, multiply, aggregate, math\n\n    Use cases:\n    - Multiply all numbers together\n    - Calculate compound values",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Product",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Randomize",
      "description": "Randomly shuffles the elements of a list.\n    list, shuffle, random, order\n\n    Use cases:\n    - Randomize the order of items in a playlist\n    - Implement random sampling without replacement\n    - Create randomized data sets for testing",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Randomize",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Reverse",
      "description": "Inverts the order of elements in a list.\n    list, reverse, invert, flip\n\n    Use cases:\n    - Reverse the order of a sequence",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Reverse",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Save List",
      "description": "Saves a list to a text file, placing each element on a new line.\n    list, save, file, serialize\n\n    Use cases:\n    - Export list data to a file\n    - Create a simple text-based database\n    - Generate line-separated output",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.SaveList",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "text.txt",
          "title": "Name",
          "description": "\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "text"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "name"
      ]
    },
    {
      "title": "Select Elements",
      "description": "Selects specific values from a list using index positions.\n    list, select, index, extract\n\n    Use cases:\n    - Pick specific elements by their positions\n    - Rearrange list elements\n    - Create a new list from selected indices",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.SelectElements",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "indices",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "int"
              }
            ]
          },
          "default": [],
          "title": "Indices"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "indices"
      ]
    },
    {
      "title": "Slice",
      "description": "Extracts a subset from a list using start, stop, and step indices.\n    list, slice, subset, extract\n\n    Use cases:\n    - Get a portion of a list\n    - Implement pagination\n    - Extract every nth element",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Slice",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start"
        },
        {
          "name": "stop",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Stop"
        },
        {
          "name": "step",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Step"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "start",
        "stop",
        "step"
      ]
    },
    {
      "title": "Sort",
      "description": "Sorts the elements of a list in ascending or descending order.\n    list, sort, order, arrange\n\n    Use cases:\n    - Organize data in a specific order\n    - Prepare data for binary search or other algorithms\n    - Rank items based on their values",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Sort",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "order",
          "type": {
            "type": "enum",
            "values": [
              "ascending",
              "descending"
            ],
            "type_name": "nodetool.nodes.nodetool.list.Sort.SortOrder"
          },
          "default": "ascending",
          "title": "Order"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "order"
      ]
    },
    {
      "title": "Sum",
      "description": "Calculates the sum of a list of numbers.\n    list, sum, aggregate, math\n\n    Use cases:\n    - Calculate total of numeric values\n    - Add up all elements in a list",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Sum",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Transform",
      "description": "Applies a transformation to each element in a list.\n    list, transform, map, convert\n\n    Use cases:\n    - Convert types (str to int, etc.)\n    - Apply formatting\n    - Mathematical operations",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Transform",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "transform_type",
          "type": {
            "type": "enum",
            "values": [
              "to_int",
              "to_float",
              "to_string",
              "uppercase",
              "lowercase",
              "strip"
            ],
            "type_name": "nodetool.nodes.nodetool.list.Transform.TransformType"
          },
          "default": "to_string",
          "title": "Transform Type"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "transform_type"
      ]
    },
    {
      "title": "Union",
      "description": "Combines unique elements from two lists.\n    list, set, union, combine\n\n    Use cases:\n    - Merge lists while removing duplicates\n    - Combine collections uniquely\n    - Create comprehensive set of items",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Union",
      "properties": [
        {
          "name": "list1",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List1"
        },
        {
          "name": "list2",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List2"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "list1",
        "list2"
      ]
    },
    {
      "title": "Collect",
      "description": "Collect items until the end of the stream and return them as a list.\n    collector, aggregate, list, stream\n\n    Use cases:\n    - Gather results from multiple processing steps\n    - Collect streaming data into batches\n    - Aggregate outputs from parallel operations",
      "namespace": "nodetool.control",
      "node_type": "nodetool.control.Collect",
      "properties": [
        {
          "name": "input_item",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "Input Item",
          "description": "The input item to collect."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_item"
      ]
    },
    {
      "title": "For Each",
      "description": "Iterate over a list and emit each item sequentially.\n    iterator, loop, list, sequence\n\n    Use cases:\n    - Process each item of a collection in order\n    - Drive downstream nodes with individual elements",
      "namespace": "nodetool.control",
      "node_type": "nodetool.control.ForEach",
      "properties": [
        {
          "name": "input_list",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Input List",
          "description": "The list of items to iterate over."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "index"
        }
      ],
      "basic_fields": [
        "input_list"
      ],
      "is_streaming_output": true
    },
    {
      "title": "If",
      "description": "Conditionally executes one of two branches based on a condition.\n    control, flow, condition, logic, else, true, false, switch, toggle, flow-control\n\n    Use cases:\n    - Branch workflow based on conditions\n    - Handle different cases in data processing\n    - Implement decision logic",
      "namespace": "nodetool.control",
      "node_type": "nodetool.control.If",
      "properties": [
        {
          "name": "condition",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Condition",
          "description": "The condition to evaluate"
        },
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "Value",
          "description": "The value to pass to the next node"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "if_true"
        },
        {
          "type": {
            "type": "any"
          },
          "name": "if_false"
        }
      ],
      "basic_fields": [
        "condition",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Reroute",
      "description": "Pass data through unchanged for tidier workflow layouts.\n    reroute, passthrough, organize, tidy, flow, connection, redirect\n\n    Use cases:\n    - Organize complex workflows by routing connections\n    - Create cleaner visual layouts\n    - Redirect data flow without modification",
      "namespace": "nodetool.control",
      "node_type": "nodetool.control.Reroute",
      "properties": [
        {
          "name": "input_value",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "Input Value",
          "description": "Value to pass through unchanged"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Execute Bash",
      "description": "Executes Bash script with safety restrictions.\n    bash, shell, code, execute",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecuteBash",
      "properties": [
        {
          "name": "code",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Code",
          "description": "Bash script to execute as-is. Dynamic inputs are provided as env vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'."
        },
        {
          "name": "image",
          "type": {
            "type": "enum",
            "values": [
              "bash:5.2",
              "debian:12",
              "ubuntu:22.04",
              "ubuntu:24.04",
              "jupyter/scipy-notebook:latest"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecuteBash.BashImage"
          },
          "default": "ubuntu:22.04",
          "title": "Image",
          "description": "Docker image to use for execution"
        },
        {
          "name": "execution_mode",
          "type": {
            "type": "enum",
            "values": [
              "docker",
              "subprocess"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutionMode"
          },
          "default": "docker",
          "title": "Execution Mode",
          "description": "Execution mode: 'docker' or 'subprocess'"
        },
        {
          "name": "stdin",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Stdin",
          "description": "String to write to process stdin before any streaming input. Use newlines to separate lines."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "code",
        "image",
        "execution_mode",
        "stdin"
      ],
      "is_dynamic": true,
      "is_streaming_output": true,
      "supports_dynamic_outputs": true
    },
    {
      "title": "Execute Command",
      "description": "Executes a single shell command inside a Docker container.\n    command, execute, shell, bash, sh\n\n    IMPORTANT: Only enabled in non-production environments",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecuteCommand",
      "properties": [
        {
          "name": "command",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Command",
          "description": "Single command to run via the selected shell. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'."
        },
        {
          "name": "image",
          "type": {
            "type": "enum",
            "values": [
              "bash:5.2",
              "alpine:3",
              "ubuntu:22.04",
              "ubuntu:24.04"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecuteCommand.CommandImage"
          },
          "default": "bash:5.2",
          "title": "Image",
          "description": "Docker image to use for execution"
        },
        {
          "name": "execution_mode",
          "type": {
            "type": "enum",
            "values": [
              "docker",
              "subprocess"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutionMode"
          },
          "default": "docker",
          "title": "Execution Mode",
          "description": "Execution mode: 'docker' or 'subprocess'"
        },
        {
          "name": "stdin",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Stdin",
          "description": "String to write to process stdin before any streaming input. Use newlines to separate lines."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "command",
        "image",
        "execution_mode",
        "stdin"
      ],
      "is_dynamic": true,
      "is_streaming_output": true,
      "supports_dynamic_outputs": true
    },
    {
      "title": "Execute Java Script",
      "description": "Executes JavaScript (Node.js) code with safety restrictions.\n    javascript, nodejs, code, execute",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecuteJavaScript",
      "properties": [
        {
          "name": "code",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Code",
          "description": "JavaScript code to execute as-is under Node.js. Dynamic inputs are provided as local vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'."
        },
        {
          "name": "image",
          "type": {
            "type": "enum",
            "values": [
              "node:22-alpine"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecuteJavaScript.JavaScriptImage"
          },
          "default": "node:22-alpine",
          "title": "Image",
          "description": "Docker image to use for execution"
        },
        {
          "name": "execution_mode",
          "type": {
            "type": "enum",
            "values": [
              "docker",
              "subprocess"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutionMode"
          },
          "default": "docker",
          "title": "Execution Mode",
          "description": "Execution mode: 'docker' or 'subprocess'"
        },
        {
          "name": "stdin",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Stdin",
          "description": "String to write to process stdin before any streaming input. Use newlines to separate lines."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "code",
        "image",
        "execution_mode",
        "stdin"
      ],
      "is_dynamic": true,
      "supports_dynamic_outputs": true
    },
    {
      "title": "Execute Lua",
      "description": "Executes Lua code with a local sandbox (no Docker).\n    lua, code, execute, sandbox",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecuteLua",
      "properties": [
        {
          "name": "code",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Code",
          "description": "Lua code to execute as-is in a restricted environment. Dynamic inputs are provided as variables. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'."
        },
        {
          "name": "executable",
          "type": {
            "type": "enum",
            "values": [
              "lua",
              "luajit"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecuteLua.LuaExecutable"
          },
          "default": "lua",
          "title": "Executable",
          "description": "Lua executable to use"
        },
        {
          "name": "execution_mode",
          "type": {
            "type": "enum",
            "values": [
              "docker",
              "subprocess"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutionMode"
          },
          "default": "subprocess",
          "title": "Execution Mode",
          "description": "Execution mode: 'docker' or 'subprocess'"
        },
        {
          "name": "timeout_seconds",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Timeout Seconds",
          "description": "Max seconds to allow execution before forced stop"
        },
        {
          "name": "stdin",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Stdin",
          "description": "String to write to process stdin before any streaming input. Use newlines to separate lines."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "code",
        "executable",
        "execution_mode",
        "timeout_seconds",
        "stdin"
      ],
      "is_dynamic": true,
      "is_streaming_output": true,
      "supports_dynamic_outputs": true
    },
    {
      "title": "Execute Python",
      "description": "Executes Python code with safety restrictions.\n    python, code, execute\n\n    Use cases:\n    - Run custom data transformations\n    - Prototype node functionality\n    - Debug and testing workflows\n\n    IMPORTANT: Only enabled in non-production environments",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecutePython",
      "properties": [
        {
          "name": "code",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Code",
          "description": "Python code to execute as-is. Dynamic inputs are provided as local vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'."
        },
        {
          "name": "image",
          "type": {
            "type": "enum",
            "values": [
              "python:3.11-slim",
              "jupyter/scipy-notebook:latest"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutePython.PythonImage"
          },
          "default": "python:3.11-slim",
          "title": "Image",
          "description": "Docker image to use for execution"
        },
        {
          "name": "execution_mode",
          "type": {
            "type": "enum",
            "values": [
              "docker",
              "subprocess"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutionMode"
          },
          "default": "docker",
          "title": "Execution Mode",
          "description": "Execution mode: 'docker' or 'subprocess'"
        },
        {
          "name": "stdin",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Stdin",
          "description": "String to write to process stdin before any streaming input. Use newlines to separate lines."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "code",
        "image",
        "execution_mode",
        "stdin"
      ],
      "is_dynamic": true,
      "is_streaming_output": true,
      "supports_dynamic_outputs": true
    },
    {
      "title": "Execute Ruby",
      "description": "Executes Ruby code with safety restrictions.\n    ruby, code, execute",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecuteRuby",
      "properties": [
        {
          "name": "code",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Code",
          "description": "Ruby code to execute as-is. Dynamic inputs are provided as env vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'."
        },
        {
          "name": "image",
          "type": {
            "type": "enum",
            "values": [
              "ruby:3.3-alpine"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecuteRuby.RubyImage"
          },
          "default": "ruby:3.3-alpine",
          "title": "Image",
          "description": "Docker image to use for execution"
        },
        {
          "name": "execution_mode",
          "type": {
            "type": "enum",
            "values": [
              "docker",
              "subprocess"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutionMode"
          },
          "default": "docker",
          "title": "Execution Mode",
          "description": "Execution mode: 'docker' or 'subprocess'"
        },
        {
          "name": "stdin",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Stdin",
          "description": "String to write to process stdin before any streaming input. Use newlines to separate lines."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "code",
        "image",
        "execution_mode",
        "stdin"
      ],
      "is_dynamic": true,
      "is_streaming_output": true,
      "supports_dynamic_outputs": true
    },
    {
      "title": "All",
      "description": "Checks if all boolean values in a list are True.\n    boolean, all, check, logic, condition, flow-control, branch\n\n\n    Use cases:\n    - Ensure all conditions in a set are met\n    - Implement comprehensive checks\n    - Validate multiple criteria simultaneously",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.All",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "bool"
              }
            ]
          },
          "default": [],
          "title": "Values",
          "description": "List of boolean values to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Compare",
      "description": "Compares two values using a specified comparison operator.\n    compare, condition, logic\n\n    Use cases:\n    - Implement decision points in workflows\n    - Filter data based on specific criteria\n    - Create dynamic thresholds or limits",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.Compare",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "A",
          "description": "First value to compare"
        },
        {
          "name": "b",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "B",
          "description": "Second value to compare"
        },
        {
          "name": "comparison",
          "type": {
            "type": "enum",
            "values": [
              "==",
              "!=",
              ">",
              "<",
              ">=",
              "<="
            ],
            "type_name": "nodetool.nodes.nodetool.boolean.Compare.Comparison"
          },
          "default": "==",
          "title": "Comparison",
          "description": "Comparison operator to use"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b",
        "comparison"
      ]
    },
    {
      "title": "Conditional Switch",
      "description": "Performs a conditional check on a boolean input and returns a value based on the result.\n    if, condition, flow-control, branch, true, false, switch, toggle\n\n    Use cases:\n    - Implement conditional logic in workflows\n    - Create dynamic branches in workflows\n    - Implement decision points in workflows",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.ConditionalSwitch",
      "properties": [
        {
          "name": "condition",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Condition",
          "description": "The condition to check"
        },
        {
          "name": "if_true",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "If True",
          "description": "The value to return if the condition is true"
        },
        {
          "name": "if_false",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "If False",
          "description": "The value to return if the condition is false"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "condition",
        "if_true",
        "if_false"
      ]
    },
    {
      "title": "Is In",
      "description": "Checks if a value is present in a list of options.\n    membership, contains, check\n\n    Use cases:\n    - Validate input against a set of allowed values\n    - Implement category or group checks\n    - Filter data based on inclusion criteria",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.IsIn",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "Value",
          "description": "The value to check for membership"
        },
        {
          "name": "options",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Options",
          "description": "The list of options to check against"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value",
        "options"
      ]
    },
    {
      "title": "Is None",
      "description": "Checks if a value is None.\n    null, none, check\n\n    Use cases:\n    - Validate input presence\n    - Handle optional parameters\n    - Implement null checks in data processing",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.IsNone",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "Value",
          "description": "The value to check for None"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "Logical Operator",
      "description": "Performs logical operations on two boolean inputs.\n    boolean, logic, operator, condition, flow-control, branch, else, true, false, switch, toggle\n\n    Use cases:\n    - Combine multiple conditions in decision-making\n    - Implement complex logical rules in workflows\n    - Create advanced filters or triggers",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.LogicalOperator",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "A",
          "description": "First boolean input"
        },
        {
          "name": "b",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "B",
          "description": "Second boolean input"
        },
        {
          "name": "operation",
          "type": {
            "type": "enum",
            "values": [
              "and",
              "or",
              "xor",
              "nand",
              "nor"
            ],
            "type_name": "nodetool.nodes.nodetool.boolean.LogicalOperator.BooleanOperation"
          },
          "default": "and",
          "title": "Operation",
          "description": "Logical operation to perform"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b",
        "operation"
      ]
    },
    {
      "title": "Not",
      "description": "Performs logical NOT operation on a boolean input.\n    boolean, logic, not, invert, !, negation, condition, else, true, false, switch, toggle, flow-control, branch\n\n    Use cases:\n    - Invert a condition's result\n    - Implement toggle functionality\n    - Create opposite logic branches",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.Not",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Value",
          "description": "Boolean input to negate"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "Some",
      "description": "Checks if any boolean value in a list is True.\n    boolean, any, check, logic, condition, flow-control, branch\n\n    Use cases:\n    - Check if at least one condition in a set is met\n    - Implement optional criteria checks\n    - Create flexible validation rules",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.Some",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "bool"
              }
            ]
          },
          "default": [],
          "title": "Values",
          "description": "List of boolean values to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Agent",
      "description": "Generate natural language responses using LLM providers and streams output.\n    llm, text-generation, chatbot, question-answering, streaming",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.Agent",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": ""
          },
          "title": "Model",
          "description": "Model to use for execution"
        },
        {
          "name": "system",
          "type": {
            "type": "str"
          },
          "default": "You are a an AI agent. \n\nBehavior\n- Understand the user's intent and the context of the task.\n- Break down the task into smaller steps.\n- Be precise, concise, and actionable.\n- Use tools to accomplish your goal. \n\nTool preambles\n- Outline the next step(s) you will perform.\n- After acting, summarize the outcome.\n\nRendering\n- Use Markdown to display media assets.\n- Display images, audio, and video assets using the appropriate Markdown.\n\nFile handling\n- Inputs and outputs are files in the /workspace directory.\n- Write outputs of code execution to the /workspace directory.\n",
          "title": "System",
          "description": "The system prompt for the LLM"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The prompt for the LLM"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to analyze"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio to analyze"
        },
        {
          "name": "history",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "message"
              }
            ]
          },
          "default": [],
          "title": "Messages",
          "description": "The messages for the LLM"
        },
        {
          "name": "thread_id",
          "type": {
            "type": "str",
            "optional": true
          },
          "default": null,
          "title": "Thread ID",
          "description": "Optional thread ID for persistent conversation history. If provided, messages will be loaded from and saved to this thread."
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 8192,
          "title": "Max Tokens",
          "min": 1.0,
          "max": 100000.0
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window (Ollama)",
          "min": 1.0,
          "max": 65536.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        },
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        }
      ],
      "recommended_models": [
        {
          "id": "gpt-oss:20b",
          "type": "llama_model",
          "name": "GPT - OSS",
          "repo_id": "gpt-oss:20b",
          "description": "OpenAI's open-weight GPT-4o-derived model excels at multi-tool routing and reasoning.",
          "size_on_disk": 34359738368
        },
        {
          "id": "mistral-small:latest",
          "type": "llama_model",
          "name": "Mistral Small",
          "repo_id": "mistral-small:latest",
          "description": "Mistral's function-calling tuned small MoE handles multi-tool orchestration reliably.",
          "size_on_disk": 7730941132
        },
        {
          "id": "llama3.1:8b",
          "type": "llama_model",
          "name": "Llama 3.1 - 8B",
          "repo_id": "llama3.1:8b",
          "description": "Meta's 8B instruct excels at structured tool calls and JSON responses with long context.",
          "size_on_disk": 14710262988
        },
        {
          "id": "llama3.2:3b",
          "type": "llama_model",
          "name": "Llama 3.2 - 3B",
          "repo_id": "llama3.2:3b",
          "description": "Compact Llama 3.2 variant keeps latency low while following tool schemas accurately.",
          "size_on_disk": 2040109465
        },
        {
          "id": "qwen3:8b",
          "type": "llama_model",
          "name": "Qwen3 - 8B",
          "repo_id": "qwen3:8b",
          "description": "Qwen3 8B ships strong function-calling primitives and dependable multi-turn tool use.",
          "size_on_disk": 16106127360
        },
        {
          "id": "qwen2.5-coder:7b",
          "type": "llama_model",
          "name": "Qwen2.5-Coder - 7B",
          "repo_id": "qwen2.5-coder:7b",
          "description": "Coder-focused Qwen reliably emits structured arguments for complex toolchains.",
          "size_on_disk": 15032385536
        },
        {
          "id": "deepseek-r1:7b",
          "type": "llama_model",
          "name": "Deepseek R1 - 7B",
          "repo_id": "deepseek-r1:7b",
          "description": "DeepSeek R1 7B balances reasoning with precise function calls for iterative agents.",
          "size_on_disk": 4617089843
        },
        {
          "id": "deepseek-r1:14b",
          "type": "llama_model",
          "name": "Deepseek R1 - 14B",
          "repo_id": "deepseek-r1:14b",
          "description": "Higher-capacity DeepSeek R1 produces reliable tool arguments for complex tasks.",
          "size_on_disk": 30064771072
        }
      ],
      "basic_fields": [
        "prompt",
        "model",
        "image",
        "audio"
      ],
      "is_streaming_output": true,
      "supports_dynamic_outputs": true
    },
    {
      "title": "Classifier",
      "description": "Classify text into predefined or dynamic categories using LLM.\n    classification, nlp, categorization\n\n    Use cases:\n    - Sentiment analysis\n    - Topic classification\n    - Intent detection\n    - Content categorization",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.Classifier",
      "properties": [
        {
          "name": "system_prompt",
          "type": {
            "type": "str"
          },
          "default": "\nYou are a precise classifier.\n\nGoal\n- Select exactly one category from the list provided by the user.\n\nOutput format (MANDATORY)\n- Return ONLY a single JSON object with this exact schema and nothing else:\n  {\"category\": \"<one-of-the-allowed-categories>\"}\n- No prose, no Markdown, no code fences, no explanations, no extra keys.\n\nSelection criteria\n- Choose the single best category that captures the main intent of the text.\n- If multiple categories seem plausible, pick the most probable one; do not return multiple.\n- If none fit perfectly, choose the closest allowed category. If the list includes \"Other\" or \"Unknown\", prefer it when appropriate.\n- Be robust to casing, punctuation, emojis, and minor typos. Handle negation correctly (e.g., \"not spam\" \u2260 spam).\n- Never invent categories that are not in the provided list.\n\nBehavior\n- Be deterministic for the same input.\n- Do not ask clarifying questions; make the best choice with what's given.\n",
          "title": "System Prompt",
          "description": "The system prompt for the classifier"
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": ""
          },
          "title": "Model",
          "description": "Model to use for classification"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to classify"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "Optional image to classify in context"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "Optional audio to classify in context"
        },
        {
          "name": "categories",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Categories",
          "description": "List of possible categories. If empty, LLM will determine categories."
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 1024,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 16384.0
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window (Ollama)",
          "min": 1.0,
          "max": 65536.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "recommended_models": [
        {
          "id": "phi3.5:latest",
          "type": "llama_model",
          "name": "Phi3.5",
          "repo_id": "phi3.5:latest",
          "description": "Reliable small model for intent and sentiment classification when VRAM is tight.",
          "size_on_disk": 2362232012
        },
        {
          "id": "mistral-small:latest",
          "type": "llama_model",
          "name": "Mistral Small",
          "repo_id": "mistral-small:latest",
          "description": "Fast MoE model that keeps category predictions consistent across batches.",
          "size_on_disk": 7730941132
        },
        {
          "id": "granite3.1-moe:1b",
          "type": "llama_model",
          "name": "Granite 3.1 MOE - 1B",
          "repo_id": "granite3.1-moe:1b",
          "description": "IBM Granite 1B excels at classification and routing tasks on CPUs and edge devices.",
          "size_on_disk": 751619276
        },
        {
          "id": "qwen3:1.7b",
          "type": "llama_model",
          "name": "Qwen3 - 1.7B",
          "repo_id": "qwen3:1.7b",
          "description": "Compact Qwen variant provides multilingual label understanding with low latency.",
          "size_on_disk": 1073741824
        },
        {
          "id": "gemma3:1b",
          "type": "llama_model",
          "name": "Gemma3 - 1B",
          "repo_id": "gemma3:1b",
          "description": "Gemma 3 1B offers deterministic small-footprint classification for mobile scenarios.",
          "size_on_disk": 805306368
        },
        {
          "id": "deepseek-r1:1.5b",
          "type": "llama_model",
          "name": "Deepseek R1 - 1.5B",
          "repo_id": "deepseek-r1:1.5b",
          "description": "Reasoning-focused DeepSeek variant is great for multi-step label decisions.",
          "size_on_disk": 912680550
        }
      ],
      "basic_fields": [
        "text",
        "categories",
        "model",
        "image",
        "audio"
      ]
    },
    {
      "title": "Extractor",
      "description": "Extract structured data from text content using LLM providers.\n    data-extraction, structured-data, nlp, parsing\n\n    Specialized for extracting structured information:\n    - Converting unstructured text into structured data\n    - Identifying and extracting specific fields from documents\n    - Parsing text according to predefined schemas\n    - Creating structured records from natural language content",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.Extractor",
      "properties": [
        {
          "name": "system_prompt",
          "type": {
            "type": "str"
          },
          "default": "\nYou are a precise structured data extractor.\n\nGoal\n- Extract exactly the fields described in <JSON_SCHEMA> from the content in <TEXT> (and any attached media).\n\nOutput format (MANDATORY)\n- Output exactly ONE fenced code block labeled json containing ONLY the JSON object:\n\n  ```json\n  { ...single JSON object matching <JSON_SCHEMA>... }\n  ```\n\n- No additional prose before or after the block.\n\nExtraction rules\n- Use only information found in <TEXT> or attached media. Do not invent facts.\n- Preserve source values; normalize internal whitespace and trim leading/trailing spaces.\n- If a required field is missing or not explicitly stated, return the closest reasonable default consistent with its type:\n  - string: \"\"\n  - number: 0\n  - boolean: false\n  - array/object: empty value of that type (only if allowed by the schema)\n- Dates/times: prefer ISO 8601 when the schema type is string and the value represents a date/time.\n- If multiple candidates exist, choose the most precise and unambiguous one.\n\nValidation\n- Ensure the final JSON validates against <JSON_SCHEMA> exactly.\n",
          "title": "System Prompt",
          "description": "The system prompt for the data extractor"
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": ""
          },
          "title": "Model",
          "description": "Model to use for data extraction"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to extract data from"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "Optional image to assist extraction"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "Optional audio to assist extraction"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 16384.0
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window (Ollama)",
          "min": 1.0,
          "max": 65536.0
        }
      ],
      "recommended_models": [
        {
          "id": "phi3.5:latest",
          "type": "llama_model",
          "name": "Phi3.5",
          "repo_id": "phi3.5:latest",
          "description": "Small Phi variant excels at JSON-style outputs and faithful field extraction on laptops.",
          "size_on_disk": 2362232012
        },
        {
          "id": "mistral-small:latest",
          "type": "llama_model",
          "name": "Mistral Small",
          "repo_id": "mistral-small:latest",
          "description": "MoE architecture keeps structured extraction consistent while staying resource efficient.",
          "size_on_disk": 7730941132
        },
        {
          "id": "granite3.1-moe:3b",
          "type": "llama_model",
          "name": "Granite 3.1 MOE - 3B",
          "repo_id": "granite3.1-moe:3b",
          "description": "Granite MoE models are tuned for business document parsing and schema-following tasks.",
          "size_on_disk": 1717986918
        },
        {
          "id": "gemma3:4b",
          "type": "llama_model",
          "name": "Gemma3 - 4B",
          "repo_id": "gemma3:4b",
          "description": "Gemma 3 4B handles multilingual extraction and adheres to required JSON schemas.",
          "size_on_disk": 2791728742
        },
        {
          "id": "qwen2.5-coder:3b",
          "type": "llama_model",
          "name": "Qwen2.5-Coder - 3B",
          "repo_id": "qwen2.5-coder:3b",
          "description": "Code-focused Qwen variant generates precise structured outputs and respects schema rules.",
          "size_on_disk": 1932735283
        },
        {
          "id": "deepseek-r1:7b",
          "type": "llama_model",
          "name": "Deepseek R1 - 7B",
          "repo_id": "deepseek-r1:7b",
          "description": "Reasoning-oriented DeepSeek shines when extraction needs cross-field validation.",
          "size_on_disk": 4617089843
        }
      ],
      "basic_fields": [
        "text",
        "model",
        "image",
        "audio"
      ],
      "supports_dynamic_outputs": true
    },
    {
      "title": "Research Agent",
      "description": "Autonomous research agent that gathers information from the web and synthesizes findings.\n    research, web-search, data-gathering, agent, automation\n\n    Uses dynamic outputs to define the structure of research results.\n    The agent will:\n    - Search the web for relevant information\n    - Browse and extract content from web pages\n    - Organize findings in the workspace\n    - Return structured results matching your output schema\n\n    Perfect for:\n    - Market research and competitive analysis\n    - Literature reviews and fact-finding\n    - Data collection from multiple sources\n    - Automated research workflows",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.ResearchAgent",
      "properties": [
        {
          "name": "objective",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Objective",
          "description": "The research objective or question to investigate"
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": ""
          },
          "title": "Model",
          "description": "Model to use for research and synthesis"
        },
        {
          "name": "system_prompt",
          "type": {
            "type": "str"
          },
          "default": "You are a research assistant.\n\nGoal\n- Conduct thorough research on the given objective\n- Use tools to gather information from multiple sources\n- Write intermediate findings to the workspace for reference\n- Synthesize information into the structured output format specified\n\nTools Available\n- google_search: Search the web for information\n- browser: Navigate to URLs and extract content\n- write_file: Save research findings to files\n- read_file: Read previously saved research files\n- list_directory: List files in the workspace\n\nWorkflow\n1. Break down the research objective into specific queries\n2. Use google_search to find relevant sources\n3. Use browser to extract content from promising URLs\n4. Save important findings using write_file\n5. Synthesize all findings into the requested output format\n\nOutput Format\n- Return a structured JSON object matching the defined output schema\n- Be thorough and cite sources where appropriate\n- Ensure all required fields are populated with accurate information\n",
          "title": "System Prompt",
          "description": "System prompt guiding the agent's research behavior"
        },
        {
          "name": "tools",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tool_name"
              }
            ]
          },
          "default": [
            {
              "name": "google_search"
            },
            {
              "name": "browser"
            }
          ],
          "title": "Tools",
          "description": "Additional research tools to enable (workspace tools are always included)"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 8192,
          "title": "Max Tokens",
          "description": "Maximum tokens for agent responses",
          "min": 1.0,
          "max": 100000.0
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 8192,
          "title": "Context Window",
          "description": "Context window size",
          "min": 1.0,
          "max": 131072.0
        }
      ],
      "recommended_models": [
        {
          "id": "gpt-oss:20b",
          "type": "llama_model",
          "name": "GPT - OSS",
          "repo_id": "gpt-oss:20b",
          "description": "Open-weight GPT-4o derivative handles research workflows with tool calling.",
          "size_on_disk": 34359738368
        },
        {
          "id": "qwen3:14b",
          "type": "llama_model",
          "name": "Qwen3 - 14B",
          "repo_id": "qwen3:14b",
          "description": "Qwen3 14B provides strong tool use and synthesis for local research agents.",
          "size_on_disk": 30064771072
        }
      ],
      "basic_fields": [
        "objective",
        "model",
        "tools"
      ],
      "supports_dynamic_outputs": true
    },
    {
      "title": "Summarizer",
      "description": "Generate concise summaries of text content using LLM providers with streaming output.\n    text, summarization, nlp, content, streaming\n\n    Specialized for creating high-quality summaries with real-time streaming:\n    - Condensing long documents into key points\n    - Creating executive summaries with live output\n    - Extracting main ideas from text as they're generated\n    - Maintaining factual accuracy while reducing length",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.Summarizer",
      "properties": [
        {
          "name": "system_prompt",
          "type": {
            "type": "str"
          },
          "default": "\n        You are an expert summarizer. Your task is to create clear, accurate, and concise summaries using Markdown for structuring. \n        Follow these guidelines:\n        1. Identify and include only the most important information.\n        2. Maintain factual accuracy - do not add or modify information.\n        3. Use clear, direct language.\n        4. Aim for approximately {self.max_tokens} tokens.\n        ",
          "title": "System Prompt",
          "description": "The system prompt for the summarizer"
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": ""
          },
          "title": "Model",
          "description": "Model to use for summarization"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to summarize"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "Optional image to condition the summary"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "Optional audio to condition the summary"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 200,
          "title": "Max Tokens",
          "description": "Target maximum number of tokens for the summary",
          "min": 50.0,
          "max": 16384.0
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window (Ollama)",
          "min": 1.0,
          "max": 65536.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        }
      ],
      "recommended_models": [
        {
          "id": "phi3.5:latest",
          "type": "llama_model",
          "name": "Phi3.5",
          "repo_id": "phi3.5:latest",
          "description": "Lightweight 3.8B model tuned for crisp instruction following and compact summaries on modest hardware.",
          "size_on_disk": 2362232012
        },
        {
          "id": "mistral-small:latest",
          "type": "llama_model",
          "name": "Mistral Small",
          "repo_id": "mistral-small:latest",
          "description": "Efficient mixture-of-experts model that delivers reliable abstractive summaries with low latency.",
          "size_on_disk": 7730941132
        },
        {
          "id": "llama3.2:3b",
          "type": "llama_model",
          "name": "Llama 3.2 - 3B",
          "repo_id": "llama3.2:3b",
          "description": "Compact Llama variant that balances coverage and brevity for everyday summarization workloads.",
          "size_on_disk": 2040109465
        },
        {
          "id": "gemma3:4b",
          "type": "llama_model",
          "name": "Gemma3 - 4B",
          "repo_id": "gemma3:4b",
          "description": "Google's 4B multimodal model performs strong factual summaries while staying resource friendly.",
          "size_on_disk": 2791728742
        },
        {
          "id": "granite3.1-moe:3b",
          "type": "llama_model",
          "name": "Granite 3.1 MOE - 3B",
          "repo_id": "granite3.1-moe:3b",
          "description": "IBM Granite MoE delivers focused meeting notes and bullet summaries with minimal VRAM needs.",
          "size_on_disk": 1717986918
        },
        {
          "id": "qwen3:4b",
          "type": "llama_model",
          "name": "Qwen3 - 4B",
          "repo_id": "qwen3:4b",
          "description": "Qwen3 4B offers multilingual summarization with tight, well-structured outputs.",
          "size_on_disk": 2684354560
        }
      ],
      "basic_fields": [
        "text",
        "max_tokens",
        "model",
        "image",
        "audio"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Chart Generator",
      "description": "LLM Agent to create Plotly Express charts based on natural language descriptions.\n    llm, data visualization, charts\n\n    Use cases:\n    - Generating interactive charts from natural language descriptions\n    - Creating data visualizations with minimal configuration\n    - Converting data analysis requirements into visual representations",
      "namespace": "nodetool.generators",
      "node_type": "nodetool.generators.ChartGenerator",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": ""
          },
          "title": "Model",
          "description": "The model to use for chart generation."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Natural language description of the desired chart"
        },
        {
          "name": "data",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Data",
          "description": "The data to visualize"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 100000.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "plotly_config"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "data",
        "model"
      ]
    },
    {
      "title": "Data Generator",
      "description": "LLM Agent to create a dataframe based on a user prompt.\n    llm, dataframe creation, data structuring\n\n    Use cases:\n    - Generating structured data from natural language descriptions\n    - Creating sample datasets for testing or demonstration\n    - Converting unstructured text into tabular format",
      "namespace": "nodetool.generators",
      "node_type": "nodetool.generators.DataGenerator",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": ""
          },
          "title": "Model",
          "description": "The model to use for data generation."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The user prompt"
        },
        {
          "name": "input_text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Input Text",
          "description": "The input text to be analyzed by the agent."
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 100000.0
        },
        {
          "name": "columns",
          "type": {
            "type": "record_type"
          },
          "default": {
            "type": "record_type",
            "columns": []
          },
          "title": "Columns",
          "description": "The columns to use in the dataframe."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "record"
        },
        {
          "type": {
            "type": "dataframe"
          },
          "name": "dataframe"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "index"
        }
      ],
      "basic_fields": [
        "prompt",
        "model",
        "columns"
      ],
      "is_streaming_output": true
    },
    {
      "title": "List Generator",
      "description": "LLM Agent to create a stream of strings based on a user prompt.\n    llm, text streaming\n\n    Use cases:\n    - Generating text from natural language descriptions\n    - Streaming responses from an LLM",
      "namespace": "nodetool.generators",
      "node_type": "nodetool.generators.ListGenerator",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": ""
          },
          "title": "Model",
          "description": "The model to use for string generation."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The user prompt"
        },
        {
          "name": "input_text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Input Text",
          "description": "The input text to be analyzed by the agent."
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 100000.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "item"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "index"
        }
      ],
      "basic_fields": [
        "prompt",
        "model"
      ],
      "is_streaming_output": true
    },
    {
      "title": "SVGGenerator",
      "description": "LLM Agent to create SVG elements based on user prompts.\n    svg, generator, vector, graphics\n\n    Use cases:\n    - Creating vector graphics from text descriptions\n    - Generating scalable illustrations\n    - Creating custom icons and diagrams",
      "namespace": "nodetool.generators",
      "node_type": "nodetool.generators.SVGGenerator",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": ""
          },
          "title": "Model",
          "description": "The language model to use for SVG generation."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The user prompt for SVG generation"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "Image to use for generation"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "Audio to use for generation"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 8192,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 100000.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "svg_element"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "image",
        "audio",
        "model"
      ]
    },
    {
      "title": "Structured Output Generator",
      "description": "Generate structured JSON objects from instructions using LLM providers.\n    data-generation, structured-data, json, synthesis\n\n    Specialized for creating structured information:\n    - Generating JSON that follows dynamic schemas\n    - Fabricating records from requirements and guidance\n    - Simulating sample data for downstream workflows\n    - Producing consistent structured outputs for testing",
      "namespace": "nodetool.generators",
      "node_type": "nodetool.generators.StructuredOutputGenerator",
      "properties": [
        {
          "name": "system_prompt",
          "type": {
            "type": "str"
          },
          "default": "\nYou are a structured data generator focused on JSON outputs.\n\nGoal\n- Produce a high-quality JSON object that matches <JSON_SCHEMA> using the guidance in <INSTRUCTIONS> and any supplemental <CONTEXT>.\n\nOutput format (MANDATORY)\n- Output exactly ONE fenced code block labeled json containing ONLY the JSON object:\n\n  ```json\n  { ...single JSON object matching <JSON_SCHEMA>... }\n  ```\n\n- No additional prose before or after the block.\n\nGeneration rules\n- Invent plausible, internally consistent values when not explicitly provided.\n- Honor all constraints from <JSON_SCHEMA> (types, enums, ranges, formats).\n- Prefer ISO 8601 for dates/times when applicable.\n- Ensure numbers respect reasonable magnitudes and relationships described in <INSTRUCTIONS>.\n- Avoid referencing external sources; rely solely on the provided guidance.\n\nValidation\n- Ensure the final JSON validates against <JSON_SCHEMA> exactly.\n",
          "title": "System Prompt",
          "description": "The system prompt guiding JSON generation."
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": ""
          },
          "title": "Model",
          "description": "Model to use for structured generation."
        },
        {
          "name": "instructions",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Instructions",
          "description": "Detailed instructions for the structured output."
        },
        {
          "name": "context",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Context",
          "description": "Optional context to ground the generation."
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 16384.0
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window (Ollama)",
          "min": 1.0,
          "max": 65536.0
        }
      ],
      "basic_fields": [
        "instructions",
        "context",
        "model"
      ],
      "supports_dynamic_outputs": true
    },
    {
      "title": "Asset Folder Input",
      "description": "Accepts an asset folder as a parameter for workflows.\n    input, parameter, folder, path, folderpath, local_folder, filesystem",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.AssetFolderInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value",
          "description": "The folder to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "folder"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Audio Input",
      "description": "Accepts a reference to an audio asset for workflows, specified by an 'AudioRef'.  An 'AudioRef' points to audio data that can be used for playback, transcription, analysis, or processing by audio-capable models.\n    input, parameter, audio, sound, voice, speech, asset\n\n    Use cases:\n    - Load an audio file for speech-to-text transcription.\n    - Analyze sound for specific events or characteristics.\n    - Provide audio input to models for tasks like voice recognition or music generation.\n    - Process audio for enhancement or feature extraction.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.AudioInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value",
          "description": "The audio to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Boolean Input",
      "description": "Accepts a boolean (true/false) value as a parameter for workflows.  This input is used for binary choices, enabling or disabling features, or controlling conditional logic paths.\n    input, parameter, boolean, bool, toggle, switch, flag\n\n    Use cases:\n    - Toggle features or settings on or off.\n    - Set binary flags to control workflow behavior.\n    - Make conditional choices within a workflow (e.g., proceed if true).",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.BooleanInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Collection Input",
      "description": "Accepts a reference to a specific data collection, typically within a vector database or similar storage system.\n    The input is a 'Collection' object, which identifies the target collection for operations like data insertion, querying, or similarity search.\n    Keywords: input, parameter, collection, database, vector_store, chroma, index\n\n    Use cases:\n    - Select a target vector database collection for indexing new documents.\n    - Specify a collection to perform a similarity search or query against.\n    - Choose a data source or destination that is represented as a named collection.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.CollectionInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Value",
          "description": "The collection to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "collection"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Color Input",
      "description": "Accepts a color value as a parameter for workflows.\n    input, parameter, color, color_picker, color_input",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.ColorInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": null
          },
          "title": "Value",
          "description": "The color to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "color"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Document File Input",
      "description": "Accepts a local file path pointing to a document and converts it into a 'DocumentRef'.\n    input, parameter, document, file, path, local_file, load\n\n    Use cases:\n    - Directly load a document (e.g., PDF, TXT, DOCX) from a specified local file path.\n    - Convert a local file path into a 'DocumentRef' that can be consumed by other document-processing nodes.\n    - Useful for development or workflows that have legitimate access to the local filesystem.\n    - To provide an existing 'DocumentRef', use 'DocumentInput'.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.DocumentFileInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value",
          "description": "The path to the document file.",
          "json_schema_extra": {
            "type": "file_path"
          }
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "document"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "path"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Document Input",
      "description": "Accepts a reference to a document asset for workflows, specified by a 'DocumentRef'.  A 'DocumentRef' points to a structured document (e.g., PDF, DOCX, TXT) which can be processed or analyzed. This node is used when the workflow needs to operate on a document as a whole entity, potentially including its structure and metadata, rather than just raw text.\n    input, parameter, document, file, asset, reference\n\n    Use cases:\n    - Load a specific document (e.g., PDF, Word, text file) for content extraction or analysis.\n    - Pass a document to models that are designed to process specific document formats.\n    - Manage documents as distinct assets within a workflow.\n    - If you have a local file path and need to convert it to a 'DocumentRef', consider using 'DocumentFileInput'.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.DocumentInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value",
          "description": "The document to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "File Path Input",
      "description": "Accepts a local filesystem path (to a file or directory) as input for workflows.\n    input, parameter, path, filepath, directory, local_file, filesystem\n\n    Use cases:\n    - Provide a local path to a specific file or directory for processing.\n    - Specify an input or output location on the local filesystem for a development task.\n    - Load local datasets or configuration files not managed as assets.\n    - Not available in production: raises an error if used in a production environment.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.FilePathInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value",
          "description": "The path to use as input.",
          "json_schema_extra": {
            "type": "file_path"
          }
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Float Input",
      "description": "Accepts a floating-point number as a parameter for workflows, typically constrained by a minimum and maximum value.  This input allows for precise numeric settings, such as adjustments, scores, or any value requiring decimal precision.\n    input, parameter, float, number, decimal, range\n\n    Use cases:\n    - Specify a numeric value within a defined range (e.g., 0.0 to 1.0).\n    - Set thresholds, confidence scores, or scaling factors.\n    - Configure continuous parameters like opacity, volume, or temperature.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.FloatInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        },
        {
          "name": "min",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Min"
        },
        {
          "name": "max",
          "type": {
            "type": "float"
          },
          "default": 100,
          "title": "Max"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Folder Path Input",
      "description": "Accepts a folder path as a parameter for workflows.\n    input, parameter, folder, path, folderpath, local_folder, filesystem",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.FolderPathInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value",
          "description": "The folder path to use as input.",
          "json_schema_extra": {
            "type": "folder_path"
          }
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Hugging Face Model Input",
      "description": "Accepts a Hugging Face model as a parameter for workflows.\n    input, parameter, model, huggingface, hugging_face, model_name",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.HuggingFaceModelInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "hf.model"
          },
          "default": {
            "type": "hf.model",
            "repo_id": "",
            "path": null,
            "variant": null,
            "allow_patterns": null,
            "ignore_patterns": null
          },
          "title": "Value",
          "description": "The Hugging Face model to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "hf.model"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Image Input",
      "description": "Accepts a reference to an image asset for workflows, specified by an 'ImageRef'.  An 'ImageRef' points to image data that can be used for display, analysis, or processing by vision models.\n    input, parameter, image, picture, graphic, visual, asset\n\n    Use cases:\n    - Load an image for visual processing or analysis.\n    - Provide an image as input to computer vision models (e.g., object detection, image classification).\n    - Select an image for manipulation, enhancement, or inclusion in a document.\n    - Display an image within a workflow interface.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.ImageInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value",
          "description": "The image to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Image Model Input",
      "description": "Accepts an image generation model as a parameter for workflows.\n    input, parameter, model, image, generation",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.ImageModelInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "image_model"
          },
          "default": {
            "type": "image_model",
            "provider": "empty",
            "id": "",
            "name": ""
          },
          "title": "Value",
          "description": "The image generation model to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image_model"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Inference Provider Input",
      "description": "Accepts an inference provider as a parameter for workflows.\n    input, parameter, provider, inference, provider_name",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.InferenceProviderInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "enum",
            "values": [
              "cerebras",
              "cohere",
              "fal-ai",
              "featherless-ai",
              "fireworks-ai",
              "groq",
              "hf-inference",
              "hyperbolic",
              "nebius",
              "novita",
              "nscale",
              "openai",
              "replicate",
              "sambanova",
              "scaleway",
              "together",
              "zai-org"
            ],
            "type_name": "nodetool.metadata.types.InferenceProvider"
          },
          "default": "hf-inference",
          "title": "Value",
          "description": "The inference provider to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "enum",
            "values": [
              "cerebras",
              "cohere",
              "fal-ai",
              "featherless-ai",
              "fireworks-ai",
              "groq",
              "hf-inference",
              "hyperbolic",
              "nebius",
              "novita",
              "nscale",
              "openai",
              "replicate",
              "sambanova",
              "scaleway",
              "together",
              "zai-org"
            ],
            "type_name": "nodetool.metadata.types.InferenceProvider"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Integer Input",
      "description": "Accepts an integer (whole number) as a parameter for workflows, typically constrained by a minimum and maximum value.  This input is used for discrete numeric values like counts, indices, or iteration limits.\n    input, parameter, integer, number, count, index, whole_number\n\n    Use cases:\n    - Specify counts or quantities (e.g., number of items, iterations).\n    - Set index values for accessing elements in a list or array.\n    - Configure discrete numeric parameters like age, steps, or quantity.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.IntegerInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        },
        {
          "name": "min",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Min"
        },
        {
          "name": "max",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Max"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Language Model Input",
      "description": "Accepts a language model as a parameter for workflows.\n    input, parameter, model, language, model_name",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.LanguageModelInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": ""
          },
          "title": "Value",
          "description": "The language model to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "language_model"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Realtime Audio Input",
      "description": "Accepts streaming audio data for workflows.\n    input, parameter, audio, sound, voice, speech, asset",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.RealtimeAudioInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "Value",
          "description": "The value of the input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio to use as input."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        }
      ],
      "basic_fields": [
        "name",
        "value",
        "audio"
      ],
      "is_streaming_output": true
    },
    {
      "title": "String Input",
      "description": "Accepts a string value as a parameter for workflows.\n    input, parameter, string, text, label, name, value\n\n    Use cases:\n    - Define a name for an entity or process.\n    - Specify a label for a component or output.\n    - Enter a short keyword or search term.\n    - Provide a simple configuration value (e.g., an API key, a model name).\n    - If you need to input multi-line text or the content of a file, use 'DocumentFileInput'.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.StringInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "String List Input",
      "description": "Accepts a list of strings as a parameter for workflows.\n    input, parameter, string, text, label, name, value",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.StringListInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": null,
          "title": "Value",
          "description": "The list of strings to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Video Input",
      "description": "Accepts a reference to a video asset for workflows, specified by a 'VideoRef'.  A 'VideoRef' points to video data that can be used for playback, analysis, frame extraction, or processing by video-capable models.\n    input, parameter, video, movie, clip, visual, asset\n\n    Use cases:\n    - Load a video file for processing or content analysis.\n    - Analyze video content for events, objects, or speech.\n    - Extract frames or audio tracks from a video.\n    - Provide video input to models that understand video data.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.VideoInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Value",
          "description": "The video to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Automatic Speech Recognition",
      "description": "Automatic speech recognition node.\n    audio, speech, recognition",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.AutomaticSpeechRecognition",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "asr_model"
          },
          "default": {
            "type": "asr_model",
            "provider": "fal_ai",
            "id": "openai/whisper-large-v3",
            "name": ""
          },
          "title": "Model"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio to transcribe"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        }
      ],
      "basic_fields": [
        "model",
        "audio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Split Text into Chunks",
      "description": "Splits text into chunks of specified word length.\n    text, chunk, split\n\n    Use cases:\n    - Preparing text for processing by models with input length limits\n    - Creating manageable text segments for parallel processing\n    - Generating summaries of text sections",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Chunk",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "length",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Length",
          "min": 1.0,
          "max": 1000.0
        },
        {
          "name": "overlap",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Overlap"
        },
        {
          "name": "separator",
          "type": {
            "type": "str",
            "optional": true
          },
          "default": null,
          "title": "Separator"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "length",
        "overlap",
        "separator"
      ]
    },
    {
      "title": "Collect",
      "description": "Collects a stream of text inputs into a single string.\n    text, collect, list, stream",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Collect",
      "properties": [
        {
          "name": "input_item",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Input Item"
        },
        {
          "name": "separator",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Separator"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_item",
        "separator"
      ]
    },
    {
      "title": "Concatenate Text",
      "description": "Concatenates two text inputs into a single output.\n    text, concatenation, combine, +\n\n    Use cases:\n    - Joining outputs from multiple text processing nodes\n    - Combining parts of sentences or paragraphs\n    - Merging text data from different sources",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Concat",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ]
    },
    {
      "title": "Contains Text",
      "description": "Checks if text contains a specified substring.\n    text, check, contains, compare, validate, substring, string\n\n    Use cases:\n    - Searching for keywords in text\n    - Filtering content based on presence of terms\n    - Validating text content",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Contains",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "substring",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Substring"
        },
        {
          "name": "case_sensitive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Case Sensitive"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "substring",
        "case_sensitive"
      ]
    },
    {
      "title": "Count Tokens",
      "description": "Counts the number of tokens in text using tiktoken.\n    text, tokens, count, encoding\n\n    Use cases:\n    - Checking text length for LLM input limits\n    - Estimating API costs\n    - Managing token budgets in text processing",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.CountTokens",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "encoding",
          "type": {
            "type": "enum",
            "values": [
              "cl100k_base",
              "p50k_base",
              "r50k_base"
            ],
            "type_name": "nodetool.nodes.nodetool.text.CountTokens.TiktokenEncoding"
          },
          "default": "cl100k_base",
          "title": "Encoding",
          "description": "The tiktoken encoding to use for token counting"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "encoding"
      ]
    },
    {
      "title": "Ends With",
      "description": "Checks if text ends with a specified suffix.\n    text, check, suffix, compare, validate, substring, string\n\n    Use cases:\n    - Validating file extensions\n    - Checking string endings\n    - Filtering text based on ending content",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.EndsWith",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "suffix",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Suffix"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "suffix"
      ]
    },
    {
      "title": "Extract Text",
      "description": "Extracts a substring from input text.\n    text, extract, substring\n\n    Use cases:\n    - Extracting specific portions of text for analysis\n    - Trimming unwanted parts from text data\n    - Focusing on relevant sections of longer documents",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Extract",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start"
        },
        {
          "name": "end",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "End"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "start",
        "end"
      ]
    },
    {
      "title": "Extract JSON",
      "description": "Extracts data from JSON using JSONPath expressions.\n    json, extract, jsonpath\n\n    Use cases:\n    - Retrieving specific fields from complex JSON structures\n    - Filtering and transforming JSON data for analysis\n    - Extracting nested data from API responses or configurations",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.ExtractJSON",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "JSON Text"
        },
        {
          "name": "json_path",
          "type": {
            "type": "str"
          },
          "default": "$.*",
          "title": "JSONPath Expression"
        },
        {
          "name": "find_all",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Find All"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "json_path",
        "find_all"
      ]
    },
    {
      "title": "Extract Regex Groups",
      "description": "Extracts substrings matching regex groups from text.\n    text, regex, extract\n\n    Use cases:\n    - Extracting structured data (e.g., dates, emails) from unstructured text\n    - Parsing specific patterns in log files or documents\n    - Isolating relevant information from complex text formats",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.ExtractRegex",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "regex",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Regex"
        },
        {
          "name": "dotall",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Dotall"
        },
        {
          "name": "ignorecase",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Ignorecase"
        },
        {
          "name": "multiline",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Multiline"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "regex",
        "dotall",
        "ignorecase",
        "multiline"
      ]
    },
    {
      "title": "Find All Regex Matches",
      "description": "Finds all regex matches in text as separate substrings.\n    text, regex, find\n\n    Use cases:\n    - Identifying all occurrences of a pattern in text\n    - Extracting multiple instances of structured data\n    - Analyzing frequency and distribution of specific text patterns",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.FindAllRegex",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "regex",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Regex"
        },
        {
          "name": "dotall",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Dotall"
        },
        {
          "name": "ignorecase",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Ignorecase"
        },
        {
          "name": "multiline",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Multiline"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "regex",
        "dotall",
        "ignorecase",
        "multiline"
      ]
    },
    {
      "title": "Format Text",
      "description": "Replaces placeholders in a string with dynamic inputs using Jinja2 templating.\n    text, template, formatting\n\n    This node is dynamic and can be used to format text with dynamic properties.\n\n    Use cases:\n    - Generating personalized messages with dynamic content\n    - Creating parameterized queries or commands\n    - Formatting and filtering text output based on variable inputs\n\n    Examples:\n    - text: \"Hello, {{ name }}!\"\n    - text: \"Title: {{ title|truncate(20) }}\"\n    - text: \"Name: {{ name|upper }}\"\n\n    Available filters:\n    - truncate(length): Truncates text to given length\n    - upper: Converts text to uppercase\n    - lower: Converts text to lowercase\n    - title: Converts text to title case\n    - trim: Removes whitespace from start/end\n    - replace(old, new): Replaces substring\n    - default(value): Sets default if value is undefined\n    - first: Gets first character/item\n    - last: Gets last character/item\n    - length: Gets length of string/list\n    - sort: Sorts list\n    - join(delimiter): Joins list with delimiter",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.FormatText",
      "properties": [
        {
          "name": "template",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Template",
          "description": "\n    Examples:\n    - text: \"Hello, {{ name }}!\"\n    - text: \"Title: {{ title|truncate(20) }}\"\n    - text: \"Name: {{ name|upper }}\" \n\n    Available filters:\n    - truncate(length): Truncates text to given length\n    - upper: Converts text to uppercase\n    - lower: Converts text to lowercase\n    - title: Converts text to title case\n    - trim: Removes whitespace from start/end\n    - replace(old, new): Replaces substring\n    - default(value): Sets default if value is undefined\n    - first: Gets first character/item\n    - last: Gets last character/item\n    - length: Gets length of string/list\n    - sort: Sorts list\n    - join(delimiter): Joins list with delimiter\n"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "template"
      ],
      "is_dynamic": true
    },
    {
      "title": "Check Length",
      "description": "Checks if text length meets specified conditions.\n    text, check, length, compare, validate, whitespace, string\n\n    Use cases:\n    - Validating input length requirements\n    - Filtering text by length\n    - Checking content size constraints",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.HasLength",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "min_length",
          "type": {
            "type": "int",
            "optional": true
          },
          "default": null,
          "title": "Minimum Length"
        },
        {
          "name": "max_length",
          "type": {
            "type": "int",
            "optional": true
          },
          "default": null,
          "title": "Maximum Length"
        },
        {
          "name": "exact_length",
          "type": {
            "type": "int",
            "optional": true
          },
          "default": null,
          "title": "Exact Length"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "min_length",
        "max_length",
        "exact_length"
      ]
    },
    {
      "title": "HTML to Text",
      "description": "Converts HTML content to plain text using html2text.\n    html, convert, text, parse, extract\n\n    Use cases:\n    - Converting HTML documents to readable plain text\n    - Extracting text content from web pages\n    - Cleaning HTML markup from text data\n    - Processing HTML emails or documents",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.HtmlToText",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "HTML",
          "description": "HTML content to convert"
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base URL",
          "description": "Base URL for resolving relative links"
        },
        {
          "name": "body_width",
          "type": {
            "type": "int"
          },
          "default": 1000,
          "title": "Body Width",
          "description": "Width for text wrapping"
        },
        {
          "name": "ignore_images",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Ignore Images",
          "description": "Whether to ignore image tags"
        },
        {
          "name": "ignore_mailto_links",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Ignore Mailto Links",
          "description": "Whether to ignore mailto links"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "html",
        "base_url",
        "body_width",
        "ignore_images",
        "ignore_mailto_links"
      ]
    },
    {
      "title": "Is Empty",
      "description": "Checks if text is empty or contains only whitespace.\n    text, check, empty, compare, validate, whitespace, string\n\n    Use cases:\n    - Validating required text fields\n    - Filtering out empty content\n    - Checking for meaningful input",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.IsEmpty",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "trim_whitespace",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Trim Whitespace"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "trim_whitespace"
      ]
    },
    {
      "title": "Join",
      "description": "Joins a list of strings into a single string using a specified separator.\n    text, join, combine, +, add, concatenate\n\n    Use cases:\n    - Combining multiple text elements with a consistent delimiter\n    - Creating comma-separated lists from individual items\n    - Assembling formatted text from array elements",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Join",
      "properties": [
        {
          "name": "strings",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Strings"
        },
        {
          "name": "separator",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Separator"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "strings",
        "separator"
      ]
    },
    {
      "title": "Load Text Assets",
      "description": "Load text files from an asset folder.\n    load, text, file, import\n\n    Use cases:\n    - Loading multiple text files for batch processing\n    - Importing text content from a directory\n    - Processing collections of text documents",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.LoadTextAssets",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The asset folder to load the text files from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "text"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        }
      ],
      "basic_fields": [
        "folder"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Parse JSON String",
      "description": "Parses a JSON string into a Python object.\n    json, parse, convert\n\n    Use cases:\n    - Converting JSON API responses for further processing\n    - Preparing structured data for analysis or storage\n    - Extracting configuration or settings from JSON files",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.ParseJSON",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "JSON string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ]
    },
    {
      "title": "Find Regex Matches",
      "description": "Find all matches of a regex pattern in text.\n    regex, search, pattern, match\n\n    Use cases:\n    - Extract specific patterns from text\n    - Validate text against patterns\n    - Find all occurrences of a pattern",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.RegexMatch",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to search in"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "Regular expression pattern"
        },
        {
          "name": "group",
          "type": {
            "type": "int",
            "optional": true
          },
          "default": null,
          "title": "Group",
          "description": "Capture group to extract (0 for full match)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "pattern",
        "group"
      ]
    },
    {
      "title": "Replace with Regex",
      "description": "Replace text matching a regex pattern.\n    regex, replace, substitute\n\n    Use cases:\n    - Clean or standardize text\n    - Remove unwanted patterns\n    - Transform text formats",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.RegexReplace",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to perform replacements on"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "Regular expression pattern"
        },
        {
          "name": "replacement",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Replacement",
          "description": "Replacement text"
        },
        {
          "name": "count",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Count",
          "description": "Maximum replacements (0 for unlimited)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "pattern",
        "replacement",
        "count"
      ]
    },
    {
      "title": "Split with Regex",
      "description": "Split text using a regex pattern as delimiter.\n    regex, split, tokenize\n\n    Use cases:\n    - Parse structured text\n    - Extract fields from formatted strings\n    - Tokenize text",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.RegexSplit",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to split"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "Regular expression pattern to split on"
        },
        {
          "name": "maxsplit",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Maxsplit",
          "description": "Maximum number of splits (0 for unlimited)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "pattern",
        "maxsplit"
      ]
    },
    {
      "title": "Validate with Regex",
      "description": "Check if text matches a regex pattern.\n    regex, validate, check\n\n    Use cases:\n    - Validate input formats (email, phone, etc)\n    - Check text structure\n    - Filter text based on patterns",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.RegexValidate",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to validate"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "Regular expression pattern"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "pattern"
      ]
    },
    {
      "title": "Replace Text",
      "description": "Replaces a substring in a text with another substring.\n    text, replace, substitute\n\n    Use cases:\n    - Correcting or updating specific text patterns\n    - Sanitizing or normalizing text data\n    - Implementing simple text transformations",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Replace",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "old",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Old"
        },
        {
          "name": "new",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "New"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "old",
        "new"
      ]
    },
    {
      "title": "Save Text",
      "description": "Saves input text to a file in the assets folder.\n    text, save, file\n\n    Use cases:\n    - Persisting processed text results\n    - Creating text files for downstream nodes or external use\n    - Archiving text data within the workflow",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.SaveText",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "Name of the output folder."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d-%H-%M-%S.txt",
          "title": "Name",
          "description": "\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "text"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "folder",
        "name"
      ]
    },
    {
      "title": "Save Text File",
      "description": "Saves input text to a file in the assets folder.\n    text, save, file",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.SaveTextFile",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Path to the output folder."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d-%H-%M-%S.txt",
          "title": "Name",
          "description": "\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "text"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "folder",
        "name"
      ]
    },
    {
      "title": "Slice Text",
      "description": "Slices text using Python's slice notation (start:stop:step).\n    text, slice, substring\n\n    Use cases:\n    - Extracting specific portions of text with flexible indexing\n    - Reversing text using negative step\n    - Taking every nth character with step parameter\n\n    Examples:\n    - start=0, stop=5: first 5 characters\n    - start=-5: last 5 characters\n    - step=2: every second character\n    - step=-1: reverse the text",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Slice",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "start",
          "type": {
            "type": "int",
            "optional": true
          },
          "default": null,
          "title": "Start Index"
        },
        {
          "name": "stop",
          "type": {
            "type": "int",
            "optional": true
          },
          "default": null,
          "title": "Stop Index"
        },
        {
          "name": "step",
          "type": {
            "type": "int",
            "optional": true
          },
          "default": null,
          "title": "Step"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "start",
        "stop",
        "step"
      ]
    },
    {
      "title": "Split Text",
      "description": "Separates text into a list of strings based on a specified delimiter.\n    text, split, tokenize\n\n    Use cases:\n    - Parsing CSV or similar delimited data\n    - Breaking down sentences into words or phrases\n    - Extracting specific elements from structured text",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Split",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "delimiter",
          "type": {
            "type": "str"
          },
          "default": ",",
          "title": "Delimiter"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "delimiter"
      ]
    },
    {
      "title": "Starts With",
      "description": "Checks if text starts with a specified prefix.\n    text, check, prefix, compare, validate, substring, string\n\n    Use cases:\n    - Validating string prefixes\n    - Filtering text based on starting content\n    - Checking file name patterns",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.StartsWith",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "prefix",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prefix"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "prefix"
      ]
    },
    {
      "title": "Template",
      "description": "Uses Jinja2 templating to format strings with variables and filters. This node is dynamic and can be used to format text with dynamic inputs.\n    text, template, formatting, format, combine, concatenate, +, add, variable, replace, filter\n\n    Use cases:\n    - Generating personalized messages with dynamic content\n    - Creating parameterized queries or commands\n    - Formatting and filtering text output based on variable inputs\n\n    Examples:\n    - text: \"Hello, {{ name }}!\"\n    - text: \"Title: {{ title|truncate(20) }}\"\n    - text: \"Name: {{ name|upper }}\"\n\n    Available filters:\n    - truncate(length): Truncates text to given length\n    - upper: Converts text to uppercase\n    - lower: Converts text to lowercase\n    - title: Converts text to title case\n    - trim: Removes whitespace from start/end\n    - replace(old, new): Replaces substring\n    - default(value): Sets default if value is undefined\n    - first: Gets first character/item\n    - last: Gets last character/item\n    - length: Gets length of string/list\n    - sort: Sorts list\n    - join(delimiter): Joins list with delimiter",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Template",
      "properties": [
        {
          "name": "string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "String",
          "description": "\n    Examples:\n    - text: \"Hello, {{ name }}!\"\n    - text: \"Title: {{ title|truncate(20) }}\"\n    - text: \"Name: {{ name|upper }}\"\n\n    Available filters:\n    - truncate(length): Truncates text to given length\n    - upper: Converts text to uppercase\n    - lower: Converts text to lowercase\n    - title: Converts text to title case\n    - trim: Removes whitespace from start/end\n    - replace(old, new): Replaces substring\n    - default(value): Sets default if value is undefined\n    - first: Gets first character/item\n    - last: Gets last character/item\n    - length: Gets length of string/list\n    - sort: Sorts list\n    - join(delimiter): Joins list with delimiter\n"
        },
        {
          "name": "values",
          "type": {
            "type": "any"
          },
          "default": {},
          "title": "Values",
          "description": "\n        The values to replace in the string.\n        - If a string, it will be used as the format string.\n        - If a list, it will be used as the format arguments.\n        - If a dictionary, it will be used as the template variables.\n        - If an object, it will be converted to a dictionary using the object's __dict__ method.\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "string",
        "values"
      ],
      "is_dynamic": true
    },
    {
      "title": "List Documents",
      "description": "List documents in a directory.\n    files, list, directory",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.ListDocuments",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "~",
          "title": "Folder",
          "description": "Directory to scan"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "*",
          "title": "Pattern",
          "description": "File pattern to match (e.g. *.txt)"
        },
        {
          "name": "recursive",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Recursive",
          "description": "Search subdirectories"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "document"
        }
      ],
      "basic_fields": [
        "folder",
        "pattern",
        "recursive"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Load Document File",
      "description": "Read a document from disk.\n    files, document, read, input, load, file",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.LoadDocumentFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the document to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Split Markdown",
      "description": "Splits markdown text by headers while preserving header hierarchy in metadata.\n    markdown, split, headers\n\n    Use cases:\n    - Splitting markdown documentation while preserving structure\n    - Processing markdown files for semantic search\n    - Creating context-aware chunks from markdown content",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitMarkdown",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document"
        },
        {
          "name": "headers_to_split_on",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tuple",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "default": [
            [
              "#",
              "Header 1"
            ],
            [
              "##",
              "Header 2"
            ],
            [
              "###",
              "Header 3"
            ]
          ],
          "title": "Headers To Split On",
          "description": "List of tuples containing (header_symbol, header_name)"
        },
        {
          "name": "strip_headers",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Strip Headers",
          "description": "Whether to remove headers from the output content"
        },
        {
          "name": "return_each_line",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Return Each Line",
          "description": "Whether to split into individual lines instead of header sections"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int",
            "optional": true
          },
          "default": null,
          "title": "Chunk Size",
          "description": "Optional maximum chunk size for further splitting"
        },
        {
          "name": "chunk_overlap",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Chunk Overlap",
          "description": "Overlap size when using chunk_size"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "source_id"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "start_index"
        }
      ],
      "basic_fields": [
        "document",
        "headers_to_split_on",
        "strip_headers",
        "return_each_line",
        "chunk_size",
        "chunk_overlap"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Save Document File",
      "description": "Write a document to disk.\n    files, document, write, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SaveDocumentFile",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document",
          "description": "The document to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Name of the file to save. Supports strftime format codes."
        }
      ],
      "basic_fields": [
        "document",
        "folder",
        "filename"
      ]
    },
    {
      "title": "Split Document",
      "description": "Split text semantically.\n    chroma, embedding, collection, RAG, index, text, markdown, semantic",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitDocument",
      "properties": [
        {
          "name": "embed_model",
          "type": {
            "type": "llama_model"
          },
          "default": {
            "type": "llama_model",
            "name": "",
            "repo_id": "",
            "modified_at": "",
            "size": 0,
            "digest": "",
            "details": {}
          },
          "title": "Embed Model",
          "description": "Embedding model to use"
        },
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document",
          "description": "Document ID to associate with the text content"
        },
        {
          "name": "buffer_size",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Buffer Size",
          "description": "Buffer size for semantic splitting",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "threshold",
          "type": {
            "type": "int"
          },
          "default": 95,
          "title": "Threshold",
          "description": "Breakpoint percentile threshold for semantic splitting",
          "min": 0.0,
          "max": 100.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "source_id"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "start_index"
        }
      ],
      "basic_fields": [
        "embed_model",
        "document",
        "buffer_size",
        "threshold"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Split HTML",
      "description": "Split HTML content into semantic chunks based on HTML tags.\n    html, text, semantic, tags, parsing",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitHTML",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document",
          "description": "Document ID to associate with the HTML content"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "source_id"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "start_index"
        }
      ],
      "basic_fields": [
        "document"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Split JSON",
      "description": "Split JSON content into semantic chunks.\n    json, parsing, semantic, structured",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitJSON",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document",
          "description": "Document ID to associate with the JSON content"
        },
        {
          "name": "include_metadata",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Include Metadata",
          "description": "Whether to include metadata in nodes"
        },
        {
          "name": "include_prev_next_rel",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Include Prev Next Rel",
          "description": "Whether to include prev/next relationships"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "source_id"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "start_index"
        }
      ],
      "basic_fields": [
        "document",
        "include_metadata",
        "include_prev_next_rel"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Split Markdown",
      "description": "Splits markdown text by headers while preserving header hierarchy in metadata.\n    markdown, split, headers\n\n    Use cases:\n    - Splitting markdown documentation while preserving structure\n    - Processing markdown files for semantic search\n    - Creating context-aware chunks from markdown content",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitMarkdown",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document"
        },
        {
          "name": "headers_to_split_on",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tuple",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "default": [
            [
              "#",
              "Header 1"
            ],
            [
              "##",
              "Header 2"
            ],
            [
              "###",
              "Header 3"
            ]
          ],
          "title": "Headers To Split On",
          "description": "List of tuples containing (header_symbol, header_name)"
        },
        {
          "name": "strip_headers",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Strip Headers",
          "description": "Whether to remove headers from the output content"
        },
        {
          "name": "return_each_line",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Return Each Line",
          "description": "Whether to split into individual lines instead of header sections"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int",
            "optional": true
          },
          "default": null,
          "title": "Chunk Size",
          "description": "Optional maximum chunk size for further splitting"
        },
        {
          "name": "chunk_overlap",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Chunk Overlap",
          "description": "Overlap size when using chunk_size"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "source_id"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "start_index"
        }
      ],
      "basic_fields": [
        "document",
        "headers_to_split_on",
        "strip_headers",
        "return_each_line",
        "chunk_size",
        "chunk_overlap"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Split Recursively",
      "description": "Splits text recursively using LangChain's RecursiveCharacterTextSplitter.\n    text, split, chunks\n\n    Use cases:\n    - Splitting documents while preserving semantic relationships\n    - Creating chunks for language model processing\n    - Handling text in languages with/without word boundaries",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitRecursively",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 1000,
          "title": "Chunk Size",
          "description": "Maximum size of each chunk in characters"
        },
        {
          "name": "chunk_overlap",
          "type": {
            "type": "int"
          },
          "default": 200,
          "title": "Chunk Overlap",
          "description": "Number of characters to overlap between chunks"
        },
        {
          "name": "separators",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [
            "\n\n",
            "\n",
            "."
          ],
          "title": "Separators",
          "description": "List of separators to use for splitting, in order of preference"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "source_id"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "start_index"
        }
      ],
      "basic_fields": [
        "document",
        "chunk_size",
        "chunk_overlap",
        "separators"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Split into Sentences",
      "description": "Splits text into sentences using LangChain's SentenceTransformersTokenTextSplitter.\n    sentences, split, nlp\n\n    Use cases:\n    - Natural sentence-based text splitting\n    - Creating semantically meaningful chunks\n    - Processing text for sentence-level analysis",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitSentences",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 40,
          "title": "Chunk Size",
          "description": "Maximum number of tokens per chunk"
        },
        {
          "name": "chunk_overlap",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "Chunk Overlap",
          "description": "Number of tokens to overlap between chunks"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "source_id"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "start_index"
        }
      ],
      "basic_fields": [
        "document",
        "chunk_size",
        "chunk_overlap"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Audio Mixer",
      "description": "Mix up to 5 audio tracks together with individual volume controls.\n    audio, mix, volume, combine, blend, layer, add, overlay\n\n    Use cases:\n    - Mix multiple audio tracks into a single output\n    - Create layered soundscapes\n    - Combine music, voice, and sound effects\n    - Adjust individual track volumes",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.AudioMixer",
      "properties": [
        {
          "name": "track1",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Track1",
          "description": "First audio track to mix."
        },
        {
          "name": "track2",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Track2",
          "description": "Second audio track to mix."
        },
        {
          "name": "track3",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Track3",
          "description": "Third audio track to mix."
        },
        {
          "name": "track4",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Track4",
          "description": "Fourth audio track to mix."
        },
        {
          "name": "track5",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Track5",
          "description": "Fifth audio track to mix."
        },
        {
          "name": "volume1",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume1",
          "description": "Volume for track 1. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "volume2",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume2",
          "description": "Volume for track 2. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "volume3",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume3",
          "description": "Volume for track 3. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "volume4",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume4",
          "description": "Volume for track 4. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "volume5",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume5",
          "description": "Volume for track 5. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "track1",
        "track2",
        "track3",
        "track4",
        "track5",
        "volume1",
        "volume2",
        "volume3",
        "volume4",
        "volume5"
      ]
    },
    {
      "title": "Audio To Numpy",
      "description": "Convert audio to numpy array for processing.\n    audio, numpy, convert, array\n\n    Use cases:\n    - Prepare audio for custom processing\n    - Convert audio for machine learning models\n    - Extract raw audio data for analysis",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.AudioToNumpy",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio to convert to numpy."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "array"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "sample_rate"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "channels"
        }
      ],
      "basic_fields": [
        "audio"
      ]
    },
    {
      "title": "Concat",
      "description": "Concatenates two audio files together.\n    audio, edit, join, +\n\n    Use cases:\n    - Combine multiple audio clips into a single file\n    - Create longer audio tracks from shorter segments",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.Concat",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "A",
          "description": "The first audio file."
        },
        {
          "name": "b",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "B",
          "description": "The second audio file."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Concat List",
      "description": "Concatenates multiple audio files together in sequence.\n    audio, edit, join, multiple, +\n\n    Use cases:\n    - Combine multiple audio clips into a single file\n    - Create longer audio tracks from multiple segments\n    - Chain multiple audio files in order",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.ConcatList",
      "properties": [
        {
          "name": "audio_files",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "audio"
              }
            ]
          },
          "default": [],
          "title": "Audio Files",
          "description": "List of audio files to concatenate in sequence."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio_files"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Convert To Array",
      "description": "Converts an audio file to a Array for further processing.\n    audio, conversion, tensor\n\n    Use cases:\n    - Prepare audio data for machine learning models\n    - Enable signal processing operations on audio\n    - Convert audio to a format suitable for spectral analysisr",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.ConvertToArray",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to convert to a tensor."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio"
      ]
    },
    {
      "title": "Create Silence",
      "description": "Creates a silent audio file with a specified duration.\n    audio, silence, empty\n\n    Use cases:\n    - Generate placeholder audio files\n    - Create audio segments for padding or spacing\n    - Add silence to the beginning or end of audio files",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.CreateSilence",
      "properties": [
        {
          "name": "duration",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Duration",
          "description": "The duration of the silence in seconds.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "duration"
      ]
    },
    {
      "title": "Fade In",
      "description": "Applies a fade-in effect to the beginning of an audio file.\n    audio, edit, transition\n\n    Use cases:\n    - Create smooth introductions to audio tracks\n    - Gradually increase volume at the start of a clip",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.FadeIn",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to apply fade-in to."
        },
        {
          "name": "duration",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Duration",
          "description": "Duration of the fade-in effect in seconds.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "duration"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Fade Out",
      "description": "Applies a fade-out effect to the end of an audio file.\n    audio, edit, transition\n\n    Use cases:\n    - Create smooth endings to audio tracks\n    - Gradually decrease volume at the end of a clip",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.FadeOut",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to apply fade-out to."
        },
        {
          "name": "duration",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Duration",
          "description": "Duration of the fade-out effect in seconds.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "duration"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Load Audio Assets",
      "description": "Load audio files from an asset folder.\n    load, audio, file, import",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.LoadAudioAssets",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The asset folder to load the audio files from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        }
      ],
      "basic_fields": [
        "folder"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Load Audio File",
      "description": "Read an audio file from disk.\n    audio, input, load, file\n\n    Use cases:\n    - Load audio for processing\n    - Import sound files for editing\n    - Read audio assets for a workflow",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.LoadAudioFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the audio file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Load Audio Folder",
      "description": "Load all audio files from a folder, optionally including subfolders.\n    audio, load, folder, files\n\n    Use cases:\n    - Batch import audio for processing\n    - Build datasets from a directory tree\n    - Iterate over audio collections",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.LoadAudioFolder",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Folder to scan for audio files"
        },
        {
          "name": "include_subdirectories",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Include Subdirectories",
          "description": "Include audio in subfolders"
        },
        {
          "name": "extensions",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [
            ".mp3",
            ".wav",
            ".flac",
            ".ogg",
            ".m4a",
            ".aac"
          ],
          "title": "Extensions",
          "description": "Audio file extensions to include"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "path"
        }
      ],
      "basic_fields": [
        "folder",
        "include_subdirectories",
        "extensions"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Mono To Stereo",
      "description": "Converts a mono audio signal to stereo.\n    audio, convert, channels\n\n    Use cases:\n    - Expand mono recordings for stereo playback systems\n    - Prepare audio for further stereo processing",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.MonoToStereo",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The mono audio file to convert."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Normalize",
      "description": "Normalizes the volume of an audio file.\n    audio, fix, dynamics, volume\n\n    Use cases:\n    - Ensure consistent volume across multiple audio files\n    - Adjust overall volume level before further processing",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.Normalize",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to normalize."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Numpy To Audio",
      "description": "Convert numpy array to audio.\n    audio, numpy, convert\n\n    Use cases:\n    - Convert processed audio data back to audio format\n    - Create audio from machine learning model outputs\n    - Generate audio from synthesized waveforms",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.NumpyToAudio",
      "properties": [
        {
          "name": "array",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Array",
          "description": "The numpy array to convert to audio."
        },
        {
          "name": "sample_rate",
          "type": {
            "type": "int"
          },
          "default": 44100,
          "title": "Sample Rate",
          "description": "Sample rate in Hz."
        },
        {
          "name": "channels",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Channels",
          "description": "Number of audio channels (1 or 2)."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "array",
        "sample_rate",
        "channels"
      ]
    },
    {
      "title": "Overlay Audio",
      "description": "Overlays two audio files together.\n    audio, edit, transform\n\n    Use cases:\n    - Mix background music with voice recording\n    - Layer sound effects over an existing audio track",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.OverlayAudio",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "A",
          "description": "The first audio file."
        },
        {
          "name": "b",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "B",
          "description": "The second audio file."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Realtime Whisper",
      "description": "Stream audio input to WhisperLive and emit real-time transcription.\n    realtime, whisper, transcription, streaming, audio-to-text, speech-to-text\n\n    Emits:\n      - `chunk` Chunk(content=..., done=False) for transcript deltas\n      - `chunk` Chunk(content=\"\", done=True) to mark segment end\n      - `text` final aggregated transcript when input ends",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.RealtimeWhisper",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "tiny",
              "base",
              "small",
              "medium",
              "large",
              "large-v2",
              "large-v3"
            ],
            "type_name": "nodetool.nodes.nodetool.audio.RealtimeWhisper.WhisperModel"
          },
          "default": "tiny",
          "title": "Model",
          "description": "Whisper model size - larger models are more accurate but slower"
        },
        {
          "name": "language",
          "type": {
            "type": "enum",
            "values": [
              "auto",
              "en",
              "es",
              "fr",
              "de",
              "it",
              "pt",
              "nl",
              "ru",
              "zh",
              "ja",
              "ko",
              "ar",
              "hi",
              "tr",
              "pl",
              "uk",
              "vi"
            ],
            "type_name": "nodetool.nodes.nodetool.audio.RealtimeWhisper.Language"
          },
          "default": "en",
          "title": "Language",
          "description": "Language code for transcription, or 'auto' for automatic detection"
        },
        {
          "name": "chunk",
          "type": {
            "type": "chunk"
          },
          "default": {
            "type": "chunk",
            "node_id": null,
            "content_type": "text",
            "content": "",
            "content_metadata": {},
            "done": false
          },
          "title": "Chunk",
          "description": "The audio chunk to transcribe"
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Temperature",
          "description": "Sampling temperature for transcription",
          "min": 0.0,
          "max": 1.0
        },
        {
          "name": "initial_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Initial Prompt",
          "description": "Optional initial prompt to guide transcription style"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "start"
        },
        {
          "type": {
            "type": "float"
          },
          "name": "end"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "speaker"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "detected_language"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "translation"
        }
      ],
      "basic_fields": [
        "model",
        "language",
        "chunk",
        "temperature",
        "initial_prompt"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Remove Silence",
      "description": "Removes or shortens silence in an audio file with smooth transitions.\n    audio, edit, clean\n\n    Use cases:\n    - Trim silent parts from beginning/end of recordings\n    - Remove or shorten long pauses between speech segments\n    - Apply crossfade for smooth transitions",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.RemoveSilence",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to process."
        },
        {
          "name": "min_length",
          "type": {
            "type": "int"
          },
          "default": 200,
          "title": "Min Length",
          "description": "Minimum length of silence to be processed (in milliseconds).",
          "min": 0.0,
          "max": 10000.0
        },
        {
          "name": "threshold",
          "type": {
            "type": "int"
          },
          "default": -40,
          "title": "Threshold",
          "description": "Silence threshold in dB (relative to full scale). Higher values detect more silence.",
          "min": -60.0,
          "max": 0.0
        },
        {
          "name": "reduction_factor",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Reduction Factor",
          "description": "Factor to reduce silent parts (0.0 to 1.0). 0.0 keeps silence as is, 1.0 removes it completely.",
          "min": 0.0,
          "max": 1.0
        },
        {
          "name": "crossfade",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Crossfade",
          "description": "Duration of crossfade in milliseconds to apply between segments for smooth transitions.",
          "min": 0.0,
          "max": 50.0
        },
        {
          "name": "min_silence_between_parts",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Min Silence Between Parts",
          "description": "Minimum silence duration in milliseconds to maintain between non-silent segments",
          "min": 0.0,
          "max": 500.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "min_length",
        "threshold",
        "reduction_factor",
        "crossfade",
        "min_silence_between_parts"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Repeat",
      "description": "Loops an audio file a specified number of times.\n    audio, edit, repeat\n\n    Use cases:\n    - Create repeating background sounds or music\n    - Extend short audio clips to fill longer durations\n    - Generate rhythmic patterns from short samples",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.Repeat",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to loop."
        },
        {
          "name": "loops",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Loops",
          "description": "Number of times to loop the audio. Minimum 1 (plays once), maximum 100.",
          "min": 1.0,
          "max": 100.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "loops"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Reverse",
      "description": "Reverses an audio file.\n    audio, edit, transform\n\n    Use cases:\n    - Create reverse audio effects\n    - Generate backwards speech or music",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.Reverse",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to reverse."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Save Audio Asset",
      "description": "Save an audio file to a specified asset folder.\n    audio, folder, name\n\n    Use cases:\n    - Save generated audio files with timestamps\n    - Organize outputs into specific folders\n    - Create backups of generated audio",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.SaveAudio",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The asset folder to save the audio file to. "
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d-%H-%M-%S.opus",
          "title": "Name",
          "description": "\n        The name of the audio file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "folder",
        "name"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Save Audio File",
      "description": "Write an audio file to disk.\n    audio, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.SaveAudioFile",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "\n        Name of the file to save.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "folder",
        "filename"
      ]
    },
    {
      "title": "Slice Audio",
      "description": "Extracts a section of an audio file.\n    audio, edit, trim\n\n    Use cases:\n    - Cut out a specific clip from a longer audio file\n    - Remove unwanted portions from beginning or end",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.SliceAudio",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file."
        },
        {
          "name": "start",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Start",
          "description": "The start time in seconds.",
          "min": 0.0
        },
        {
          "name": "end",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "End",
          "description": "The end time in seconds.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "start",
        "end"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Stereo To Mono",
      "description": "Converts a stereo audio signal to mono.\n    audio, convert, channels\n\n    Use cases:\n    - Reduce file size for mono-only applications\n    - Simplify audio for certain processing tasks",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.StereoToMono",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The stereo audio file to convert."
        },
        {
          "name": "method",
          "type": {
            "type": "str"
          },
          "default": "average",
          "title": "Method",
          "description": "Method to use for conversion: 'average', 'left', or 'right'."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "method"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Text To Speech",
      "description": "Generate speech audio from text using any supported TTS provider.\n    Automatically routes to the appropriate backend (OpenAI, HuggingFace, MLX).\n    audio, generation, AI, text-to-speech, tts, voice\n\n    Use cases:\n    - Create voiceovers for videos and presentations\n    - Generate natural-sounding narration for content\n    - Build voice assistants and chatbots\n    - Convert written content to audio format\n    - Create accessible audio versions of text",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.TextToSpeech",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "tts_model"
          },
          "default": {
            "type": "tts_model",
            "provider": "openai",
            "id": "tts-1",
            "name": "TTS 1",
            "voices": [
              "alloy",
              "echo",
              "fable",
              "onyx",
              "nova",
              "shimmer"
            ],
            "selected_voice": ""
          },
          "title": "Model",
          "description": "The text-to-speech model to use"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "Hello! This is a text-to-speech demonstration.",
          "title": "Text",
          "description": "Text to convert to speech"
        },
        {
          "name": "speed",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Speed",
          "description": "Speech speed multiplier (0.25 to 4.0)",
          "min": 0.25,
          "max": 4.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        },
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        }
      ],
      "basic_fields": [
        "model",
        "text",
        "voice",
        "speed"
      ],
      "is_streaming_output": true,
      "expose_as_tool": true
    },
    {
      "title": "Trim",
      "description": "Trim an audio file to a specified duration.\n    audio, trim, cut\n\n    Use cases:\n    - Remove silence from the beginning or end of audio files\n    - Extract specific segments from audio files\n    - Prepare audio data for machine learning models",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.Trim",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to trim."
        },
        {
          "name": "start",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Start",
          "description": "The start time of the trimmed audio in seconds.",
          "min": 0.0
        },
        {
          "name": "end",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "End",
          "description": "The end time of the trimmed audio in seconds.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "start",
        "end"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Audio",
      "description": "Represents an audio file constant in the workflow.\n    audio, file, mp3, wav\n\n    Use cases:\n    - Provide a fixed audio input for audio processing nodes\n    - Reference a specific audio file in the workflow\n    - Set default audio for testing or demonstration purposes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Audio",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Bool",
      "description": "Represents a boolean constant in the workflow.\n    boolean, logic, flag\n\n    Use cases:\n    - Control flow decisions in conditional nodes\n    - Toggle features or behaviors in the workflow\n    - Set default boolean values for configuration",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Bool",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Constant",
      "description": "Base class for fixed-value nodes.\n\n    constant, parameter, default\n\n    Use cases:\n    - Provide static inputs to a workflow\n    - Hold configuration values\n    - Simplify testing with deterministic outputs",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Constant"
    },
    {
      "title": "Data Frame",
      "description": "Represents a fixed DataFrame constant in the workflow.\n    table, data, dataframe, pandas\n\n    Use cases:\n    - Provide static data for analysis or processing\n    - Define lookup tables or reference data\n    - Set sample data for testing or demonstration",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.DataFrame",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "DataFrame"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Date",
      "description": "Make a date object from year, month, day.\n    date, make, create",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Date",
      "properties": [
        {
          "name": "year",
          "type": {
            "type": "int"
          },
          "default": 1900,
          "title": "Year",
          "description": "Year of the date"
        },
        {
          "name": "month",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Month",
          "description": "Month of the date"
        },
        {
          "name": "day",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Day",
          "description": "Day of the date"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "date"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "year",
        "month",
        "day"
      ]
    },
    {
      "title": "Date Time",
      "description": "Make a datetime object from year, month, day, hour, minute, second.\n    datetime, make, create",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.DateTime",
      "properties": [
        {
          "name": "year",
          "type": {
            "type": "int"
          },
          "default": 1900,
          "title": "Year",
          "description": "Year of the datetime"
        },
        {
          "name": "month",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Month",
          "description": "Month of the datetime"
        },
        {
          "name": "day",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Day",
          "description": "Day of the datetime"
        },
        {
          "name": "hour",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Hour",
          "description": "Hour of the datetime"
        },
        {
          "name": "minute",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Minute",
          "description": "Minute of the datetime"
        },
        {
          "name": "second",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Second",
          "description": "Second of the datetime"
        },
        {
          "name": "microsecond",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Microsecond",
          "description": "Microsecond of the datetime"
        },
        {
          "name": "tzinfo",
          "type": {
            "type": "str"
          },
          "default": "UTC",
          "title": "Tzinfo",
          "description": "Timezone of the datetime"
        },
        {
          "name": "utc_offset",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Utc Offset",
          "description": "UTC offset of the datetime"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "year",
        "month",
        "day",
        "hour",
        "minute",
        "second",
        "microsecond",
        "tzinfo",
        "utc_offset"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Dict",
      "description": "Represents a dictionary constant in the workflow.\n    dictionary, key-value, mapping\n\n    Use cases:\n    - Store configuration settings\n    - Provide structured data inputs\n    - Define parameter sets for other nodes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Dict",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Document",
      "description": "Represents a document constant in the workflow.\n    document, pdf, word, docx",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Document",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Float",
      "description": "Represents a floating-point number constant in the workflow.\n    number, decimal, float\n\n    Use cases:\n    - Set numerical parameters for calculations\n    - Define thresholds or limits\n    - Provide fixed numerical inputs for processing",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Float",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "Image",
      "description": "Represents an image file constant in the workflow.\n    picture, photo, image\n\n    Use cases:\n    - Provide a fixed image input for image processing nodes\n    - Reference a specific image file in the workflow\n    - Set default image for testing or demonstration purposes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Image",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Integer",
      "description": "Represents an integer constant in the workflow.\n    number, integer, whole\n\n    Use cases:\n    - Set numerical parameters for calculations\n    - Define counts, indices, or sizes\n    - Provide fixed numerical inputs for processing",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Integer",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "JSON",
      "description": "Represents a JSON constant in the workflow.\n    json, object, dictionary",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.JSON",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "json"
          },
          "default": {
            "type": "json",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "json"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "List",
      "description": "Represents a list constant in the workflow.\n    array, sequence, collection\n\n    Use cases:\n    - Store multiple values of the same type\n    - Provide ordered data inputs\n    - Define sequences for iteration in other nodes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.List",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "String",
      "description": "Represents a string constant in the workflow.\n    text, string, characters\n\n    Use cases:\n    - Provide fixed text inputs for processing\n    - Define labels, identifiers, or names\n    - Set default text values for configuration",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.String",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "Video",
      "description": "Represents a video file constant in the workflow.\n    video, movie, mp4, file\n\n    Use cases:\n    - Provide a fixed video input for video processing nodes\n    - Reference a specific video file in the workflow\n    - Set default video for testing or demonstration purposes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Video",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Copy Workspace File",
      "description": "Copy a file within the workspace.\n    workspace, file, copy, duplicate\n\n    Use cases:\n    - Create file backups in workspace\n    - Duplicate files for different processing\n    - Copy files to subdirectories",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.CopyWorkspaceFile",
      "properties": [
        {
          "name": "source",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Source",
          "description": "Relative source path within workspace"
        },
        {
          "name": "destination",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Destination",
          "description": "Relative destination path within workspace"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "source",
        "destination"
      ]
    },
    {
      "title": "Create Workspace Directory",
      "description": "Create a directory in the workspace.\n    workspace, directory, create, folder\n\n    Use cases:\n    - Organize workspace files into directories\n    - Create output directories for generated files\n    - Set up workspace structure",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.CreateWorkspaceDirectory",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path to directory within workspace"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Delete Workspace File",
      "description": "Delete a file or directory from the workspace.\n    workspace, file, delete, remove\n\n    Use cases:\n    - Clean up temporary files\n    - Remove processed files\n    - Clear workspace data",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.DeleteWorkspaceFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path to file or directory within workspace"
        },
        {
          "name": "recursive",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Recursive",
          "description": "Delete directories recursively"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "none"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path",
        "recursive"
      ]
    },
    {
      "title": "Get Workspace Dir",
      "description": "Get the current workspace directory path.\n    workspace, directory, path\n\n    Use cases:\n    - Get the workspace path for reference\n    - Display workspace location\n    - Pass workspace path to other nodes",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.GetWorkspaceDir",
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ]
    },
    {
      "title": "Get Workspace File Info",
      "description": "Get information about a file in the workspace.\n    workspace, file, info, metadata\n\n    Use cases:\n    - Get file size and timestamps\n    - Check file type (file vs directory)\n    - Inspect file metadata",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.GetWorkspaceFileInfo",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path to file within workspace"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Get Workspace File Size",
      "description": "Get file size in bytes for a workspace file.\n    workspace, file, size, bytes\n\n    Use cases:\n    - Check file size before processing\n    - Monitor generated file sizes\n    - Validate file completeness",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.GetWorkspaceFileSize",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path to file within workspace"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Is Workspace Directory",
      "description": "Check if a path in the workspace is a directory.\n    workspace, directory, check, type\n\n    Use cases:\n    - Distinguish directories from files\n    - Validate directory paths\n    - Filter paths by type",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.IsWorkspaceDirectory",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path within workspace to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Is Workspace File",
      "description": "Check if a path in the workspace is a file.\n    workspace, file, check, type\n\n    Use cases:\n    - Distinguish files from directories\n    - Validate file types\n    - Filter paths by type",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.IsWorkspaceFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path within workspace to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Join Workspace Paths",
      "description": "Join path components relative to workspace.\n    workspace, path, join, combine\n\n    Use cases:\n    - Build file paths within workspace\n    - Construct nested paths\n    - Create organized file structures",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.JoinWorkspacePaths",
      "properties": [
        {
          "name": "paths",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Paths",
          "description": "Path components to join (relative to workspace)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "paths"
      ]
    },
    {
      "title": "List Workspace Files",
      "description": "List files in the workspace directory matching a pattern.\n    workspace, files, list, directory\n\n    Use cases:\n    - Get files for batch processing within workspace\n    - Filter workspace files by extension or pattern\n    - Discover generated files in workspace",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.ListWorkspaceFiles",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": ".",
          "title": "Path",
          "description": "Relative path within workspace (use . for workspace root)"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "*",
          "title": "Pattern",
          "description": "File pattern to match (e.g. *.txt, *.json)"
        },
        {
          "name": "recursive",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Recursive",
          "description": "Search subdirectories recursively"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "file"
        }
      ],
      "basic_fields": [
        "path",
        "pattern",
        "recursive"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Move Workspace File",
      "description": "Move or rename a file within the workspace.\n    workspace, file, move, rename\n\n    Use cases:\n    - Rename files in workspace\n    - Move files to subdirectories\n    - Reorganize workspace files",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.MoveWorkspaceFile",
      "properties": [
        {
          "name": "source",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Source",
          "description": "Relative source path within workspace"
        },
        {
          "name": "destination",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Destination",
          "description": "Relative destination path within workspace"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "source",
        "destination"
      ]
    },
    {
      "title": "Read Binary File",
      "description": "Read a binary file from the workspace as base64-encoded string.\n    workspace, file, read, binary\n\n    Use cases:\n    - Read generated binary data\n    - Load binary files for processing\n    - Access non-text files",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.ReadBinaryFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path to file within workspace"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Read Text File",
      "description": "Read a text file from the workspace.\n    workspace, file, read, text\n\n    Use cases:\n    - Read configuration files\n    - Load text data generated by previous nodes\n    - Process text files in workspace",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.ReadTextFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path to file within workspace"
        },
        {
          "name": "encoding",
          "type": {
            "type": "str"
          },
          "default": "utf-8",
          "title": "Encoding",
          "description": "Text encoding (utf-8, ascii, etc.)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path",
        "encoding"
      ]
    },
    {
      "title": "Save Image File",
      "description": "Save an image to a file in the workspace.\n    workspace, image, save, file, output\n\n    Use cases:\n    - Save processed images to workspace\n    - Export edited photos\n    - Archive image results",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.SaveImageFile",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": ".",
          "title": "Folder",
          "description": "Relative folder path within workspace (use . for workspace root)"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "image.png",
          "title": "Filename",
          "description": "\n        The name of the image file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        },
        {
          "name": "overwrite",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Overwrite",
          "description": "Overwrite the file if it already exists, otherwise file will be renamed"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "folder",
        "filename",
        "overwrite"
      ]
    },
    {
      "title": "Save Video File",
      "description": "Save a video file to the workspace.\n    workspace, video, save, file, output\n\n    Use cases:\n    - Save processed videos to workspace\n    - Export video results\n    - Archive video content\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.SaveVideoFile",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The video to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": ".",
          "title": "Folder",
          "description": "Relative folder path within workspace (use . for workspace root)"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "video.mp4",
          "title": "Filename",
          "description": "\n        Name of the file to save.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        },
        {
          "name": "overwrite",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Overwrite",
          "description": "Overwrite the file if it already exists, otherwise file will be renamed"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "folder",
        "filename",
        "overwrite"
      ]
    },
    {
      "title": "Workspace File Exists",
      "description": "Check if a file or directory exists in the workspace.\n    workspace, file, exists, check\n\n    Use cases:\n    - Validate file presence before processing\n    - Implement conditional logic based on file existence\n    - Check for generated files",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.WorkspaceFileExists",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path within workspace to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Write Binary File",
      "description": "Write binary data (base64-encoded) to a file in the workspace.\n    workspace, file, write, binary, save\n\n    Use cases:\n    - Save binary data to workspace\n    - Write decoded base64 data\n    - Export binary results",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.WriteBinaryFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path to file within workspace"
        },
        {
          "name": "content",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Content",
          "description": "Base64-encoded binary content to write"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path",
        "content"
      ]
    },
    {
      "title": "Write Text File",
      "description": "Write text to a file in the workspace.\n    workspace, file, write, text, save\n\n    Use cases:\n    - Save generated text to workspace\n    - Create configuration files\n    - Export processed text data",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.WriteTextFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path to file within workspace"
        },
        {
          "name": "content",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Content",
          "description": "Text content to write"
        },
        {
          "name": "encoding",
          "type": {
            "type": "str"
          },
          "default": "utf-8",
          "title": "Encoding",
          "description": "Text encoding (utf-8, ascii, etc.)"
        },
        {
          "name": "append",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Append",
          "description": "Append to file instead of overwriting"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path",
        "content",
        "encoding",
        "append"
      ]
    },
    {
      "title": "Arg Max",
      "description": "Returns the label associated with the highest value in a dictionary.\n    dictionary, maximum, label, argmax\n\n    Use cases:\n    - Get the most likely class from classification probabilities\n    - Find the category with highest score\n    - Identify the winner in a voting/ranking system",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.ArgMax",
      "layout": "small",
      "properties": [
        {
          "name": "scores",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": {},
          "title": "Scores",
          "description": "Dictionary mapping labels to their corresponding scores/values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "scores"
      ]
    },
    {
      "title": "Combine",
      "description": "Merges two dictionaries, with second dictionary values taking precedence.\n    dictionary, merge, update, +, add, concatenate\n\n    Use cases:\n    - Combine default and custom configurations\n    - Merge partial updates with existing data\n    - Create aggregate data structures",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Combine",
      "layout": "small",
      "properties": [
        {
          "name": "dict_a",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dict A"
        },
        {
          "name": "dict_b",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dict B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dict_a",
        "dict_b"
      ]
    },
    {
      "title": "Filter",
      "description": "Creates a new dictionary with only specified keys from the input.\n    dictionary, filter, select\n\n    Use cases:\n    - Extract relevant fields from a larger data structure\n    - Implement data access controls\n    - Prepare specific data subsets for processing",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Filter",
      "properties": [
        {
          "name": "dictionary",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dictionary"
        },
        {
          "name": "keys",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Keys"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dictionary",
        "keys"
      ]
    },
    {
      "title": "Get Value",
      "description": "Retrieves a value from a dictionary using a specified key.\n    dictionary, get, value, key\n\n    Use cases:\n    - Access a specific item in a configuration dictionary\n    - Retrieve a value from a parsed JSON object\n    - Extract a particular field from a data structure",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.GetValue",
      "layout": "small",
      "properties": [
        {
          "name": "dictionary",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dictionary"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key"
        },
        {
          "name": "default",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "Default"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dictionary",
        "key",
        "default"
      ]
    },
    {
      "title": "Load CSVFile",
      "description": "Read a CSV file from disk.\n    files, csv, read, input, load, file",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.LoadCSVFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the CSV file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Make Dictionary",
      "description": "Creates a simple dictionary with up to three key-value pairs.\n    dictionary, create, simple\n\n    Use cases:\n    - Create configuration entries\n    - Initialize simple data structures\n    - Build basic key-value mappings",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.MakeDictionary",
      "layout": "small",
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "is_dynamic": true
    },
    {
      "title": "Parse JSON",
      "description": "Parses a JSON string into a Python dictionary.\n    json, parse, dictionary\n\n    Use cases:\n    - Process API responses\n    - Load configuration files\n    - Deserialize stored data",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.ParseJSON",
      "layout": "small",
      "properties": [
        {
          "name": "json_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Json String"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "json_string"
      ]
    },
    {
      "title": "Reduce Dictionaries",
      "description": "Reduces a list of dictionaries into one dictionary based on a specified key field.\n    dictionary, reduce, aggregate\n\n    Use cases:\n    - Aggregate data by a specific field\n    - Create summary dictionaries from list of records\n    - Combine multiple data points into a single structure",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.ReduceDictionaries",
      "properties": [
        {
          "name": "dictionaries",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Dictionaries",
          "description": "List of dictionaries to be reduced"
        },
        {
          "name": "key_field",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key Field",
          "description": "The field to use as the key in the resulting dictionary"
        },
        {
          "name": "value_field",
          "type": {
            "type": "str",
            "optional": true
          },
          "default": null,
          "title": "Value Field",
          "description": "Optional field to use as the value. If not specified, the entire dictionary (minus the key field) will be used as the value."
        },
        {
          "name": "conflict_resolution",
          "type": {
            "type": "enum",
            "values": [
              "first",
              "last",
              "error"
            ],
            "type_name": "nodetool.nodes.nodetool.dictionary.ReduceDictionaries.ConflictResolution"
          },
          "default": "first",
          "title": "Conflict Resolution",
          "description": "How to handle conflicts when the same key appears multiple times"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "any"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dictionaries",
        "key_field",
        "value_field",
        "conflict_resolution"
      ]
    },
    {
      "title": "Remove",
      "description": "Removes a key-value pair from a dictionary.\n    dictionary, remove, delete\n\n    Use cases:\n    - Delete a specific configuration option\n    - Remove sensitive information before processing\n    - Clean up temporary entries in a data structure",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Remove",
      "layout": "small",
      "properties": [
        {
          "name": "dictionary",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dictionary"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dictionary",
        "key"
      ]
    },
    {
      "title": "Save CSVFile",
      "description": "Write a list of dictionaries to a CSV file.\n    files, csv, write, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.SaveCSVFile",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Data",
          "description": "list of dictionaries to write to CSV"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Name of the CSV file to save. Supports strftime format codes."
        }
      ],
      "basic_fields": [
        "data",
        "folder",
        "filename"
      ]
    },
    {
      "title": "Update",
      "description": "Updates a dictionary with new key-value pairs.\n    dictionary, add, update\n\n    Use cases:\n    - Extend a configuration with additional settings\n    - Add new entries to a cache or lookup table\n    - Merge user input with existing data",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Update",
      "layout": "small",
      "properties": [
        {
          "name": "dictionary",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dictionary"
        },
        {
          "name": "new_pairs",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "New Pairs"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dictionary",
        "new_pairs"
      ]
    },
    {
      "title": "Zip",
      "description": "Creates a dictionary from parallel lists of keys and values.\n    dictionary, create, zip\n\n    Use cases:\n    - Convert separate data columns into key-value pairs\n    - Create lookups from parallel data structures\n    - Transform list data into associative arrays",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Zip",
      "layout": "small",
      "properties": [
        {
          "name": "keys",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Keys"
        },
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "any"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "keys",
        "values"
      ]
    },
    {
      "title": "Add Audio",
      "description": "Add an audio track to a video, replacing or mixing with existing audio.\n    video, audio, soundtrack, merge\n\n    Use cases:\n    1. Add background music or narration to a silent video\n    2. Replace original audio with a new soundtrack\n    3. Mix new audio with existing video sound",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.AddAudio",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to add audio to."
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to add to the video."
        },
        {
          "name": "volume",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume",
          "description": "Volume adjustment for the added audio. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "mix",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Mix",
          "description": "If True, mix new audio with existing. If False, replace existing audio."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "audio",
        "volume",
        "mix"
      ]
    },
    {
      "title": "Add Subtitles",
      "description": "Add subtitles to a video.\n    video, subtitles, text, caption\n\n    Use cases:\n    1. Add translations or closed captions to videos\n    2. Include explanatory text or commentary in educational videos\n    3. Create lyric videos for music content",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.AddSubtitles",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to add subtitles to."
        },
        {
          "name": "chunks",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "audio_chunk"
              }
            ]
          },
          "default": [],
          "title": "Chunks",
          "description": "Audio chunks to add as subtitles."
        },
        {
          "name": "font",
          "type": {
            "type": "font"
          },
          "default": {
            "type": "font",
            "name": ""
          },
          "title": "Font",
          "description": "The font to use."
        },
        {
          "name": "align",
          "type": {
            "type": "enum",
            "values": [
              "top",
              "center",
              "bottom"
            ],
            "type_name": "nodetool.nodes.nodetool.video.AddSubtitles.SubtitleTextAlignment"
          },
          "default": "bottom",
          "title": "Align",
          "description": "Vertical alignment of subtitles."
        },
        {
          "name": "font_size",
          "type": {
            "type": "int"
          },
          "default": 24,
          "title": "Font Size",
          "description": "The font size.",
          "min": 1.0,
          "max": 72.0
        },
        {
          "name": "font_color",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#FFFFFF"
          },
          "title": "Font Color",
          "description": "The font color."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "chunks",
        "font",
        "align",
        "font_size",
        "font_color"
      ]
    },
    {
      "title": "Blur",
      "description": "Apply a blur effect to a video.\n    video, blur, smooth, soften\n\n    Use cases:\n    1. Create a dreamy or soft focus effect\n    2. Obscure or censor specific areas of the video\n    3. Reduce noise or grain in low-quality footage",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Blur",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to apply blur effect."
        },
        {
          "name": "strength",
          "type": {
            "type": "float"
          },
          "default": 5.0,
          "title": "Strength",
          "description": "The strength of the blur effect. Higher values create a stronger blur.",
          "min": 0.0,
          "max": 20.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "strength"
      ]
    },
    {
      "title": "Chroma Key",
      "description": "Apply chroma key (green screen) effect to a video.\n    video, chroma key, green screen, compositing\n\n    Use cases:\n    1. Remove green or blue background from video footage\n    2. Create special effects by compositing video onto new backgrounds\n    3. Produce professional-looking videos for presentations or marketing",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.ChromaKey",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to apply chroma key effect."
        },
        {
          "name": "key_color",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#00FF00"
          },
          "title": "Key Color",
          "description": "The color to key out (e.g., '#00FF00' for green)."
        },
        {
          "name": "similarity",
          "type": {
            "type": "float"
          },
          "default": 0.3,
          "title": "Similarity",
          "description": "Similarity threshold for the key color.",
          "min": 0.0,
          "max": 1.0
        },
        {
          "name": "blend",
          "type": {
            "type": "float"
          },
          "default": 0.1,
          "title": "Blend",
          "description": "Blending of the keyed area edges.",
          "min": 0.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "key_color",
        "similarity",
        "blend"
      ]
    },
    {
      "title": "Color Balance",
      "description": "Adjust the color balance of a video.\n    video, color, balance, adjustment\n\n    Use cases:\n    1. Correct color casts in video footage\n    2. Enhance specific color tones for artistic effect\n    3. Normalize color balance across multiple video clips",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.ColorBalance",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to adjust color balance."
        },
        {
          "name": "red_adjust",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Red Adjust",
          "description": "Red channel adjustment factor.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "green_adjust",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Green Adjust",
          "description": "Green channel adjustment factor.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "blue_adjust",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Blue Adjust",
          "description": "Blue channel adjustment factor.",
          "min": 0.0,
          "max": 2.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "red_adjust",
        "green_adjust",
        "blue_adjust"
      ]
    },
    {
      "title": "Concat",
      "description": "Concatenate multiple video files into a single video, including audio when available.\n    video, concat, merge, combine, audio, +",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Concat",
      "properties": [
        {
          "name": "video_a",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video A",
          "description": "The first video to concatenate."
        },
        {
          "name": "video_b",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video B",
          "description": "The second video to concatenate."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video_a",
        "video_b"
      ]
    },
    {
      "title": "Denoise",
      "description": "Apply noise reduction to a video.\n    video, denoise, clean, enhance\n\n    Use cases:\n    1. Improve video quality by reducing unwanted noise\n    2. Enhance low-light footage\n    3. Prepare video for further processing or compression",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Denoise",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to denoise."
        },
        {
          "name": "strength",
          "type": {
            "type": "float"
          },
          "default": 5.0,
          "title": "Strength",
          "description": "Strength of the denoising effect. Higher values mean more denoising.",
          "min": 0.0,
          "max": 20.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "strength"
      ]
    },
    {
      "title": "Extract Audio",
      "description": "Separate audio from a video file.\n    video, audio, extract, separate",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.ExtractAudio",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to separate."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video"
      ]
    },
    {
      "title": "Fps",
      "description": "Get the frames per second (FPS) of a video file.\n    video, analysis, frames, fps\n\n    Use cases:\n    1. Analyze video properties for quality assessment\n    2. Determine appropriate playback speed for video editing\n    3. Ensure compatibility with target display systems",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Fps",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to analyze for FPS."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video"
      ]
    },
    {
      "title": "Frame Iterator",
      "description": "Extract frames from a video file using OpenCV.\n    video, frames, extract, sequence\n\n    Use cases:\n    1. Generate image sequences for further processing\n    2. Extract specific frame ranges from a video\n    3. Create thumbnails or previews from video content",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.FrameIterator",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to extract frames from."
        },
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start",
          "description": "The frame to start extracting from."
        },
        {
          "name": "end",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End",
          "description": "The frame to stop extracting from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "frame"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "index"
        },
        {
          "type": {
            "type": "float"
          },
          "name": "fps"
        }
      ],
      "basic_fields": [
        "video",
        "start",
        "end"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Frame To Video",
      "description": "Combine a sequence of frames into a single video file.\n    video, frames, combine, sequence\n\n    Use cases:\n    1. Create time-lapse videos from image sequences\n    2. Compile processed frames back into a video\n    3. Generate animations from individual images",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.FrameToVideo",
      "properties": [
        {
          "name": "frame",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Frame",
          "description": "Collect input frames"
        },
        {
          "name": "fps",
          "type": {
            "type": "float"
          },
          "default": 30,
          "title": "Fps",
          "description": "The FPS of the output video."
        }
      ],
      "basic_fields": [
        "frame",
        "fps"
      ]
    },
    {
      "title": "Image To Video",
      "description": "Generate videos from input images using any supported video provider.\n    Animates static images into dynamic video content with AI-powered motion.\n    video, image-to-video, i2v, animation, AI, generation, sora, veo\n\n    Use cases:\n    - Animate static images into video sequences\n    - Create dynamic content from still photographs\n    - Generate video variations from reference images\n    - Produce animated visual effects from static artwork\n    - Convert product photos into engaging video ads",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.ImageToVideo",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The input image to animate into a video"
        },
        {
          "name": "model",
          "type": {
            "type": "video_model"
          },
          "default": {
            "type": "video_model",
            "provider": "gemini",
            "id": "veo-3.0-fast-generate-001",
            "name": "Veo 3.0 Fast"
          },
          "title": "Model",
          "description": "The video generation model to use"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text prompt to guide the video animation"
        },
        {
          "name": "negative_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Negative Prompt",
          "description": "Text prompt describing what to avoid in the video"
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "16:9",
              "9:16",
              "1:1",
              "4:3",
              "3:4"
            ],
            "type_name": "nodetool.nodes.nodetool.video.ImageToVideo.AspectRatio"
          },
          "default": "16:9",
          "title": "Aspect Ratio",
          "description": "Aspect ratio for the video"
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "480p",
              "720p",
              "1080p"
            ],
            "type_name": "nodetool.nodes.nodetool.video.ImageToVideo.Resolution"
          },
          "default": "720p",
          "title": "Resolution",
          "description": "Video resolution"
        },
        {
          "name": "num_frames",
          "type": {
            "type": "int"
          },
          "default": 60,
          "title": "Num Frames",
          "description": "Number of frames to generate (provider-specific)",
          "min": 1.0,
          "max": 300.0
        },
        {
          "name": "guidance_scale",
          "type": {
            "type": "float"
          },
          "default": 7.5,
          "title": "Guidance Scale",
          "description": "Classifier-free guidance scale (higher = closer to prompt)",
          "min": 0.0,
          "max": 30.0
        },
        {
          "name": "num_inference_steps",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Num Inference Steps",
          "description": "Number of denoising steps",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "seed",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Seed",
          "description": "Random seed for reproducibility (-1 for random)",
          "min": -1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "model",
        "prompt",
        "aspect_ratio",
        "resolution",
        "seed"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Load Video Folder",
      "description": "Load video files from an asset folder.\n\n    video, assets, load\n\n    Use cases:\n    - Provide videos for batch processing\n    - Iterate over stored video assets\n    - Prepare clips for editing or analysis",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.LoadVideoAssets",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The asset folder to load the video files from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "video"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        }
      ],
      "basic_fields": [
        "folder"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Load Video File",
      "description": "Read a video file from disk.\n    video, input, load, file\n\n    Use cases:\n    - Load videos for processing\n    - Import video files for editing\n    - Read video assets for a workflow",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.LoadVideoFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the video file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Overlay",
      "description": "Overlay one video on top of another, including audio overlay when available.\n    video, overlay, composite, picture-in-picture, audio",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Overlay",
      "properties": [
        {
          "name": "main_video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Main Video",
          "description": "The main (background) video."
        },
        {
          "name": "overlay_video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Overlay Video",
          "description": "The video to overlay on top."
        },
        {
          "name": "x",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "X",
          "description": "X-coordinate for overlay placement."
        },
        {
          "name": "y",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Y",
          "description": "Y-coordinate for overlay placement."
        },
        {
          "name": "scale",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Scale",
          "description": "Scale factor for the overlay video."
        },
        {
          "name": "overlay_audio_volume",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Overlay Audio Volume",
          "description": "Volume of the overlay audio relative to the main audio.",
          "min": 0.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "main_video",
        "overlay_video",
        "x",
        "y",
        "scale",
        "overlay_audio_volume"
      ]
    },
    {
      "title": "Resize",
      "description": "Resize a video to a specific width and height.\n    video, resize, scale, dimensions\n\n    Use cases:\n    1. Adjust video resolution for different display requirements\n    2. Reduce file size by downscaling video\n    3. Prepare videos for specific platforms with size constraints",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Resize",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to resize."
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Width",
          "description": "The target width. Use -1 to maintain aspect ratio."
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Height",
          "description": "The target height. Use -1 to maintain aspect ratio."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "width",
        "height"
      ]
    },
    {
      "title": "Reverse",
      "description": "Reverse the playback of a video.\n    video, reverse, backwards, effect\n\n    Use cases:\n    1. Create artistic effects by playing video in reverse\n    2. Analyze motion or events in reverse order\n    3. Generate unique transitions or intros for video projects",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Reverse",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to reverse."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video"
      ]
    },
    {
      "title": "Rotate",
      "description": "Rotate a video by a specified angle.\n    video, rotate, orientation, transform\n\n    Use cases:\n    1. Correct orientation of videos taken with a rotated camera\n    2. Create artistic effects by rotating video content\n    3. Adjust video for different display orientations",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Rotate",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to rotate."
        },
        {
          "name": "angle",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Angle",
          "description": "The angle of rotation in degrees.",
          "min": -360.0,
          "max": 360.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "angle"
      ]
    },
    {
      "title": "Saturation",
      "description": "Adjust the color saturation of a video.\n    video, saturation, color, enhance\n\n    Use cases:\n    1. Enhance color vibrancy in dull or flat-looking footage\n    2. Create stylistic effects by over-saturating or desaturating video\n    3. Correct oversaturated footage from certain cameras",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Saturation",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to adjust saturation."
        },
        {
          "name": "saturation",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Saturation",
          "description": "Saturation level. 1.0 is original, <1 decreases saturation, >1 increases saturation.",
          "min": 0.0,
          "max": 3.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "saturation"
      ]
    },
    {
      "title": "Save Video Asset",
      "description": "Save a video to an asset folder.\n    video, save, file, output\n\n    Use cases:\n    1. Export processed video to a specific asset folder\n    2. Save video with a custom name\n    3. Create a copy of a video in a different location",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.SaveVideo",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The video to save."
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The asset folder to save the video in."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d-%H-%M-%S.mp4",
          "title": "Name",
          "description": "\n        Name of the output video.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "folder",
        "name"
      ]
    },
    {
      "title": "Save Video File",
      "description": "Write a video file to disk.\n    video, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.SaveVideoFile",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The video to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "\n        Name of the file to save.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "folder",
        "filename"
      ]
    },
    {
      "title": "Set Speed",
      "description": "Adjust the playback speed of a video.\n    video, speed, tempo, time\n\n    Use cases:\n    1. Create slow-motion effects by decreasing video speed\n    2. Generate time-lapse videos by increasing playback speed\n    3. Synchronize video duration with audio or other timing requirements",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.SetSpeed",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to adjust speed."
        },
        {
          "name": "speed_factor",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Speed Factor",
          "description": "The speed adjustment factor. Values > 1 speed up, < 1 slow down."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "speed_factor"
      ]
    },
    {
      "title": "Sharpness",
      "description": "Adjust the sharpness of a video.\n    video, sharpen, enhance, detail\n\n    Use cases:\n    1. Enhance detail in slightly out-of-focus footage\n    2. Correct softness introduced by video compression\n    3. Create stylistic effects by over-sharpening",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Sharpness",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to sharpen."
        },
        {
          "name": "luma_amount",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Luma Amount",
          "description": "Amount of sharpening to apply to luma (brightness) channel.",
          "min": 0.0,
          "max": 3.0
        },
        {
          "name": "chroma_amount",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Chroma Amount",
          "description": "Amount of sharpening to apply to chroma (color) channels.",
          "min": 0.0,
          "max": 3.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "luma_amount",
        "chroma_amount"
      ]
    },
    {
      "title": "Stabilize",
      "description": "Apply video stabilization to reduce camera shake and jitter.\n    video, stabilize, smooth, shake-reduction\n\n    Use cases:\n    1. Improve quality of handheld or action camera footage\n    2. Smooth out panning and tracking shots\n    3. Enhance viewer experience by reducing motion sickness",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Stabilize",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to stabilize."
        },
        {
          "name": "smoothing",
          "type": {
            "type": "float"
          },
          "default": 10.0,
          "title": "Smoothing",
          "description": "Smoothing strength. Higher values result in smoother but potentially more cropped video.",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "crop_black",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Crop Black",
          "description": "Whether to crop black borders that may appear after stabilization."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "smoothing",
        "crop_black"
      ]
    },
    {
      "title": "Text To Video",
      "description": "Generate videos from text prompts using any supported video provider.\n    Automatically routes to the appropriate backend (Gemini Veo, HuggingFace).\n    video, generation, AI, text-to-video, t2v\n\n    Use cases:\n    - Create videos from text descriptions\n    - Generate video content from prompts\n    - Produce short video clips with AI\n    - Switch between providers without changing workflows",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.TextToVideo",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "video_model"
          },
          "default": {
            "type": "video_model",
            "provider": "gemini",
            "id": "veo-3.0-fast-generate-001",
            "name": "Veo 3.0 Fast"
          },
          "title": "Model",
          "description": "The video generation model to use"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "A cat playing with a ball of yarn",
          "title": "Prompt",
          "description": "Text prompt describing the desired video"
        },
        {
          "name": "negative_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Negative Prompt",
          "description": "Text prompt describing what to avoid in the video"
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "16:9",
              "9:16",
              "1:1",
              "4:3",
              "3:4"
            ],
            "type_name": "nodetool.nodes.nodetool.video.TextToVideo.AspectRatio"
          },
          "default": "16:9",
          "title": "Aspect Ratio",
          "description": "Aspect ratio for the video"
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "480p",
              "720p",
              "1080p"
            ],
            "type_name": "nodetool.nodes.nodetool.video.TextToVideo.Resolution"
          },
          "default": "720p",
          "title": "Resolution",
          "description": "Video resolution"
        },
        {
          "name": "num_frames",
          "type": {
            "type": "int"
          },
          "default": 60,
          "title": "Num Frames",
          "description": "Number of frames to generate (provider-specific)",
          "min": 1.0,
          "max": 300.0
        },
        {
          "name": "guidance_scale",
          "type": {
            "type": "float"
          },
          "default": 7.5,
          "title": "Guidance Scale",
          "description": "Classifier-free guidance scale (higher = closer to prompt)",
          "min": 0.0,
          "max": 30.0
        },
        {
          "name": "num_inference_steps",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Num Inference Steps",
          "description": "Number of denoising steps",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "seed",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Seed",
          "description": "Random seed for reproducibility (-1 for random)",
          "min": -1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "prompt",
        "aspect_ratio",
        "resolution",
        "seed"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Transition",
      "description": "Create a transition effect between two videos, including audio transition when available.\n    video, transition, effect, merge, audio\n\n    Use cases:\n    1. Create smooth transitions between video clips in a montage\n    2. Add professional-looking effects to video projects\n    3. Blend scenes together for creative storytelling\n    4. Smoothly transition between audio tracks of different video clips",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Transition",
      "properties": [
        {
          "name": "video_a",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video A",
          "description": "The first video in the transition."
        },
        {
          "name": "video_b",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video B",
          "description": "The second video in the transition."
        },
        {
          "name": "transition_type",
          "type": {
            "type": "enum",
            "values": [
              "fade",
              "wipeleft",
              "wiperight",
              "wipeup",
              "wipedown",
              "slideleft",
              "slideright",
              "slideup",
              "slidedown",
              "circlecrop",
              "rectcrop",
              "distance",
              "fadeblack",
              "fadewhite",
              "radial",
              "smoothleft",
              "smoothright",
              "smoothup",
              "smoothdown",
              "circleopen",
              "circleclose",
              "vertopen",
              "vertclose",
              "horzopen",
              "horzclose",
              "dissolve",
              "pixelize",
              "diagtl",
              "diagtr",
              "diagbl",
              "diagbr",
              "hlslice",
              "hrslice",
              "vuslice",
              "vdslice",
              "hblur",
              "fadegrays",
              "wipetl",
              "wipetr",
              "wipebl",
              "wipebr",
              "squeezeh",
              "squeezev",
              "zoomin",
              "fadefast",
              "fadeslow",
              "hlwind",
              "hrwind",
              "vuwind",
              "vdwind",
              "coverleft",
              "coverright",
              "coverup",
              "coverdown",
              "revealleft",
              "revealright",
              "revealup",
              "revealdown"
            ],
            "type_name": "nodetool.nodes.nodetool.video.Transition.TransitionType"
          },
          "default": "fade",
          "title": "Transition Type",
          "description": "Type of transition effect"
        },
        {
          "name": "duration",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Duration",
          "description": "Duration of the transition effect in seconds.",
          "min": 0.1,
          "max": 5.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video_a",
        "video_b",
        "transition_type",
        "duration"
      ]
    },
    {
      "title": "Trim",
      "description": "Trim a video to a specific start and end time.\n    video, trim, cut, segment\n\n    Use cases:\n    1. Extract specific segments from a longer video\n    2. Remove unwanted parts from the beginning or end of a video\n    3. Create shorter clips from a full-length video",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Trim",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to trim."
        },
        {
          "name": "start_time",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Start Time",
          "description": "The start time in seconds for the trimmed video."
        },
        {
          "name": "end_time",
          "type": {
            "type": "float"
          },
          "default": -1.0,
          "title": "End Time",
          "description": "The end time in seconds for the trimmed video. Use -1 for the end of the video."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "start_time",
        "end_time"
      ]
    },
    {
      "title": "Batch To List",
      "description": "Convert an image batch to a list of image references.\n    batch, list, images, processing\n\n    Use cases:\n    - Convert comfy batch outputs to list format",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.BatchToList",
      "properties": [
        {
          "name": "batch",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Batch",
          "description": "The batch of images to convert."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "batch"
      ]
    },
    {
      "title": "Crop",
      "description": "Crop an image to specified coordinates.\n    image, crop\n\n    - Remove unwanted borders from images\n    - Focus on particular subjects within an image\n    - Simplify images by removing distractions",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Crop",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to crop."
        },
        {
          "name": "left",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Left",
          "description": "The left coordinate.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "top",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Top",
          "description": "The top coordinate.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "right",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Right",
          "description": "The right coordinate.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "bottom",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Bottom",
          "description": "The bottom coordinate.",
          "min": 0.0,
          "max": 4096.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "left",
        "top",
        "right",
        "bottom"
      ]
    },
    {
      "title": "Fit",
      "description": "Resize an image to fit within specified dimensions while preserving aspect ratio.\n    image, resize, fit\n\n    - Resize images for online publishing requirements\n    - Preprocess images to uniform sizes for machine learning\n    - Control image display sizes for web development",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Fit",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to fit."
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Width",
          "description": "Width to fit to.",
          "min": 1.0,
          "max": 4096.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Height",
          "description": "Height to fit to.",
          "min": 1.0,
          "max": 4096.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "width",
        "height"
      ]
    },
    {
      "title": "Get Metadata",
      "description": "Get metadata about the input image.\n    metadata, properties, analysis, information\n\n    Use cases:\n    - Use width and height for layout calculations\n    - Analyze image properties for processing decisions\n    - Gather information for image cataloging or organization",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.GetMetadata",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The input image."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "format"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "mode"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "width"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "height"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "channels"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Image To Image",
      "description": "Transform images using text prompts with any supported image provider.\n    Automatically routes to the appropriate backend (HuggingFace, FAL, MLX).\n    image, transformation, AI, image-to-image, i2i\n\n    Use cases:\n    - Modify existing images with text instructions\n    - Style transfer and artistic modifications\n    - Image enhancement and refinement\n    - Creative image edits guided by prompts",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.ImageToImage",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "image_model"
          },
          "default": {
            "type": "image_model",
            "provider": "huggingface_fal_ai",
            "id": "fal-ai/flux/dev",
            "name": "FLUX.1 Dev"
          },
          "title": "Model",
          "description": "The image generation model to use"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "Input image to transform"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "A photorealistic version of the input image",
          "title": "Prompt",
          "description": "Text prompt describing the desired transformation"
        },
        {
          "name": "negative_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Negative Prompt",
          "description": "Text prompt describing what to avoid"
        },
        {
          "name": "strength",
          "type": {
            "type": "float"
          },
          "default": 0.8,
          "title": "Strength",
          "description": "How much to transform the input image (0.0 = no change, 1.0 = maximum change)",
          "min": 0.0,
          "max": 1.0
        },
        {
          "name": "guidance_scale",
          "type": {
            "type": "float"
          },
          "default": 7.5,
          "title": "Guidance Scale",
          "description": "Classifier-free guidance scale",
          "min": 0.0,
          "max": 30.0
        },
        {
          "name": "num_inference_steps",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Num Inference Steps",
          "description": "Number of denoising steps",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "target_width",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Target Width",
          "description": "Target width of the output image",
          "min": 64.0,
          "max": 2048.0
        },
        {
          "name": "target_height",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Target Height",
          "description": "Target height of the output image",
          "min": 64.0,
          "max": 2048.0
        },
        {
          "name": "seed",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Seed",
          "description": "Random seed for reproducibility (-1 for random)",
          "min": -1.0
        },
        {
          "name": "scheduler",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Scheduler",
          "description": "Scheduler to use (provider-specific)"
        },
        {
          "name": "safety_check",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Safety Check",
          "description": "Enable safety checker"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "image",
        "prompt",
        "strength",
        "seed"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Load Image Assets",
      "description": "Load images from an asset folder.\n    load, image, file, import",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.LoadImageAssets",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The asset folder to load the images from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "image"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        }
      ],
      "basic_fields": [
        "folder"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Load Image File",
      "description": "Read an image file from disk.\n    image, input, load, file\n\n    Use cases:\n    - Load images for processing\n    - Import photos for editing\n    - Read image assets for a workflow",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.LoadImageFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the image file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Load Image Folder",
      "description": "Load all images from a folder, optionally including subfolders.\n    image, load, folder, files\n\n    Use cases:\n    - Batch import images for processing\n    - Build datasets from a directory tree\n    - Iterate over photo collections",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.LoadImageFolder",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Folder to scan for images"
        },
        {
          "name": "include_subdirectories",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Include Subdirectories",
          "description": "Include images in subfolders"
        },
        {
          "name": "extensions",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [
            ".png",
            ".jpg",
            ".jpeg",
            ".bmp",
            ".gif",
            ".webp",
            ".tiff"
          ],
          "title": "Extensions",
          "description": "Image file extensions to include"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "Pattern to match image files"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "image"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "path"
        }
      ],
      "basic_fields": [
        "folder",
        "include_subdirectories",
        "extensions",
        "pattern"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Paste",
      "description": "Paste one image onto another at specified coordinates.\n    paste, composite, positioning, overlay\n\n    Use cases:\n    - Add watermarks or logos to images\n    - Combine multiple image elements\n    - Create collages or montages",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Paste",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to paste into."
        },
        {
          "name": "paste",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Paste",
          "description": "The image to paste."
        },
        {
          "name": "left",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Left",
          "description": "The left coordinate.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "top",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Top",
          "description": "The top coordinate.",
          "min": 0.0,
          "max": 4096.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "paste",
        "left",
        "top"
      ]
    },
    {
      "title": "Resize",
      "description": "Change image dimensions to specified width and height.\n    image, resize\n\n    - Preprocess images for machine learning model inputs\n    - Optimize images for faster web page loading\n    - Create uniform image sizes for layouts",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Resize",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to resize."
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Width",
          "description": "The target width.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Height",
          "description": "The target height.",
          "min": 0.0,
          "max": 4096.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "width",
        "height"
      ]
    },
    {
      "title": "Save Image Asset",
      "description": "Save an image to specified asset folder with customizable name format.\n    save, image, folder, naming\n\n    Use cases:\n    - Save generated images with timestamps\n    - Organize outputs into specific folders\n    - Create backups of processed images",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.SaveImage",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to save."
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The asset folder to save the image in."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d_%H-%M-%S.png",
          "title": "Name",
          "description": "\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "folder",
        "name"
      ]
    },
    {
      "title": "Save Image File",
      "description": "Write an image to disk.\n    image, output, save, file\n\n    Use cases:\n    - Save processed images\n    - Export edited photos\n    - Archive image results",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.SaveImageFile",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "\n        The name of the image file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        },
        {
          "name": "overwrite",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Overwrite",
          "description": "Overwrite the file if it already exists, otherwise file will be renamed"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "folder",
        "filename",
        "overwrite"
      ]
    },
    {
      "title": "Scale",
      "description": "Enlarge or shrink an image by a scale factor.\n    image, resize, scale\n\n    - Adjust image dimensions for display galleries\n    - Standardize image sizes for machine learning datasets\n    - Create thumbnail versions of images",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Scale",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to scale."
        },
        {
          "name": "scale",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Scale",
          "description": "The scale factor.",
          "min": 0.0,
          "max": 10.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "scale"
      ]
    },
    {
      "title": "Text To Image",
      "description": "Generate images from text prompts using any supported image provider.\n    Automatically routes to the appropriate backend (HuggingFace, FAL, MLX).\n    image, generation, AI, text-to-image, t2i\n\n    Use cases:\n    - Create images from text descriptions\n    - Switch between providers without changing workflows\n    - Generate images with different AI models\n    - Cost-optimize by choosing different providers",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.TextToImage",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "image_model"
          },
          "default": {
            "type": "image_model",
            "provider": "huggingface_fal_ai",
            "id": "fal-ai/flux/schnell",
            "name": "FLUX.1 Schnell"
          },
          "title": "Model",
          "description": "The image generation model to use"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "A cat holding a sign that says hello world",
          "title": "Prompt",
          "description": "Text prompt describing the desired image"
        },
        {
          "name": "negative_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Negative Prompt",
          "description": "Text prompt describing what to avoid in the image"
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Width",
          "description": "Width of the generated image",
          "min": 64.0,
          "max": 2048.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Height",
          "description": "Height of the generated image",
          "min": 64.0,
          "max": 2048.0
        },
        {
          "name": "guidance_scale",
          "type": {
            "type": "float"
          },
          "default": 7.5,
          "title": "Guidance Scale",
          "description": "Classifier-free guidance scale (higher = closer to prompt)",
          "min": 0.0,
          "max": 30.0
        },
        {
          "name": "num_inference_steps",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Num Inference Steps",
          "description": "Number of denoising steps",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "seed",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Seed",
          "description": "Random seed for reproducibility (-1 for random)",
          "min": -1.0
        },
        {
          "name": "scheduler",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Scheduler",
          "description": "Scheduler to use (provider-specific, leave empty for default)"
        },
        {
          "name": "safety_check",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Safety Check",
          "description": "Enable safety checker to filter inappropriate content"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "prompt",
        "width",
        "height",
        "seed"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Add Column",
      "description": "Add list of values as new column to dataframe.\n    dataframe, column, list\n\n    Use cases:\n    - Incorporate external data into existing dataframe\n    - Add calculated results as new column\n    - Augment dataframe with additional features",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.AddColumn",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "Dataframe object to add a new column to."
        },
        {
          "name": "column_name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Column Name",
          "description": "The name of the new column to be added to the dataframe."
        },
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values",
          "description": "A list of any type of elements which will be the new column's values."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "column_name",
        "values"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Aggregate",
      "description": "Aggregate dataframe by one or more columns.\n    aggregate, groupby, group, sum, mean, count, min, max, std, var, median, first, last\n\n    Use cases:\n    - Prepare data for aggregation operations\n    - Analyze data by categories\n    - Create summary statistics by groups",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Aggregate",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "The DataFrame to group."
        },
        {
          "name": "columns",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Columns",
          "description": "Comma-separated column names to group by."
        },
        {
          "name": "aggregation",
          "type": {
            "type": "str"
          },
          "default": "sum",
          "title": "Aggregation",
          "description": "Aggregation function: sum, mean, count, min, max, std, var, median, first, last"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "columns",
        "aggregation"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Append",
      "description": "Append two dataframes along rows.\n    append, concat, rows\n\n    Use cases:\n    - Combine data from multiple time periods\n    - Merge datasets with same structure\n    - Aggregate data from different sources",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Append",
      "properties": [
        {
          "name": "dataframe_a",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe A",
          "description": "First DataFrame to be appended."
        },
        {
          "name": "dataframe_b",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe B",
          "description": "Second DataFrame to be appended."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe_a",
        "dataframe_b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Drop Duplicates",
      "description": "Remove duplicate rows from dataframe.\n    duplicates, unique, clean\n\n    Use cases:\n    - Clean dataset by removing redundant entries\n    - Ensure data integrity in analysis\n    - Prepare data for unique value operations",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.DropDuplicates",
      "properties": [
        {
          "name": "df",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Df",
          "description": "The input DataFrame."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "df"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Drop NA",
      "description": "Remove rows with NA values from dataframe.\n    na, missing, clean\n\n    Use cases:\n    - Clean dataset by removing incomplete entries\n    - Prepare data for analysis requiring complete cases\n    - Improve data quality for modeling",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.DropNA",
      "properties": [
        {
          "name": "df",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Df",
          "description": "The input DataFrame."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "df"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Column",
      "description": "Convert dataframe column to list.\n    dataframe, column, list\n\n    Use cases:\n    - Extract data for use in other processing steps\n    - Prepare column data for plotting or analysis\n    - Convert categorical data to list for encoding",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.ExtractColumn",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "The input dataframe."
        },
        {
          "name": "column_name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Column Name",
          "description": "The name of the column to be converted to a list."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "column_name"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Fill NA",
      "description": "Fill missing values in dataframe.\n    fillna, missing, impute\n\n    Use cases:\n    - Handle missing data\n    - Prepare data for analysis\n    - Improve data quality",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.FillNA",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "The DataFrame with missing values."
        },
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "default": 0,
          "title": "Value",
          "description": "Value to use for filling missing values."
        },
        {
          "name": "method",
          "type": {
            "type": "str"
          },
          "default": "value",
          "title": "Method",
          "description": "Method for filling: value, forward, backward, mean, median"
        },
        {
          "name": "columns",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Columns",
          "description": "Comma-separated column names to fill. Leave empty for all columns."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "value",
        "method",
        "columns"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Filter",
      "description": "Filter dataframe based on condition.\n    filter, query, condition\n\n    Example conditions:\n    age > 30\n    age > 30 and salary < 50000\n    name == 'John Doe'\n    100 <= price <= 200\n    status in ['Active', 'Pending']\n    not (age < 18)\n\n    Use cases:\n    - Extract subset of data meeting specific criteria\n    - Remove outliers or invalid data points\n    - Focus analysis on relevant data segments",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Filter",
      "properties": [
        {
          "name": "df",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Df",
          "description": "The DataFrame to filter."
        },
        {
          "name": "condition",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Condition",
          "description": "The filtering condition to be applied to the DataFrame, e.g. column_name > 5."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "df",
        "condition"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Find Row",
      "description": "Find the first row in a dataframe that matches a given condition.\n    filter, query, condition, single row\n\n    Example conditions:\n    age > 30\n    age > 30 and salary < 50000\n    name == 'John Doe'\n    100 <= price <= 200\n    status in ['Active', 'Pending']\n    not (age < 18)\n\n    Use cases:\n    - Retrieve specific record based on criteria\n    - Find first occurrence of a particular condition\n    - Extract single data point for further analysis",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.FindRow",
      "properties": [
        {
          "name": "df",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Df",
          "description": "The DataFrame to search."
        },
        {
          "name": "condition",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Condition",
          "description": "The condition to filter the DataFrame, e.g. 'column_name == value'."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "df",
        "condition"
      ],
      "expose_as_tool": true
    },
    {
      "title": "From List",
      "description": "Convert list of dicts to dataframe.\n    list, dataframe, convert\n\n    Use cases:\n    - Transform list data into structured dataframe\n    - Prepare list data for analysis or visualization\n    - Convert API responses to dataframe format",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.FromList",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values",
          "description": "List of values to be converted, each value will be a row."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Import CSV",
      "description": "Convert CSV string to dataframe.\n    csv, dataframe, import\n\n    Use cases:\n    - Import CSV data from string input\n    - Convert CSV responses from APIs to dataframe",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.ImportCSV",
      "properties": [
        {
          "name": "csv_data",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "CSV Data",
          "description": "String input of CSV formatted text."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "csv_data"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Convert JSON to DataFrame",
      "description": "Transforms a JSON string into a pandas DataFrame.\n    json, dataframe, conversion\n\n    Use cases:\n    - Converting API responses to tabular format\n    - Preparing JSON data for analysis or visualization\n    - Structuring unstructured JSON data for further processing",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.JSONToDataframe",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "JSON"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Join",
      "description": "Join two dataframes on specified column.\n    join, merge, column\n\n    Use cases:\n    - Combine data from related tables\n    - Enrich dataset with additional information\n    - Link data based on common identifiers",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Join",
      "properties": [
        {
          "name": "dataframe_a",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe A",
          "description": "First DataFrame to be merged."
        },
        {
          "name": "dataframe_b",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe B",
          "description": "Second DataFrame to be merged."
        },
        {
          "name": "join_on",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Join On",
          "description": "The column name on which to join the two dataframes."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe_a",
        "dataframe_b",
        "join_on"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Load CSV Assets",
      "description": "Load dataframes from an asset folder.\n    load, dataframe, file, import\n\n    Use cases:\n    - Load multiple dataframes from a folder\n    - Process multiple datasets in sequence\n    - Batch import of data files",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.LoadCSVAssets",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The asset folder to load the dataframes from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "dataframe"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        }
      ],
      "basic_fields": [
        "folder"
      ],
      "is_streaming_output": true,
      "expose_as_tool": true
    },
    {
      "title": "Load CSVFile",
      "description": "Load CSV file from file path.\n    csv, dataframe, import",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.LoadCSVFile",
      "properties": [
        {
          "name": "file_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "File Path",
          "description": "The path to the CSV file to load."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "file_path"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Load CSVURL",
      "description": "Load CSV file from URL.\n    csv, dataframe, import",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.LoadCSVURL",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL of the CSV file to load."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Merge",
      "description": "Merge two dataframes along columns.\n    merge, concat, columns\n\n    Use cases:\n    - Combine data from multiple sources\n    - Add new features to existing dataframe\n    - Merge time series data from different periods",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Merge",
      "properties": [
        {
          "name": "dataframe_a",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe A",
          "description": "First DataFrame to be merged."
        },
        {
          "name": "dataframe_b",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe B",
          "description": "Second DataFrame to be merged."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe_a",
        "dataframe_b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Pivot",
      "description": "Pivot dataframe to reshape data.\n    pivot, reshape, transform\n\n    Use cases:\n    - Transform long data to wide format\n    - Create cross-tabulation tables\n    - Reorganize data for visualization",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Pivot",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "The DataFrame to pivot."
        },
        {
          "name": "index",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Index",
          "description": "Column name to use as index (rows)."
        },
        {
          "name": "columns",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Columns",
          "description": "Column name to use as columns."
        },
        {
          "name": "values",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Values",
          "description": "Column name to use as values."
        },
        {
          "name": "aggfunc",
          "type": {
            "type": "str"
          },
          "default": "sum",
          "title": "Aggfunc",
          "description": "Aggregation function: sum, mean, count, min, max, first, last"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "index",
        "columns",
        "values",
        "aggfunc"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Rename",
      "description": "Rename columns in dataframe.\n    rename, columns, names\n\n    Use cases:\n    - Standardize column names\n    - Make column names more descriptive\n    - Prepare data for specific requirements",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Rename",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "The DataFrame to rename columns."
        },
        {
          "name": "rename_map",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Rename Map",
          "description": "Column rename mapping in format: old1:new1,old2:new2"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "rename_map"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Row Iterator",
      "description": "Iterate over rows of a dataframe.",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.RowIterator",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "The input dataframe."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "dict"
        },
        {
          "type": {
            "type": "any"
          },
          "name": "index"
        }
      ],
      "basic_fields": [
        "dataframe"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Save CSVDataframe File",
      "description": "Write a pandas DataFrame to a CSV file.\n    files, csv, write, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.SaveCSVDataframeFile",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "DataFrame to write to CSV"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Name of the CSV file to save. Supports strftime format codes."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "folder",
        "filename"
      ]
    },
    {
      "title": "Save Dataframe",
      "description": "Save dataframe in specified folder.\n    csv, folder, save\n\n    Use cases:\n    - Export processed data for external use\n    - Create backups of dataframes",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.SaveDataframe",
      "properties": [
        {
          "name": "df",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Df"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "Name of the output folder."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "output.csv",
          "title": "Name",
          "description": "\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "df",
        "folder",
        "name"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Schema",
      "description": "Define a schema for a dataframe.\n    schema, dataframe, create",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Schema",
      "properties": [
        {
          "name": "columns",
          "type": {
            "type": "record_type"
          },
          "default": {
            "type": "record_type",
            "columns": []
          },
          "title": "Columns",
          "description": "The columns to use in the dataframe."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "record_type"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "columns"
      ]
    },
    {
      "title": "Select Column",
      "description": "Select specific columns from dataframe.\n    dataframe, columns, filter\n\n    Use cases:\n    - Extract relevant features for analysis\n    - Reduce dataframe size by removing unnecessary columns\n    - Prepare data for specific visualizations or models",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.SelectColumn",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "a dataframe from which columns are to be selected"
        },
        {
          "name": "columns",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Columns",
          "description": "comma separated list of column names"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "columns"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Slice",
      "description": "Slice a dataframe by rows using start and end indices.\n    slice, subset, rows\n\n    Use cases:\n    - Extract a specific range of rows from a large dataset\n    - Create training and testing subsets for machine learning\n    - Analyze data in smaller chunks",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Slice",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "The input dataframe to be sliced."
        },
        {
          "name": "start_index",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Index",
          "description": "The starting index of the slice (inclusive)."
        },
        {
          "name": "end_index",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Index",
          "description": "The ending index of the slice (exclusive). Use -1 for the last row."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "start_index",
        "end_index"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Sort By Column",
      "description": "Sort dataframe by specified column.\n    sort, order, column\n\n    Use cases:\n    - Arrange data in ascending or descending order\n    - Identify top or bottom values in dataset\n    - Prepare data for rank-based analysis",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.SortByColumn",
      "properties": [
        {
          "name": "df",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Df"
        },
        {
          "name": "column",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Column",
          "description": "The column to sort the DataFrame by."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "df",
        "column"
      ]
    },
    {
      "title": "To List",
      "description": "Convert dataframe to list of dictionaries.\n    dataframe, list, convert\n\n    Use cases:\n    - Convert dataframe data for API consumption\n    - Transform data for JSON serialization\n    - Prepare data for document-based storage",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.ToList",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "The input dataframe to convert."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Array Output",
      "description": "Output node for generic array data, typically numerical ('NPArray').\n    array, numerical, list, tensor, vector, matrix\n\n    Use cases:\n    - Outputting results from machine learning models (e.g., embeddings, predictions).\n    - Representing complex numerical data structures.\n    - Passing arrays of numbers between processing steps.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.ArrayOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Audio Output",
      "description": "Output node for audio content references ('AudioRef').\n    audio, sound, media, voice, speech, asset, reference\n\n    Use cases:\n    - Displaying or returning processed or generated audio.\n    - Passing audio data (as an 'AudioRef') between workflow nodes.\n    - Returning results of audio analysis (e.g., transcription reference, audio features).",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.AudioOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Boolean Output",
      "description": "Output node for a single boolean value.\n    boolean, true, false, flag, condition, flow-control, branch, else, switch, toggle\n\n    Use cases:\n    - Returning binary results (yes/no, true/false)\n    - Controlling conditional logic in workflows\n    - Indicating success/failure of operations",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.BooleanOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Dataframe Output",
      "description": "Output node for structured data references, typically tabular ('DataframeRef').\n    dataframe, table, structured, csv, tabular_data, rows, columns\n\n    Use cases:\n    - Outputting tabular data results from analysis or queries.\n    - Passing structured datasets between processing or analysis steps.\n    - Displaying data in a table format or making it available for download.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.DataframeOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Dictionary Output",
      "description": "Output node for key-value pair data (dictionary).\n    dictionary, key-value, mapping, object, json_object, struct\n\n    Use cases:\n    - Returning multiple named values as a single structured output.\n    - Passing complex data structures or configurations between nodes.\n    - Organizing heterogeneous output data into a named map.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.DictionaryOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Document Output",
      "description": "Output node for document content references ('DocumentRef').\n    document, file, pdf, text_file, asset, reference\n\n    Use cases:\n    - Displaying or returning processed or generated documents.\n    - Passing document data (as a 'DocumentRef') between workflow nodes.\n    - Returning results of document analysis or manipulation.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.DocumentOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "File Path Output",
      "description": "Output node for a file path.\n    file, path, file_path",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.FilePathOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "file_path"
          },
          "default": {
            "type": "file_path",
            "path": ""
          },
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Float Output",
      "description": "Output node for a single float value.\n    float, decimal, number\n\n    Use cases:\n    - Returning decimal results (e.g. percentages, ratios)\n    - Passing floating-point parameters between nodes\n    - Displaying numeric metrics with decimal precision",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.FloatOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Folder Path Output",
      "description": "Output node for a folder path.\n    folder, path, folder_path",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.FolderPathOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "folder_path"
          },
          "default": {
            "type": "folder_path",
            "path": ""
          },
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Image Output",
      "description": "Output node for a single image reference ('ImageRef').\n    image, picture, visual, asset, reference\n\n    Use cases:\n    - Displaying a single processed or generated image.\n    - Passing image data (as an 'ImageRef') between workflow nodes.\n    - Returning image analysis results encapsulated in an 'ImageRef'.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.ImageOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Integer Output",
      "description": "Output node for a single integer value.\n    integer, number, count\n\n    Use cases:\n    - Returning numeric results (e.g. counts, indices)\n    - Passing integer parameters between nodes\n    - Displaying numeric metrics",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.IntegerOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "List Output",
      "description": "Output node for a list of arbitrary values.\n    list, output, any\n\n    Use cases:\n    - Returning multiple results from a workflow\n    - Aggregating outputs from multiple nodes",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.ListOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "String Output",
      "description": "Output node for a string value.\n    string, text, output, label, name\n\n    Use cases:\n    - Returning short text results or messages.\n    - Passing concise string parameters or identifiers between nodes.\n    - Displaying brief textual outputs.\n    - For multi-line text or structured document content, use appropriate output nodes if available or consider how data is structured.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.StringOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Video Output",
      "description": "Output node for video content references ('VideoRef').\n    video, media, clip, asset, reference\n\n    Use cases:\n    - Displaying processed or generated video content.\n    - Passing video data (as a 'VideoRef') between workflow steps.\n    - Returning results of video analysis encapsulated in a 'VideoRef'.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.VideoOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Grounded Search",
      "description": "Search the web using Google's Gemini API with grounding capabilities.\n    google, search, grounded, web, gemini, ai\n\n    This node uses Google's Gemini API to perform web searches and return structured results\n    with source information. Requires a Gemini API key.\n\n    Use cases:\n    - Research current events and latest information\n    - Find reliable sources for fact-checking\n    - Gather web-based information with citations\n    - Get up-to-date information beyond the model's training data",
      "namespace": "gemini.text",
      "node_type": "gemini.text.GroundedSearch",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "The search query to execute"
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gemini-2.5-pro",
              "gemini-2.5-flash",
              "gemini-2.0-flash",
              "gemini-1.5-pro",
              "gemini-1.5-flash"
            ],
            "type_name": "nodetool.nodes.gemini.text.GeminiModel"
          },
          "default": "gemini-2.0-flash",
          "title": "Model",
          "description": "The Gemini model to use for search"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "results"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "source"
              }
            ]
          },
          "name": "sources"
        }
      ],
      "basic_fields": [
        "query",
        "model"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Text To Speech",
      "description": "Generate speech audio from text using Google's Gemini text-to-speech models.\n    google, text-to-speech, tts, audio, speech, voice, ai\n\n    This node converts text input into natural-sounding speech audio using Google's\n    advanced text-to-speech models with support for multiple voices and speech styles.\n\n    Use cases:\n    - Create voiceovers for videos and presentations\n    - Generate audio content for podcasts and audiobooks\n    - Add voice narration to applications\n    - Create accessibility features with speech output\n    - Generate multilingual audio content",
      "namespace": "gemini.audio",
      "node_type": "gemini.audio.TextToSpeech",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to convert to speech."
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gemini-2.5-flash-preview-tts",
              "gemini-2.5-pro-preview-tts"
            ],
            "type_name": "nodetool.nodes.gemini.audio.TTSModel"
          },
          "default": "gemini-2.5-flash-preview-tts",
          "title": "Model",
          "description": "The text-to-speech model to use"
        },
        {
          "name": "voice_name",
          "type": {
            "type": "enum",
            "values": [
              "Zephyr",
              "Puck",
              "Nova",
              "Quest",
              "Echo",
              "Fable",
              "Orbit",
              "Chime",
              "Kore",
              "Zenith",
              "Cosmos",
              "Sage",
              "Breeze",
              "Glimmer",
              "Drift",
              "Pearl",
              "Flux",
              "Prism",
              "Vega",
              "Lyra",
              "Ripple",
              "Azure",
              "Juno",
              "River",
              "Sterling",
              "Atlas",
              "Beacon",
              "Ember",
              "Harmony",
              "Spirit"
            ],
            "type_name": "nodetool.nodes.gemini.audio.VoiceName"
          },
          "default": "Kore",
          "title": "Voice Name",
          "description": "The voice to use for speech generation"
        },
        {
          "name": "style_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Style Prompt",
          "description": "Optional style prompt to control speech characteristics (e.g., 'Say cheerfully', 'Speak with excitement')"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "model",
        "voice_name",
        "style_prompt"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Image To Video",
      "description": "Generate videos from images using Google's Veo models.\n    google, video, generation, image-to-video, veo, ai, animation\n\n    This node uses Google's Veo models to animate static images into dynamic videos.\n    Supports 720p resolution at 24fps with 8-second duration and native audio generation.\n\n    Use cases:\n    - Animate still artwork and photographs\n    - Create dynamic social media content from images\n    - Generate product showcase videos from photos\n    - Transform static graphics into engaging animations\n    - Create video presentations from slide images",
      "namespace": "gemini.video",
      "node_type": "gemini.video.ImageToVideo",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to animate into a video"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text prompt describing the desired animation"
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "veo-3.0-generate-preview",
              "veo-3.0-fast-generate-preview",
              "veo-2.0-generate-001"
            ],
            "type_name": "nodetool.nodes.gemini.video.VeoModel"
          },
          "default": "veo-3.0-generate-preview",
          "title": "Model",
          "description": "The Veo model to use for video generation"
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "16:9",
              "9:16"
            ],
            "type_name": "nodetool.nodes.gemini.video.VeoAspectRatio"
          },
          "default": "16:9",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated video"
        },
        {
          "name": "negative_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Negative Prompt",
          "description": "Negative prompt to guide what to avoid in the video"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "prompt",
        "model",
        "aspect_ratio",
        "negative_prompt"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Text To Video",
      "description": "Generate videos from text prompts using Google's Veo models.\n    google, video, generation, text-to-video, veo, ai\n\n    This node uses Google's Veo models to generate high-quality videos from text descriptions.\n    Supports 720p resolution at 24fps with 8-second duration and native audio generation.\n\n    Use cases:\n    - Create cinematic clips from text descriptions\n    - Generate social media video content\n    - Produce marketing and promotional videos\n    - Visualize creative concepts and storyboards\n    - Create animated content with accompanying audio",
      "namespace": "gemini.video",
      "node_type": "gemini.video.TextToVideo",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the video to generate"
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "veo-3.0-generate-preview",
              "veo-3.0-fast-generate-preview",
              "veo-2.0-generate-001"
            ],
            "type_name": "nodetool.nodes.gemini.video.VeoModel"
          },
          "default": "veo-3.0-generate-preview",
          "title": "Model",
          "description": "The Veo model to use for video generation"
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "16:9",
              "9:16"
            ],
            "type_name": "nodetool.nodes.gemini.video.VeoAspectRatio"
          },
          "default": "16:9",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated video"
        },
        {
          "name": "negative_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Negative Prompt",
          "description": "Negative prompt to guide what to avoid in the video"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "model",
        "aspect_ratio",
        "negative_prompt"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Image Generation",
      "description": "Generate an image using Google's Imagen model via the Gemini API.\n    google, image generation, ai, imagen\n\n    Use cases:\n    - Create images from text descriptions\n    - Generate assets for creative projects\n    - Explore AI-powered image synthesis",
      "namespace": "gemini.image",
      "node_type": "gemini.image.ImageGeneration",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the image to generate."
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gemini-2.0-flash-preview-image-generation",
              "gemini-2.5-flash-image-preview",
              "imagen-3.0-generate-001",
              "imagen-3.0-generate-002",
              "imagen-4.0-generate-preview-06-06",
              "imagen-4.0-ultra-generate-preview-06-06"
            ],
            "type_name": "nodetool.nodes.gemini.image.ImageGenerationModel"
          },
          "default": "imagen-3.0-generate-002",
          "title": "Model",
          "description": "The image generation model to use"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to use as a base for the generation."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "model",
        "image"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Finance",
      "description": "Retrieve financial market data from Google Finance.\n    google, finance, stocks, market, serp",
      "namespace": "search.google",
      "node_type": "search.google.GoogleFinance",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "Stock symbol or company name to search for"
        },
        {
          "name": "window",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Window",
          "description": "Time window for financial data (e.g., '1d', '5d', '1m', '3m', '6m', '1y', '5y')"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "query",
        "window"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Images",
      "description": "Search Google Images to retrieve live image results.\n    google, images, serp, visual, reverse, search",
      "namespace": "search.google",
      "node_type": "search.google.GoogleImages",
      "properties": [
        {
          "name": "keyword",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Keyword",
          "description": "Search query or keyword for images"
        },
        {
          "name": "image_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Image Url",
          "description": "URL of image for reverse image search"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 20,
          "title": "Num Results",
          "description": "Maximum number of image results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "keyword",
        "image_url",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Jobs",
      "description": "Search Google Jobs for job listings.\n    google, jobs, employment, careers, serp",
      "namespace": "search.google",
      "node_type": "search.google.GoogleJobs",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "Job title, skills, or company name to search for"
        },
        {
          "name": "location",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Location",
          "description": "Geographic location for job search"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Num Results",
          "description": "Maximum number of job results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "job_result"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "query",
        "location",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Lens",
      "description": "Search with an image URL using Google Lens to find visual matches and related content.\n    google, lens, visual, image, search, serp",
      "namespace": "search.google",
      "node_type": "search.google.GoogleLens",
      "properties": [
        {
          "name": "image_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Image Url",
          "description": "URL of the image to analyze with Google Lens"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Num Results",
          "description": "Maximum number of visual search results to return"
        }
      ],
      "basic_fields": [
        "image_url",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Maps",
      "description": "Search Google Maps for places or get details about a specific place.\n    google, maps, places, locations, serp",
      "namespace": "search.google",
      "node_type": "search.google.GoogleMaps",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "Place name, address, or location query"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Num Results",
          "description": "Maximum number of map results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "local_result"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "query",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google News",
      "description": "Search Google News to retrieve live news articles.\n    google, news, serp, articles",
      "namespace": "search.google",
      "node_type": "search.google.GoogleNews",
      "properties": [
        {
          "name": "keyword",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Keyword",
          "description": "Search query or keyword for news articles"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Num Results",
          "description": "Maximum number of news results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "news_result"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "keyword",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Search",
      "description": "Search Google to retrieve organic search results.\n    google, search, serp, web",
      "namespace": "search.google",
      "node_type": "search.google.GoogleSearch",
      "properties": [
        {
          "name": "keyword",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Keyword",
          "description": "Search query or keyword to search for"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Num Results",
          "description": "Maximum number of results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "organic_result"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "keyword",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Shopping",
      "description": "Search Google Shopping for products.\n    google, shopping, products, ecommerce, serp",
      "namespace": "search.google",
      "node_type": "search.google.GoogleShopping",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "Product name or description to search for"
        },
        {
          "name": "country",
          "type": {
            "type": "str"
          },
          "default": "us",
          "title": "Country",
          "description": "Country code for shopping search (e.g., 'us', 'uk', 'ca')"
        },
        {
          "name": "min_price",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Min Price",
          "description": "Minimum price filter for products"
        },
        {
          "name": "max_price",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Max Price",
          "description": "Maximum price filter for products"
        },
        {
          "name": "condition",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Condition",
          "description": "Product condition filter (e.g., 'new', 'used', 'refurbished')"
        },
        {
          "name": "sort_by",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Sort By",
          "description": "Sort order for results (e.g., 'price_low_to_high', 'price_high_to_low', 'review_score')"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Num Results",
          "description": "Maximum number of shopping results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "shopping_result"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "query",
        "country",
        "min_price",
        "max_price",
        "condition",
        "sort_by",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Add Label",
      "description": "Adds a label to a Gmail message.\n    email, gmail, label",
      "namespace": "lib.mail",
      "node_type": "lib.mail.AddLabel",
      "properties": [
        {
          "name": "message_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Message Id",
          "description": "Message ID to label"
        },
        {
          "name": "label",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Label",
          "description": "Label to add to the message"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "message_id",
        "label"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Email Fields",
      "description": "Decomposes an email into its individual components.\n    email, decompose, extract\n\n    Takes an Email object and returns its individual fields:\n    - id: Message ID\n    - subject: Email subject\n    - sender: Sender address\n    - date: Datetime of email\n    - body: Email body content",
      "namespace": "lib.mail",
      "node_type": "lib.mail.EmailFields",
      "properties": [
        {
          "name": "email",
          "type": {
            "type": "email"
          },
          "default": {
            "type": "email",
            "id": "",
            "sender": "",
            "subject": "",
            "date": {
              "type": "datetime",
              "year": 0,
              "month": 0,
              "day": 0,
              "hour": 0,
              "minute": 0,
              "second": 0,
              "microsecond": 0,
              "tzinfo": "UTC",
              "utc_offset": 0
            },
            "body": ""
          },
          "title": "Email",
          "description": "Email object to decompose"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "id"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "subject"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "sender"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "date"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "body"
        }
      ],
      "basic_fields": [
        "email"
      ]
    },
    {
      "title": "Gmail Search",
      "description": "Searches Gmail using Gmail-specific search operators and yields matching emails.\n    email, gmail, search\n\n    Use cases:\n    - Search for emails based on specific criteria\n    - Retrieve emails from a specific sender\n    - Filter emails by subject, sender, or date",
      "namespace": "lib.mail",
      "node_type": "lib.mail.GmailSearch",
      "properties": [
        {
          "name": "from_address",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "From Address",
          "description": "Sender's email address to search for"
        },
        {
          "name": "to_address",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "To Address",
          "description": "Recipient's email address to search for"
        },
        {
          "name": "subject",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Subject",
          "description": "Text to search for in email subject"
        },
        {
          "name": "body",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Body",
          "description": "Text to search for in email body"
        },
        {
          "name": "date_filter",
          "type": {
            "type": "enum",
            "values": [
              "SINCE_ONE_HOUR",
              "SINCE_ONE_DAY",
              "SINCE_ONE_WEEK",
              "SINCE_ONE_MONTH",
              "SINCE_ONE_YEAR"
            ],
            "type_name": "nodetool.nodes.lib.mail.GmailSearch.DateFilter"
          },
          "default": "SINCE_ONE_DAY",
          "title": "Date Filter",
          "description": "Date filter to search for"
        },
        {
          "name": "keywords",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Keywords",
          "description": "Custom keywords or labels to search for"
        },
        {
          "name": "folder",
          "type": {
            "type": "enum",
            "values": [
              "INBOX",
              "[Gmail]/Sent Mail",
              "[Gmail]/Drafts",
              "[Gmail]/Spam",
              "[Gmail]/Trash"
            ],
            "type_name": "nodetool.nodes.lib.mail.GmailSearch.GmailFolder"
          },
          "default": "INBOX",
          "title": "Folder",
          "description": "Email folder to search in"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "General text to search for anywhere in the email"
        },
        {
          "name": "max_results",
          "type": {
            "type": "int"
          },
          "default": 50,
          "title": "Max Results",
          "description": "Maximum number of emails to return"
        },
        {
          "name": "retry_attempts",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "Retry Attempts",
          "description": "Maximum retry attempts for Gmail operations"
        },
        {
          "name": "retry_base_delay",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Retry Base Delay",
          "description": "Base delay (seconds) for exponential backoff"
        },
        {
          "name": "retry_max_delay",
          "type": {
            "type": "float"
          },
          "default": 5.0,
          "title": "Retry Max Delay",
          "description": "Maximum delay (seconds) for exponential backoff"
        },
        {
          "name": "retry_factor",
          "type": {
            "type": "float"
          },
          "default": 2.0,
          "title": "Retry Factor",
          "description": "Exponential growth factor for backoff"
        },
        {
          "name": "retry_jitter",
          "type": {
            "type": "float"
          },
          "default": 0.1,
          "title": "Retry Jitter",
          "description": "Random jitter (seconds) added to each backoff"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "email"
          },
          "name": "email"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "message_id"
        }
      ],
      "basic_fields": [
        "from_address",
        "subject",
        "body",
        "date_filter",
        "max_results"
      ],
      "is_streaming_output": true,
      "expose_as_tool": true
    },
    {
      "title": "Move To Archive",
      "description": "Moves specified emails to Gmail archive.\n    email, gmail, archive",
      "namespace": "lib.mail",
      "node_type": "lib.mail.MoveToArchive",
      "properties": [
        {
          "name": "message_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Message Id",
          "description": "Message ID to archive"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "message_id"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Send Email",
      "description": "Send a plain text email via SMTP.\n    email, smtp, send\n\n    Use cases:\n    - Send simple notification messages\n    - Automate email reports",
      "namespace": "lib.mail",
      "node_type": "lib.mail.SendEmail",
      "properties": [
        {
          "name": "smtp_server",
          "type": {
            "type": "str"
          },
          "default": "smtp.gmail.com",
          "title": "Smtp Server",
          "description": "SMTP server hostname"
        },
        {
          "name": "smtp_port",
          "type": {
            "type": "int"
          },
          "default": 587,
          "title": "Smtp Port",
          "description": "SMTP server port"
        },
        {
          "name": "username",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Username",
          "description": "SMTP username"
        },
        {
          "name": "password",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Password",
          "description": "SMTP password"
        },
        {
          "name": "from_address",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "From Address",
          "description": "Sender email address"
        },
        {
          "name": "to_address",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "To Address",
          "description": "Recipient email address"
        },
        {
          "name": "subject",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Subject",
          "description": "Email subject"
        },
        {
          "name": "body",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Body",
          "description": "Email body"
        },
        {
          "name": "retry_attempts",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "Retry Attempts",
          "description": "Maximum retry attempts for SMTP send"
        },
        {
          "name": "retry_base_delay",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Retry Base Delay",
          "description": "Base delay (seconds) for exponential backoff"
        },
        {
          "name": "retry_max_delay",
          "type": {
            "type": "float"
          },
          "default": 5.0,
          "title": "Retry Max Delay",
          "description": "Maximum delay (seconds) for exponential backoff"
        },
        {
          "name": "retry_factor",
          "type": {
            "type": "float"
          },
          "default": 2.0,
          "title": "Retry Factor",
          "description": "Exponential growth factor for backoff"
        },
        {
          "name": "retry_jitter",
          "type": {
            "type": "float"
          },
          "default": 0.1,
          "title": "Retry Jitter",
          "description": "Random jitter (seconds) added to each backoff"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "smtp_server",
        "smtp_port",
        "username",
        "password",
        "from_address",
        "to_address",
        "subject",
        "body",
        "retry_attempts",
        "retry_base_delay",
        "retry_max_delay",
        "retry_factor",
        "retry_jitter"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Gzip Compress",
      "description": "Compress bytes using gzip.\n    gzip, compress, bytes\n\n    Use cases:\n    - Reduce size of binary data\n    - Store assets in compressed form\n    - Prepare data for network transfer",
      "namespace": "lib.gzip",
      "node_type": "lib.gzip.GzipCompress",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "bytes",
            "optional": true
          },
          "default": null,
          "title": "Data",
          "description": "Data to compress"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Gzip Decompress",
      "description": "Decompress gzip data.\n    gzip, decompress, bytes\n\n    Use cases:\n    - Restore compressed files\n    - Read data from gzip archives\n    - Process network payloads",
      "namespace": "lib.gzip",
      "node_type": "lib.gzip.GzipDecompress",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "bytes",
            "optional": true
          },
          "default": null,
          "title": "Data",
          "description": "Gzip data to decompress"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Combine Image Grid",
      "description": "Combine a grid of image tiles into a single image.\n    image, grid, combine, tiles\n\n    Use cases:\n    - Reassemble processed image chunks\n    - Create composite images from smaller parts\n    - Merge tiled image data from distributed processing",
      "namespace": "lib.grid",
      "node_type": "lib.grid.CombineImageGrid",
      "properties": [
        {
          "name": "tiles",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "default": [],
          "title": "Tiles",
          "description": "List of image tiles to combine."
        },
        {
          "name": "columns",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Columns",
          "description": "Number of columns in the grid.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "tiles",
        "columns"
      ]
    },
    {
      "title": "Slice Image Grid",
      "description": "Slice an image into a grid of tiles.\n    image, grid, slice, tiles\n\n    Use cases:\n    - Prepare large images for processing in smaller chunks\n    - Create image puzzles or mosaic effects\n    - Distribute image processing tasks across multiple workers",
      "namespace": "lib.grid",
      "node_type": "lib.grid.SliceImageGrid",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to slice into a grid."
        },
        {
          "name": "columns",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Columns",
          "description": "Number of columns in the grid.",
          "min": 0.0
        },
        {
          "name": "rows",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Rows",
          "description": "Number of rows in the grid.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "columns",
        "rows"
      ]
    },
    {
      "title": "Extract Feed Metadata",
      "description": "Extracts metadata from an RSS feed.\n    rss, metadata, feed\n\n    Use cases:\n    - Get feed information\n    - Validate feed details\n    - Extract feed metadata",
      "namespace": "lib.rss",
      "node_type": "lib.rss.ExtractFeedMetadata",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL of the RSS feed"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "Fetch RSS Feed",
      "description": "Fetches and parses an RSS feed from a URL.\n    rss, feed, network\n\n    Use cases:\n    - Monitor news feeds\n    - Aggregate content from multiple sources\n    - Process blog updates",
      "namespace": "lib.rss",
      "node_type": "lib.rss.FetchRSSFeed",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL of the RSS feed to fetch"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "title"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "link"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "published"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "summary"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "author"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "is_streaming_output": true,
      "expose_as_tool": true
    },
    {
      "title": "Dedent Text",
      "description": "Removes any common leading whitespace from every line in text.\n    textwrap, dedent, whitespace",
      "namespace": "lib.textwrap",
      "node_type": "lib.textwrap.Dedent",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ]
    },
    {
      "title": "Fill Text",
      "description": "Wraps text to a specified width, returning a formatted string.\n    textwrap, fill, wrap",
      "namespace": "lib.textwrap",
      "node_type": "lib.textwrap.Fill",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 70,
          "title": "Width",
          "min": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "width"
      ]
    },
    {
      "title": "Indent Text",
      "description": "Adds a prefix to the beginning of each line in the text.\n    textwrap, indent, prefix",
      "namespace": "lib.textwrap",
      "node_type": "lib.textwrap.Indent",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "prefix",
          "type": {
            "type": "str"
          },
          "default": "    ",
          "title": "Prefix"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "prefix"
      ]
    },
    {
      "title": "Shorten Text",
      "description": "Shortens text to fit within a width, using a placeholder if truncated.\n    textwrap, shorten, truncate",
      "namespace": "lib.textwrap",
      "node_type": "lib.textwrap.Shorten",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 70,
          "title": "Width",
          "min": 1.0
        },
        {
          "name": "placeholder",
          "type": {
            "type": "str"
          },
          "default": "...",
          "title": "Placeholder"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "width",
        "placeholder"
      ]
    },
    {
      "title": "Wrap Text",
      "description": "Wraps text to a specified width, returning a list of lines.\n    textwrap, wrap, lines",
      "namespace": "lib.textwrap",
      "node_type": "lib.textwrap.Wrap",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 70,
          "title": "Width",
          "min": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "width"
      ]
    },
    {
      "title": "Decode Base64",
      "description": "Decodes Base64 text to plain string.\n    base64, decode, string\n\n    Use cases:\n    - Read encoded data\n    - Extract original text from Base64",
      "namespace": "lib.base64",
      "node_type": "lib.base64.Decode",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Data",
          "description": "Base64 encoded text"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Encode Base64",
      "description": "Encodes text to Base64 format.\n    base64, encode, string\n\n    Use cases:\n    - Prepare text for transmission\n    - Embed data in JSON or HTML",
      "namespace": "lib.base64",
      "node_type": "lib.base64.Encode",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to encode"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Hash File",
      "description": "Compute the cryptographic hash of a file.\n    hash, hashlib, digest, file\n\n    Use cases:\n    - Verify downloaded files\n    - Detect file changes\n    - Identify duplicates",
      "namespace": "lib.hashlib",
      "node_type": "lib.hashlib.HashFile",
      "properties": [
        {
          "name": "file",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "File",
          "description": "The file to hash"
        },
        {
          "name": "algorithm",
          "type": {
            "type": "str"
          },
          "default": "md5",
          "title": "Algorithm",
          "description": "Hash algorithm name (e.g. md5, sha1, sha256)"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 8192,
          "title": "Chunk Size",
          "description": "Read size for hashing in bytes",
          "min": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "file",
        "algorithm",
        "chunk_size"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Hash String",
      "description": "Compute the cryptographic hash of a string using hashlib.\n    hash, hashlib, digest, string\n\n    Use cases:\n    - Generate deterministic identifiers\n    - Verify data integrity\n    - Create fingerprints for caching",
      "namespace": "lib.hashlib",
      "node_type": "lib.hashlib.HashString",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to hash"
        },
        {
          "name": "algorithm",
          "type": {
            "type": "str"
          },
          "default": "md5",
          "title": "Algorithm",
          "description": "Hash algorithm name (e.g. md5, sha1, sha256)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "algorithm"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Create Tar",
      "description": "Create a tar archive from a directory.\n    files, tar, create\n\n    Use cases:\n    - Package multiple files into a single archive\n    - Backup directories\n    - Prepare archives for distribution",
      "namespace": "lib.tar",
      "node_type": "lib.tar.CreateTar",
      "properties": [
        {
          "name": "source_folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Source Folder",
          "description": "Folder to archive"
        },
        {
          "name": "tar_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Tar Path",
          "description": "Output tar file path"
        },
        {
          "name": "gzip",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Gzip",
          "description": "Use gzip compression"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "source_folder",
        "tar_path",
        "gzip"
      ]
    },
    {
      "title": "Extract Tar",
      "description": "Extract a tar archive to a folder.\n    files, tar, extract\n\n    Use cases:\n    - Unpack archived data\n    - Restore backups\n    - Retrieve files for processing",
      "namespace": "lib.tar",
      "node_type": "lib.tar.ExtractTar",
      "properties": [
        {
          "name": "tar_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Tar Path",
          "description": "Tar archive to extract"
        },
        {
          "name": "output_folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Output Folder",
          "description": "Folder to extract into"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "tar_path",
        "output_folder"
      ]
    },
    {
      "title": "List Tar",
      "description": "List contents of a tar archive.\n    files, tar, list\n\n    Use cases:\n    - Inspect archives without extracting\n    - Preview tar contents\n    - Verify archive contents",
      "namespace": "lib.tar",
      "node_type": "lib.tar.ListTar",
      "properties": [
        {
          "name": "tar_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Tar Path",
          "description": "Tar archive to inspect"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "tar_path"
      ]
    },
    {
      "title": "Escape",
      "description": "Escape special characters in text into HTML-safe sequences.\n    html, escape, entities, convert\n\n    Use cases:\n    - Prepare text for inclusion in HTML\n    - Prevent cross-site scripting in user content\n    - Encode strings for web output",
      "namespace": "lib.html",
      "node_type": "lib.html.Escape",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to escape"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Unescape",
      "description": "Convert HTML entities back to normal text.\n    html, unescape, entities, decode\n\n    Use cases:\n    - Decode HTML-encoded data\n    - Process text scraped from the web\n    - Convert form submissions to plain text",
      "namespace": "lib.html",
      "node_type": "lib.html.Unescape",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The HTML text to unescape"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Absolute Path",
      "description": "Return the absolute path of a file or directory.\n    files, path, absolute\n\n    Use cases:\n    - Convert relative paths to absolute\n    - Get full system path\n    - Resolve path references",
      "namespace": "lib.os",
      "node_type": "lib.os.AbsolutePath",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to convert to absolute"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Accessed Time",
      "description": "Get file last accessed timestamp.\n    files, metadata, accessed, time",
      "namespace": "lib.os",
      "node_type": "lib.os.AccessedTime",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Basename",
      "description": "Get the base name component of a file path.\n    files, path, basename\n\n    Use cases:\n    - Extract filename from full path\n    - Get file name without directory\n    - Process file names independently",
      "namespace": "lib.os",
      "node_type": "lib.os.Basename",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "File path to get basename from"
        },
        {
          "name": "remove_extension",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Remove Extension",
          "description": "Remove file extension from basename"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path",
        "remove_extension"
      ]
    },
    {
      "title": "Copy File",
      "description": "Copy a file from source to destination path.\n    files, copy, manage\n\n    Use cases:\n    - Create file backups\n    - Duplicate files for processing\n    - Copy files to new locations",
      "namespace": "lib.os",
      "node_type": "lib.os.CopyFile",
      "properties": [
        {
          "name": "source_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Source Path",
          "description": "Source file path"
        },
        {
          "name": "destination_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Destination Path",
          "description": "Destination file path"
        }
      ],
      "basic_fields": [
        "source_path",
        "destination_path"
      ]
    },
    {
      "title": "Create Directory",
      "description": "Create a new directory at specified path.\n    files, directory, create\n\n    Use cases:\n    - Set up directory structure for file organization\n    - Create output directories for processed files",
      "namespace": "lib.os",
      "node_type": "lib.os.CreateDirectory",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Directory path to create"
        },
        {
          "name": "exist_ok",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Exist Ok",
          "description": "Don't error if directory already exists"
        }
      ],
      "basic_fields": [
        "path",
        "exist_ok"
      ]
    },
    {
      "title": "Created Time",
      "description": "Get file creation timestamp.\n    files, metadata, created, time",
      "namespace": "lib.os",
      "node_type": "lib.os.CreatedTime",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Dirname",
      "description": "Get the directory name component of a file path.\n    files, path, dirname\n\n    Use cases:\n    - Extract directory path from full path\n    - Get parent directory\n    - Process directory paths",
      "namespace": "lib.os",
      "node_type": "lib.os.Dirname",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "File path to get dirname from"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "File Exists",
      "description": "Check if a file or directory exists at the specified path.\n    files, check, exists\n\n    Use cases:\n    - Validate file presence before processing\n    - Implement conditional logic based on file existence",
      "namespace": "lib.os",
      "node_type": "lib.os.FileExists",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to check for existence"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "File Extension",
      "description": "Get file extension.\n    files, metadata, extension",
      "namespace": "lib.os",
      "node_type": "lib.os.FileExtension",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "File Name",
      "description": "Get file name without path.\n    files, metadata, name",
      "namespace": "lib.os",
      "node_type": "lib.os.FileName",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "File Name Match",
      "description": "Match a filename against a pattern using Unix shell-style wildcards.\n    files, pattern, match, filter\n\n    Use cases:\n    - Filter files by name pattern\n    - Validate file naming conventions\n    - Match file extensions",
      "namespace": "lib.os",
      "node_type": "lib.os.FileNameMatch",
      "properties": [
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Filename to check"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "*",
          "title": "Pattern",
          "description": "Pattern to match against (e.g. *.txt, data_*.csv)"
        },
        {
          "name": "case_sensitive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Case Sensitive",
          "description": "Whether the pattern matching should be case-sensitive"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "filename",
        "pattern",
        "case_sensitive"
      ]
    },
    {
      "title": "Filter File Names",
      "description": "Filter a list of filenames using Unix shell-style wildcards.\n    files, pattern, filter, list\n\n    Use cases:\n    - Filter multiple files by pattern\n    - Batch process files matching criteria\n    - Select files by extension",
      "namespace": "lib.os",
      "node_type": "lib.os.FilterFileNames",
      "properties": [
        {
          "name": "filenames",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Filenames",
          "description": "list of filenames to filter"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "*",
          "title": "Pattern",
          "description": "Pattern to filter by (e.g. *.txt, data_*.csv)"
        },
        {
          "name": "case_sensitive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Case Sensitive",
          "description": "Whether the pattern matching should be case-sensitive"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "filenames",
        "pattern",
        "case_sensitive"
      ]
    },
    {
      "title": "Get Directory",
      "description": "Get directory containing the file.\n    files, metadata, directory",
      "namespace": "lib.os",
      "node_type": "lib.os.GetDirectory",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Get Environment Variable",
      "description": "Gets an environment variable value.\n    environment, variable, system\n\n    Use cases:\n    - Access configuration\n    - Get system settings",
      "namespace": "lib.os",
      "node_type": "lib.os.GetEnvironmentVariable",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "Environment variable name"
        },
        {
          "name": "default",
          "type": {
            "type": "str",
            "optional": true
          },
          "default": null,
          "title": "Default",
          "description": "Default value if not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str",
            "optional": true
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "default"
      ]
    },
    {
      "title": "Get File Size",
      "description": "Get file size in bytes.\n    files, metadata, size",
      "namespace": "lib.os",
      "node_type": "lib.os.GetFileSize",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Get Path Info",
      "description": "Gets information about a path.\n    path, info, metadata\n\n    Use cases:\n    - Extract path components\n    - Parse file paths",
      "namespace": "lib.os",
      "node_type": "lib.os.GetPathInfo",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Get System Info",
      "description": "Gets system information.\n    system, info, platform\n\n    Use cases:\n    - Check system compatibility\n    - Platform-specific logic",
      "namespace": "lib.os",
      "node_type": "lib.os.GetSystemInfo",
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ]
    },
    {
      "title": "Is Directory",
      "description": "Check if path is a directory.\n    files, metadata, type",
      "namespace": "lib.os",
      "node_type": "lib.os.IsDirectory",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Is File",
      "description": "Check if path is a file.\n    files, metadata, type",
      "namespace": "lib.os",
      "node_type": "lib.os.IsFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Join Paths",
      "description": "Joins path components.\n    path, join, combine\n\n    Use cases:\n    - Build file paths\n    - Create cross-platform paths",
      "namespace": "lib.os",
      "node_type": "lib.os.JoinPaths",
      "properties": [
        {
          "name": "paths",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Paths",
          "description": "Path components to join"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "paths"
      ]
    },
    {
      "title": "List Files",
      "description": "list files in a directory matching a pattern.\n    files, list, directory\n\n    Use cases:\n    - Get files for batch processing\n    - Filter files by extension or pattern",
      "namespace": "lib.os",
      "node_type": "lib.os.ListFiles",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "~",
          "title": "Folder",
          "description": "Directory to scan"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "*",
          "title": "Pattern",
          "description": "File pattern to match (e.g. *.txt)"
        },
        {
          "name": "include_subdirectories",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Include Subdirectories",
          "description": "Search subdirectories"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "file"
        }
      ],
      "basic_fields": [
        "folder",
        "pattern",
        "include_subdirectories"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Modified Time",
      "description": "Get file last modified timestamp.\n    files, metadata, modified, time",
      "namespace": "lib.os",
      "node_type": "lib.os.ModifiedTime",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Move File",
      "description": "Move a file from source to destination path.\n    files, move, manage\n\n    Use cases:\n    - Organize files into directories\n    - Process and archive files\n    - Relocate completed files",
      "namespace": "lib.os",
      "node_type": "lib.os.MoveFile",
      "properties": [
        {
          "name": "source_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Source Path",
          "description": "Source file path"
        },
        {
          "name": "destination_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Destination Path",
          "description": "Destination file path"
        }
      ],
      "basic_fields": [
        "source_path",
        "destination_path"
      ]
    },
    {
      "title": "Normalize Path",
      "description": "Normalizes a path.\n    path, normalize, clean\n\n    Use cases:\n    - Standardize paths\n    - Remove redundant separators",
      "namespace": "lib.os",
      "node_type": "lib.os.NormalizePath",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to normalize"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Open Workspace Directory",
      "description": "Open the workspace directory.\n    files, workspace, directory",
      "namespace": "lib.os",
      "node_type": "lib.os.OpenWorkspaceDirectory",
      "outputs": [
        {
          "type": {
            "type": "none"
          },
          "name": "output"
        }
      ]
    },
    {
      "title": "Path To String",
      "description": "Convert a FilePath object to a string.\n    files, path, string, convert\n\n    Use cases:\n    - Get raw string path from FilePath object\n    - Convert FilePath for string operations\n    - Extract path string for external use",
      "namespace": "lib.os",
      "node_type": "lib.os.PathToString",
      "properties": [
        {
          "name": "file_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "File Path",
          "description": "File path to convert to string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "file_path"
      ]
    },
    {
      "title": "Relative Path",
      "description": "Return a relative path to a target from a start directory.\n    files, path, relative\n\n    Use cases:\n    - Create relative path references\n    - Generate portable paths\n    - Compare file locations",
      "namespace": "lib.os",
      "node_type": "lib.os.RelativePath",
      "properties": [
        {
          "name": "target_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Target Path",
          "description": "Target path to convert to relative"
        },
        {
          "name": "start_path",
          "type": {
            "type": "str"
          },
          "default": ".",
          "title": "Start Path",
          "description": "Start path for relative conversion"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "target_path",
        "start_path"
      ]
    },
    {
      "title": "Set Environment Variable",
      "description": "Sets an environment variable.\n    environment, variable, system\n\n    Use cases:\n    - Configure runtime settings\n    - Set up process environment",
      "namespace": "lib.os",
      "node_type": "lib.os.SetEnvironmentVariable",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "Environment variable name"
        },
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value",
          "description": "Environment variable value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "none"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Show Notification",
      "description": "Shows a system notification.\n    notification, system, alert\n\n    Use cases:\n    - Alert user of completed tasks\n    - Show process status\n    - Display important messages",
      "namespace": "lib.os",
      "node_type": "lib.os.ShowNotification",
      "properties": [
        {
          "name": "title",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Title",
          "description": "Title of the notification"
        },
        {
          "name": "message",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Message",
          "description": "Content of the notification"
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Timeout",
          "description": "How long the notification should stay visible (in seconds)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "none"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "title",
        "message",
        "timeout"
      ]
    },
    {
      "title": "Split Extension",
      "description": "Split a path into root and extension components.\n    files, path, extension, split\n\n    Use cases:\n    - Extract file extension\n    - Process filename without extension\n    - Handle file types",
      "namespace": "lib.os",
      "node_type": "lib.os.SplitExtension",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to split"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Split Path",
      "description": "Split a path into directory and file components.\n    files, path, split\n\n    Use cases:\n    - Separate directory from filename\n    - Process path components separately\n    - Extract path parts",
      "namespace": "lib.os",
      "node_type": "lib.os.SplitPath",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to split"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Workspace Directory",
      "description": "Get the workspace directory.\n    files, workspace, directory",
      "namespace": "lib.os",
      "node_type": "lib.os.WorkspaceDirectory",
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ]
    },
    {
      "title": "Get Close Matches",
      "description": "Finds close matches for a word within a list of possibilities.\n    difflib, fuzzy, match\n\n    Use cases:\n    - Suggest alternatives for misspelled words\n    - Map user input to valid options\n    - Provide recommendations based on partial text",
      "namespace": "lib.difflib",
      "node_type": "lib.difflib.GetCloseMatches",
      "properties": [
        {
          "name": "word",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Word",
          "description": "Word to match"
        },
        {
          "name": "possibilities",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Possibilities",
          "description": "List of possible words"
        },
        {
          "name": "n",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "N",
          "description": "Maximum number of matches to return",
          "min": 1.0
        },
        {
          "name": "cutoff",
          "type": {
            "type": "float"
          },
          "default": 0.6,
          "title": "Cutoff",
          "description": "Minimum similarity ratio",
          "min": 0.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "word",
        "possibilities",
        "n",
        "cutoff"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Sequence Similarity Ratio",
      "description": "Calculates the similarity ratio between two strings.\n    difflib, similarity, ratio, compare\n\n    Use cases:\n    - Fuzzy string matching\n    - Compare document versions\n    - Evaluate similarity of user input",
      "namespace": "lib.difflib",
      "node_type": "lib.difflib.SimilarityRatio",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "A",
          "description": "First string to compare"
        },
        {
          "name": "b",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "B",
          "description": "Second string to compare"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Unified Diff",
      "description": "Generates a unified diff between two texts.\n    difflib, diff, compare\n\n    Use cases:\n    - Display differences between versions of text files\n    - Highlight changes in user submitted documents\n    - Compare code snippets",
      "namespace": "lib.difflib",
      "node_type": "lib.difflib.UnifiedDiff",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "A",
          "description": "Original text"
        },
        {
          "name": "b",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "B",
          "description": "Modified text"
        },
        {
          "name": "fromfile",
          "type": {
            "type": "str"
          },
          "default": "a",
          "title": "Fromfile",
          "description": "Name of the original file"
        },
        {
          "name": "tofile",
          "type": {
            "type": "str"
          },
          "default": "b",
          "title": "Tofile",
          "description": "Name of the modified file"
        },
        {
          "name": "lineterm",
          "type": {
            "type": "str"
          },
          "default": "\n",
          "title": "Lineterm",
          "description": "Line terminator"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b",
        "fromfile",
        "tofile",
        "lineterm"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Chart Renderer",
      "description": "Node responsible for rendering chart configurations into image format using seaborn.\n    chart, seaborn, plot, visualization, data",
      "namespace": "lib.seaborn",
      "node_type": "lib.seaborn.ChartRenderer",
      "properties": [
        {
          "name": "chart_config",
          "type": {
            "type": "chart_config"
          },
          "default": {
            "type": "chart_config",
            "title": "",
            "x_label": "",
            "y_label": "",
            "legend": true,
            "data": {
              "type": "chart_data",
              "series": [],
              "row": null,
              "col": null,
              "col_wrap": null
            },
            "height": null,
            "aspect": null,
            "x_lim": null,
            "y_lim": null,
            "x_scale": null,
            "y_scale": null,
            "legend_position": "auto",
            "palette": null,
            "hue_order": null,
            "hue_norm": null,
            "sizes": null,
            "size_order": null,
            "size_norm": null,
            "marginal_kws": null,
            "joint_kws": null,
            "diag_kind": null,
            "corner": false,
            "center": null,
            "vmin": null,
            "vmax": null,
            "cmap": null,
            "annot": false,
            "fmt": ".2g",
            "square": false
          },
          "title": "Chart Config",
          "description": "The chart configuration to render."
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 640,
          "title": "Width",
          "description": "The width of the chart in pixels.",
          "min": 0.0,
          "max": 10000.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 480,
          "title": "Height",
          "description": "The height of the chart in pixels.",
          "min": 0.0,
          "max": 10000.0
        },
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "Data",
          "description": "The data to visualize as a pandas DataFrame."
        },
        {
          "name": "despine",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Despine",
          "description": "Whether to remove top and right spines."
        },
        {
          "name": "trim_margins",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Trim Margins",
          "description": "Whether to use tight layout for margins."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "chart_config",
        "width",
        "height",
        "data",
        "despine",
        "trim_margins"
      ]
    },
    {
      "title": "Simple Http Server",
      "description": "Starts a simple HTTP server inside Docker and streams logs.\n    http, server, web\n\n    Emits the reachable endpoint URL on the \"endpoint\" output when ready,\n    then streams stdout/stderr lines on the corresponding outputs.",
      "namespace": "lib.http_server",
      "node_type": "lib.http_server.SimpleHttpServer",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "str"
          },
          "default": "python:3.11-slim",
          "title": "Image",
          "description": "Docker image to run the server in"
        },
        {
          "name": "container_port",
          "type": {
            "type": "int"
          },
          "default": 8000,
          "title": "Container Port",
          "description": "Port the server listens on inside the container"
        },
        {
          "name": "command",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Command",
          "description": "Startup command. If empty, uses 'python -m http.server <container_port> --bind 0.0.0.0'"
        },
        {
          "name": "timeout_seconds",
          "type": {
            "type": "int"
          },
          "default": 600,
          "title": "Timeout Seconds",
          "description": "Max lifetime of the server container (seconds)"
        },
        {
          "name": "ready_timeout_seconds",
          "type": {
            "type": "int"
          },
          "default": 15,
          "title": "Ready Timeout Seconds",
          "description": "Seconds to wait for server readiness"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "endpoint"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "image",
        "container_port",
        "command",
        "timeout_seconds",
        "ready_timeout_seconds"
      ],
      "is_streaming_output": true,
      "supports_dynamic_outputs": true
    },
    {
      "title": "Random Bool",
      "description": "Return a random boolean value.\n    random, boolean, coinflip, bool\n\n    Use cases:\n    - Make random yes/no decisions\n    - Simulate coin flips\n    - Introduce randomness in control flow",
      "namespace": "lib.random",
      "node_type": "lib.random.RandomBool",
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "expose_as_tool": true
    },
    {
      "title": "Random Choice",
      "description": "Select a random element from a list.\n    random, choice, select, pick\n\n    Use cases:\n    - Choose a random sample from options\n    - Implement simple lottery behaviour\n    - Pick a random item from user input",
      "namespace": "lib.random",
      "node_type": "lib.random.RandomChoice",
      "properties": [
        {
          "name": "options",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Options",
          "description": "List of options"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "options"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Random Float",
      "description": "Generate a random floating point number within a range.\n    random, float, number, rand, uniform\n\n    Use cases:\n    - Create random probabilities\n    - Generate noisy data for testing\n    - Produce random values for simulations",
      "namespace": "lib.random",
      "node_type": "lib.random.RandomFloat",
      "properties": [
        {
          "name": "minimum",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Minimum",
          "description": "Minimum value"
        },
        {
          "name": "maximum",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Maximum",
          "description": "Maximum value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "minimum",
        "maximum"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Random Int",
      "description": "Generate a random integer within a range.\n    random, integer, number, rand, randint\n\n    Use cases:\n    - Pick a random index or identifier\n    - Create randomized counters or IDs\n    - Sample integers for testing",
      "namespace": "lib.random",
      "node_type": "lib.random.RandomInt",
      "properties": [
        {
          "name": "minimum",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Minimum",
          "description": "Minimum value (inclusive)"
        },
        {
          "name": "maximum",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Maximum",
          "description": "Maximum value (inclusive)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "minimum",
        "maximum"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Download File",
      "description": "Download a file from an FTP server.\n    ftp, download, file\n\n    Use cases:\n    - Retrieve remote files for processing\n    - Backup data from an FTP server\n    - Integrate legacy FTP systems",
      "namespace": "lib.ftplib",
      "node_type": "lib.ftplib.FTPDownloadFile",
      "properties": [
        {
          "name": "host",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Host",
          "description": "FTP server host"
        },
        {
          "name": "username",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Username",
          "description": "Username for authentication"
        },
        {
          "name": "password",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Password",
          "description": "Password for authentication"
        },
        {
          "name": "remote_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Remote Path",
          "description": "Remote file path to download"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "host",
        "username",
        "password",
        "remote_path"
      ],
      "expose_as_tool": true
    },
    {
      "title": "List Directory",
      "description": "List files in a directory on an FTP server.\n    ftp, list, directory\n\n    Use cases:\n    - Browse remote directories\n    - Check available files before download\n    - Monitor FTP server contents",
      "namespace": "lib.ftplib",
      "node_type": "lib.ftplib.FTPListDirectory",
      "properties": [
        {
          "name": "host",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Host",
          "description": "FTP server host"
        },
        {
          "name": "username",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Username",
          "description": "Username for authentication"
        },
        {
          "name": "password",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Password",
          "description": "Password for authentication"
        },
        {
          "name": "directory",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Directory",
          "description": "Remote directory to list"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "host",
        "username",
        "password",
        "directory"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Upload File",
      "description": "Upload a file to an FTP server.\n    ftp, upload, file\n\n    Use cases:\n    - Transfer files to an FTP server\n    - Automate backups to a remote system\n    - Integrate with legacy FTP workflows",
      "namespace": "lib.ftplib",
      "node_type": "lib.ftplib.FTPUploadFile",
      "properties": [
        {
          "name": "host",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Host",
          "description": "FTP server host"
        },
        {
          "name": "username",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Username",
          "description": "Username for authentication"
        },
        {
          "name": "password",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Password",
          "description": "Password for authentication"
        },
        {
          "name": "remote_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Remote Path",
          "description": "Remote file path to upload to"
        },
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document",
          "description": "Document to upload"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "none"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "host",
        "username",
        "password",
        "remote_path",
        "document"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Create Table",
      "description": "Create a new SQLite table with specified columns.\n    sqlite, database, table, create, schema\n\n    Use cases:\n    - Initialize database schema for flashcards\n    - Set up tables for persistent storage\n    - Create memory structures for agents",
      "namespace": "lib.sqlite",
      "node_type": "lib.sqlite.CreateTable",
      "properties": [
        {
          "name": "database_name",
          "type": {
            "type": "str"
          },
          "default": "memory.db",
          "title": "Database Name",
          "description": "Name of the SQLite database file"
        },
        {
          "name": "table_name",
          "type": {
            "type": "str"
          },
          "default": "flashcards",
          "title": "Table Name",
          "description": "Name of the table to create"
        },
        {
          "name": "columns",
          "type": {
            "type": "record_type"
          },
          "default": {
            "type": "record_type",
            "columns": []
          },
          "title": "Columns",
          "description": "Column definitions"
        },
        {
          "name": "add_primary_key",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Add Primary Key",
          "description": "Automatically make first integer column PRIMARY KEY AUTOINCREMENT"
        },
        {
          "name": "if_not_exists",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "If Not Exists",
          "description": "Only create table if it doesn't exist"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "database_name"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "table_name"
        },
        {
          "type": {
            "type": "record_type"
          },
          "name": "columns"
        }
      ],
      "basic_fields": [
        "database_name",
        "table_name",
        "columns",
        "add_primary_key",
        "if_not_exists"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Delete",
      "description": "Delete records from a SQLite table.\n    sqlite, database, delete, remove, drop\n\n    Use cases:\n    - Remove flashcards\n    - Delete agent memory\n    - Clean up old data",
      "namespace": "lib.sqlite",
      "node_type": "lib.sqlite.Delete",
      "properties": [
        {
          "name": "database_name",
          "type": {
            "type": "str"
          },
          "default": "memory.db",
          "title": "Database Name",
          "description": "Name of the SQLite database file"
        },
        {
          "name": "table_name",
          "type": {
            "type": "str"
          },
          "default": "flashcards",
          "title": "Table Name",
          "description": "Name of the table to delete from"
        },
        {
          "name": "where",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Where",
          "description": "WHERE clause (without 'WHERE' keyword), e.g., 'id = 1'. REQUIRED for safety."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "database_name",
        "table_name",
        "where"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Execute SQL",
      "description": "Execute arbitrary SQL statements for advanced operations.\n    sqlite, database, sql, execute, custom\n\n    Use cases:\n    - Complex queries with joins\n    - Aggregate functions (COUNT, SUM, AVG)\n    - Custom SQL operations",
      "namespace": "lib.sqlite",
      "node_type": "lib.sqlite.ExecuteSQL",
      "properties": [
        {
          "name": "database_name",
          "type": {
            "type": "str"
          },
          "default": "memory.db",
          "title": "Database Name",
          "description": "Name of the SQLite database file"
        },
        {
          "name": "sql",
          "type": {
            "type": "str"
          },
          "default": "SELECT * FROM flashcards",
          "title": "Sql",
          "description": "SQL statement to execute"
        },
        {
          "name": "parameters",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Parameters",
          "description": "Parameters for parameterized queries (use ? in SQL)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "database_name",
        "sql",
        "parameters"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Get Database Path",
      "description": "Get the full path to a SQLite database file.\n    sqlite, database, path, location\n\n    Use cases:\n    - Reference database location\n    - Verify database exists\n    - Pass path to external tools",
      "namespace": "lib.sqlite",
      "node_type": "lib.sqlite.GetDatabasePath",
      "properties": [
        {
          "name": "database_name",
          "type": {
            "type": "str"
          },
          "default": "memory.db",
          "title": "Database Name",
          "description": "Name of the SQLite database file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "database_name"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Insert",
      "description": "Insert a record into a SQLite table.\n    sqlite, database, insert, add, record\n\n    Use cases:\n    - Add new flashcards to database\n    - Store agent observations\n    - Persist workflow results",
      "namespace": "lib.sqlite",
      "node_type": "lib.sqlite.Insert",
      "properties": [
        {
          "name": "database_name",
          "type": {
            "type": "str"
          },
          "default": "memory.db",
          "title": "Database Name",
          "description": "Name of the SQLite database file"
        },
        {
          "name": "table_name",
          "type": {
            "type": "str"
          },
          "default": "flashcards",
          "title": "Table Name",
          "description": "Name of the table to insert into"
        },
        {
          "name": "data",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {
            "content": "example"
          },
          "title": "Data",
          "description": "Data to insert as dict (column: value)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "database_name",
        "table_name",
        "data"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Query",
      "description": "Query records from a SQLite table.\n    sqlite, database, query, select, search, retrieve\n\n    Use cases:\n    - Retrieve flashcards for review\n    - Search agent memory\n    - Fetch stored data",
      "namespace": "lib.sqlite",
      "node_type": "lib.sqlite.Query",
      "properties": [
        {
          "name": "database_name",
          "type": {
            "type": "str"
          },
          "default": "memory.db",
          "title": "Database Name",
          "description": "Name of the SQLite database file"
        },
        {
          "name": "table_name",
          "type": {
            "type": "str"
          },
          "default": "flashcards",
          "title": "Table Name",
          "description": "Name of the table to query"
        },
        {
          "name": "where",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Where",
          "description": "WHERE clause (without 'WHERE' keyword), e.g., 'id = 1'"
        },
        {
          "name": "columns",
          "type": {
            "type": "record_type"
          },
          "default": {
            "type": "record_type",
            "columns": []
          },
          "title": "Columns",
          "description": "Columns to select"
        },
        {
          "name": "order_by",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Order By",
          "description": "ORDER BY clause (without 'ORDER BY' keyword)"
        },
        {
          "name": "limit",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Limit",
          "description": "Maximum number of rows to return (0 = no limit)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "index"
        },
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "row"
        },
        {
          "type": {
            "type": "dataframe"
          },
          "name": "dataframe"
        }
      ],
      "basic_fields": [
        "database_name",
        "table_name",
        "where",
        "columns",
        "order_by",
        "limit"
      ],
      "is_streaming_output": true,
      "expose_as_tool": true
    },
    {
      "title": "Update",
      "description": "Update records in a SQLite table.\n    sqlite, database, update, modify, change\n\n    Use cases:\n    - Update flashcard content\n    - Modify stored records\n    - Change agent memory",
      "namespace": "lib.sqlite",
      "node_type": "lib.sqlite.Update",
      "properties": [
        {
          "name": "database_name",
          "type": {
            "type": "str"
          },
          "default": "memory.db",
          "title": "Database Name",
          "description": "Name of the SQLite database file"
        },
        {
          "name": "table_name",
          "type": {
            "type": "str"
          },
          "default": "flashcards",
          "title": "Table Name",
          "description": "Name of the table to update"
        },
        {
          "name": "data",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {
            "content": "updated"
          },
          "title": "Data",
          "description": "Data to update as dict (column: new_value)"
        },
        {
          "name": "where",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Where",
          "description": "WHERE clause (without 'WHERE' keyword), e.g., 'id = 1'"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "database_name",
        "table_name",
        "data",
        "where"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Compress",
      "description": "Compress binary data using the zlib algorithm.\n    zlib, compress, deflate, binary\n\n    Use cases:\n    - Reduce size of binary data\n    - Prepare payloads for transmission\n    - Store data in compressed form",
      "namespace": "lib.zlib",
      "node_type": "lib.zlib.Compress",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "bytes"
          },
          "default": "",
          "title": "Data",
          "description": "Data to compress"
        },
        {
          "name": "level",
          "type": {
            "type": "int"
          },
          "default": 9,
          "title": "Level",
          "description": "Compression level",
          "min": 0.0,
          "max": 9.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "level"
      ]
    },
    {
      "title": "Decompress",
      "description": "Decompress zlib-compressed binary data.\n    zlib, decompress, inflate, binary\n\n    Use cases:\n    - Restore compressed payloads\n    - Read previously compressed files\n    - Handle zlib streams from external services",
      "namespace": "lib.zlib",
      "node_type": "lib.zlib.Decompress",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "bytes"
          },
          "default": "",
          "title": "Data",
          "description": "Data to decompress"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data"
      ]
    },
    {
      "title": "Browser",
      "description": "Fetches content from a web page using a headless browser.\n    browser, web, scraping, content, fetch\n\n    Use cases:\n    - Extract content from JavaScript-heavy websites\n    - Retrieve text content from web pages\n    - Get metadata from web pages\n    - Save extracted content to files",
      "namespace": "lib.browser",
      "node_type": "lib.browser.Browser",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to navigate to"
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 20000,
          "title": "Timeout",
          "description": "Timeout in milliseconds for page navigation"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "success"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "content"
        },
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "metadata"
        }
      ],
      "basic_fields": [
        "url",
        "timeout"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Browser Navigation",
      "description": "Navigates and interacts with web pages in a browser session.\n    browser, navigation, interaction, click, extract\n\n    Use cases:\n    - Perform complex web interactions\n    - Navigate through multi-step web processes\n    - Extract content after interaction",
      "namespace": "lib.browser",
      "node_type": "lib.browser.BrowserNavigation",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to navigate to (required for 'goto' action)"
        },
        {
          "name": "action",
          "type": {
            "type": "enum",
            "values": [
              "click",
              "goto",
              "back",
              "forward",
              "reload",
              "extract"
            ],
            "type_name": "nodetool.nodes.lib.browser.BrowserNavigation.Action"
          },
          "default": "goto",
          "title": "Action",
          "description": "Navigation or extraction action to perform"
        },
        {
          "name": "selector",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Selector",
          "description": "CSS selector for the element to interact with or extract from"
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 30000,
          "title": "Timeout",
          "description": "Timeout in milliseconds for the action"
        },
        {
          "name": "wait_for",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Wait For",
          "description": "Optional selector to wait for after performing the action"
        },
        {
          "name": "extract_type",
          "type": {
            "type": "enum",
            "values": [
              "text",
              "html",
              "value",
              "attribute"
            ],
            "type_name": "nodetool.nodes.lib.browser.BrowserNavigation.ExtractType"
          },
          "default": "text",
          "title": "Extract Type",
          "description": "Type of content to extract (for 'extract' action)"
        },
        {
          "name": "attribute",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Attribute",
          "description": "Attribute name to extract (when extract_type is 'attribute')"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url",
        "action",
        "selector",
        "timeout",
        "wait_for",
        "extract_type",
        "attribute"
      ]
    },
    {
      "title": "Browser Use",
      "description": "Browser agent tool that uses browser_use under the hood.\n\n    This module provides a tool for running browser-based agents using the browser_use library.\n    The agent can perform complex web automation tasks like form filling, navigation, data extraction,\n    and multi-step workflows using natural language instructions.\n\n    Use cases:\n    - Perform complex web automation tasks based on natural language.\n    - Automate form filling and data entry.\n    - Scrape data after complex navigation or interaction sequences.\n    - Automate multi-step web workflows.",
      "namespace": "lib.browser",
      "node_type": "lib.browser.BrowserUse",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gpt-4o",
              "claude-3-5-sonnet"
            ],
            "type_name": "nodetool.nodes.lib.browser.BrowserUseModel"
          },
          "default": "gpt-4o",
          "title": "Model",
          "description": "The model to use for the browser agent."
        },
        {
          "name": "task",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Task",
          "description": "Natural language description of the browser task to perform. Can include complex multi-step instructions like 'Compare prices between websites', 'Fill out forms', or 'Extract specific data'."
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 300,
          "title": "Timeout",
          "description": "Maximum time in seconds to allow for task completion. Complex tasks may require longer timeouts.",
          "min": 1.0,
          "max": 3600.0
        },
        {
          "name": "use_remote_browser",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Use Remote Browser",
          "description": "Use a remote browser instead of a local one"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "success"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "task"
        },
        {
          "type": {
            "type": "any"
          },
          "name": "result"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "error"
        }
      ],
      "basic_fields": [
        "model",
        "task",
        "timeout",
        "use_remote_browser"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Download File",
      "description": "Downloads a file from a URL and saves it to disk.\n    download, file, web, save\n\n    Use cases:\n    - Download documents, images, or other files from the web\n    - Save data for further processing\n    - Retrieve file assets for analysis",
      "namespace": "lib.browser",
      "node_type": "lib.browser.DownloadFile",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL of the file to download"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Screenshot",
      "description": "Takes a screenshot of a web page or specific element.\n    browser, screenshot, capture, image\n\n    Use cases:\n    - Capture visual representation of web pages\n    - Document specific UI elements\n    - Create visual records of web content",
      "namespace": "lib.browser",
      "node_type": "lib.browser.Screenshot",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to navigate to before taking screenshot"
        },
        {
          "name": "selector",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Selector",
          "description": "Optional CSS selector for capturing a specific element"
        },
        {
          "name": "output_file",
          "type": {
            "type": "str"
          },
          "default": "screenshot.png",
          "title": "Output File",
          "description": "Path to save the screenshot (relative to workspace)"
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 30000,
          "title": "Timeout",
          "description": "Timeout in milliseconds for page navigation"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url",
        "selector",
        "output_file",
        "timeout"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Web Fetch",
      "description": "Fetches HTML content from a URL and converts it to text.\n    web, fetch, html, markdown, http\n\n    Use cases:\n    - Extract text content from web pages\n    - Process web content for analysis\n    - Save web content to files",
      "namespace": "lib.browser",
      "node_type": "lib.browser.WebFetch",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to fetch content from"
        },
        {
          "name": "selector",
          "type": {
            "type": "str"
          },
          "default": "body",
          "title": "Selector",
          "description": "CSS selector to extract specific elements"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url",
        "selector"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Paddle OCR",
      "description": "Performs Optical Character Recognition (OCR) on images using PaddleOCR.\n    image, text, ocr, document\n\n    Use cases:\n    - Text extraction from images\n    - Document digitization\n    - Receipt/invoice processing\n    - Handwriting recognition",
      "namespace": "lib.ocr",
      "node_type": "lib.ocr.PaddleOCR",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Input Image",
          "description": "The image to perform OCR on"
        },
        {
          "name": "language",
          "type": {
            "type": "enum",
            "values": [
              "en",
              "fr",
              "de",
              "es",
              "it",
              "pt",
              "nl",
              "pl",
              "ro",
              "hr",
              "cs",
              "hu",
              "sk",
              "sl",
              "tr",
              "vi",
              "id",
              "ms",
              "la",
              "ru",
              "bg",
              "uk",
              "be",
              "mn",
              "ch",
              "ja",
              "ko",
              "ar",
              "fa",
              "ur",
              "hi",
              "mr",
              "ne",
              "sa"
            ],
            "type_name": "nodetool.nodes.lib.ocr.OCRLanguage"
          },
          "default": "en",
          "title": "Language",
          "description": "Language code for OCR"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "ocr_result"
              }
            ]
          },
          "name": "boxes"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        }
      ],
      "basic_fields": [
        "image",
        "language"
      ]
    },
    {
      "title": "Convert To Markdown",
      "description": "Converts various document formats to markdown using MarkItDown.\n    markdown, convert, document\n\n    Use cases:\n    - Convert Word documents to markdown\n    - Convert Excel files to markdown tables\n    - Convert PowerPoint to markdown content",
      "namespace": "lib.markitdown",
      "node_type": "lib.markitdown.ConvertToMarkdown",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document",
          "description": "The document to convert to markdown"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "document"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Get Secret",
      "description": "Get a secret value from configuration.\n    secrets, credentials, configuration",
      "namespace": "lib.secret",
      "node_type": "lib.secret.GetSecret",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "Secret key name"
        },
        {
          "name": "default",
          "type": {
            "type": "str",
            "optional": true
          },
          "default": null,
          "title": "Default",
          "description": "Default value if not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str",
            "optional": true
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "default"
      ]
    },
    {
      "title": "Set Secret",
      "description": "Set a secret value and persist it.\n    secrets, credentials, configuration",
      "namespace": "lib.secret",
      "node_type": "lib.secret.SetSecret",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "Secret key name"
        },
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value",
          "description": "Secret value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "none"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Base Url",
      "description": "Extract the base URL from a given URL.\n    url parsing, domain extraction, web utilities\n\n    Use cases:\n    - Get domain name from full URLs\n    - Clean up URLs for comparison\n    - Extract root website addresses\n    - Standardize URL formats",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.BaseUrl",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "URL",
          "description": "The URL to extract the base from"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "Extract Audio",
      "description": "Extract audio elements from HTML content.\n    extract, audio, src\n\n    Use cases:\n    - Collect audio sources from web pages\n    - Analyze audio usage on websites\n    - Create audio playlists",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractAudio",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract audio from."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "The base URL of the page, used to resolve relative audio URLs."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        }
      ],
      "basic_fields": [
        "html",
        "base_url"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Extract Images",
      "description": "Extract images from HTML content.\n    extract, images, src\n\n    Use cases:\n    - Collect images from web pages\n    - Analyze image usage on websites\n    - Create image galleries",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractImages",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract images from."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "The base URL of the page, used to resolve relative image URLs."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "image"
        }
      ],
      "basic_fields": [
        "html",
        "base_url"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Extract Links",
      "description": "Extract links from HTML content.\n    extract, links, urls\n\n    Use cases:\n    - Analyze website structure\n    - Discover related content\n    - Build sitemaps",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractLinks",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract links from."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "The base URL of the page, used to determine internal/external links."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "href"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "type"
        }
      ],
      "basic_fields": [
        "html",
        "base_url"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Extract Metadata",
      "description": "Extract metadata from HTML content.\n    extract, metadata, seo\n\n    Use cases:\n    - Analyze SEO elements\n    - Gather page information\n    - Extract structured data",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractMetadata",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract metadata from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "title"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "description"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "keywords"
        }
      ],
      "basic_fields": [
        "html"
      ]
    },
    {
      "title": "Extract Videos",
      "description": "Extract videos from HTML content.\n    extract, videos, src\n\n    Use cases:\n    - Collect video sources from web pages\n    - Analyze video usage on websites\n    - Create video playlists",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractVideos",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract videos from."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "The base URL of the page, used to resolve relative video URLs."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "video"
        }
      ],
      "basic_fields": [
        "html",
        "base_url"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Convert HTML to Text",
      "description": "Converts HTML to plain text by removing tags and decoding entities using BeautifulSoup.\n    html, text, convert\n\n    Use cases:\n    - Cleaning HTML content for text analysis\n    - Extracting readable content from web pages\n    - Preparing HTML data for natural language processing",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.HTMLToText",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "HTML"
        },
        {
          "name": "preserve_linebreaks",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Preserve Line Breaks",
          "description": "Convert block-level elements to newlines"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "preserve_linebreaks"
      ]
    },
    {
      "title": "Website Content Extractor",
      "description": "Extract main content from a website, removing navigation, ads, and other non-essential elements.\n    scrape, web scraping, content extraction, text analysis\n\n    Use cases:\n    - Clean web content for further analysis\n    - Extract article text from news websites\n    - Prepare web content for summarization",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.WebsiteContentExtractor",
      "properties": [
        {
          "name": "html_content",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html Content",
          "description": "The raw HTML content of the website."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "html_content"
      ]
    },
    {
      "title": "Circle",
      "description": "Generate SVG circle element.\n    svg, shape, vector, circle",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Circle",
      "properties": [
        {
          "name": "cx",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Cx",
          "description": "Center X coordinate"
        },
        {
          "name": "cy",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Cy",
          "description": "Center Y coordinate"
        },
        {
          "name": "radius",
          "type": {
            "type": "int"
          },
          "default": 50,
          "title": "Radius",
          "description": "Radius"
        },
        {
          "name": "fill",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Fill",
          "description": "Fill color"
        },
        {
          "name": "stroke",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "none"
          },
          "title": "Stroke",
          "description": "Stroke color"
        },
        {
          "name": "stroke_width",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Stroke Width",
          "description": "Stroke width"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "cx",
        "cy",
        "radius",
        "fill",
        "stroke",
        "stroke_width"
      ]
    },
    {
      "title": "Clip Path",
      "description": "Create clipping paths for SVG elements.\n    svg, clip, mask\n\n    Use cases:\n    - Mask parts of elements\n    - Create complex shapes through clipping\n    - Apply visual effects using masks",
      "namespace": "lib.svg",
      "node_type": "lib.svg.ClipPath",
      "properties": [
        {
          "name": "clip_content",
          "type": {
            "type": "svg_element"
          },
          "default": null,
          "title": "Clip Content",
          "description": "SVG element to use as clip path"
        },
        {
          "name": "content",
          "type": {
            "type": "svg_element"
          },
          "default": null,
          "title": "Content",
          "description": "SVG element to clip"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "clip_content",
        "content"
      ]
    },
    {
      "title": "SVG Document",
      "description": "Combine SVG elements into a complete SVG document.\n    svg, document, combine\n\n    Use cases:\n    - Combine multiple SVG elements into a single document\n    - Set document-level properties like viewBox and dimensions\n    - Export complete SVG documents",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Document",
      "properties": [
        {
          "name": "content",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "svg_element"
              },
              {
                "type": "list",
                "type_args": [
                  {
                    "type": "svg_element"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Content",
          "description": "SVG content"
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 800,
          "title": "Width",
          "description": "Document width",
          "min": 1.0,
          "max": 4096.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 600,
          "title": "Height",
          "description": "Document height",
          "min": 1.0,
          "max": 4096.0
        },
        {
          "name": "viewBox",
          "type": {
            "type": "str"
          },
          "default": "0 0 800 600",
          "title": "Viewbox",
          "description": "SVG viewBox attribute"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "content",
        "width",
        "height",
        "viewBox"
      ]
    },
    {
      "title": "Drop Shadow",
      "description": "Apply drop shadow filter to SVG elements.\n    svg, filter, shadow, effects",
      "namespace": "lib.svg",
      "node_type": "lib.svg.DropShadow",
      "properties": [
        {
          "name": "std_deviation",
          "type": {
            "type": "float"
          },
          "default": 3.0,
          "title": "Std Deviation",
          "description": "Standard deviation for blur"
        },
        {
          "name": "dx",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Dx",
          "description": "X offset for shadow"
        },
        {
          "name": "dy",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Dy",
          "description": "Y offset for shadow"
        },
        {
          "name": "color",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Color",
          "description": "Color for shadow"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "std_deviation",
        "dx",
        "dy",
        "color"
      ]
    },
    {
      "title": "Ellipse",
      "description": "Generate SVG ellipse element.\n    svg, shape, vector, ellipse",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Ellipse",
      "properties": [
        {
          "name": "cx",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Cx",
          "description": "Center X coordinate"
        },
        {
          "name": "cy",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Cy",
          "description": "Center Y coordinate"
        },
        {
          "name": "rx",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Rx",
          "description": "X radius"
        },
        {
          "name": "ry",
          "type": {
            "type": "int"
          },
          "default": 50,
          "title": "Ry",
          "description": "Y radius"
        },
        {
          "name": "fill",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Fill",
          "description": "Fill color"
        },
        {
          "name": "stroke",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "none"
          },
          "title": "Stroke",
          "description": "Stroke color"
        },
        {
          "name": "stroke_width",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Stroke Width",
          "description": "Stroke width"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "cx",
        "cy",
        "rx",
        "ry",
        "fill",
        "stroke",
        "stroke_width"
      ]
    },
    {
      "title": "Gaussian Blur",
      "description": "Apply Gaussian blur filter to SVG elements.\n    svg, filter, blur, effects",
      "namespace": "lib.svg",
      "node_type": "lib.svg.GaussianBlur",
      "properties": [
        {
          "name": "std_deviation",
          "type": {
            "type": "float"
          },
          "default": 3.0,
          "title": "Std Deviation",
          "description": "Standard deviation for blur"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "std_deviation"
      ]
    },
    {
      "title": "Gradient",
      "description": "Create linear or radial gradients for SVG elements.\n    svg, gradient, color\n\n    Use cases:\n    - Add smooth color transitions\n    - Create complex color effects\n    - Define reusable gradient definitions",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Gradient",
      "properties": [
        {
          "name": "gradient_type",
          "type": {
            "type": "enum",
            "values": [
              "linearGradient",
              "radialGradient"
            ],
            "type_name": "nodetool.nodes.lib.svg.Gradient.GradientType"
          },
          "default": "linearGradient",
          "title": "Gradient Type",
          "description": "Type of gradient"
        },
        {
          "name": "x1",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "X1",
          "description": "Start X position (linear) or center X (radial)"
        },
        {
          "name": "y1",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Y1",
          "description": "Start Y position (linear) or center Y (radial)"
        },
        {
          "name": "x2",
          "type": {
            "type": "float"
          },
          "default": 100,
          "title": "X2",
          "description": "End X position (linear) or radius X (radial)"
        },
        {
          "name": "y2",
          "type": {
            "type": "float"
          },
          "default": 100,
          "title": "Y2",
          "description": "End Y position (linear) or radius Y (radial)"
        },
        {
          "name": "color1",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Color1",
          "description": "Start color of gradient"
        },
        {
          "name": "color2",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#FFFFFF"
          },
          "title": "Color2",
          "description": "End color of gradient"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "gradient_type",
        "x1",
        "y1",
        "x2",
        "y2",
        "color1",
        "color2"
      ]
    },
    {
      "title": "Line",
      "description": "Generate SVG line element.\n    svg, shape, vector, line",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Line",
      "properties": [
        {
          "name": "x1",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "X1",
          "description": "Start X coordinate"
        },
        {
          "name": "y1",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Y1",
          "description": "Start Y coordinate"
        },
        {
          "name": "x2",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "X2",
          "description": "End X coordinate"
        },
        {
          "name": "y2",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Y2",
          "description": "End Y coordinate"
        },
        {
          "name": "stroke",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Stroke",
          "description": "Stroke color"
        },
        {
          "name": "stroke_width",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Stroke Width",
          "description": "Stroke width"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "x1",
        "y1",
        "x2",
        "y2",
        "stroke",
        "stroke_width"
      ]
    },
    {
      "title": "Path",
      "description": "Generate SVG path element.\n    svg, shape, vector, path",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Path",
      "properties": [
        {
          "name": "path_data",
          "type": {
            "type": "str"
          },
          "default": null,
          "title": "Path Data",
          "description": "SVG path data (d attribute)"
        },
        {
          "name": "fill",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Fill",
          "description": "Fill color"
        },
        {
          "name": "stroke",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "none"
          },
          "title": "Stroke",
          "description": "Stroke color"
        },
        {
          "name": "stroke_width",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Stroke Width",
          "description": "Stroke width"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path_data",
        "fill",
        "stroke",
        "stroke_width"
      ]
    },
    {
      "title": "Polygon",
      "description": "Generate SVG polygon element.\n    svg, shape, vector, polygon",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Polygon",
      "properties": [
        {
          "name": "points",
          "type": {
            "type": "str"
          },
          "default": null,
          "title": "Points",
          "description": "Points in format 'x1,y1 x2,y2 x3,y3...'"
        },
        {
          "name": "fill",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Fill",
          "description": "Fill color"
        },
        {
          "name": "stroke",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "none"
          },
          "title": "Stroke",
          "description": "Stroke color"
        },
        {
          "name": "stroke_width",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Stroke Width",
          "description": "Stroke width"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "points",
        "fill",
        "stroke",
        "stroke_width"
      ]
    },
    {
      "title": "Rectangle",
      "description": "Generate SVG rectangle element.\n    svg, shape, vector, rectangle",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Rect",
      "properties": [
        {
          "name": "x",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "X",
          "description": "X coordinate"
        },
        {
          "name": "y",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Y",
          "description": "Y coordinate"
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Width",
          "description": "Width"
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Height",
          "description": "Height"
        },
        {
          "name": "fill",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Fill",
          "description": "Fill color"
        },
        {
          "name": "stroke",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "none"
          },
          "title": "Stroke",
          "description": "Stroke color"
        },
        {
          "name": "stroke_width",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Stroke Width",
          "description": "Stroke width"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "x",
        "y",
        "width",
        "height",
        "fill",
        "stroke",
        "stroke_width"
      ]
    },
    {
      "title": "SVG to Image",
      "description": "Create an SVG document and convert it to a raster image in one step.\n    svg, document, raster, convert\n\n    Use cases:\n    - Create and rasterize SVG documents in a single operation\n    - Generate image files from SVG elements\n    - Convert vector graphics to bitmap format with custom dimensions",
      "namespace": "lib.svg",
      "node_type": "lib.svg.SVGToImage",
      "properties": [
        {
          "name": "content",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "svg_element"
              },
              {
                "type": "list",
                "type_args": [
                  {
                    "type": "svg_element"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Content",
          "description": "SVG content"
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 800,
          "title": "Width",
          "description": "Document width",
          "min": 1.0,
          "max": 4096.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 600,
          "title": "Height",
          "description": "Document height",
          "min": 1.0,
          "max": 4096.0
        },
        {
          "name": "viewBox",
          "type": {
            "type": "str"
          },
          "default": "0 0 800 600",
          "title": "Viewbox",
          "description": "SVG viewBox attribute"
        },
        {
          "name": "scale",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Scale",
          "description": "Scale factor for rasterization",
          "min": 1.0,
          "max": 10.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "content",
        "width",
        "height",
        "viewBox",
        "scale"
      ]
    },
    {
      "title": "Text",
      "description": "Add text elements to SVG.\n    svg, text, typography\n\n    Use cases:\n    - Add labels to vector graphics\n    - Create text-based logos\n    - Generate dynamic text content in SVGs",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Text",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text content"
        },
        {
          "name": "x",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "X",
          "description": "X coordinate"
        },
        {
          "name": "y",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Y",
          "description": "Y coordinate"
        },
        {
          "name": "font_family",
          "type": {
            "type": "str"
          },
          "default": "Arial",
          "title": "Font Family",
          "description": "Font family"
        },
        {
          "name": "font_size",
          "type": {
            "type": "int"
          },
          "default": 16,
          "title": "Font Size",
          "description": "Font size"
        },
        {
          "name": "fill",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Fill",
          "description": "Text color"
        },
        {
          "name": "text_anchor",
          "type": {
            "type": "enum",
            "values": [
              "start",
              "middle",
              "end"
            ],
            "type_name": "nodetool.nodes.lib.svg.SVGTextAnchor"
          },
          "default": "start",
          "title": "Text Anchor",
          "description": "Text anchor position"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "x",
        "y",
        "font_family",
        "font_size",
        "fill",
        "text_anchor"
      ]
    },
    {
      "title": "Transform",
      "description": "Apply transformations to SVG elements.\n    svg, transform, animation\n\n    Use cases:\n    - Rotate, scale, or translate elements\n    - Create complex transformations\n    - Prepare elements for animation",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Transform",
      "properties": [
        {
          "name": "content",
          "type": {
            "type": "svg_element"
          },
          "default": null,
          "title": "Content",
          "description": "SVG element to transform"
        },
        {
          "name": "translate_x",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Translate X",
          "description": "X translation"
        },
        {
          "name": "translate_y",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Translate Y",
          "description": "Y translation"
        },
        {
          "name": "rotate",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Rotate",
          "description": "Rotation angle in degrees"
        },
        {
          "name": "scale_x",
          "type": {
            "type": "float"
          },
          "default": 1,
          "title": "Scale X",
          "description": "X scale factor"
        },
        {
          "name": "scale_y",
          "type": {
            "type": "float"
          },
          "default": 1,
          "title": "Scale Y",
          "description": "Y scale factor"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "content",
        "translate_x",
        "translate_y",
        "rotate",
        "scale_x",
        "scale_y"
      ]
    },
    {
      "title": "Extract Bullet Lists",
      "description": "Extracts bulleted lists from markdown.\n    markdown, lists, bullets, extraction\n\n    Use cases:\n    - Extract unordered list items\n    - Analyze bullet point structures\n    - Convert bullet lists to structured data",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractBulletLists",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "markdown"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Code Blocks",
      "description": "Extracts code blocks and their languages from markdown.\n    markdown, code, extraction\n\n    Use cases:\n    - Extract code samples for analysis\n    - Collect programming examples\n    - Analyze code snippets in documentation",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractCodeBlocks",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "markdown"
      ]
    },
    {
      "title": "Extract Headers",
      "description": "Extracts headers and creates a document structure/outline.\n    markdown, headers, structure\n\n    Use cases:\n    - Generate table of contents\n    - Analyze document structure\n    - Extract main topics from documents",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractHeaders",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        },
        {
          "name": "max_level",
          "type": {
            "type": "int"
          },
          "default": 6,
          "title": "Max Level",
          "description": "Maximum header level to extract (1-6)",
          "min": 1.0,
          "max": 6.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "markdown",
        "max_level"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Links",
      "description": "Extracts all links from markdown text.\n    markdown, links, extraction\n\n    Use cases:\n    - Extract references and citations from academic documents\n    - Build link graphs from markdown documentation\n    - Analyze external resources referenced in markdown files",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractLinks",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        },
        {
          "name": "include_titles",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Include Titles",
          "description": "Whether to include link titles in output"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "markdown",
        "include_titles"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Numbered Lists",
      "description": "Extracts numbered lists from markdown.\n    markdown, lists, numbered, extraction\n\n    Use cases:\n    - Extract ordered list items\n    - Analyze enumerated structures\n    - Convert numbered lists to structured data",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractNumberedLists",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "markdown"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Tables",
      "description": "Extracts tables from markdown and converts them to structured data.\n    markdown, tables, data\n\n    Use cases:\n    - Extract tabular data from markdown\n    - Convert markdown tables to structured formats\n    - Analyze tabulated information",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractTables",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "markdown"
      ],
      "expose_as_tool": true
    },
    {
      "title": "DELETE Request",
      "description": "Remove a resource from a server using an HTTP DELETE request.\n    http, delete, request, url\n\n    Use cases:\n    - Delete user accounts\n    - Remove API resources\n    - Cancel subscriptions\n    - Clear cache entries",
      "namespace": "lib.http",
      "node_type": "lib.http.DeleteRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Download Dataframe",
      "description": "Download data from a URL and return as a dataframe.\n    http, get, request, url, dataframe, csv, json, data\n\n    Use cases:\n    - Download CSV data and convert to dataframe\n    - Fetch JSON data and convert to dataframe\n    - Retrieve tabular data from APIs\n    - Process data files from URLs",
      "namespace": "lib.http",
      "node_type": "lib.http.DownloadDataframe",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "file_format",
          "type": {
            "type": "enum",
            "values": [
              "csv",
              "json",
              "tsv"
            ],
            "type_name": "nodetool.nodes.lib.http.DownloadDataframe.FileFormat"
          },
          "default": "csv",
          "title": "File Format",
          "description": "The format of the data file (csv, json, tsv)."
        },
        {
          "name": "columns",
          "type": {
            "type": "record_type"
          },
          "default": {
            "type": "record_type",
            "columns": []
          },
          "title": "Columns",
          "description": "The columns of the dataframe."
        },
        {
          "name": "encoding",
          "type": {
            "type": "str"
          },
          "default": "utf-8",
          "title": "Encoding",
          "description": "The encoding of the text file."
        },
        {
          "name": "delimiter",
          "type": {
            "type": "str"
          },
          "default": ",",
          "title": "Delimiter",
          "description": "The delimiter for CSV/TSV files."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url",
        "columns",
        "file_format"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Download Files",
      "description": "Download files from a list of URLs into a local folder.\n    download, files, urls, batch\n\n    Use cases:\n    - Batch download files from multiple URLs\n    - Create local copies of remote resources\n    - Archive web content\n    - Download datasets",
      "namespace": "lib.http",
      "node_type": "lib.http.DownloadFiles",
      "properties": [
        {
          "name": "urls",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Urls",
          "description": "List of URLs to download."
        },
        {
          "name": "output_folder",
          "type": {
            "type": "str"
          },
          "default": "downloads",
          "title": "Output Folder",
          "description": "Local folder path where files will be saved."
        },
        {
          "name": "max_concurrent_downloads",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "Max Concurrent Downloads",
          "description": "Maximum number of concurrent downloads."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "success"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "failed"
        }
      ],
      "basic_fields": [
        "urls",
        "output_folder",
        "max_concurrent_downloads"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Fetch Page",
      "description": "Fetch a web page using Selenium and return its content.\n    selenium, fetch, webpage, http\n\n    Use cases:\n    - Retrieve content from dynamic websites\n    - Capture JavaScript-rendered content\n    - Interact with web applications",
      "namespace": "lib.http",
      "node_type": "lib.http.FetchPage",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to fetch the page from."
        },
        {
          "name": "wait_time",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Wait Time",
          "description": "Maximum time to wait for page load (in seconds)."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "html"
        },
        {
          "type": {
            "type": "bool"
          },
          "name": "success"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "error_message"
        }
      ],
      "basic_fields": [
        "url",
        "wait_time"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Filter Valid URLs",
      "description": "Filter a list of URLs by checking their validity using HEAD requests.\n    url validation, http, head request\n\n    Use cases:\n    - Clean URL lists by removing broken links\n    - Verify resource availability\n    - Validate website URLs before processing",
      "namespace": "lib.http",
      "node_type": "lib.http.FilterValidURLs",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "urls",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Urls",
          "description": "List of URLs to validate."
        },
        {
          "name": "max_concurrent_requests",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Max Concurrent Requests",
          "description": "Maximum number of concurrent HEAD requests."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "GET Request",
      "description": "Perform an HTTP GET request to retrieve data from a specified URL.\n    http, get, request, url\n\n    Use cases:\n    - Fetch web page content\n    - Retrieve API data\n    - Download files\n    - Check website availability",
      "namespace": "lib.http",
      "node_type": "lib.http.GetRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "GET Binary",
      "description": "Perform an HTTP GET request and return raw binary data.\n    http, get, request, url, binary, download\n\n    Use cases:\n    - Download binary files\n    - Fetch images or media\n    - Retrieve PDF documents\n    - Download any non-text content",
      "namespace": "lib.http",
      "node_type": "lib.http.GetRequestBinary",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "GET Document",
      "description": "Perform an HTTP GET request and return a document\n    http, get, request, url, document\n\n    Use cases:\n    - Download PDF documents\n    - Retrieve Word documents\n    - Fetch Excel files\n    - Download any document format",
      "namespace": "lib.http",
      "node_type": "lib.http.GetRequestDocument",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "HEAD Request",
      "description": "Retrieve headers from a resource using an HTTP HEAD request.\n    http, head, request, url\n\n    Use cases:\n    - Check resource existence\n    - Get metadata without downloading content\n    - Verify authentication or permissions",
      "namespace": "lib.http",
      "node_type": "lib.http.HeadRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "Image Downloader",
      "description": "Download images from list of URLs and return a list of ImageRefs.\n    image download, web scraping, data processing\n\n    Use cases:\n    - Prepare image datasets for machine learning tasks\n    - Archive images from web pages\n    - Process and analyze images extracted from websites",
      "namespace": "lib.http",
      "node_type": "lib.http.ImageDownloader",
      "properties": [
        {
          "name": "images",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Images",
          "description": "List of image URLs to download."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "Base URL to prepend to relative image URLs."
        },
        {
          "name": "max_concurrent_downloads",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Max Concurrent Downloads",
          "description": "Maximum number of concurrent image downloads."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "name": "images"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "failed_urls"
        }
      ],
      "basic_fields": [
        "images",
        "base_url",
        "max_concurrent_downloads"
      ],
      "expose_as_tool": true
    },
    {
      "title": "GET JSON",
      "description": "Perform an HTTP GET request and parse the response as JSON.\n    http, get, request, url, json, api\n\n    Use cases:\n    - Fetch data from REST APIs\n    - Retrieve JSON-formatted responses\n    - Interface with JSON web services",
      "namespace": "lib.http",
      "node_type": "lib.http.JSONGetRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "PATCH JSON",
      "description": "Partially update resources with JSON data using an HTTP PATCH request.\n    http, patch, request, url, json, api\n\n    Use cases:\n    - Partial updates to API resources\n    - Modify specific fields without full replacement\n    - Efficient updates for large objects",
      "namespace": "lib.http",
      "node_type": "lib.http.JSONPatchRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Data",
          "description": "The JSON data to send in the PATCH request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "POST JSON",
      "description": "Send JSON data to a server using an HTTP POST request.\n    http, post, request, url, json, api\n\n    Use cases:\n    - Send structured data to REST APIs\n    - Create resources with JSON payloads\n    - Interface with modern web services",
      "namespace": "lib.http",
      "node_type": "lib.http.JSONPostRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Data",
          "description": "The JSON data to send in the POST request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "PUT JSON",
      "description": "Update resources with JSON data using an HTTP PUT request.\n    http, put, request, url, json, api\n\n    Use cases:\n    - Update existing API resources\n    - Replace complete objects in REST APIs\n    - Set configuration with JSON data",
      "namespace": "lib.http",
      "node_type": "lib.http.JSONPutRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Data",
          "description": "The JSON data to send in the PUT request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "POST Request",
      "description": "Send data to a server using an HTTP POST request.\n    http, post, request, url, data\n\n    Use cases:\n    - Submit form data\n    - Create new resources on an API\n    - Upload files\n    - Authenticate users",
      "namespace": "lib.http",
      "node_type": "lib.http.PostRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Data",
          "description": "The data to send in the POST request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "POST Binary",
      "description": "Send data using an HTTP POST request and return raw binary data.\n    http, post, request, url, data, binary\n\n    Use cases:\n    - Upload and receive binary files\n    - Interact with binary APIs\n    - Process image or media uploads\n    - Handle binary file transformations",
      "namespace": "lib.http",
      "node_type": "lib.http.PostRequestBinary",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "bytes"
              }
            ]
          },
          "default": "",
          "title": "Data",
          "description": "The data to send in the POST request. Can be string or binary."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "PUT Request",
      "description": "Update existing resources on a server using an HTTP PUT request.\n    http, put, request, url, data\n\n    Use cases:\n    - Update user profiles\n    - Modify existing API resources\n    - Replace file contents\n    - Set configuration values",
      "namespace": "lib.http",
      "node_type": "lib.http.PutRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Data",
          "description": "The data to send in the PUT request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Add",
      "description": "Adds two numbers.\n    math, add, plus",
      "namespace": "lib.math",
      "node_type": "lib.math.Add",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Cosine",
      "description": "Computes cosine of the given angle in radians.\n    math, cosine, trig",
      "namespace": "lib.math",
      "node_type": "lib.math.Cosine",
      "layout": "small",
      "properties": [
        {
          "name": "angle_rad",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "Angle (rad)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "angle_rad"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Divide",
      "description": "Divides A by B.\n    math, divide, division, quotient",
      "namespace": "lib.math",
      "node_type": "lib.math.Divide",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 1.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Math Function",
      "description": "Performs a selected unary math operation on an input.\n    math, negate, absolute, square, cube, square_root, cube_root, sine, cosine, tangent, arcsine, arccosine, arctangent, log",
      "namespace": "lib.math",
      "node_type": "lib.math.MathFunction",
      "layout": "small",
      "properties": [
        {
          "name": "input",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "Input"
        },
        {
          "name": "operation",
          "type": {
            "type": "enum",
            "values": [
              "negate",
              "absolute",
              "square",
              "cube",
              "square_root",
              "cube_root",
              "sine",
              "cosine",
              "tangent",
              "arcsin",
              "arccos",
              "arctan",
              "log"
            ],
            "type_name": "nodetool.nodes.lib.math.MathFunction.Operation"
          },
          "default": "negate",
          "title": "Operation",
          "description": "Unary operation to perform"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input",
        "operation"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Modulus",
      "description": "Computes A modulo B.\n    math, modulus, modulo, remainder",
      "namespace": "lib.math",
      "node_type": "lib.math.Modulus",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 1.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Multiply",
      "description": "Multiplies two numbers.\n    math, multiply, product",
      "namespace": "lib.math",
      "node_type": "lib.math.Multiply",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Power",
      "description": "Raises base to the given exponent.\n    math, power, exponent",
      "namespace": "lib.math",
      "node_type": "lib.math.Power",
      "layout": "small",
      "properties": [
        {
          "name": "base",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "Base"
        },
        {
          "name": "exponent",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 1.0,
          "title": "Exponent"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "base",
        "exponent"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Sine",
      "description": "Computes sine of the given angle in radians.\n    math, sine, trig",
      "namespace": "lib.math",
      "node_type": "lib.math.Sine",
      "layout": "small",
      "properties": [
        {
          "name": "angle_rad",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "Angle (rad)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "angle_rad"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Sqrt",
      "description": "Computes square root of x.\n    math, sqrt, square_root",
      "namespace": "lib.math",
      "node_type": "lib.math.Sqrt",
      "layout": "small",
      "properties": [
        {
          "name": "x",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "X"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "x"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Subtract",
      "description": "Subtracts B from A.\n    math, subtract, minus",
      "namespace": "lib.math",
      "node_type": "lib.math.Subtract",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Load Bytes File",
      "description": "Read raw bytes from a file on disk.\n    files, bytes, read, input, load, file\n\n    Use cases:\n    - Load binary data for processing\n    - Read binary files for a workflow",
      "namespace": "lib.bytes",
      "node_type": "lib.bytes.LoadBytesFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Save Bytes File",
      "description": "Write raw bytes to a file on disk.\n    files, bytes, save, output\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "lib.bytes",
      "node_type": "lib.bytes.SaveBytesFile",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "bytes",
            "optional": true
          },
          "default": null,
          "title": "Data",
          "description": "The bytes to write to file"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Name of the file to save. Supports strftime format codes."
        }
      ],
      "basic_fields": [
        "data",
        "folder",
        "filename"
      ]
    },
    {
      "title": "Add Time Delta",
      "description": "Add or subtract time from a datetime.\n    datetime, add, subtract\n\n    Use cases:\n    - Calculate future/past dates\n    - Generate date ranges",
      "namespace": "lib.date",
      "node_type": "lib.date.AddTimeDelta",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Input Datetime",
          "description": "Starting datetime"
        },
        {
          "name": "days",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Days",
          "description": "Number of days to add (negative to subtract)",
          "min": -3650.0,
          "max": 3650.0
        },
        {
          "name": "hours",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Hours",
          "description": "Number of hours to add (negative to subtract)",
          "min": -24.0,
          "max": 24.0
        },
        {
          "name": "minutes",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Minutes",
          "description": "Number of minutes to add (negative to subtract)",
          "min": -60.0,
          "max": 60.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_datetime",
        "days",
        "hours",
        "minutes"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Boundary Time",
      "description": "Get the start or end of a time period (day, week, month, year).\n    datetime, start, end, boundary, day, week, month, year\n\n    Use cases:\n    - Get period boundaries for reporting\n    - Normalize dates to period starts/ends",
      "namespace": "lib.date",
      "node_type": "lib.date.BoundaryTime",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Input Datetime",
          "description": "Input datetime"
        },
        {
          "name": "period",
          "type": {
            "type": "enum",
            "values": [
              "day",
              "week",
              "month",
              "year"
            ],
            "type_name": "nodetool.nodes.lib.date.PeriodType"
          },
          "default": "day",
          "title": "Period",
          "description": "Time period type"
        },
        {
          "name": "boundary",
          "type": {
            "type": "enum",
            "values": [
              "start",
              "end"
            ],
            "type_name": "nodetool.nodes.lib.date.BoundaryType"
          },
          "default": "start",
          "title": "Boundary",
          "description": "Start or end of period"
        },
        {
          "name": "start_monday",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Start Monday",
          "description": "For week period: Consider Monday as start of week (False for Sunday)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_datetime",
        "period",
        "boundary",
        "start_monday"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Date Difference",
      "description": "Calculate the difference between two dates.\n    datetime, difference, duration\n\n    Use cases:\n    - Calculate time periods\n    - Measure durations",
      "namespace": "lib.date",
      "node_type": "lib.date.DateDifference",
      "properties": [
        {
          "name": "start_date",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Start Date",
          "description": "Start datetime"
        },
        {
          "name": "end_date",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "End Date",
          "description": "End datetime"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "total_seconds"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "days"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "hours"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "minutes"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "seconds"
        }
      ],
      "basic_fields": [
        "start_date",
        "end_date"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Date Range",
      "description": "Generate a list of dates between start and end dates.\n    datetime, range, list\n\n    Use cases:\n    - Generate date sequences\n    - Create date-based iterations",
      "namespace": "lib.date",
      "node_type": "lib.date.DateRange",
      "properties": [
        {
          "name": "start_date",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Start Date",
          "description": "Start date of the range"
        },
        {
          "name": "end_date",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "End Date",
          "description": "End date of the range"
        },
        {
          "name": "step_days",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Step Days",
          "description": "Number of days between each date"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "datetime"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "start_date",
        "end_date",
        "step_days"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Date To Datetime",
      "description": "Convert a Date object to a Datetime object.\n    date, datetime, convert",
      "namespace": "lib.date",
      "node_type": "lib.date.DateToDatetime",
      "properties": [
        {
          "name": "input_date",
          "type": {
            "type": "date"
          },
          "default": {
            "type": "date",
            "year": 0,
            "month": 0,
            "day": 0
          },
          "title": "Input Date",
          "description": "Date to convert"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_date"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Datetime To Date",
      "description": "Convert a Datetime object to a Date object.\n    date, datetime, convert",
      "namespace": "lib.date",
      "node_type": "lib.date.DatetimeToDate",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Input Datetime",
          "description": "Datetime to convert"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "date"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_datetime"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Format Date Time",
      "description": "Convert a datetime object to a formatted string.\n    datetime, format, convert\n\n    Use cases:\n    - Standardize date formats\n    - Prepare dates for different systems",
      "namespace": "lib.date",
      "node_type": "lib.date.FormatDateTime",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Input Datetime",
          "description": "Datetime object to format"
        },
        {
          "name": "output_format",
          "type": {
            "type": "enum",
            "values": [
              "%Y-%m-%d",
              "%m/%d/%Y",
              "%d/%m/%Y",
              "%B %d, %Y",
              "%Y%m%d",
              "%Y%m%d_%H%M%S",
              "%Y-%m-%dT%H:%M:%S",
              "%Y-%m-%dT%H:%M:%S%z",
              "%Y-%m-%dT%H:%M:%S%z"
            ],
            "type_name": "nodetool.nodes.lib.date.DateFormat"
          },
          "default": "%B %d, %Y",
          "title": "Output Format",
          "description": "Desired output format"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_datetime",
        "output_format"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Get Quarter",
      "description": "Get the quarter number and start/end dates for a given datetime.\n    datetime, quarter, period\n\n    Use cases:\n    - Financial reporting periods\n    - Quarterly analytics",
      "namespace": "lib.date",
      "node_type": "lib.date.GetQuarter",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Input Datetime",
          "description": "Input datetime"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "quarter"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "quarter_start"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "quarter_end"
        }
      ],
      "basic_fields": [
        "input_datetime"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Get Weekday",
      "description": "Get the weekday name or number from a datetime.\n    datetime, weekday, name\n\n    Use cases:\n    - Get day names for scheduling\n    - Filter events by weekday",
      "namespace": "lib.date",
      "node_type": "lib.date.GetWeekday",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Input Datetime",
          "description": "Input datetime"
        },
        {
          "name": "as_name",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "As Name",
          "description": "Return weekday name instead of number (0-6)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_datetime",
        "as_name"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Is Date In Range",
      "description": "Check if a date falls within a specified range.\n    datetime, range, check\n\n    Use cases:\n    - Validate date ranges\n    - Filter date-based data",
      "namespace": "lib.date",
      "node_type": "lib.date.IsDateInRange",
      "properties": [
        {
          "name": "check_date",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Check Date",
          "description": "Date to check"
        },
        {
          "name": "start_date",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Start Date",
          "description": "Start of date range"
        },
        {
          "name": "end_date",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "End Date",
          "description": "End of date range"
        },
        {
          "name": "inclusive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Inclusive",
          "description": "Include start and end dates in range"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "check_date",
        "start_date",
        "end_date",
        "inclusive"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Now",
      "description": "Get the current date and time.\n    datetime, current, now",
      "namespace": "lib.date",
      "node_type": "lib.date.Now",
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "expose_as_tool": true
    },
    {
      "title": "Parse Date",
      "description": "Parse a date string into components.\n    date, parse, format",
      "namespace": "lib.date",
      "node_type": "lib.date.ParseDate",
      "properties": [
        {
          "name": "date_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Date String",
          "description": "The date string to parse"
        },
        {
          "name": "input_format",
          "type": {
            "type": "enum",
            "values": [
              "%Y-%m-%d",
              "%m/%d/%Y",
              "%d/%m/%Y",
              "%B %d, %Y",
              "%Y%m%d",
              "%Y%m%d_%H%M%S",
              "%Y-%m-%dT%H:%M:%S",
              "%Y-%m-%dT%H:%M:%S%z",
              "%Y-%m-%dT%H:%M:%S%z"
            ],
            "type_name": "nodetool.nodes.lib.date.DateFormat"
          },
          "default": "%Y-%m-%d",
          "title": "Input Format",
          "description": "Format of the input date string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "date"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "date_string",
        "input_format"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Parse Date Time",
      "description": "Parse a date/time string into components.\n    datetime, parse, format\n\n    Use cases:\n    - Extract date components from strings\n    - Convert between date formats",
      "namespace": "lib.date",
      "node_type": "lib.date.ParseDateTime",
      "properties": [
        {
          "name": "datetime_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Datetime String",
          "description": "The datetime string to parse"
        },
        {
          "name": "input_format",
          "type": {
            "type": "enum",
            "values": [
              "%Y-%m-%d",
              "%m/%d/%Y",
              "%d/%m/%Y",
              "%B %d, %Y",
              "%Y%m%d",
              "%Y%m%d_%H%M%S",
              "%Y-%m-%dT%H:%M:%S",
              "%Y-%m-%dT%H:%M:%S%z",
              "%Y-%m-%dT%H:%M:%S%z"
            ],
            "type_name": "nodetool.nodes.lib.date.DateFormat"
          },
          "default": "%Y-%m-%d",
          "title": "Input Format",
          "description": "Format of the input datetime string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "datetime_string",
        "input_format"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Relative Time",
      "description": "Get datetime relative to current time (past or future).\n    datetime, past, future, relative, hours, days, months\n\n    Use cases:\n    - Calculate past or future dates\n    - Generate relative timestamps",
      "namespace": "lib.date",
      "node_type": "lib.date.RelativeTime",
      "properties": [
        {
          "name": "amount",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Amount",
          "description": "Amount of time units",
          "min": 0.0
        },
        {
          "name": "unit",
          "type": {
            "type": "enum",
            "values": [
              "hours",
              "days",
              "months"
            ],
            "type_name": "nodetool.nodes.lib.date.TimeUnitType"
          },
          "default": "days",
          "title": "Unit",
          "description": "Time unit type"
        },
        {
          "name": "direction",
          "type": {
            "type": "enum",
            "values": [
              "past",
              "future"
            ],
            "type_name": "nodetool.nodes.lib.date.TimeDirection"
          },
          "default": "future",
          "title": "Direction",
          "description": "Past or future"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "amount",
        "unit",
        "direction"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Today",
      "description": "Get the current date.\n    date, today, now",
      "namespace": "lib.date",
      "node_type": "lib.date.Today",
      "outputs": [
        {
          "type": {
            "type": "date"
          },
          "name": "output"
        }
      ],
      "expose_as_tool": true
    },
    {
      "title": "Filter JSON",
      "description": "Filter JSON array based on a key-value condition.\n    json, filter, array\n\n    Use cases:\n    - Filter arrays of objects\n    - Search JSON data",
      "namespace": "lib.json",
      "node_type": "lib.json.FilterJSON",
      "properties": [
        {
          "name": "array",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Array",
          "description": "Array of JSON objects to filter"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key",
          "description": "Key to filter on"
        },
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "Value",
          "description": "Value to match"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "array",
        "key",
        "value"
      ]
    },
    {
      "title": "Get JSONPath Bool",
      "description": "Extract a boolean value from a JSON path\n    json, path, extract, boolean",
      "namespace": "lib.json",
      "node_type": "lib.json.GetJSONPathBool",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path",
        "default"
      ]
    },
    {
      "title": "Get JSONPath Dict",
      "description": "Extract a dictionary value from a JSON path\n    json, path, extract, object",
      "namespace": "lib.json",
      "node_type": "lib.json.GetJSONPathDict",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path",
        "default"
      ]
    },
    {
      "title": "Get JSONPath Float",
      "description": "Extract a float value from a JSON path\n    json, path, extract, number",
      "namespace": "lib.json",
      "node_type": "lib.json.GetJSONPathFloat",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path",
        "default"
      ]
    },
    {
      "title": "Get JSONPath Int",
      "description": "Extract an integer value from a JSON path\n    json, path, extract, number",
      "namespace": "lib.json",
      "node_type": "lib.json.GetJSONPathInt",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path",
        "default"
      ]
    },
    {
      "title": "Get JSONPath List",
      "description": "Extract a list value from a JSON path\n    json, path, extract, array",
      "namespace": "lib.json",
      "node_type": "lib.json.GetJSONPathList",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "list"
          },
          "default": [],
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path",
        "default"
      ]
    },
    {
      "title": "Get JSONPath Str",
      "description": "Extract a string value from a JSON path\n    json, path, extract, string",
      "namespace": "lib.json",
      "node_type": "lib.json.GetJSONPathStr",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path",
        "default"
      ]
    },
    {
      "title": "JSON Template",
      "description": "Template JSON strings with variable substitution.\n    json, template, substitute, variables\n\n    Example:\n    template: '{\"name\": \"$user\", \"age\": $age}'\n    values: {\"user\": \"John\", \"age\": 30}\n    result: '{\"name\": \"John\", \"age\": 30}'\n\n    Use cases:\n    - Create dynamic JSON payloads\n    - Generate JSON with variable data\n    - Build API request templates",
      "namespace": "lib.json",
      "node_type": "lib.json.JSONTemplate",
      "properties": [
        {
          "name": "template",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Template",
          "description": "JSON template string with $variable placeholders"
        },
        {
          "name": "values",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Values",
          "description": "Dictionary of values to substitute into the template"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "template",
        "values"
      ]
    },
    {
      "title": "Load JSON Folder",
      "description": "Load JSON files from an asset folder.\n    load, json, file, import",
      "namespace": "lib.json",
      "node_type": "lib.json.LoadJSONAssets",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The asset folder to load the JSON files from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "json"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        }
      ],
      "basic_fields": [
        "folder"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Parse Dict",
      "description": "Parse a JSON string into a Python dictionary.\n    json, parse, decode, dictionary\n\n    Use cases:\n    - Convert JSON API responses to Python dictionaries\n    - Process JSON configuration files\n    - Parse object-like JSON data",
      "namespace": "lib.json",
      "node_type": "lib.json.ParseDict",
      "properties": [
        {
          "name": "json_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Json String",
          "description": "JSON string to parse into a dictionary"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "json_string"
      ]
    },
    {
      "title": "Parse List",
      "description": "Parse a JSON string into a Python list.\n    json, parse, decode, array, list\n\n    Use cases:\n    - Convert JSON array responses to Python lists\n    - Process JSON data collections\n    - Parse array-like JSON data",
      "namespace": "lib.json",
      "node_type": "lib.json.ParseList",
      "properties": [
        {
          "name": "json_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Json String",
          "description": "JSON string to parse into a list"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "json_string"
      ]
    },
    {
      "title": "Stringify JSON",
      "description": "Convert a Python object to a JSON string.\n    json, stringify, encode\n\n    Use cases:\n    - Prepare data for API requests\n    - Save data in JSON format",
      "namespace": "lib.json",
      "node_type": "lib.json.StringifyJSON",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": {},
          "title": "Data",
          "description": "Data to convert to JSON"
        },
        {
          "name": "indent",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Indent",
          "description": "Number of spaces for indentation"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "indent"
      ]
    },
    {
      "title": "Validate JSON",
      "description": "Validate JSON data against a schema.\n    json, validate, schema\n\n    Use cases:\n    - Ensure API payloads match specifications\n    - Validate configuration files",
      "namespace": "lib.json",
      "node_type": "lib.json.ValidateJSON",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": null,
          "title": "Data",
          "description": "JSON data to validate"
        },
        {
          "name": "json_schema",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Json Schema",
          "description": "JSON schema for validation"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "json_schema"
      ]
    },
    {
      "title": "Extract Markdown",
      "description": "Convert PDF to Markdown format using pymupdf4llm.\n    pdf, markdown, convert\n\n    Use cases:\n    - Convert PDF documents to markdown format\n    - Preserve document structure in markdown\n    - Create editable markdown from PDFs",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractMarkdown",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Pdf",
          "description": "The PDF document to convert to markdown"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Tables",
      "description": "Extract tables from a PDF document using PyMuPDF.\n    pdf, tables, extract, structured\n\n    Use cases:\n    - Extract tabular data from PDFs\n    - Convert PDF tables to structured formats\n    - Analyze table layouts and content",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractTables",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Pdf",
          "description": "The PDF document to extract tables from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Text",
      "description": "Extract plain text from a PDF document using PyMuPDF.\n    pdf, text, extract\n\n    Use cases:\n    - Extract raw text content from PDFs\n    - Convert PDF documents to plain text\n    - Prepare text for further processing",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractText",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Pdf",
          "description": "The PDF document to extract text from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Text Blocks",
      "description": "Extract text blocks with their bounding boxes from a PDF.\n    pdf, text, blocks, layout\n\n    Use cases:\n    - Analyze text layout and structure\n    - Extract text while preserving block-level formatting\n    - Get text position information",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractTextBlocks",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Pdf",
          "description": "The PDF document to extract text blocks from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Text With Style",
      "description": "Extract text with style information (font, size, color) from a PDF.\n    pdf, text, style, formatting\n\n    Use cases:\n    - Preserve text formatting during extraction\n    - Analyze document styling\n    - Extract text with font information",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractTextWithStyle",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Pdf",
          "description": "The PDF document to extract styled text from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Format UUID",
      "description": "Format a UUID string in different representations.\n    uuid, format, convert, hex, urn, identifier\n\n    Use cases:\n    - Convert UUID to different formats\n    - Generate URN representations\n    - Format UUIDs for specific use cases",
      "namespace": "lib.uuid",
      "node_type": "lib.uuid.FormatUUID",
      "properties": [
        {
          "name": "uuid_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Uuid String",
          "description": "UUID string to format"
        },
        {
          "name": "format",
          "type": {
            "type": "enum",
            "values": [
              "standard",
              "hex",
              "urn",
              "int",
              "bytes_hex"
            ],
            "type_name": "nodetool.nodes.lib.uuid.UUIDFormat"
          },
          "default": "standard",
          "title": "Format",
          "description": "Output format (standard, hex, urn, int, bytes_hex)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "uuid_string",
        "format"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Generate UUID 1",
      "description": "Generate a time-based UUID (version 1).\n    uuid, time, identifier, unique, guid, timestamp\n\n    Use cases:\n    - Create sortable unique identifiers\n    - Generate time-ordered IDs\n    - Track creation timestamps in IDs",
      "namespace": "lib.uuid",
      "node_type": "lib.uuid.GenerateUUID1",
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "expose_as_tool": true
    },
    {
      "title": "Generate UUID 3",
      "description": "Generate a name-based UUID using MD5 (version 3).\n    uuid, name, identifier, unique, guid, md5, deterministic\n\n    Use cases:\n    - Create deterministic IDs from names\n    - Generate consistent identifiers for the same input\n    - Map names to unique identifiers",
      "namespace": "lib.uuid",
      "node_type": "lib.uuid.GenerateUUID3",
      "properties": [
        {
          "name": "namespace",
          "type": {
            "type": "str"
          },
          "default": "dns",
          "title": "Namespace",
          "description": "Namespace (dns, url, oid, x500, or a UUID string)"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "Name to generate UUID from"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "namespace",
        "name"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Generate UUID 4",
      "description": "Generate a random UUID (version 4).\n    uuid, random, identifier, unique, guid\n\n    Use cases:\n    - Create unique identifiers for records\n    - Generate session IDs\n    - Produce random unique keys",
      "namespace": "lib.uuid",
      "node_type": "lib.uuid.GenerateUUID4",
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "expose_as_tool": true
    },
    {
      "title": "Generate UUID 5",
      "description": "Generate a name-based UUID using SHA-1 (version 5).\n    uuid, name, identifier, unique, guid, sha1, deterministic\n\n    Use cases:\n    - Create deterministic IDs from names (preferred over UUID3)\n    - Generate consistent identifiers for the same input\n    - Map names to unique identifiers with better collision resistance",
      "namespace": "lib.uuid",
      "node_type": "lib.uuid.GenerateUUID5",
      "properties": [
        {
          "name": "namespace",
          "type": {
            "type": "str"
          },
          "default": "dns",
          "title": "Namespace",
          "description": "Namespace (dns, url, oid, x500, or a UUID string)"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "Name to generate UUID from"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "namespace",
        "name"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Is Valid UUID",
      "description": "Check if a string is a valid UUID.\n    uuid, validate, check, verify, identifier\n\n    Use cases:\n    - Validate user input\n    - Filter valid UUIDs from a dataset\n    - Conditional workflow based on UUID validity",
      "namespace": "lib.uuid",
      "node_type": "lib.uuid.IsValidUUID",
      "properties": [
        {
          "name": "uuid_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Uuid String",
          "description": "String to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "uuid_string"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Parse UUID",
      "description": "Parse and validate a UUID string.\n    uuid, parse, validate, check, identifier\n\n    Use cases:\n    - Validate UUID format\n    - Normalize UUID strings\n    - Extract UUID version information",
      "namespace": "lib.uuid",
      "node_type": "lib.uuid.ParseUUID",
      "properties": [
        {
          "name": "uuid_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Uuid String",
          "description": "UUID string to parse"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "uuid_string"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Encode Query Params",
      "description": "Encode a dictionary of parameters into a query string using\n    ``urllib.parse.urlencode``.\n    urllib, query, encode, params\n\n    Use cases:\n    - Build GET request URLs\n    - Serialize data for APIs\n    - Convert parameters to query strings",
      "namespace": "lib.urllib",
      "node_type": "lib.urllib.EncodeQueryParams",
      "properties": [
        {
          "name": "params",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "str"
              }
            ]
          },
          "default": null,
          "title": "Params",
          "description": "Parameters to encode"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "params"
      ]
    },
    {
      "title": "Join URL",
      "description": "Join a base URL with a relative URL using ``urllib.parse.urljoin``.\n    urllib, join, url\n\n    Use cases:\n    - Build absolute links from relative paths\n    - Combine API base with endpoints\n    - Resolve resources from a base URL",
      "namespace": "lib.urllib",
      "node_type": "lib.urllib.JoinURL",
      "properties": [
        {
          "name": "base",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base",
          "description": "Base URL"
        },
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "Relative or absolute URL"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "base",
        "url"
      ]
    },
    {
      "title": "Parse URL",
      "description": "Parse a URL into its components using ``urllib.parse.urlparse``.\n    urllib, parse, url\n\n    Use cases:\n    - Inspect links for validation\n    - Extract host or path information\n    - Analyze query parameters",
      "namespace": "lib.urllib",
      "node_type": "lib.urllib.ParseURL",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to parse"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "Quote URL",
      "description": "Percent-encode a string for safe use in URLs using ``urllib.parse.quote``.\n    urllib, quote, encode\n\n    Use cases:\n    - Escape spaces or special characters\n    - Prepare text for query parameters\n    - Encode file names in URLs",
      "namespace": "lib.urllib",
      "node_type": "lib.urllib.QuoteURL",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to quote"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ]
    },
    {
      "title": "Unquote URL",
      "description": "Decode a percent-encoded URL string using ``urllib.parse.unquote``.\n    urllib, unquote, decode\n\n    Use cases:\n    - Convert encoded URLs to readable form\n    - Parse user input from URLs\n    - Display unescaped paths",
      "namespace": "lib.urllib",
      "node_type": "lib.urllib.UnquoteURL",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Encoded text"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ]
    },
    {
      "title": "Index Array",
      "description": "Select specific indices from an array along a specified axis.\n    array, index, select, subset\n\n    Use cases:\n    - Extract specific samples from a dataset\n    - Select particular features or dimensions\n    - Implement batch sampling operations",
      "namespace": "lib.numpy.manipulation",
      "node_type": "lib.numpy.manipulation.IndexArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The input array to index"
        },
        {
          "name": "indices",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Indices",
          "description": "The comma separated indices to select"
        },
        {
          "name": "axis",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Axis",
          "description": "Axis along which to index"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "indices",
        "axis"
      ]
    },
    {
      "title": "Mat Mul",
      "description": "Perform matrix multiplication on two input arrays.\n    array, matrix, multiplication, linear algebra\n\n    Use cases:\n    - Implement linear transformations\n    - Calculate dot products of vectors\n    - Perform matrix operations in neural networks",
      "namespace": "lib.numpy.manipulation",
      "node_type": "lib.numpy.manipulation.MatMul",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "A",
          "description": "First input array"
        },
        {
          "name": "b",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "B",
          "description": "Second input array"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ]
    },
    {
      "title": "Slice Array",
      "description": "Extract a slice of an array along a specified axis.\n    array, slice, subset, index\n\n    Use cases:\n    - Extract specific time periods from time series data\n    - Select subset of features from datasets\n    - Create sliding windows over sequential data",
      "namespace": "lib.numpy.manipulation",
      "node_type": "lib.numpy.manipulation.SliceArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The input array to slice"
        },
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start",
          "description": "Starting index (inclusive)"
        },
        {
          "name": "stop",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Stop",
          "description": "Ending index (exclusive)"
        },
        {
          "name": "step",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Step",
          "description": "Step size between elements"
        },
        {
          "name": "axis",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Axis",
          "description": "Axis along which to slice"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "start",
        "stop",
        "step",
        "axis"
      ]
    },
    {
      "title": "Split Array",
      "description": "Split an array into multiple sub-arrays along a specified axis.\n    array, split, divide, partition\n\n    Use cases:\n    - Divide datasets into training/validation splits\n    - Create batches from large arrays\n    - Separate multi-channel data",
      "namespace": "lib.numpy.manipulation",
      "node_type": "lib.numpy.manipulation.SplitArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The input array to split"
        },
        {
          "name": "num_splits",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Splits",
          "description": "Number of equal splits to create"
        },
        {
          "name": "axis",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Axis",
          "description": "Axis along which to split"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "num_splits",
        "axis"
      ]
    },
    {
      "title": "Stack",
      "description": "Stack multiple arrays along a specified axis.\n    array, stack, concatenate, join, merge, axis\n\n    Use cases:\n    - Combine multiple 2D arrays into a 3D array\n    - Stack time series data from multiple sources\n    - Merge feature vectors for machine learning models",
      "namespace": "lib.numpy.manipulation",
      "node_type": "lib.numpy.manipulation.Stack",
      "properties": [
        {
          "name": "arrays",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "np_array"
              }
            ]
          },
          "default": [],
          "title": "Arrays",
          "description": "Arrays to stack"
        },
        {
          "name": "axis",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Axis",
          "description": "The axis to stack along.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "arrays",
        "axis"
      ]
    },
    {
      "title": "Transpose Array",
      "description": "Transpose the dimensions of the input array.\n    array, transpose, reshape, dimensions\n\n    Use cases:\n    - Convert row vectors to column vectors\n    - Rearrange data for compatibility with other operations\n    - Implement certain linear algebra operations",
      "namespace": "lib.numpy.manipulation",
      "node_type": "lib.numpy.manipulation.TransposeArray",
      "layout": "small",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Array to transpose"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Add Array",
      "description": "Performs addition on two arrays.\n    math, plus, add, addition, sum, +",
      "namespace": "lib.numpy.arithmetic",
      "node_type": "lib.numpy.arithmetic.AddArray",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ]
    },
    {
      "title": "Divide Array",
      "description": "Divides the first array by the second.\n    math, division, arithmetic, quotient, /",
      "namespace": "lib.numpy.arithmetic",
      "node_type": "lib.numpy.arithmetic.DivideArray",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ]
    },
    {
      "title": "Modulus Array",
      "description": "Calculates the element-wise remainder of division.\n    math, modulo, remainder, mod, %\n\n    Use cases:\n    - Implementing cyclic behaviors\n    - Checking for even/odd numbers\n    - Limiting values to a specific range",
      "namespace": "lib.numpy.arithmetic",
      "node_type": "lib.numpy.arithmetic.ModulusArray",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ]
    },
    {
      "title": "Multiply Array",
      "description": "Multiplies two arrays.\n    math, product, times, *",
      "namespace": "lib.numpy.arithmetic",
      "node_type": "lib.numpy.arithmetic.MultiplyArray",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ]
    },
    {
      "title": "Subtract Array",
      "description": "Subtracts the second array from the first.\n    math, minus, difference, -",
      "namespace": "lib.numpy.arithmetic",
      "node_type": "lib.numpy.arithmetic.SubtractArray",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ]
    },
    {
      "title": "Reshape 1 D",
      "description": "Reshape an array to a 1D shape without changing its data.\n    array, reshape, vector, flatten\n\n    Use cases:\n    - Flatten multi-dimensional data for certain algorithms\n    - Convert images to vector form for machine learning\n    - Prepare data for 1D operations",
      "namespace": "lib.numpy.reshaping",
      "node_type": "lib.numpy.reshaping.Reshape1D",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The input array to reshape"
        },
        {
          "name": "num_elements",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Elements",
          "description": "The number of elements"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "num_elements"
      ]
    },
    {
      "title": "Reshape 2 D",
      "description": "Reshape an array to a new shape without changing its data.\n    array, reshape, dimensions, structure\n\n    Use cases:\n    - Convert between different dimensional representations\n    - Prepare data for specific model architectures\n    - Flatten or unflatten arrays",
      "namespace": "lib.numpy.reshaping",
      "node_type": "lib.numpy.reshaping.Reshape2D",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The input array to reshape"
        },
        {
          "name": "num_rows",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Rows",
          "description": "The number of rows"
        },
        {
          "name": "num_cols",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Cols",
          "description": "The number of columns"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "num_rows",
        "num_cols"
      ]
    },
    {
      "title": "Reshape 3 D",
      "description": "Reshape an array to a 3D shape without changing its data.\n    array, reshape, dimensions, volume\n\n    Use cases:\n    - Convert data for 3D visualization\n    - Prepare image data with channels\n    - Structure data for 3D convolutions",
      "namespace": "lib.numpy.reshaping",
      "node_type": "lib.numpy.reshaping.Reshape3D",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The input array to reshape"
        },
        {
          "name": "num_rows",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Rows",
          "description": "The number of rows"
        },
        {
          "name": "num_cols",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Cols",
          "description": "The number of columns"
        },
        {
          "name": "num_depths",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Depths",
          "description": "The number of depths"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "num_rows",
        "num_cols",
        "num_depths"
      ]
    },
    {
      "title": "Reshape 4 D",
      "description": "Reshape an array to a 4D shape without changing its data.\n    array, reshape, dimensions, batch\n\n    Use cases:\n    - Prepare batch data for neural networks\n    - Structure spatiotemporal data\n    - Format data for 3D image processing with channels",
      "namespace": "lib.numpy.reshaping",
      "node_type": "lib.numpy.reshaping.Reshape4D",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The input array to reshape"
        },
        {
          "name": "num_rows",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Rows",
          "description": "The number of rows"
        },
        {
          "name": "num_cols",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Cols",
          "description": "The number of columns"
        },
        {
          "name": "num_depths",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Depths",
          "description": "The number of depths"
        },
        {
          "name": "num_channels",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Channels",
          "description": "The number of channels"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "num_rows",
        "num_cols",
        "num_depths",
        "num_channels"
      ]
    },
    {
      "title": "Save Array",
      "description": "Save a numpy array to a file in the specified folder.\n    array, save, file, storage\n\n    Use cases:\n    - Store processed arrays for later use\n    - Save analysis results\n    - Create checkpoints in processing pipelines",
      "namespace": "lib.numpy.io",
      "node_type": "lib.numpy.io.SaveArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The array to save."
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The folder to save the array in."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d_%H-%M-%S.npy",
          "title": "Name",
          "description": "\n        The name of the asset to save.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "folder",
        "name"
      ]
    },
    {
      "title": "Array To List",
      "description": "Convert a array to a nested list structure.\n    array, list, conversion, type\n\n    Use cases:\n    - Prepare array data for JSON serialization\n    - Convert array outputs to Python data structures\n    - Interface array data with non-array operations",
      "namespace": "lib.numpy.conversion",
      "node_type": "lib.numpy.conversion.ArrayToList",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Array to convert to list"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Array To Scalar",
      "description": "Convert a single-element array to a scalar value.\n    array, scalar, conversion, type\n\n    Use cases:\n    - Extract final results from array computations\n    - Prepare values for non-array operations\n    - Simplify output for human-readable results",
      "namespace": "lib.numpy.conversion",
      "node_type": "lib.numpy.conversion.ArrayToScalar",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Array to convert to scalar"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Convert To Array",
      "description": "Convert PIL Image to normalized tensor representation.\n    image, tensor, conversion, normalization\n\n    Use cases:\n    - Prepare images for machine learning models\n    - Convert between image formats for processing\n    - Normalize image data for consistent calculations",
      "namespace": "lib.numpy.conversion",
      "node_type": "lib.numpy.conversion.ConvertToArray",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The input image to convert to a tensor. The image should have either 1 (grayscale), 3 (RGB), or 4 (RGBA) channels."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Convert To Audio",
      "description": "Converts a array object back to an audio file.\n    audio, conversion, array\n\n    Use cases:\n    - Save processed audio data as a playable file\n    - Convert generated or modified audio arrays to audio format\n    - Output results of audio processing pipelinesr",
      "namespace": "lib.numpy.conversion",
      "node_type": "lib.numpy.conversion.ConvertToAudio",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The array to convert to an audio file."
        },
        {
          "name": "sample_rate",
          "type": {
            "type": "int"
          },
          "default": 44100,
          "title": "Sample Rate",
          "description": "The sample rate of the audio file.",
          "min": 0.0,
          "max": 44100.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "sample_rate"
      ]
    },
    {
      "title": "Convert To Image",
      "description": "Convert array data to PIL Image format.\n    array, image, conversion, denormalization\n\n    Use cases:\n    - Visualize array data as images\n    - Save processed array results as images\n    - Convert model outputs back to viewable format",
      "namespace": "lib.numpy.conversion",
      "node_type": "lib.numpy.conversion.ConvertToImage",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The input array to convert to an image. Should have either 1, 3, or 4 channels."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "List To Array",
      "description": "Convert a list of values to a array.\n    list, array, conversion, type\n\n    Use cases:\n    - Prepare list data for array operations\n    - Create arrays from Python data structures\n    - Convert sequence data to array format",
      "namespace": "lib.numpy.conversion",
      "node_type": "lib.numpy.conversion.ListToArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values",
          "description": "List of values to convert to array"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Scalar To Array",
      "description": "Convert a scalar value to a single-element array.\n    scalar, array, conversion, type\n\n    Use cases:\n    - Prepare scalar inputs for array operations\n    - Create constant arrays for computations\n    - Initialize array values in workflows",
      "namespace": "lib.numpy.conversion",
      "node_type": "lib.numpy.conversion.ScalarToArray",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "default": 0,
          "title": "Value",
          "description": "Scalar value to convert to array"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "Plot Array",
      "description": "Create a plot visualization of array data.\n    array, plot, visualization, graph\n\n    Use cases:\n    - Visualize trends in array data\n    - Create charts for reports or dashboards\n    - Debug array outputs in workflows",
      "namespace": "lib.numpy.visualization",
      "node_type": "lib.numpy.visualization.PlotArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Array to plot"
        },
        {
          "name": "plot_type",
          "type": {
            "type": "enum",
            "values": [
              "line",
              "bar",
              "scatter"
            ],
            "type_name": "nodetool.nodes.lib.numpy.visualization.PlotArray.PlotType"
          },
          "default": "line",
          "title": "Plot Type",
          "description": "Type of plot to create"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "plot_type"
      ]
    },
    {
      "title": "Binary Operation",
      "description": "",
      "namespace": "lib.numpy.utils",
      "node_type": "lib.numpy.utils.BinaryOperation",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ]
    },
    {
      "title": "Arg Max Array",
      "description": "Find indices of maximum values along a specified axis of a array.\n    array, argmax, index, maximum\n\n    Use cases:\n    - Determine winning classes in classification tasks\n    - Find peaks in signal processing\n    - Locate best-performing items in datasets",
      "namespace": "lib.numpy.statistics",
      "node_type": "lib.numpy.statistics.ArgMaxArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Input array"
        },
        {
          "name": "axis",
          "type": {
            "type": "int",
            "optional": true
          },
          "default": null,
          "title": "Axis",
          "description": "Axis along which to find maximum indices"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "np_array"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "axis"
      ]
    },
    {
      "title": "Arg Min Array",
      "description": "Find indices of minimum values along a specified axis of a array.\n    array, argmin, index, minimum\n\n    Use cases:\n    - Locate lowest-performing items in datasets\n    - Find troughs in signal processing\n    - Determine least likely classes in classification tasks",
      "namespace": "lib.numpy.statistics",
      "node_type": "lib.numpy.statistics.ArgMinArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Input array"
        },
        {
          "name": "axis",
          "type": {
            "type": "int",
            "optional": true
          },
          "default": null,
          "title": "Axis",
          "description": "Axis along which to find minimum indices"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "np_array"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "axis"
      ]
    },
    {
      "title": "Max Array",
      "description": "Compute the maximum value along a specified axis of a array.\n    array, maximum, reduction, statistics\n\n    Use cases:\n    - Find peak values in time series data\n    - Implement max pooling in neural networks\n    - Determine highest scores across multiple categories",
      "namespace": "lib.numpy.statistics",
      "node_type": "lib.numpy.statistics.MaxArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Input array"
        },
        {
          "name": "axis",
          "type": {
            "type": "int",
            "optional": true
          },
          "default": null,
          "title": "Axis",
          "description": "Axis along which to compute maximum"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "np_array"
              },
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "axis"
      ]
    },
    {
      "title": "Mean Array",
      "description": "Compute the mean value along a specified axis of a array.\n    array, average, reduction, statistics\n\n    Use cases:\n    - Calculate average values in datasets\n    - Implement mean pooling in neural networks\n    - Compute centroids in clustering algorithms",
      "namespace": "lib.numpy.statistics",
      "node_type": "lib.numpy.statistics.MeanArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Input array"
        },
        {
          "name": "axis",
          "type": {
            "type": "int",
            "optional": true
          },
          "default": null,
          "title": "Axis",
          "description": "Axis along which to compute mean"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "np_array"
              },
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "axis"
      ]
    },
    {
      "title": "Min Array",
      "description": "Calculate the minimum value along a specified axis of a array.\n    array, minimum, reduction, statistics\n\n    Use cases:\n    - Find lowest values in datasets\n    - Implement min pooling in neural networks\n    - Determine minimum thresholds across categories",
      "namespace": "lib.numpy.statistics",
      "node_type": "lib.numpy.statistics.MinArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Input array"
        },
        {
          "name": "axis",
          "type": {
            "type": "int",
            "optional": true
          },
          "default": null,
          "title": "Axis",
          "description": "Axis along which to compute minimum"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "np_array"
              },
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "axis"
      ]
    },
    {
      "title": "Sum Array",
      "description": "Calculate the sum of values along a specified axis of a array.\n    array, summation, reduction, statistics\n\n    Use cases:\n    - Compute total values across categories\n    - Implement sum pooling in neural networks\n    - Calculate cumulative metrics in time series data",
      "namespace": "lib.numpy.statistics",
      "node_type": "lib.numpy.statistics.SumArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Input array"
        },
        {
          "name": "axis",
          "type": {
            "type": "int",
            "optional": true
          },
          "default": null,
          "title": "Axis",
          "description": "Axis along which to compute sum"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "np_array"
              },
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "axis"
      ]
    },
    {
      "title": "Abs Array",
      "description": "Compute the absolute value of each element in a array.\n    array, absolute, magnitude\n\n    Use cases:\n    - Calculate magnitudes of complex numbers\n    - Preprocess data for certain algorithms\n    - Implement activation functions in neural networks",
      "namespace": "lib.numpy.math",
      "node_type": "lib.numpy.math.AbsArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The input array to compute the absolute values from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Cosine Array",
      "description": "Computes the cosine of input angles in radians.\n    math, trigonometry, cosine, cos\n\n    Use cases:\n    - Calculating horizontal components in physics\n    - Creating circular motions\n    - Phase calculations in signal processing",
      "namespace": "lib.numpy.math",
      "node_type": "lib.numpy.math.CosineArray",
      "layout": "small",
      "properties": [
        {
          "name": "angle_rad",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "Angle (Radians)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "angle_rad"
      ]
    },
    {
      "title": "Exp Array",
      "description": "Calculate the exponential of each element in a array.\n    array, exponential, math, activation\n\n    Use cases:\n    - Implement exponential activation functions\n    - Calculate growth rates in scientific models\n    - Transform data for certain statistical analyses",
      "namespace": "lib.numpy.math",
      "node_type": "lib.numpy.math.ExpArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Input array"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Log Array",
      "description": "Calculate the natural logarithm of each element in a array.\n    array, logarithm, math, transformation\n\n    Use cases:\n    - Implement log transformations on data\n    - Calculate entropy in information theory\n    - Normalize data with large ranges",
      "namespace": "lib.numpy.math",
      "node_type": "lib.numpy.math.LogArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Input array"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Power Array",
      "description": "Raises the base array to the power of the exponent element-wise.\n    math, exponentiation, power, pow, **\n\n    Use cases:\n    - Calculating compound interest\n    - Implementing polynomial functions\n    - Applying non-linear transformations to data",
      "namespace": "lib.numpy.math",
      "node_type": "lib.numpy.math.PowerArray",
      "layout": "small",
      "properties": [
        {
          "name": "base",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 1.0,
          "title": "Base"
        },
        {
          "name": "exponent",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 2.0,
          "title": "Exponent"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "base",
        "exponent"
      ]
    },
    {
      "title": "Sine Array",
      "description": "Computes the sine of input angles in radians.\n    math, trigonometry, sine, sin\n\n    Use cases:\n    - Calculating vertical components in physics\n    - Generating smooth periodic functions\n    - Audio signal processing",
      "namespace": "lib.numpy.math",
      "node_type": "lib.numpy.math.SineArray",
      "layout": "small",
      "properties": [
        {
          "name": "angle_rad",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "Angle (Radians)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "angle_rad"
      ]
    },
    {
      "title": "Sqrt Array",
      "description": "Calculates the square root of the input array element-wise.\n    math, square root, sqrt, \u221a\n\n    Use cases:\n    - Normalizing data\n    - Calculating distances in Euclidean space\n    - Finding intermediate values in binary search",
      "namespace": "lib.numpy.math",
      "node_type": "lib.numpy.math.SqrtArray",
      "layout": "small",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Input array"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Adaptive Contrast",
      "description": "Applies localized contrast enhancement using adaptive techniques.\n    image, contrast, enhance\n\n    Use cases:\n    - Improve visibility in images with varying lighting conditions\n    - Prepare images for improved feature detection in computer vision",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.AdaptiveContrast",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust the contrast for."
        },
        {
          "name": "clip_limit",
          "type": {
            "type": "float"
          },
          "default": 2.0,
          "title": "Clip Limit",
          "description": "Clip limit for adaptive contrast.",
          "min": 0.0,
          "max": 100.0
        },
        {
          "name": "grid_size",
          "type": {
            "type": "int"
          },
          "default": 8,
          "title": "Grid Size",
          "description": "Grid size for adaptive contrast.",
          "min": 1.0,
          "max": 64.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "clip_limit",
        "grid_size"
      ]
    },
    {
      "title": "Auto Contrast",
      "description": "Automatically adjusts image contrast for enhanced visual quality.\n    image, contrast, balance\n\n    Use cases:\n    - Enhance image clarity for better visual perception\n    - Pre-process images for computer vision tasks\n    - Improve photo aesthetics in editing workflows",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.AutoContrast",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust the contrast for."
        },
        {
          "name": "cutoff",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Cutoff",
          "description": "Represents the percentage of pixels to ignore at both the darkest and lightest ends of the histogram. A cutoff value of 5 means ignoring the darkest 5% and the lightest 5% of pixels, enhancing overall contrast by stretching the remaining pixel values across the full brightness range.",
          "min": 0.0,
          "max": 255.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "cutoff"
      ]
    },
    {
      "title": "Brightness",
      "description": "Adjusts overall image brightness to lighten or darken.\n    image, brightness, enhance\n\n    Use cases:\n    - Correct underexposed or overexposed photographs\n    - Enhance visibility of dark image regions\n    - Prepare images for consistent display across devices",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.Brightness",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust the brightness for."
        },
        {
          "name": "factor",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "default": 1.0,
          "title": "Factor",
          "description": "Factor to adjust the brightness. 1.0 means no change."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "factor"
      ]
    },
    {
      "title": "Color",
      "description": "Adjusts color intensity of an image.\n    image, color, enhance\n\n    Use cases:\n    - Enhance color vibrancy in photographs\n    - Correct color imbalances in digital images\n    - Prepare images for consistent brand color representation",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.Color",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust the brightness for."
        },
        {
          "name": "factor",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Factor",
          "description": "Factor to adjust the contrast. 1.0 means no change."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "factor"
      ]
    },
    {
      "title": "Contrast",
      "description": "Adjusts image contrast to modify light-dark differences.\n    image, contrast, enhance\n\n    Use cases:\n    - Enhance visibility of details in low-contrast images\n    - Prepare images for visual analysis or recognition tasks\n    - Create dramatic effects in artistic photography",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.Contrast",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust the brightness for."
        },
        {
          "name": "factor",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Factor",
          "description": "Factor to adjust the contrast. 1.0 means no change."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "factor"
      ]
    },
    {
      "title": "Detail",
      "description": "Enhances fine details in images.\n    image, detail, enhance\n\n    Use cases:\n    - Improve clarity of textural elements in photographs\n    - Enhance visibility of small features for analysis\n    - Prepare images for high-resolution display or printing",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.Detail",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to detail."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Edge Enhance",
      "description": "Enhances edge visibility by increasing contrast along boundaries.\n    image, edge, enhance\n\n    Use cases:\n    - Improve object boundary detection for computer vision\n    - Highlight structural elements in technical drawings\n    - Prepare images for feature extraction in image analysis",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.EdgeEnhance",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to edge enhance."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Equalize",
      "description": "Enhances image contrast by equalizing intensity distribution.\n    image, contrast, histogram\n\n    Use cases:\n    - Improve visibility in poorly lit images\n    - Enhance details for image analysis tasks\n    - Normalize image data for machine learning",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.Equalize",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to equalize."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Rank Filter",
      "description": "Applies rank-based filtering to enhance or smooth image features.\n    image, filter, enhance\n\n    Use cases:\n    - Reduce noise while preserving edges in images\n    - Enhance specific image features based on local intensity\n    - Pre-process images for improved segmentation results",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.RankFilter",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to rank filter."
        },
        {
          "name": "size",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "Size",
          "description": "Rank filter size.",
          "min": 1.0,
          "max": 512.0
        },
        {
          "name": "rank",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "Rank",
          "description": "Rank filter rank.",
          "min": 1.0,
          "max": 512.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "size",
        "rank"
      ]
    },
    {
      "title": "Sharpen",
      "description": "Enhances image detail by intensifying local pixel contrast.\n    image, sharpen, clarity\n\n    Use cases:\n    - Improve clarity of photographs for print or display\n    - Refine texture details in product photography\n    - Enhance readability of text in document images",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.Sharpen",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to sharpen."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Sharpness",
      "description": "Adjusts image sharpness to enhance or reduce detail clarity.\n    image, clarity, sharpness\n\n    Use cases:\n    - Enhance photo details for improved visual appeal\n    - Refine images for object detection tasks\n    - Correct slightly blurred images",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.Sharpness",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust the brightness for."
        },
        {
          "name": "factor",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Factor",
          "description": "Factor to adjust the contrast. 1.0 means no change."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "factor"
      ]
    },
    {
      "title": "Unsharp Mask",
      "description": "Sharpens images using the unsharp mask technique.\n    image, sharpen, enhance\n\n    Use cases:\n    - Enhance edge definition in photographs\n    - Improve perceived sharpness of digital artwork\n    - Prepare images for high-quality printing or display",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.UnsharpMask",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to unsharp mask."
        },
        {
          "name": "radius",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Radius",
          "description": "Unsharp mask radius.",
          "min": 0.0,
          "max": 512.0
        },
        {
          "name": "percent",
          "type": {
            "type": "int"
          },
          "default": 150,
          "title": "Percent",
          "description": "Unsharp mask percent.",
          "min": 0.0,
          "max": 1000.0
        },
        {
          "name": "threshold",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "Threshold",
          "description": "Unsharp mask threshold.",
          "min": 0.0,
          "max": 512.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "radius",
        "percent",
        "threshold"
      ]
    },
    {
      "title": "Blend",
      "description": "Blend two images with adjustable alpha mixing.\n    blend, mix, fade, transition\n\n    Use cases:\n    - Create smooth transitions between images\n    - Adjust opacity of overlays\n    - Combine multiple exposures or effects",
      "namespace": "lib.pillow.__init__",
      "node_type": "lib.pillow.__init__.Blend",
      "properties": [
        {
          "name": "image1",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image1",
          "description": "The first image to blend."
        },
        {
          "name": "image2",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image2",
          "description": "The second image to blend."
        },
        {
          "name": "alpha",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Alpha",
          "description": "The mix ratio.",
          "min": 0.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image1",
        "image2",
        "alpha"
      ]
    },
    {
      "title": "Composite",
      "description": "Combine two images using a mask for advanced compositing.\n    composite, mask, blend, layering\n\n    Use cases:\n    - Create complex image compositions\n    - Apply selective blending or effects\n    - Implement advanced photo editing techniques",
      "namespace": "lib.pillow.__init__",
      "node_type": "lib.pillow.__init__.Composite",
      "properties": [
        {
          "name": "image1",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image1",
          "description": "The first image to composite."
        },
        {
          "name": "image2",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image2",
          "description": "The second image to composite."
        },
        {
          "name": "mask",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Mask",
          "description": "The mask to composite with."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image1",
        "image2",
        "mask"
      ]
    },
    {
      "title": "Blur",
      "description": "Apply a Gaussian blur effect to an image.\n    image, filter, blur\n\n    - Soften images or reduce noise and detail\n    - Make focal areas stand out by blurring surroundings\n    - Protect privacy by blurring sensitive information",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.Blur",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to blur."
        },
        {
          "name": "radius",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Radius",
          "description": "Blur radius.",
          "min": 0.0,
          "max": 128.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "radius"
      ]
    },
    {
      "title": "Canny",
      "description": "Apply Canny edge detection to an image.\n    image, filter, edges\n\n    - Highlight areas of rapid intensity change\n    - Outline object boundaries and structure\n    - Enhance inputs for object detection and image segmentation",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.Canny",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to canny."
        },
        {
          "name": "low_threshold",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Low Threshold",
          "description": "Low threshold.",
          "min": 0.0,
          "max": 255.0
        },
        {
          "name": "high_threshold",
          "type": {
            "type": "int"
          },
          "default": 200,
          "title": "High Threshold",
          "description": "High threshold.",
          "min": 0.0,
          "max": 255.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "low_threshold",
        "high_threshold"
      ]
    },
    {
      "title": "Contour",
      "description": "Apply a contour filter to highlight image edges.\n    image, filter, contour\n\n    - Extract key features from complex images\n    - Aid pattern recognition and object detection\n    - Create stylized contour sketch art effects",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.Contour",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to contour."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Convert To Grayscale",
      "description": "Convert an image to grayscale.\n    image, grayscale\n\n    - Simplify images for feature and edge detection\n    - Prepare images for shape-based machine learning\n    - Create vintage or monochrome aesthetic effects",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.ConvertToGrayscale",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to convert."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Emboss",
      "description": "Apply an emboss filter for a 3D raised effect.\n    image, filter, emboss\n\n    - Add texture and depth to photos\n    - Create visually interesting graphics\n    - Incorporate unique effects in digital artwork",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.Emboss",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to emboss."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Expand",
      "description": "Add a border around an image to increase its size.\n    image, border, expand\n\n    - Make images stand out by adding a colored border\n    - Create framed photo effects\n    - Separate image content from surroundings",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.Expand",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to expand."
        },
        {
          "name": "border",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Border",
          "description": "Border size.",
          "min": 0.0,
          "max": 512.0
        },
        {
          "name": "fill",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Fill",
          "description": "Fill color.",
          "min": 0.0,
          "max": 255.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "border",
        "fill"
      ]
    },
    {
      "title": "Find Edges",
      "description": "Detect and highlight edges in an image.\n    image, filter, edges\n\n    - Analyze structural patterns in images\n    - Aid object detection in computer vision\n    - Detect important features like corners and ridges",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.FindEdges",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to find edges."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Get Channel",
      "description": "Extract a specific color channel from an image.\n    image, color, channel, isolate, extract\n\n    - Isolate color information for image analysis\n    - Manipulate specific color components in graphic design\n    - Enhance or reduce visibility of certain colors",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.GetChannel",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to get the channel from."
        },
        {
          "name": "channel",
          "type": {
            "type": "enum",
            "values": [
              "R",
              "G",
              "B"
            ],
            "type_name": "nodetool.nodes.lib.pillow.filter.GetChannel.ChannelEnum"
          },
          "default": "R",
          "title": "Channel"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "channel"
      ]
    },
    {
      "title": "Invert",
      "description": "Invert the colors of an image.\n    image, filter, invert\n\n    - Create negative versions of images for visual effects\n    - Analyze image data by bringing out hidden details\n    - Preprocess images for operations that work better on inverted colors",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.Invert",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust the brightness for."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Posterize",
      "description": "Reduce the number of colors in an image for a poster-like effect.\n    image, filter, posterize\n\n    - Create graphic art by simplifying image colors\n    - Apply artistic effects to photographs\n    - Generate visually compelling content for advertising",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.Posterize",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to posterize."
        },
        {
          "name": "bits",
          "type": {
            "type": "int"
          },
          "default": 4,
          "title": "Bits",
          "description": "Number of bits to posterize to.",
          "min": 1.0,
          "max": 8.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "bits"
      ]
    },
    {
      "title": "Smooth",
      "description": "Apply smoothing to reduce image noise and detail.\n    image, filter, smooth\n\n    - Enhance visual aesthetics of images\n    - Improve object detection by reducing irrelevant details\n    - Aid facial recognition by simplifying images",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.Smooth",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to smooth."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Solarize",
      "description": "Apply a solarize effect to partially invert image tones.\n    image, filter, solarize\n\n    - Create surreal artistic photo effects\n    - Enhance visual data by making certain elements more prominent\n    - Add a unique style to images for graphic design",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.Solarize",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to solarize."
        },
        {
          "name": "threshold",
          "type": {
            "type": "int"
          },
          "default": 128,
          "title": "Threshold",
          "description": "Threshold for solarization.",
          "min": 0.0,
          "max": 255.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "threshold"
      ]
    },
    {
      "title": "Background",
      "description": "The Background Node creates a blank background.\n    image, background, blank, base, layer\n    This node is mainly used for generating a base layer for image processing tasks. It produces a uniform image, having a user-specified width, height and color. The color is given in a hexadecimal format, defaulting to white if not specified.\n\n    #### Applications\n    - As a base layer for creating composite images.\n    - As a starting point for generating patterns or graphics.\n    - When blank backgrounds of specific colors are required for visualization tasks.",
      "namespace": "lib.pillow.draw",
      "node_type": "lib.pillow.draw.Background",
      "properties": [
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Width",
          "min": 1.0,
          "max": 4096.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Height",
          "min": 1.0,
          "max": 4096.0
        },
        {
          "name": "color",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#FFFFFF"
          },
          "title": "Color"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "width",
        "height",
        "color"
      ]
    },
    {
      "title": "Gaussian Noise",
      "description": "This node creates and adds Gaussian noise to an image.\n    image, noise, gaussian, distortion, artifact\n\n    The Gaussian Noise Node is designed to simulate realistic distortions that can occur in a photographic image. It generates a noise-filled image using the Gaussian (normal) distribution. The noise level can be adjusted using the mean and standard deviation parameters.\n\n    #### Applications\n    - Simulating sensor noise in synthetic data.\n    - Testing image-processing algorithms' resilience to noise.\n    - Creating artistic effects in images.",
      "namespace": "lib.pillow.draw",
      "node_type": "lib.pillow.draw.GaussianNoise",
      "properties": [
        {
          "name": "mean",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Mean"
        },
        {
          "name": "stddev",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Stddev"
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Width",
          "min": 1.0,
          "max": 1024.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Height",
          "min": 1.0,
          "max": 1024.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "mean",
        "stddev",
        "width",
        "height"
      ]
    },
    {
      "title": "Render Text",
      "description": "This node allows you to add text to images.\n    text, font, label, title, watermark, caption, image, overlay\n    This node takes text, font updates, coordinates (where to place the text), and an image to work with. A user can use the Render Text Node to add a label or title to an image, watermark an image, or place a caption directly on an image.\n\n    The Render Text Node offers customizable options, including the ability to choose the text's font, size, color, and alignment (left, center, or right). Text placement can also be defined, providing flexibility to place the text wherever you see fit.\n\n    #### Applications\n    - Labeling images in a image gallery or database.\n    - Watermarking images for copyright protection.\n    - Adding custom captions to photographs.\n    - Creating instructional images to guide the reader's view.",
      "namespace": "lib.pillow.draw",
      "node_type": "lib.pillow.draw.RenderText",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to render."
        },
        {
          "name": "font",
          "type": {
            "type": "font"
          },
          "default": {
            "type": "font",
            "name": "DejaVuSans"
          },
          "title": "Font",
          "description": "The font to use."
        },
        {
          "name": "x",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "X",
          "description": "The x coordinate.",
          "min": 0.0
        },
        {
          "name": "y",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Y",
          "description": "The y coordinate.",
          "min": 0.0
        },
        {
          "name": "size",
          "type": {
            "type": "int"
          },
          "default": 12,
          "title": "Size",
          "description": "The font size.",
          "min": 1.0,
          "max": 512.0
        },
        {
          "name": "color",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Color",
          "description": "The font color."
        },
        {
          "name": "align",
          "type": {
            "type": "enum",
            "values": [
              "left",
              "center",
              "right"
            ],
            "type_name": "nodetool.nodes.lib.pillow.draw.RenderText.TextAlignment"
          },
          "default": "left",
          "title": "Align"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to render on."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "font",
        "x",
        "y",
        "size",
        "color",
        "align",
        "image"
      ]
    },
    {
      "title": "List Scheduled Events",
      "description": "Fetch scheduled events for a Calendly user.",
      "namespace": "calendly.events",
      "node_type": "calendly.events.ListScheduledEvents",
      "properties": [
        {
          "name": "user",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "User",
          "description": "User URI to fetch events for"
        },
        {
          "name": "count",
          "type": {
            "type": "int"
          },
          "default": 20,
          "title": "Count",
          "description": "Number of events to return",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "status",
          "type": {
            "type": "str"
          },
          "default": "active",
          "title": "Status",
          "description": "Event status filter"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "calendly_event"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "user",
        "count",
        "status"
      ]
    },
    {
      "title": "Scheduled Event Fields",
      "description": "Extract fields from a CalendlyEvent.",
      "namespace": "calendly.events",
      "node_type": "calendly.events.ScheduledEventFields",
      "properties": [
        {
          "name": "event",
          "type": {
            "type": "calendly_event"
          },
          "default": {
            "type": "calendly_event",
            "uri": "",
            "name": "",
            "start_time": {
              "type": "datetime",
              "year": 0,
              "month": 0,
              "day": 0,
              "hour": 0,
              "minute": 0,
              "second": 0,
              "microsecond": 0,
              "tzinfo": "UTC",
              "utc_offset": 0
            },
            "end_time": {
              "type": "datetime",
              "year": 0,
              "month": 0,
              "day": 0,
              "hour": 0,
              "minute": 0,
              "second": 0,
              "microsecond": 0,
              "tzinfo": "UTC",
              "utc_offset": 0
            },
            "location": ""
          },
          "title": "Event",
          "description": "The Calendly event to extract"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "uri"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "start_time"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "end_time"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "location"
        }
      ],
      "basic_fields": [
        "event"
      ]
    },
    {
      "title": "Add Vectors",
      "description": "Add vectors to a FAISS index.\n    faiss, add, vectors",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.AddVectors",
      "properties": [
        {
          "name": "index",
          "type": {
            "type": "faiss_index"
          },
          "default": {
            "type": "faiss_index",
            "index": null
          },
          "title": "Index",
          "description": "FAISS index"
        },
        {
          "name": "vectors",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Vectors",
          "description": "Vectors to add (n, d)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "faiss_index"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "index",
        "vectors"
      ]
    },
    {
      "title": "Add With Ids",
      "description": "Add vectors with explicit integer IDs to a FAISS index.\n    faiss, add, ids, vectors",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.AddWithIds",
      "properties": [
        {
          "name": "index",
          "type": {
            "type": "faiss_index"
          },
          "default": {
            "type": "faiss_index",
            "index": null
          },
          "title": "Index",
          "description": "FAISS index"
        },
        {
          "name": "vectors",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Vectors",
          "description": "Vectors to add (n, d)"
        },
        {
          "name": "ids",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Ids",
          "description": "1-D int64 IDs (n,)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "faiss_index"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "index",
        "vectors",
        "ids"
      ]
    },
    {
      "title": "Create Index Flat IP",
      "description": "Create a FAISS IndexFlatIP (inner product / cosine with normalized vectors).\n    faiss, index, ip, create",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.CreateIndexFlatIP",
      "properties": [
        {
          "name": "dim",
          "type": {
            "type": "int"
          },
          "default": 768,
          "title": "Dim",
          "description": "Embedding dimensionality",
          "min": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "faiss_index"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dim"
      ]
    },
    {
      "title": "Create Index Flat L 2",
      "description": "Create a FAISS IndexFlatL2.\n    faiss, index, l2, create",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.CreateIndexFlatL2",
      "properties": [
        {
          "name": "dim",
          "type": {
            "type": "int"
          },
          "default": 768,
          "title": "Dim",
          "description": "Embedding dimensionality",
          "min": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "faiss_index"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dim"
      ]
    },
    {
      "title": "Create Index IVFFlat",
      "description": "Create a FAISS IndexIVFFlat (inverted file index with flat quantizer).\n    faiss, index, ivf, create",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.CreateIndexIVFFlat",
      "properties": [
        {
          "name": "dim",
          "type": {
            "type": "int"
          },
          "default": 768,
          "title": "Dim",
          "description": "Embedding dimensionality",
          "min": 1.0
        },
        {
          "name": "nlist",
          "type": {
            "type": "int"
          },
          "default": 1024,
          "title": "Nlist",
          "description": "Number of Voronoi cells",
          "min": 1.0
        },
        {
          "name": "metric",
          "type": {
            "type": "enum",
            "values": [
              "L2",
              "IP"
            ],
            "type_name": "nodetool.nodes.vector.faiss.Metric"
          },
          "default": "L2",
          "title": "Metric",
          "description": "Distance metric"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "faiss_index"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dim",
        "nlist",
        "metric"
      ]
    },
    {
      "title": "Search",
      "description": "Search a FAISS index with query vectors, returning distances and indices.\n    faiss, search, query, knn",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.Search",
      "properties": [
        {
          "name": "index",
          "type": {
            "type": "faiss_index"
          },
          "default": {
            "type": "faiss_index",
            "index": null
          },
          "title": "Index",
          "description": "FAISS index"
        },
        {
          "name": "query",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Query",
          "description": "Query vectors (m, d) or (d,)"
        },
        {
          "name": "k",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "K",
          "description": "Number of nearest neighbors",
          "min": 1.0
        },
        {
          "name": "nprobe",
          "type": {
            "type": "int",
            "optional": true
          },
          "default": null,
          "title": "Nprobe",
          "description": "nprobe for IVF indices"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "distances"
        },
        {
          "type": {
            "type": "np_array"
          },
          "name": "indices"
        }
      ],
      "basic_fields": [
        "index",
        "query",
        "k",
        "nprobe"
      ]
    },
    {
      "title": "Train Index",
      "description": "Train a FAISS index with training vectors (required for IVF indices).\n    faiss, train, index",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.TrainIndex",
      "properties": [
        {
          "name": "index",
          "type": {
            "type": "faiss_index"
          },
          "default": {
            "type": "faiss_index",
            "index": null
          },
          "title": "Index",
          "description": "FAISS index"
        },
        {
          "name": "vectors",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Vectors",
          "description": "Training vectors (n, d)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "faiss_index"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "index",
        "vectors"
      ]
    },
    {
      "title": "Collection",
      "description": "Get or create a collection.\n    vector, embedding, collection, RAG, get, create, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.Collection",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The name of the collection to create"
        },
        {
          "name": "embedding_model",
          "type": {
            "type": "llama_model"
          },
          "default": {
            "type": "llama_model",
            "name": "",
            "repo_id": "",
            "modified_at": "",
            "size": 0,
            "digest": "",
            "details": {}
          },
          "title": "Embedding Model",
          "description": "Model to use for embedding, search for nomic-embed-text and download it"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "collection"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "embedding_model"
      ]
    },
    {
      "title": "Count",
      "description": "Count the number of documents in a collection.\n    vector, embedding, collection, RAG, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.Count",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to count"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "collection"
      ]
    },
    {
      "title": "Get Documents",
      "description": "Get documents from a chroma collection.\n    vector, embedding, collection, RAG, retrieve, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.GetDocuments",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to get"
        },
        {
          "name": "ids",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Ids",
          "description": "The ids of the documents to get"
        },
        {
          "name": "limit",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Limit",
          "description": "The limit of the documents to get"
        },
        {
          "name": "offset",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Offset",
          "description": "The offset of the documents to get"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "collection",
        "ids",
        "limit",
        "offset"
      ]
    },
    {
      "title": "Hybrid Search",
      "description": "Hybrid search combining semantic and keyword-based search for better retrieval. Uses reciprocal rank fusion to combine results from both methods.\n    vector, RAG, query, semantic, text, similarity, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.HybridSearch",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to query"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to query"
        },
        {
          "name": "n_results",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "N Results",
          "description": "The number of final results to return"
        },
        {
          "name": "k_constant",
          "type": {
            "type": "float"
          },
          "default": 60.0,
          "title": "K Constant",
          "description": "Constant for reciprocal rank fusion (default: 60.0)"
        },
        {
          "name": "min_keyword_length",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "Min Keyword Length",
          "description": "Minimum length for keyword tokens"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "ids"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "metadatas"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "distances"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "scores"
        }
      ],
      "basic_fields": [
        "collection",
        "text",
        "n_results",
        "k_constant",
        "min_keyword_length"
      ]
    },
    {
      "title": "Index Aggregated Text",
      "description": "Index multiple text chunks at once with aggregated embeddings from Ollama.\n    vector, embedding, collection, RAG, index, text, chunk, batch, ollama, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.IndexAggregatedText",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "document",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document",
          "description": "The document to index"
        },
        {
          "name": "document_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document Id",
          "description": "The document ID to associate with the text"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the text"
        },
        {
          "name": "text_chunks",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "union",
                "type_args": [
                  {
                    "type": "text_chunk"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Text Chunks",
          "description": "List of text chunks to index"
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window",
          "description": "The context window size to use for the model",
          "min": 1.0
        },
        {
          "name": "aggregation",
          "type": {
            "type": "enum",
            "values": [
              "mean",
              "max",
              "min",
              "sum"
            ],
            "type_name": "nodetool.nodes.vector.chroma.EmbeddingAggregation"
          },
          "default": "mean",
          "title": "Aggregation",
          "description": "The aggregation method to use for the embeddings."
        }
      ],
      "basic_fields": [
        "collection",
        "document",
        "document_id",
        "metadata",
        "text_chunks",
        "context_window",
        "aggregation"
      ]
    },
    {
      "title": "Index Embedding",
      "description": "Index a single embedding vector into a Chroma collection with optional metadata. Creates a searchable entry that can be queried for similarity matching.\n    vector, index, embedding, chroma, storage, RAG",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.IndexEmbedding",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "embedding",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Embedding",
          "description": "The embedding to index"
        },
        {
          "name": "index_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Index Id",
          "description": "The ID to associate with the embedding"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the embedding"
        }
      ],
      "basic_fields": [
        "collection",
        "embedding",
        "index_id",
        "metadata"
      ]
    },
    {
      "title": "Index Image",
      "description": "Index a list of image assets or files.\n    vector, embedding, collection, RAG, index, image, batch, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.IndexImage",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": [],
          "title": "Image",
          "description": "List of image assets to index"
        },
        {
          "name": "index_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Index Id",
          "description": "The ID to associate with the image, defaults to the URI of the image"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the image"
        },
        {
          "name": "upsert",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Upsert",
          "description": "Whether to upsert the images"
        }
      ],
      "basic_fields": [
        "collection",
        "image",
        "index_id",
        "metadata",
        "upsert"
      ]
    },
    {
      "title": "Index String",
      "description": "Index a string with a Document ID to a collection.\n    vector, embedding, collection, RAG, index, text, string, chroma\n\n    Use cases:\n    - Index documents for a vector search",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.IndexString",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text content to index"
        },
        {
          "name": "document_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document Id",
          "description": "Document ID to associate with the text content"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the text"
        }
      ],
      "basic_fields": [
        "collection",
        "text",
        "document_id",
        "metadata"
      ]
    },
    {
      "title": "Index Text Chunk",
      "description": "Index a single text chunk.\n    vector, embedding, collection, RAG, index, text, chunk, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.IndexTextChunk",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "document_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document Id",
          "description": "The document ID to associate with the text chunk"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to index"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the text chunk"
        }
      ],
      "basic_fields": [
        "collection",
        "document_id",
        "text",
        "metadata"
      ]
    },
    {
      "title": "Peek",
      "description": "Peek at the documents in a collection.\n    vector, embedding, collection, RAG, preview, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.Peek",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to peek"
        },
        {
          "name": "limit",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Limit",
          "description": "The limit of the documents to peek"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "collection",
        "limit"
      ]
    },
    {
      "title": "Query Image",
      "description": "Query the index for similar images.\n    vector, RAG, query, image, search, similarity, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.QueryImage",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to query"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to query"
        },
        {
          "name": "n_results",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "N Results",
          "description": "The number of results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "ids"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "metadatas"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "distances"
        }
      ],
      "basic_fields": [
        "collection",
        "image",
        "n_results"
      ]
    },
    {
      "title": "Query Text",
      "description": "Query the index for similar text.\n    vector, RAG, query, text, search, similarity, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.QueryText",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to query"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to query"
        },
        {
          "name": "n_results",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "N Results",
          "description": "The number of results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "ids"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "metadatas"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "distances"
        }
      ],
      "basic_fields": [
        "collection",
        "text",
        "n_results"
      ]
    },
    {
      "title": "Remove Overlap",
      "description": "Removes overlapping words between consecutive strings in a list. Splits text into words and matches word sequences for more accurate overlap detection.\n    vector, RAG, query, text, processing, overlap, deduplication",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.RemoveOverlap",
      "properties": [
        {
          "name": "documents",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Documents",
          "description": "List of strings to process for overlap removal"
        },
        {
          "name": "min_overlap_words",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Min Overlap Words",
          "description": "Minimum number of words that must overlap to be considered"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        }
      ],
      "basic_fields": [
        "documents",
        "min_overlap_words"
      ]
    },
    {
      "title": "Realtime Agent",
      "description": "Stream responses using the official OpenAI Realtime client. Supports optional audio input and streams text chunks.\n    realtime, streaming, openai, audio-input, text-output\n\n    Uses `AsyncOpenAI().beta.realtime.connect(...)` with the events API:\n    - Sends session settings via `session.update`\n    - Adds user input via `conversation.item.create`\n    - Streams back `response.text.delta` events until `response.done`",
      "namespace": "openai.agents",
      "node_type": "openai.agents.RealtimeAgent",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gpt-4o-realtime-preview",
              "gpt-4o-mini-realtime-preview"
            ],
            "type_name": "nodetool.nodes.openai.agents.RealtimeAgent.Model"
          },
          "default": "gpt-4o-mini-realtime-preview",
          "title": "Model"
        },
        {
          "name": "system",
          "type": {
            "type": "str"
          },
          "default": "\nYou are an AI assistant interacting in real-time. Follow these rules unless explicitly overridden by the user:\n\n1. Respond promptly \u2014 minimize delay. If you do not yet have a complete answer, acknowledge the question and indicate what you are doing to find the answer.\n2. Maintain correctness. Always aim for accuracy; if you\u2019re uncertain, say so and optionally offer to verify.\n3. Be concise but clear. Prioritize key information first, then supporting details if helpful.\n4. Ask clarifying questions when needed. If the user\u2019s request is ambiguous, request clarification rather than guessing.\n5. Be consistent in terminology and definitions. Once you adopt a term or abbreviation, use it consistently in this conversation.\n6. Respect politeness and neutrality. Do not use emotive language unless the conversation tone demands it.\n7. Stay within safe and ethical bounds. Avoid disallowed content; follow OpenAI policies.\n8. Adapt to the user\u2019s style and level. If the user seems technical, use technical detail; if non-technical, explain with simpler language.\n---\nYou are now active. Await the user\u2019s request.\n",
          "title": "System",
          "description": "System instructions for the realtime session"
        },
        {
          "name": "chunk",
          "type": {
            "type": "chunk"
          },
          "default": {
            "type": "chunk",
            "node_id": null,
            "content_type": "text",
            "content": "",
            "content_metadata": {},
            "done": false
          },
          "title": "Chunk",
          "description": "The audio chunk to use as input."
        },
        {
          "name": "voice",
          "type": {
            "type": "enum",
            "values": [
              "none",
              "ash",
              "alloy",
              "ballad",
              "coral",
              "echo",
              "fable",
              "onyx",
              "nova",
              "shimmer",
              "sage",
              "verse"
            ],
            "type_name": "nodetool.nodes.openai.agents.RealtimeAgent.Voice"
          },
          "default": "alloy",
          "title": "Voice",
          "description": "The voice for the audio output"
        },
        {
          "name": "speed",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Speed",
          "description": "The speed of the model's spoken response",
          "min": 0.25,
          "max": 1.5
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 0.8,
          "title": "Temperature",
          "description": "The temperature for the response",
          "min": 0.6,
          "max": 1.2
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        },
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        }
      ],
      "basic_fields": [
        "model",
        "prompt",
        "chunk",
        "speed"
      ],
      "is_streaming_output": true,
      "supports_dynamic_outputs": true
    },
    {
      "title": "Realtime Transcription",
      "description": "Stream microphone or audio input to OpenAI Realtime and emit transcription.\n\n    Emits:\n      - `chunk` Chunk(content=..., done=False) for transcript deltas\n      - `chunk` Chunk(content=\"\", done=True) to mark segment end\n      - `text` final aggregated transcript when input ends",
      "namespace": "openai.agents",
      "node_type": "openai.agents.RealtimeTranscription",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": ""
          },
          "title": "Model",
          "description": "Model to use"
        },
        {
          "name": "system",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "System",
          "description": "System instructions (optional)"
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 0.8,
          "title": "Temperature",
          "description": "Decoding temperature"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        }
      ],
      "basic_fields": [
        "model",
        "system",
        "temperature"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Embedding",
      "description": "Generate vector representations of text for semantic analysis.\n    embeddings, similarity, search, clustering, classification\n\n    Uses OpenAI's embedding models to create dense vector representations of text.\n    These vectors capture semantic meaning, enabling:\n    - Semantic search\n    - Text clustering\n    - Document classification\n    - Recommendation systems\n    - Anomaly detection\n    - Measuring text similarity and diversity",
      "namespace": "openai.text",
      "node_type": "openai.text.Embedding",
      "properties": [
        {
          "name": "input",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Input"
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "text-embedding-3-large",
              "text-embedding-3-small"
            ],
            "type_name": "nodetool.nodes.openai.text.Embedding.EmbeddingModel"
          },
          "default": "text-embedding-3-small",
          "title": "Model"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Chunk Size"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input",
        "model",
        "chunk_size"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Web Search",
      "description": "\ud83d\udd0d OpenAI Web Search - Searches the web using OpenAI's web search capabilities.\n\n    This node uses an OpenAI model equipped with web search functionality\n    (like gpt-4o with search preview) to answer queries based on current web information.\n    Requires an OpenAI API key.",
      "namespace": "openai.text",
      "node_type": "openai.text.WebSearch",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "The search query to execute."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "query"
      ]
    },
    {
      "title": "Text To Speech",
      "description": "Converts text to speech using OpenAI TTS models.\n    audio, tts, text-to-speech, voice, synthesis\n\n    Use cases:\n    - Generate spoken content for videos or podcasts\n    - Create voice-overs for presentations\n    - Assist visually impaired users with text reading\n    - Produce audio versions of written content",
      "namespace": "openai.audio",
      "node_type": "openai.audio.TextToSpeech",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "tts-1",
              "tts-1-hd",
              "gpt-4o-mini-tts"
            ],
            "type_name": "nodetool.nodes.openai.audio.TextToSpeech.TtsModel"
          },
          "default": "tts-1",
          "title": "Model"
        },
        {
          "name": "voice",
          "type": {
            "type": "enum",
            "values": [
              "alloy",
              "ash",
              "ballad",
              "coral",
              "echo",
              "fable",
              "onyx",
              "nova",
              "sage",
              "shimmer",
              "verse"
            ],
            "type_name": "nodetool.nodes.openai.audio.TextToSpeech.Voice"
          },
          "default": "alloy",
          "title": "Voice"
        },
        {
          "name": "input",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Input"
        },
        {
          "name": "speed",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Speed",
          "min": 0.25,
          "max": 4.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input",
        "model",
        "voice"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Transcribe",
      "description": "Converts speech to text using OpenAI's speech-to-text API.\n    audio, transcription, speech-to-text, stt, whisper\n\n    Use cases:\n    - Generate accurate transcriptions of audio content\n    - Create searchable text from audio recordings\n    - Support multiple languages for transcription\n    - Enable automated subtitling and captioning",
      "namespace": "openai.audio",
      "node_type": "openai.audio.Transcribe",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "whisper-1",
              "gpt-4o-transcribe",
              "gpt-4o-mini-transcribe"
            ],
            "type_name": "nodetool.nodes.openai.audio.Transcribe.TranscriptionModel"
          },
          "default": "whisper-1",
          "title": "Model",
          "description": "The model to use for transcription."
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to transcribe (max 25 MB)."
        },
        {
          "name": "language",
          "type": {
            "type": "enum",
            "values": [
              "auto_detect",
              "spanish",
              "italian",
              "korean",
              "portuguese",
              "english",
              "japanese",
              "german",
              "russian",
              "dutch",
              "polish",
              "catalan",
              "french",
              "indonesian",
              "ukrainian",
              "turkish",
              "malay",
              "swedish",
              "mandarin",
              "finnish",
              "norwegian",
              "romanian",
              "thai",
              "vietnamese",
              "slovak",
              "arabic",
              "czech",
              "croatian",
              "greek",
              "serbian",
              "danish",
              "bulgarian",
              "hungarian",
              "filipino",
              "bosnian",
              "galician",
              "macedonian",
              "hindi",
              "estonian",
              "slovenian",
              "tamil",
              "latvian",
              "azerbaijani",
              "urdu",
              "lithuanian",
              "hebrew",
              "welsh",
              "persian",
              "icelandic",
              "kazakh",
              "afrikaans",
              "kannada",
              "marathi",
              "swahili",
              "telugu",
              "maori",
              "nepali",
              "armenian",
              "belarusian",
              "gujarati",
              "punjabi",
              "bengali"
            ],
            "type_name": "nodetool.nodes.openai.audio.Transcribe.Language"
          },
          "default": "auto_detect",
          "title": "Language",
          "description": "The language of the input audio"
        },
        {
          "name": "timestamps",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Timestamps",
          "description": "Whether to return timestamps for the generated text."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text to guide the model's style or continue a previous audio segment."
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Temperature",
          "description": "The sampling temperature between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.",
          "min": 0.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "audio_chunk"
              }
            ]
          },
          "name": "words"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "audio_chunk"
              }
            ]
          },
          "name": "segments"
        }
      ],
      "basic_fields": [
        "audio",
        "language",
        "timestamps"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Translate",
      "description": "Translates speech in audio to English text.\n    audio, translation, speech-to-text, localization\n\n    Use cases:\n    - Translate foreign language audio content to English\n    - Create English transcripts of multilingual recordings\n    - Assist non-English speakers in understanding audio content\n    - Enable cross-language communication in audio formats",
      "namespace": "openai.audio",
      "node_type": "openai.audio.Translate",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to translate."
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Temperature",
          "description": "The temperature to use for the translation."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "temperature"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Create Image",
      "description": "Generates images from textual descriptions.\n    image, t2i, tti, text-to-image, create, generate, picture, photo, art, drawing, illustration\n\n    Use cases:\n    1. Create custom illustrations for articles or presentations\n    2. Generate concept art for creative projects\n    3. Produce visual aids for educational content\n    4. Design unique marketing visuals or product mockups\n    5. Explore artistic ideas and styles programmatically",
      "namespace": "openai.image",
      "node_type": "openai.image.CreateImage",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The prompt to use."
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gpt-image-1"
            ],
            "type_name": "nodetool.nodes.openai.image.CreateImage.Model"
          },
          "default": "gpt-image-1",
          "title": "Model",
          "description": "The model to use for image generation."
        },
        {
          "name": "size",
          "type": {
            "type": "enum",
            "values": [
              "1024x1024",
              "1536x1024",
              "1024x1536"
            ],
            "type_name": "nodetool.nodes.openai.image.CreateImage.Size"
          },
          "default": "1024x1024",
          "title": "Size",
          "description": "The size of the image to generate."
        },
        {
          "name": "background",
          "type": {
            "type": "enum",
            "values": [
              "transparent",
              "opaque",
              "auto"
            ],
            "type_name": "nodetool.nodes.openai.image.CreateImage.Background"
          },
          "default": "auto",
          "title": "Background",
          "description": "The background of the image to generate."
        },
        {
          "name": "quality",
          "type": {
            "type": "enum",
            "values": [
              "high",
              "medium",
              "low"
            ],
            "type_name": "nodetool.nodes.openai.image.CreateImage.Quality"
          },
          "default": "high",
          "title": "Quality",
          "description": "The quality of the image to generate."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "model",
        "size",
        "background",
        "quality"
      ],
      "expose_as_tool": true
    }
  ],
  "assets": [
    {
      "package_name": "nodetool-base",
      "name": "Categorize Mails.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Chat with Docs.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Index PDFs.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Image Enhance.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Story to Video Generator.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Fetch Papers.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Meeting Transcript Summarizer.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Summarize RSS.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Flashcard Generator.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Daily Digest.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Summarize Paper.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Transcribe Audio.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Creative Story Ideas.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Movie Posters.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Summarize Newsletters.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Image To Audio Story.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Data Generator.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Data Visualization Pipeline.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Realtime Agent.jpg",
      "path": ""
    }
  ],
  "examples": [
    {
      "id": "39664b20a78311f0bfc6000069947dd1",
      "name": "Summarize Newsletters",
      "description": "",
      "tags": [
        "email",
        "start"
      ]
    },
    {
      "id": "af5a2636a78211f09af400006952c72c",
      "name": "Chat with Docs",
      "description": "An intelligent document retrieval and question-answering system that leverages vector search and local LLMs to provide accurate, context-aware responses based on your document collection.",
      "tags": [
        "chat",
        "rag"
      ]
    },
    {
      "id": "7c89894e8ce411f083b10000284d49a0",
      "name": "Image Enhance",
      "description": "Improve image quality with basic enhancement tools like sharpening, contrast and color adjustment",
      "tags": [
        "image",
        "start"
      ]
    },
    {
      "id": "830163fea2fc11f0b02700001a475e0e",
      "name": "Image To Audio Story",
      "description": "Generate and narrate creative stories from images using AI",
      "tags": [
        "start",
        "multimodal"
      ]
    },
    {
      "id": "06d8221c907e11f0a4240000006ab9b5",
      "name": "Realtime Agent",
      "description": "",
      "tags": [
        "openai",
        "agent"
      ]
    },
    {
      "id": "d22725a09fc211f0b7bb00007bf02e69",
      "name": "Summarize Paper",
      "description": "",
      "tags": [
        "audio",
        "start"
      ]
    },
    {
      "id": "bcbefdbea78311f09c5e000014a97b82",
      "name": "Summarize RSS",
      "description": "",
      "tags": []
    },
    {
      "id": "flashcard_generator",
      "name": "Flashcard Generator",
      "description": "Generate study flashcards using AI and store them persistently in a database. Enter any topic and get instant flashcards that are saved for future review.",
      "tags": [
        "education",
        "database",
        "ai",
        "flashcards",
        "learning"
      ]
    },
    {
      "id": "1302ffe8a2f911f0b74c000014916b9c",
      "name": "Categorize Mails",
      "description": "Automatically categorize and organize emails using AI",
      "tags": [
        "email",
        "start"
      ]
    },
    {
      "id": "beginner_template_story_ideas",
      "name": "Creative Story Ideas",
      "description": "A beginner-friendly template demonstrating core NodeTool concepts: inputs, templates, LLM agents, streaming, and outputs. Generate creative story ideas based on your preferences.",
      "tags": [
        "start",
        "beginner",
        "tutorial",
        "template"
      ]
    },
    {
      "id": "3527dcf2a7a811f09339000078c92dc5",
      "name": "Meeting Transcript Summarizer",
      "description": "Automatically transcribe a meeting recording and generate concise notes.",
      "tags": [
        "audio",
        "llm"
      ]
    },
    {
      "id": "09eedfbaa30511f0a0840000727222e1",
      "name": "Movie Posters",
      "description": "Create cinematic movie posters using AI image generation",
      "tags": [
        "start",
        "image"
      ]
    },
    {
      "id": "3047c2fa760811f0b24700002df0a13c",
      "name": "Index PDFs",
      "description": "Workflow to index PDFs in a folder into a Chroma collection",
      "tags": [
        "rag",
        "start"
      ]
    },
    {
      "id": "4fd373a0a7a711f08ffb0000744cb0d1",
      "name": "Transcribe Audio",
      "description": "Convert speech to text using Whisper model with word-level timestamps",
      "tags": [
        "start",
        "audio",
        "huggingface"
      ]
    },
    {
      "id": "8c588b4cf3c711efb8fd000014c2afa2",
      "name": "Fetch Papers",
      "description": "This workflow automatically fetches and downloads research papers from the Awesome Transformers GitHub repository. It extracts paper links from the README.md file, filters for actual papers, and downloads them to a specified folder. Ideal for researchers and AI enthusiasts who want to stay updated with the latest transformer model papers.",
      "tags": [
        "automation"
      ]
    },
    {
      "id": "data_visualization_pipeline",
      "name": "Data Visualization Pipeline",
      "description": "Transform natural language descriptions into data visualizations with AI-powered data and chart generation. This workflow demonstrates how to create customized charts from text prompts without manual data preparation.",
      "tags": [
        "agents"
      ]
    },
    {
      "id": "story_to_video_generator",
      "name": "Story to Video Generator",
      "description": "Transform story ideas into cinematic AI-generated videos. An agent crafts detailed visual prompts optimized for video generation, then creates the video using Gemini Veo.",
      "tags": [
        "video",
        "generation",
        "ai",
        "storytelling",
        "creative"
      ]
    },
    {
      "id": "data_generator",
      "name": "Data Generator",
      "description": "Generate structured data using AI agents",
      "tags": [
        "agents"
      ]
    }
  ]
}