{
  "name": "nodetool-base",
  "description": "Nodetool Base nodes",
  "version": "0.6.0",
  "authors": [
    "Matthias Georgi <matti.georgi@gmail.com>"
  ],
  "repo_id": "",
  "nodes": [
    {
      "title": "Audio Classification",
      "description": "Audio classification node using HuggingFace Inference API. Assigns a label or class to audio data.\n    audio, classification, huggingface, inference",
      "namespace": "huggingface_hub",
      "node_type": "huggingface_hub.AudioClassification",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "inference_provider_audio_classification_model"
          },
          "default": {
            "provider": "fal-ai",
            "model_id": "superb/hubert-base-superb-er"
          },
          "title": "Model",
          "description": "The model to use for audio classification"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio to classify"
        },
        {
          "name": "function_to_apply",
          "type": {
            "type": "enum",
            "values": [
              "sigmoid",
              "softmax",
              "none"
            ],
            "type_name": "nodetool.nodes.huggingface_hub.OutputTransform"
          },
          "default": "none",
          "title": "Function To Apply",
          "description": "The function to apply to the model outputs"
        },
        {
          "name": "top_k",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Top K",
          "description": "The number of top predictions to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "audio",
        "function_to_apply",
        "top_k"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Automatic Speech Recognition",
      "description": "Automatic speech recognition node.\n    audio, speech, recognition, huggingface, inference",
      "namespace": "huggingface_hub",
      "node_type": "huggingface_hub.AutomaticSpeechRecognition",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "inference_provider_automatic_speech_recognition_model"
          },
          "default": {
            "provider": "fal-ai",
            "model_id": "openai/whisper-large-v3"
          },
          "title": "Model"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio to transcribe"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "audio_chunk"
              }
            ]
          },
          "name": "chunks"
        }
      ],
      "basic_fields": [
        "model",
        "audio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Chat Completion",
      "description": "Chat completion node using HuggingFace Inference API. Generates text based on a given prompt.\n    chat, completion, huggingface, inference",
      "namespace": "huggingface_hub",
      "node_type": "huggingface_hub.ChatCompletion",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "inference_provider_text_generation_model"
          },
          "default": {
            "provider": "cerebras",
            "model_id": "Qwen/Qwen3-235B-A22B-Thinking-2507"
          },
          "title": "Model",
          "description": "The model to use for text generation"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The input text prompt to generate from"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "description": "Maximum number of tokens to generate",
          "min": 1.0,
          "max": 16384.0
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Temperature",
          "description": "The value used to module the logits distribution",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "top_p",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Top P",
          "description": "Top-p value for nucleus sampling",
          "min": 0.0,
          "max": 1.0
        },
        {
          "name": "top_k",
          "type": {
            "type": "int"
          },
          "default": 50,
          "title": "Top K",
          "description": "The number of highest probability vocabulary tokens to keep for top-k-filtering"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "prompt",
        "max_tokens",
        "temperature",
        "top_p",
        "top_k"
      ]
    },
    {
      "title": "Hugging Face Inference",
      "description": "HuggingFace inference node.",
      "namespace": "huggingface_hub",
      "node_type": "huggingface_hub.HuggingFaceInference",
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ]
    },
    {
      "title": "Image Classification",
      "description": "Image classification node using HuggingFace Inference API. Assigns a label or class to image data.\n    image, classification, huggingface, inference",
      "namespace": "huggingface_hub",
      "node_type": "huggingface_hub.ImageClassification",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "inference_provider_image_classification_model"
          },
          "default": {
            "model_id": "google/vit-base-patch16-224"
          },
          "title": "Model",
          "description": "The model to use for image classification"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to classify"
        },
        {
          "name": "function_to_apply",
          "type": {
            "type": "enum",
            "values": [
              "sigmoid",
              "softmax",
              "none"
            ],
            "type_name": "nodetool.nodes.huggingface_hub.OutputTransform"
          },
          "default": "none",
          "title": "Function To Apply",
          "description": "The function to apply to the model outputs"
        },
        {
          "name": "top_k",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Top K",
          "description": "The number of top predictions to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "image",
        "function_to_apply",
        "top_k"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Image Segmentation",
      "description": "Image segmentation node using HuggingFace Inference API. Divides an image into segments where each pixel is mapped to an object.\n    image, segmentation, huggingface, inference",
      "namespace": "huggingface_hub",
      "node_type": "huggingface_hub.ImageSegmentation",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "inference_provider_image_segmentation_model"
          },
          "default": {
            "model_id": "openmmlab/upernet-convnext-small"
          },
          "title": "Model",
          "description": "The model to use for image segmentation"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to segment"
        },
        {
          "name": "mask_threshold",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Mask Threshold",
          "description": "Threshold to use when turning the predicted masks into binary values"
        },
        {
          "name": "overlap_mask_area_threshold",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Overlap Mask Area Threshold",
          "description": "Mask overlap threshold to eliminate small, disconnected segments"
        },
        {
          "name": "subtask",
          "type": {
            "type": "enum",
            "values": [
              "instance",
              "panoptic",
              "semantic"
            ],
            "type_name": "nodetool.nodes.huggingface_hub.Subtask"
          },
          "default": "semantic",
          "title": "Subtask",
          "description": "The segmentation subtask to perform"
        },
        {
          "name": "threshold",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Threshold",
          "description": "Probability threshold to filter out predicted masks"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image_segmentation_result"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "image",
        "mask_threshold",
        "overlap_mask_area_threshold",
        "subtask",
        "threshold"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Image To Image",
      "description": "Image-to-image node using HuggingFace Inference API. Transforms a source image to match the characteristics of a target image or domain.\n    img2img, img-to-img, huggingface, inference",
      "namespace": "huggingface_hub",
      "node_type": "huggingface_hub.ImageToImage",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "inference_provider_image_to_image_model"
          },
          "default": {
            "provider": "black-forest-labs",
            "model_id": "black-forest-labs/FLUX.1-Kontext-dev"
          },
          "title": "Model",
          "description": "The model to use for image-to-image transformation"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The input image to transform"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt to guide the image transformation"
        },
        {
          "name": "guidance_scale",
          "type": {
            "type": "float"
          },
          "default": 7.5,
          "title": "Guidance Scale",
          "description": "A higher guidance scale value encourages the model to generate images closely linked to the text prompt at the expense of lower image quality"
        },
        {
          "name": "negative_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Negative Prompt",
          "description": "One prompt to guide what NOT to include in image generation"
        },
        {
          "name": "num_inference_steps",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Num Inference Steps",
          "description": "The number of denoising steps. More denoising steps usually lead to a higher quality image at the expense of slower inference"
        },
        {
          "name": "target_width",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Target Width",
          "description": "The target width in pixels of the output image"
        },
        {
          "name": "target_height",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Target Height",
          "description": "The target height in pixels of the output image"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "image",
        "prompt",
        "guidance_scale",
        "negative_prompt",
        "num_inference_steps",
        "target_width",
        "target_height"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Summarization",
      "description": "Summarization node using HuggingFace Inference API. Produces a shorter version of a document while preserving its important information. Some models can extract text from the original input, while others can generate entirely new text.\n    summarization, huggingface, inference",
      "namespace": "huggingface_hub",
      "node_type": "huggingface_hub.Summarization",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "inference_provider_summarization_model"
          },
          "default": {
            "model_id": "facebook/bart-large-cnn"
          },
          "title": "Model",
          "description": "The model to use for summarization"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The input text to summarize"
        },
        {
          "name": "clean_up_tokenization_spaces",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Clean Up Tokenization Spaces",
          "description": "Whether to clean up the potential extra spaces in the text output"
        },
        {
          "name": "truncation",
          "type": {
            "type": "enum",
            "values": [
              "do_not_truncate",
              "longest_first",
              "only_first",
              "only_second"
            ],
            "type_name": "nodetool.nodes.huggingface_hub.Truncation"
          },
          "default": "do_not_truncate",
          "title": "Truncation",
          "description": "Truncation strategy for the input text"
        },
        {
          "name": "max_length",
          "type": {
            "type": "int"
          },
          "default": 150,
          "title": "Max Length",
          "description": "Maximum length of the generated summary",
          "min": 1.0
        },
        {
          "name": "min_length",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Min Length",
          "description": "Minimum length of the generated summary",
          "min": 1.0
        },
        {
          "name": "num_beams",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Num Beams",
          "description": "Number of beams for beam search. 1 means no beam search",
          "min": 1.0
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Temperature",
          "description": "The value used to modulate the logits distribution",
          "min": 0.1,
          "max": 2.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "text",
        "clean_up_tokenization_spaces",
        "truncation",
        "max_length",
        "min_length",
        "num_beams",
        "temperature"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Text Classification",
      "description": "Text classification node using HuggingFace Inference API. Assigns a label or class to given text. Use cases include sentiment analysis, natural language inference, and assessing grammatical correctness.\n    text, sentiment, classification, natural language, inference, grammatical correctness, huggingface, inference",
      "namespace": "huggingface_hub",
      "node_type": "huggingface_hub.TextClassification",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "inference_provider_text_classification_model"
          },
          "default": {
            "model_id": "distilbert/distilbert-base-uncased-finetuned-sst-2-english"
          },
          "title": "Model",
          "description": "The model to use for text classification"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to classify"
        },
        {
          "name": "function_to_apply",
          "type": {
            "type": "enum",
            "values": [
              "sigmoid",
              "softmax",
              "none"
            ],
            "type_name": "nodetool.nodes.huggingface_hub.OutputTransform"
          },
          "default": "none",
          "title": "Function To Apply",
          "description": "The function to apply to the model outputs"
        },
        {
          "name": "top_k",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Top K",
          "description": "When specified, limits the output to the top K most probable classes"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "text",
        "function_to_apply",
        "top_k"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Text To Image",
      "description": "Text-to-image node using HuggingFace Inference API. Generates an image based on a given text prompt.\n    text2img, text-to-img, huggingface, inference",
      "namespace": "huggingface_hub",
      "node_type": "huggingface_hub.TextToImage",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "inference_provider_text_to_image_model"
          },
          "default": {
            "provider": "",
            "model_id": "black-forest-labs/FLUX.1-dev"
          },
          "title": "Model",
          "description": "The model to use for text-to-image generation"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The input text prompt to generate an image from"
        },
        {
          "name": "guidance_scale",
          "type": {
            "type": "float"
          },
          "default": 7.5,
          "title": "Guidance Scale",
          "description": "A higher guidance scale value encourages the model to generate images closely linked to the text prompt, but values too high may cause saturation and other artifacts"
        },
        {
          "name": "negative_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Negative Prompt",
          "description": "One prompt to guide what NOT to include in image generation"
        },
        {
          "name": "num_inference_steps",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Num Inference Steps",
          "description": "The number of denoising steps. More denoising steps usually lead to a higher quality image at the expense of slower inference"
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Width",
          "description": "The width in pixels of the output image"
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Height",
          "description": "The height in pixels of the output image"
        },
        {
          "name": "seed",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Seed",
          "description": "Seed for the random number generator. Use -1 for random seed"
        },
        {
          "name": "scheduler",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Scheduler",
          "description": "Override the scheduler with a compatible one"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "prompt",
        "guidance_scale",
        "negative_prompt",
        "num_inference_steps",
        "width",
        "height",
        "seed",
        "scheduler"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Text To Speech",
      "description": "Text-to-speech node using HuggingFace Inference API. Generates speech audio from input text.\n    text-to-speech, text-to-audio, speech, huggingface, inference",
      "namespace": "huggingface_hub",
      "node_type": "huggingface_hub.TextToSpeech",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "inference_provider_text_to_speech_model"
          },
          "default": {
            "model_id": "microsoft/speecht5_tts"
          },
          "title": "Model",
          "description": "The model to use for text-to-speech synthesis"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The input text to convert to speech"
        },
        {
          "name": "do_sample",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Do Sample",
          "description": "Whether to use sampling instead of greedy decoding when generating new tokens"
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Temperature",
          "description": "The value used to modulate the next token probabilities",
          "min": 0.1,
          "max": 2.0
        },
        {
          "name": "top_k",
          "type": {
            "type": "int"
          },
          "default": 50,
          "title": "Top K",
          "description": "The number of highest probability vocabulary tokens to keep for top-k-filtering",
          "min": 1.0
        },
        {
          "name": "top_p",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Top P",
          "description": "If set to float < 1, only the smallest set of most probable tokens are kept for generation",
          "min": 0.0,
          "max": 1.0
        },
        {
          "name": "max_new_tokens",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Max New Tokens",
          "description": "The maximum number of tokens to generate",
          "min": 1.0
        },
        {
          "name": "num_beams",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Num Beams",
          "description": "Number of beams to use for beam search",
          "min": 1.0
        },
        {
          "name": "use_cache",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Use Cache",
          "description": "Whether the model should use the past last key/values attentions to speed up decoding"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "text",
        "do_sample",
        "temperature",
        "top_k",
        "top_p",
        "max_new_tokens",
        "num_beams",
        "use_cache"
      ]
    },
    {
      "title": "Translation",
      "description": "Translation node using HuggingFace Inference API. Converts text from one language to another.\n    translation, huggingface, inference",
      "namespace": "huggingface_hub",
      "node_type": "huggingface_hub.Translation",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "inference_provider_translation_model"
          },
          "default": {
            "model_id": "google-t5/t5-base"
          },
          "title": "Model",
          "description": "The model to use for translation"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to translate"
        },
        {
          "name": "src_lang",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Src Lang",
          "description": "The source language of the text. Required for models that can translate from multiple languages"
        },
        {
          "name": "tgt_lang",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Tgt Lang",
          "description": "Target language to translate to. Required for models that can translate to multiple languages"
        },
        {
          "name": "clean_up_tokenization_spaces",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Clean Up Tokenization Spaces",
          "description": "Whether to clean up the potential extra spaces in the text output"
        },
        {
          "name": "truncation",
          "type": {
            "type": "enum",
            "values": [
              "do_not_truncate",
              "longest_first",
              "only_first",
              "only_second"
            ],
            "type_name": "nodetool.nodes.huggingface_hub.Truncation"
          },
          "default": "do_not_truncate",
          "title": "Truncation",
          "description": "Truncation strategy for the input text"
        },
        {
          "name": "max_length",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Max Length",
          "description": "Maximum length of the generated translation",
          "min": 1.0
        },
        {
          "name": "num_beams",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Num Beams",
          "description": "Number of beams for beam search. 1 means no beam search",
          "min": 1.0
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Temperature",
          "description": "The value used to modulate the logits distribution",
          "min": 0.1,
          "max": 2.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "text",
        "src_lang",
        "tgt_lang",
        "clean_up_tokenization_spaces",
        "truncation",
        "max_length",
        "num_beams",
        "temperature"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Append",
      "description": "Adds a value to the end of a list.\n    list, add, insert, extend\n\n    Use cases:\n    - Grow a list dynamically\n    - Add new elements to an existing list\n    - Implement a stack-like structure",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Append",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "value"
      ]
    },
    {
      "title": "Average",
      "description": "Calculates the arithmetic mean of a list of numbers.\n    list, average, mean, aggregate, math\n\n    Use cases:\n    - Find average value\n    - Calculate mean of numeric data",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Average",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Chunk",
      "description": "Splits a list into smaller chunks of specified size.\n    list, chunk, split, group\n\n    Use cases:\n    - Batch processing\n    - Pagination\n    - Creating sublists of fixed size",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Chunk",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Chunk Size"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "list",
                "type_args": [
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "chunk_size"
      ]
    },
    {
      "title": "Dedupe",
      "description": "Removes duplicate elements from a list, ensuring uniqueness.\n    list, unique, distinct, deduplicate\n\n    Use cases:\n    - Remove redundant entries\n    - Create a set-like structure\n    - Ensure list elements are unique",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Dedupe",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Difference",
      "description": "Finds elements that exist in first list but not in second list.\n    list, set, difference, subtract\n\n    Use cases:\n    - Find unique elements in one list\n    - Remove items present in another list\n    - Identify distinct elements",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Difference",
      "properties": [
        {
          "name": "list1",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List1"
        },
        {
          "name": "list2",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List2"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "list1",
        "list2"
      ]
    },
    {
      "title": "Extend",
      "description": "Merges one list into another, extending the original list.\n    list, merge, concatenate, combine\n\n    Use cases:\n    - Combine multiple lists\n    - Add all elements from one list to another",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Extend",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "other_values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Other Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "other_values"
      ]
    },
    {
      "title": "Filter Dicts",
      "description": "Filter a list of dictionaries based on a condition.\n    list, filter, query, condition\n\n    Basic Operators:\n    - Comparison: >, <, >=, <=, ==, !=\n    - Logical: and, or, not\n    - Membership: in, not in\n\n    Example Conditions:\n    # Basic comparisons\n    age > 30\n    price <= 100\n    status == 'active'\n\n    # Multiple conditions\n    age > 30 and salary < 50000\n    (price >= 100) and (price <= 200)\n    department in ['Sales', 'Marketing']\n\n    # String operations\n    name.str.startswith('J')\n    email.str.contains('@company.com')\n\n    # Datetime conditions\n    date > '2024-01-01'\n    date.dt.year == 2024\n    date.dt.month >= 6\n    date.dt.day_name() == 'Monday'\n\n    # Date ranges\n    date.between('2024-01-01', '2024-12-31')\n    date >= '2024-01-01' and date < '2025-01-01'\n\n    # Complex datetime\n    date.dt.hour < 12\n    date.dt.dayofweek <= 4  # Weekdays only\n\n    # Numeric operations\n    price.between(100, 200)\n    quantity % 2 == 0  # Even numbers\n\n    # Special values\n    value.isna()  # Check for NULL/NaN\n    value.notna()  # Check for non-NULL/non-NaN\n\n    Note: Dates should be in ISO format (YYYY-MM-DD) or include time (YYYY-MM-DD HH:MM:SS)\n\n    Use cases:\n    - Filter list of dictionary objects based on criteria\n    - Extract subset of data meeting specific conditions\n    - Clean data by removing unwanted entries",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterDicts",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "condition",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Condition",
          "description": "\n        The filtering condition using pandas query syntax.\n\n        Basic Operators:\n        - Comparison: >, <, >=, <=, ==, !=\n        - Logical: and, or, not\n        - Membership: in, not in\n        \n        Example Conditions:\n        # Basic comparisons\n        age > 30\n        price <= 100\n        status == 'active'\n        \n        See node documentation for more examples.\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "condition"
      ]
    },
    {
      "title": "Filter Dicts By Number",
      "description": "Filters a list of dictionaries based on numeric values for a specified key.\n    list, filter, dictionary, numbers, numeric\n\n    Use cases:\n    - Filter dictionaries by numeric comparisons (greater than, less than, equal to)\n    - Filter records with even/odd numeric values\n    - Filter entries with positive/negative numbers",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterDictsByNumber",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key"
        },
        {
          "name": "filter_type",
          "type": {
            "type": "enum",
            "values": [
              "greater_than",
              "less_than",
              "equal_to",
              "even",
              "odd",
              "positive",
              "negative"
            ],
            "type_name": "nodetool.nodes.nodetool.list.FilterDictNumberType"
          },
          "default": "greater_than",
          "title": "Filter Type"
        },
        {
          "name": "value",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "key",
        "filter_type",
        "value"
      ]
    },
    {
      "title": "Filter Dicts By Range",
      "description": "Filters a list of dictionaries based on a numeric range for a specified key.\n    list, filter, dictionary, range, between\n\n    Use cases:\n    - Filter records based on numeric ranges (e.g., price range, age range)\n    - Find entries with values within specified bounds\n    - Filter data sets based on numeric criteria",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterDictsByRange",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key",
          "description": "The dictionary key to check for the range"
        },
        {
          "name": "min_value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Min Value",
          "description": "The minimum value (inclusive) of the range"
        },
        {
          "name": "max_value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Max Value",
          "description": "The maximum value (inclusive) of the range"
        },
        {
          "name": "inclusive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Inclusive",
          "description": "If True, includes the min and max values in the results"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "key",
        "min_value",
        "max_value",
        "inclusive"
      ]
    },
    {
      "title": "Filter Dicts By Value",
      "description": "Filters a list of dictionaries based on their values using various criteria.\n    list, filter, dictionary, values\n\n    Use cases:\n    - Filter dictionaries by value content\n    - Filter dictionaries by value type\n    - Filter dictionaries by value patterns",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterDictsByValue",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key",
          "description": "The dictionary key to check"
        },
        {
          "name": "filter_type",
          "type": {
            "type": "enum",
            "values": [
              "contains",
              "starts_with",
              "ends_with",
              "equals",
              "type_is",
              "length_greater",
              "length_less",
              "exact_length"
            ],
            "type_name": "nodetool.nodes.nodetool.list.FilterType"
          },
          "default": "contains",
          "title": "Filter Type",
          "description": "The type of filter to apply"
        },
        {
          "name": "criteria",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Criteria",
          "description": "The filtering criteria (text to match, type name, or length as string)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "key",
        "filter_type",
        "criteria"
      ]
    },
    {
      "title": "Filter Dicts Regex",
      "description": "Filters a list of dictionaries using regular expressions on specified keys.\n    list, filter, regex, dictionary, pattern\n\n    Use cases:\n    - Filter dictionaries with values matching complex patterns\n    - Search for dictionaries containing emails, dates, or specific formats\n    - Advanced text pattern matching across dictionary values",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterDictsRegex",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern"
        },
        {
          "name": "full_match",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Full Match"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "key",
        "pattern",
        "full_match"
      ]
    },
    {
      "title": "Filter None",
      "description": "Filters out None values from a list.\n    list, filter, none, null\n\n    Use cases:\n    - Clean data by removing null values\n    - Get only valid entries\n    - Remove placeholder values",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterNone",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Filter Number Range",
      "description": "Filters a list of numbers to find values within a specified range.\n    list, filter, numbers, range, between\n\n    Use cases:\n    - Find numbers within a specific range\n    - Filter data points within bounds\n    - Implement range-based filtering",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterNumberRange",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "min_value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Min Value"
        },
        {
          "name": "max_value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Max Value"
        },
        {
          "name": "inclusive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Inclusive"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "min_value",
        "max_value",
        "inclusive"
      ]
    },
    {
      "title": "Filter Numbers",
      "description": "Filters a list of numbers based on various numerical conditions.\n    list, filter, numbers, numeric\n\n    Use cases:\n    - Filter numbers by comparison (greater than, less than, equal to)\n    - Filter even/odd numbers\n    - Filter positive/negative numbers",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterNumbers",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "filter_type",
          "type": {
            "type": "enum",
            "values": [
              "greater_than",
              "less_than",
              "equal_to",
              "even",
              "odd",
              "positive",
              "negative"
            ],
            "type_name": "nodetool.nodes.nodetool.list.FilterNumberType"
          },
          "default": "greater_than",
          "title": "Filter Type",
          "description": "The type of filter to apply"
        },
        {
          "name": "value",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Value",
          "description": "The comparison value (for greater_than, less_than, equal_to)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "filter_type",
        "value"
      ]
    },
    {
      "title": "Filter Regex",
      "description": "Filters a list of strings using regular expressions.\n    list, filter, regex, pattern, text\n\n    Use cases:\n    - Filter strings using complex patterns\n    - Extract strings matching specific formats (emails, dates, etc.)\n    - Advanced text pattern matching",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterRegex",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "The regular expression pattern to match against."
        },
        {
          "name": "full_match",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Full Match",
          "description": "Whether to match the entire string or find pattern anywhere in string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "pattern",
        "full_match"
      ]
    },
    {
      "title": "Filter Strings",
      "description": "Filters a list of strings based on various criteria.\n    list, filter, strings, text\n\n    Use cases:\n    - Filter strings by length\n    - Filter strings containing specific text\n    - Filter strings by prefix/suffix\n    - Filter strings using regex patterns",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterStrings",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "filter_type",
          "type": {
            "type": "enum",
            "values": [
              "contains",
              "starts_with",
              "ends_with",
              "length_greater",
              "length_less",
              "exact_length"
            ],
            "type_name": "nodetool.nodes.nodetool.list.FilterType"
          },
          "default": "contains",
          "title": "Filter Type",
          "description": "The type of filter to apply"
        },
        {
          "name": "criteria",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Criteria",
          "description": "The filtering criteria (text to match or length as string)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "filter_type",
        "criteria"
      ]
    },
    {
      "title": "Flatten",
      "description": "Flattens a nested list structure into a single flat list.\n    list, flatten, nested, structure\n\n    Use cases:\n    - Convert nested lists into a single flat list\n    - Simplify complex list structures\n    - Process hierarchical data as a sequence\n\n    Examples:\n    [[1, 2], [3, 4]] -> [1, 2, 3, 4]\n    [[1, [2, 3]], [4, [5, 6]]] -> [1, 2, 3, 4, 5, 6]",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Flatten",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "max_depth",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Max Depth",
          "min": -1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "max_depth"
      ]
    },
    {
      "title": "Generate Sequence",
      "description": "Generates a list of integers within a specified range.\n    list, range, sequence, numbers\n\n    Use cases:\n    - Create numbered lists\n    - Generate index sequences\n    - Produce arithmetic progressions",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.GenerateSequence",
      "properties": [
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start"
        },
        {
          "name": "stop",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Stop"
        },
        {
          "name": "step",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Step"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "start",
        "stop",
        "step"
      ]
    },
    {
      "title": "Get Element",
      "description": "Retrieves a single value from a list at a specific index.\n    list, get, extract, value\n\n    Use cases:\n    - Access a specific element by position\n    - Implement array-like indexing\n    - Extract the first or last element",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.GetElement",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "index",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Index"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "index"
      ]
    },
    {
      "title": "Intersection",
      "description": "Finds common elements between two lists.\n    list, set, intersection, common\n\n    Use cases:\n    - Find elements present in both lists\n    - Identify shared items between collections\n    - Filter for matching elements",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Intersection",
      "properties": [
        {
          "name": "list1",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List1"
        },
        {
          "name": "list2",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List2"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "list1",
        "list2"
      ]
    },
    {
      "title": "Length",
      "description": "Calculates the length of a list.\n    list, count, size\n\n    Use cases:\n    - Determine the number of elements in a list\n    - Check if a list is empty\n    - Validate list size constraints",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Length",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Map Field",
      "description": "Extracts a specific field from a list of dictionaries or objects.\n    list, map, field, extract, pluck\n\n    Use cases:\n    - Extract specific fields from a list of objects\n    - Transform complex data structures into simple lists\n    - Collect values for a particular key across multiple dictionaries",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.MapField",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "union",
                "type_args": [
                  {
                    "type": "dict"
                  },
                  {
                    "type": "object"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "field",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Field"
        },
        {
          "name": "default",
          "type": {
            "type": "any"
          },
          "title": "Default"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "field",
        "default"
      ]
    },
    {
      "title": "Maximum",
      "description": "Finds the largest value in a list of numbers.\n    list, max, maximum, aggregate, math\n\n    Use cases:\n    - Find highest value\n    - Get largest number in dataset",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Maximum",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Minimum",
      "description": "Finds the smallest value in a list of numbers.\n    list, min, minimum, aggregate, math\n\n    Use cases:\n    - Find lowest value\n    - Get smallest number in dataset",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Minimum",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Product",
      "description": "Calculates the product of all numbers in a list.\n    list, product, multiply, aggregate, math\n\n    Use cases:\n    - Multiply all numbers together\n    - Calculate compound values",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Product",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Randomize",
      "description": "Randomly shuffles the elements of a list.\n    list, shuffle, random, order\n\n    Use cases:\n    - Randomize the order of items in a playlist\n    - Implement random sampling without replacement\n    - Create randomized data sets for testing",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Randomize",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Reverse",
      "description": "Inverts the order of elements in a list.\n    list, reverse, invert, flip\n\n    Use cases:\n    - Reverse the order of a sequence",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Reverse",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Save List",
      "description": "Saves a list to a text file, placing each element on a new line.\n    list, save, file, serialize\n\n    Use cases:\n    - Export list data to a file\n    - Create a simple text-based database\n    - Generate line-separated output",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.SaveList",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "text.txt",
          "title": "Name",
          "description": "\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "text"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "name"
      ]
    },
    {
      "title": "Select Elements",
      "description": "Selects specific values from a list using index positions.\n    list, select, index, extract\n\n    Use cases:\n    - Pick specific elements by their positions\n    - Rearrange list elements\n    - Create a new list from selected indices",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.SelectElements",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "indices",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "int"
              }
            ]
          },
          "default": [],
          "title": "Indices"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "indices"
      ]
    },
    {
      "title": "Sequence Iterator",
      "description": "Iterates over a sequence of numbers.\n    list, range, sequence, numbers",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.SequenceIterator",
      "properties": [
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start"
        },
        {
          "name": "stop",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Stop"
        },
        {
          "name": "step",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Step"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "start",
        "stop",
        "step"
      ]
    },
    {
      "title": "Slice",
      "description": "Extracts a subset from a list using start, stop, and step indices.\n    list, slice, subset, extract\n\n    Use cases:\n    - Get a portion of a list\n    - Implement pagination\n    - Extract every nth element",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Slice",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start"
        },
        {
          "name": "stop",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Stop"
        },
        {
          "name": "step",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Step"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "start",
        "stop",
        "step"
      ]
    },
    {
      "title": "Sort",
      "description": "Sorts the elements of a list in ascending or descending order.\n    list, sort, order, arrange\n\n    Use cases:\n    - Organize data in a specific order\n    - Prepare data for binary search or other algorithms\n    - Rank items based on their values",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Sort",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "order",
          "type": {
            "type": "enum",
            "values": [
              "ascending",
              "descending"
            ],
            "type_name": "nodetool.nodes.nodetool.list.SortOrder"
          },
          "default": "ascending",
          "title": "Order"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "order"
      ]
    },
    {
      "title": "Sum",
      "description": "Calculates the sum of a list of numbers.\n    list, sum, aggregate, math\n\n    Use cases:\n    - Calculate total of numeric values\n    - Add up all elements in a list",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Sum",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Transform",
      "description": "Applies a transformation to each element in a list.\n    list, transform, map, convert\n\n    Use cases:\n    - Convert types (str to int, etc.)\n    - Apply formatting\n    - Mathematical operations",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Transform",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "transform_type",
          "type": {
            "type": "enum",
            "values": [
              "to_int",
              "to_float",
              "to_string",
              "uppercase",
              "lowercase",
              "strip"
            ],
            "type_name": "nodetool.nodes.nodetool.list.TransformType"
          },
          "default": "to_string",
          "title": "Transform Type"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "transform_type"
      ]
    },
    {
      "title": "Union",
      "description": "Combines unique elements from two lists.\n    list, set, union, combine\n\n    Use cases:\n    - Merge lists while removing duplicates\n    - Combine collections uniquely\n    - Create comprehensive set of items",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Union",
      "properties": [
        {
          "name": "list1",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List1"
        },
        {
          "name": "list2",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List2"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "list1",
        "list2"
      ]
    },
    {
      "title": "Collect",
      "description": "Collect items until the end of the stream and return them as a list.\n    collector, aggregate, list, stream\n\n    Use cases:\n    - Gather results from multiple processing steps\n    - Collect streaming data into batches\n    - Aggregate outputs from parallel operations",
      "namespace": "nodetool.control",
      "node_type": "nodetool.control.Collect",
      "properties": [
        {
          "name": "input_item",
          "type": {
            "type": "any"
          },
          "title": "Input Item",
          "description": "The input item to collect."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_item"
      ]
    },
    {
      "title": "For Each",
      "description": "Iterate over a list and emit each item sequentially.\n    iterator, loop, list, sequence\n\n    Use cases:\n    - Process each item of a collection in order\n    - Drive downstream nodes with individual elements",
      "namespace": "nodetool.control",
      "node_type": "nodetool.control.ForEach",
      "properties": [
        {
          "name": "input_list",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Input List",
          "description": "The list of items to iterate over."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "index"
        }
      ],
      "basic_fields": [
        "input_list"
      ]
    },
    {
      "title": "If",
      "description": "Conditionally executes one of two branches based on a condition.\n    control, flow, condition, logic, else, true, false, switch, toggle, flow-control\n\n    Use cases:\n    - Branch workflow based on conditions\n    - Handle different cases in data processing\n    - Implement decision logic",
      "namespace": "nodetool.control",
      "node_type": "nodetool.control.If",
      "properties": [
        {
          "name": "condition",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Condition",
          "description": "The condition to evaluate"
        },
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "title": "Value",
          "description": "The value to pass to the next node"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "if_true"
        },
        {
          "type": {
            "type": "any"
          },
          "name": "if_false"
        }
      ],
      "basic_fields": [
        "condition",
        "value"
      ]
    },
    {
      "title": "Reroute",
      "description": "Pass data through unchanged for tidier workflow layouts.\n    reroute, passthrough, organize, tidy, flow, connection, redirect\n\n    Use cases:\n    - Organize complex workflows by routing connections\n    - Create cleaner visual layouts\n    - Redirect data flow without modification",
      "namespace": "nodetool.control",
      "node_type": "nodetool.control.Reroute",
      "properties": [
        {
          "name": "input_value",
          "type": {
            "type": "any"
          },
          "title": "Input Value",
          "description": "Value to pass through unchanged"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_value"
      ]
    },
    {
      "title": "Execute Bash",
      "description": "Executes Bash script with safety restrictions.\n    bash, shell, code, execute",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecuteBash",
      "properties": [
        {
          "name": "code",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Code",
          "description": "Bash script to execute as-is. Dynamic inputs are provided as env vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'."
        },
        {
          "name": "image",
          "type": {
            "type": "enum",
            "values": [
              "bash:5.2",
              "debian:12",
              "ubuntu:22.04",
              "ubuntu:24.04",
              "jupyter/scipy-notebook:latest"
            ],
            "type_name": "nodetool.nodes.nodetool.code.BashImage"
          },
          "default": "ubuntu:22.04",
          "title": "Image",
          "description": "Docker image to use for execution"
        },
        {
          "name": "execution_mode",
          "type": {
            "type": "enum",
            "values": [
              "docker",
              "subprocess"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutionMode"
          },
          "default": "docker",
          "title": "Execution Mode",
          "description": "Execution mode: 'docker' or 'subprocess'"
        },
        {
          "name": "stdin",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Stdin",
          "description": "String to write to process stdin before any streaming input. Use newlines to separate lines."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "code",
        "image",
        "execution_mode",
        "stdin"
      ]
    },
    {
      "title": "Execute Command",
      "description": "Executes a single shell command inside a Docker container.\n    command, execute, shell, bash, sh\n\n    IMPORTANT: Only enabled in non-production environments",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecuteCommand",
      "properties": [
        {
          "name": "command",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Command",
          "description": "Single command to run via the selected shell. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'."
        },
        {
          "name": "image",
          "type": {
            "type": "enum",
            "values": [
              "bash:5.2",
              "alpine:3",
              "ubuntu:22.04",
              "ubuntu:24.04"
            ],
            "type_name": "nodetool.nodes.nodetool.code.CommandImage"
          },
          "default": "bash:5.2",
          "title": "Image",
          "description": "Docker image to use for execution"
        },
        {
          "name": "execution_mode",
          "type": {
            "type": "enum",
            "values": [
              "docker",
              "subprocess"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutionMode"
          },
          "default": "docker",
          "title": "Execution Mode",
          "description": "Execution mode: 'docker' or 'subprocess'"
        },
        {
          "name": "stdin",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Stdin",
          "description": "String to write to process stdin before any streaming input. Use newlines to separate lines."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "command",
        "image",
        "execution_mode",
        "stdin"
      ]
    },
    {
      "title": "Execute Java Script",
      "description": "Executes JavaScript (Node.js) code with safety restrictions.\n    javascript, nodejs, code, execute",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecuteJavaScript",
      "properties": [
        {
          "name": "code",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Code",
          "description": "JavaScript code to execute as-is under Node.js. Dynamic inputs are provided as env vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'."
        },
        {
          "name": "image",
          "type": {
            "type": "enum",
            "values": [
              "node:22-alpine"
            ],
            "type_name": "nodetool.nodes.nodetool.code.JavaScriptImage"
          },
          "default": "node:22-alpine",
          "title": "Image",
          "description": "Docker image to use for execution"
        },
        {
          "name": "execution_mode",
          "type": {
            "type": "enum",
            "values": [
              "docker",
              "subprocess"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutionMode"
          },
          "default": "docker",
          "title": "Execution Mode",
          "description": "Execution mode: 'docker' or 'subprocess'"
        },
        {
          "name": "stdin",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Stdin",
          "description": "String to write to process stdin before any streaming input. Use newlines to separate lines."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "code",
        "image",
        "execution_mode",
        "stdin"
      ]
    },
    {
      "title": "Execute Lua",
      "description": "Executes Lua code with a local sandbox (no Docker).\n    lua, code, execute, sandbox",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecuteLua",
      "properties": [
        {
          "name": "code",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Code",
          "description": "Lua code to execute as-is in a restricted environment. Dynamic inputs are provided as variables. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'."
        },
        {
          "name": "executable",
          "type": {
            "type": "enum",
            "values": [
              "lua",
              "luajit"
            ],
            "type_name": "nodetool.nodes.nodetool.code.LuaExecutable"
          },
          "default": "lua",
          "title": "Executable",
          "description": "Lua executable to use"
        },
        {
          "name": "execution_mode",
          "type": {
            "type": "enum",
            "values": [
              "docker",
              "subprocess"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutionMode"
          },
          "default": "subprocess",
          "title": "Execution Mode",
          "description": "Execution mode: 'docker' or 'subprocess'"
        },
        {
          "name": "timeout_seconds",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Timeout Seconds",
          "description": "Max seconds to allow execution before forced stop"
        },
        {
          "name": "stdin",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Stdin",
          "description": "String to write to process stdin before any streaming input. Use newlines to separate lines."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "code",
        "executable",
        "execution_mode",
        "timeout_seconds",
        "stdin"
      ]
    },
    {
      "title": "Execute Python",
      "description": "Executes Python code with safety restrictions.\n    python, code, execute\n\n    Use cases:\n    - Run custom data transformations\n    - Prototype node functionality\n    - Debug and testing workflows\n\n    IMPORTANT: Only enabled in non-production environments",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecutePython",
      "properties": [
        {
          "name": "code",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Code",
          "description": "Python code to execute as-is. Dynamic inputs are provided as env vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'."
        },
        {
          "name": "image",
          "type": {
            "type": "enum",
            "values": [
              "python:3.11-slim",
              "jupyter/scipy-notebook:latest"
            ],
            "type_name": "nodetool.nodes.nodetool.code.PythonImage"
          },
          "default": "python:3.11-slim",
          "title": "Image",
          "description": "Docker image to use for execution"
        },
        {
          "name": "execution_mode",
          "type": {
            "type": "enum",
            "values": [
              "docker",
              "subprocess"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutionMode"
          },
          "default": "docker",
          "title": "Execution Mode",
          "description": "Execution mode: 'docker' or 'subprocess'"
        },
        {
          "name": "stdin",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Stdin",
          "description": "String to write to process stdin before any streaming input. Use newlines to separate lines."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "code",
        "image",
        "execution_mode",
        "stdin"
      ]
    },
    {
      "title": "Execute Ruby",
      "description": "Executes Ruby code with safety restrictions.\n    ruby, code, execute",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecuteRuby",
      "properties": [
        {
          "name": "code",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Code",
          "description": "Ruby code to execute as-is. Dynamic inputs are provided as env vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'."
        },
        {
          "name": "image",
          "type": {
            "type": "enum",
            "values": [
              "ruby:3.3-alpine"
            ],
            "type_name": "nodetool.nodes.nodetool.code.RubyImage"
          },
          "default": "ruby:3.3-alpine",
          "title": "Image",
          "description": "Docker image to use for execution"
        },
        {
          "name": "execution_mode",
          "type": {
            "type": "enum",
            "values": [
              "docker",
              "subprocess"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutionMode"
          },
          "default": "docker",
          "title": "Execution Mode",
          "description": "Execution mode: 'docker' or 'subprocess'"
        },
        {
          "name": "stdin",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Stdin",
          "description": "String to write to process stdin before any streaming input. Use newlines to separate lines."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "code",
        "image",
        "execution_mode",
        "stdin"
      ]
    },
    {
      "title": "All",
      "description": "Checks if all boolean values in a list are True.\n    boolean, all, check, logic, condition, flow-control, branch\n\n\n    Use cases:\n    - Ensure all conditions in a set are met\n    - Implement comprehensive checks\n    - Validate multiple criteria simultaneously",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.All",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "bool"
              }
            ]
          },
          "default": [],
          "title": "Values",
          "description": "List of boolean values to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Compare",
      "description": "Compares two values using a specified comparison operator.\n    compare, condition, logic\n\n    Use cases:\n    - Implement decision points in workflows\n    - Filter data based on specific criteria\n    - Create dynamic thresholds or limits",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.Compare",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "any"
          },
          "title": "A",
          "description": "First value to compare"
        },
        {
          "name": "b",
          "type": {
            "type": "any"
          },
          "title": "B",
          "description": "Second value to compare"
        },
        {
          "name": "comparison",
          "type": {
            "type": "enum",
            "values": [
              "==",
              "!=",
              ">",
              "<",
              ">=",
              "<="
            ],
            "type_name": "nodetool.nodes.nodetool.boolean.Comparison"
          },
          "default": "==",
          "title": "Comparison",
          "description": "Comparison operator to use"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b",
        "comparison"
      ]
    },
    {
      "title": "Conditional Switch",
      "description": "Performs a conditional check on a boolean input and returns a value based on the result.\n    if, condition, flow-control, branch, true, false, switch, toggle\n\n    Use cases:\n    - Implement conditional logic in workflows\n    - Create dynamic branches in workflows\n    - Implement decision points in workflows",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.ConditionalSwitch",
      "properties": [
        {
          "name": "condition",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Condition",
          "description": "The condition to check"
        },
        {
          "name": "if_true",
          "type": {
            "type": "any"
          },
          "title": "If True",
          "description": "The value to return if the condition is true"
        },
        {
          "name": "if_false",
          "type": {
            "type": "any"
          },
          "title": "If False",
          "description": "The value to return if the condition is false"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "condition",
        "if_true",
        "if_false"
      ]
    },
    {
      "title": "Is In",
      "description": "Checks if a value is present in a list of options.\n    membership, contains, check\n\n    Use cases:\n    - Validate input against a set of allowed values\n    - Implement category or group checks\n    - Filter data based on inclusion criteria",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.IsIn",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "title": "Value",
          "description": "The value to check for membership"
        },
        {
          "name": "options",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Options",
          "description": "The list of options to check against"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value",
        "options"
      ]
    },
    {
      "title": "Is None",
      "description": "Checks if a value is None.\n    null, none, check\n\n    Use cases:\n    - Validate input presence\n    - Handle optional parameters\n    - Implement null checks in data processing",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.IsNone",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "title": "Value",
          "description": "The value to check for None"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "Logical Operator",
      "description": "Performs logical operations on two boolean inputs.\n    boolean, logic, operator, condition, flow-control, branch, else, true, false, switch, toggle\n\n    Use cases:\n    - Combine multiple conditions in decision-making\n    - Implement complex logical rules in workflows\n    - Create advanced filters or triggers",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.LogicalOperator",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "A",
          "description": "First boolean input"
        },
        {
          "name": "b",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "B",
          "description": "Second boolean input"
        },
        {
          "name": "operation",
          "type": {
            "type": "enum",
            "values": [
              "and",
              "or",
              "xor",
              "nand",
              "nor"
            ],
            "type_name": "nodetool.nodes.nodetool.boolean.BooleanOperation"
          },
          "default": "and",
          "title": "Operation",
          "description": "Logical operation to perform"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b",
        "operation"
      ]
    },
    {
      "title": "Not",
      "description": "Performs logical NOT operation on a boolean input.\n    boolean, logic, not, invert, !, negation, condition, else, true, false, switch, toggle, flow-control, branch\n\n    Use cases:\n    - Invert a condition's result\n    - Implement toggle functionality\n    - Create opposite logic branches",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.Not",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Value",
          "description": "Boolean input to negate"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "Some",
      "description": "Checks if any boolean value in a list is True.\n    boolean, any, check, logic, condition, flow-control, branch\n\n    Use cases:\n    - Check if at least one condition in a set is met\n    - Implement optional criteria checks\n    - Create flexible validation rules",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.Some",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "bool"
              }
            ]
          },
          "default": [],
          "title": "Values",
          "description": "List of boolean values to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Agent",
      "description": "Generate natural language responses using LLM providers and streams output.\n    llm, text-generation, chatbot, question-answering, streaming",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.Agent",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "Model to use for execution"
        },
        {
          "name": "system",
          "type": {
            "type": "str"
          },
          "default": "You are a an AI agent. \n\nBehavior\n- Understand the user's intent and the context of the task.\n- Break down the task into smaller steps.\n- Be precise, concise, and actionable.\n- Use tools to accomplish your goal. \n\nTool preambles\n- Outline the next step(s) you will perform.\n- After acting, summarize the outcome.\n\nRendering\n- Use Markdown to display media assets.\n- Display images, audio, and video assets using the appropriate Markdown.\n\nFile handling\n- Inputs and outputs are files in the /workspace directory.\n- Write outputs of code execution to the /workspace directory.\n",
          "title": "System",
          "description": "The system prompt for the LLM"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The prompt for the LLM"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to analyze"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio to analyze"
        },
        {
          "name": "history",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "message"
              }
            ]
          },
          "default": [],
          "title": "Messages",
          "description": "The messages for the LLM"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 8192,
          "title": "Max Tokens",
          "min": 1.0,
          "max": 100000.0
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window (Ollama)",
          "min": 1.0,
          "max": 65536.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        }
      ],
      "basic_fields": [
        "prompt",
        "model",
        "image",
        "audio"
      ]
    },
    {
      "title": "Classifier",
      "description": "Classify text into predefined or dynamic categories using LLM.\n    classification, nlp, categorization\n\n    Use cases:\n    - Sentiment analysis\n    - Topic classification\n    - Intent detection\n    - Content categorization",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.Classifier",
      "properties": [
        {
          "name": "system_prompt",
          "type": {
            "type": "str"
          },
          "default": "\nYou are a precise classifier.\n\nGoal\n- Select exactly one category from the list provided by the user.\n\nOutput format (MANDATORY)\n- Return ONLY a single JSON object with this exact schema and nothing else:\n  {\"category\": \"<one-of-the-allowed-categories>\"}\n- No prose, no Markdown, no code fences, no explanations, no extra keys.\n\nSelection criteria\n- Choose the single best category that captures the main intent of the text.\n- If multiple categories seem plausible, pick the most probable one; do not return multiple.\n- If none fit perfectly, choose the closest allowed category. If the list includes \"Other\" or \"Unknown\", prefer it when appropriate.\n- Be robust to casing, punctuation, emojis, and minor typos. Handle negation correctly (e.g., \"not spam\" \u2260 spam).\n- Never invent categories that are not in the provided list.\n\nBehavior\n- Be deterministic for the same input.\n- Do not ask clarifying questions; make the best choice with what's given.\n",
          "title": "System Prompt",
          "description": "The system prompt for the classifier"
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "Model to use for classification"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to classify"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "Optional image to classify in context"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "Optional audio to classify in context"
        },
        {
          "name": "categories",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Categories",
          "description": "List of possible categories. If empty, LLM will determine categories."
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 1024,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 16384.0
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window (Ollama)",
          "min": 1.0,
          "max": 65536.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "categories",
        "model",
        "image",
        "audio"
      ]
    },
    {
      "title": "Extractor",
      "description": "Extract structured data from text content using LLM providers.\n    data-extraction, structured-data, nlp, parsing\n\n    Specialized for extracting structured information:\n    - Converting unstructured text into structured data\n    - Identifying and extracting specific fields from documents\n    - Parsing text according to predefined schemas\n    - Creating structured records from natural language content",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.Extractor",
      "properties": [
        {
          "name": "system_prompt",
          "type": {
            "type": "str"
          },
          "default": "\nYou are a precise structured data extractor.\n\nGoal\n- Extract exactly the fields described in <JSON_SCHEMA> from the content in <TEXT> (and any attached media).\n\nOutput format (MANDATORY)\n- Output exactly ONE fenced code block labeled json containing ONLY the JSON object:\n\n  ```json\n  { ...single JSON object matching <JSON_SCHEMA>... }\n  ```\n\n- No additional prose before or after the block.\n\nExtraction rules\n- Use only information found in <TEXT> or attached media. Do not invent facts.\n- Preserve source values; normalize internal whitespace and trim leading/trailing spaces.\n- If a required field is missing or not explicitly stated, return the closest reasonable default consistent with its type:\n  - string: \"\"\n  - number: 0\n  - boolean: false\n  - array/object: empty value of that type (only if allowed by the schema)\n- Dates/times: prefer ISO 8601 when the schema type is string and the value represents a date/time.\n- If multiple candidates exist, choose the most precise and unambiguous one.\n\nValidation\n- Ensure the final JSON validates against <JSON_SCHEMA> exactly.\n",
          "title": "System Prompt",
          "description": "The system prompt for the data extractor"
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "Model to use for data extraction"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to extract data from"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "Optional image to assist extraction"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "Optional audio to assist extraction"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 16384.0
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window (Ollama)",
          "min": 1.0,
          "max": 65536.0
        }
      ],
      "basic_fields": [
        "text",
        "model",
        "image",
        "audio"
      ]
    },
    {
      "title": "Summarizer",
      "description": "Generate concise summaries of text content using LLM providers with streaming output.\n    text, summarization, nlp, content, streaming\n\n    Specialized for creating high-quality summaries with real-time streaming:\n    - Condensing long documents into key points\n    - Creating executive summaries with live output\n    - Extracting main ideas from text as they're generated\n    - Maintaining factual accuracy while reducing length",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.Summarizer",
      "properties": [
        {
          "name": "system_prompt",
          "type": {
            "type": "str"
          },
          "default": "\n        You are an expert summarizer. Your task is to create clear, accurate, and concise summaries using Markdown for structuring. \n        Follow these guidelines:\n        1. Identify and include only the most important information.\n        2. Maintain factual accuracy - do not add or modify information.\n        3. Use clear, direct language.\n        4. Aim for approximately {self.max_tokens} tokens.\n        ",
          "title": "System Prompt",
          "description": "The system prompt for the summarizer"
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "Model to use for summarization"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to summarize"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "Optional image to condition the summary"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "Optional audio to condition the summary"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 200,
          "title": "Max Tokens",
          "description": "Target maximum number of tokens for the summary",
          "min": 50.0,
          "max": 16384.0
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window (Ollama)",
          "min": 1.0,
          "max": 65536.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        }
      ],
      "basic_fields": [
        "text",
        "max_tokens",
        "model",
        "image",
        "audio"
      ]
    },
    {
      "title": "Chart Generator",
      "description": "LLM Agent to create Plotly Express charts based on natural language descriptions.\n    llm, data visualization, charts\n\n    Use cases:\n    - Generating interactive charts from natural language descriptions\n    - Creating data visualizations with minimal configuration\n    - Converting data analysis requirements into visual representations",
      "namespace": "nodetool.generators",
      "node_type": "nodetool.generators.ChartGenerator",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "The model to use for chart generation."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Natural language description of the desired chart"
        },
        {
          "name": "data",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Data",
          "description": "The data to visualize"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 100000.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "plotly_config"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "data",
        "model"
      ]
    },
    {
      "title": "Data Generator",
      "description": "LLM Agent to create a dataframe based on a user prompt.\n    llm, dataframe creation, data structuring\n\n    Use cases:\n    - Generating structured data from natural language descriptions\n    - Creating sample datasets for testing or demonstration\n    - Converting unstructured text into tabular format",
      "namespace": "nodetool.generators",
      "node_type": "nodetool.generators.DataGenerator",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "The model to use for data generation."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The user prompt"
        },
        {
          "name": "input_text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Input Text",
          "description": "The input text to be analyzed by the agent."
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 100000.0
        },
        {
          "name": "columns",
          "type": {
            "type": "record_type"
          },
          "default": {},
          "title": "Columns",
          "description": "The columns to use in the dataframe."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "record"
        },
        {
          "type": {
            "type": "dataframe"
          },
          "name": "dataframe"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "index"
        }
      ],
      "basic_fields": [
        "prompt",
        "model",
        "columns"
      ]
    },
    {
      "title": "List Generator",
      "description": "LLM Agent to create a stream of strings based on a user prompt.\n    llm, text streaming\n\n    Use cases:\n    - Generating text from natural language descriptions\n    - Streaming responses from an LLM",
      "namespace": "nodetool.generators",
      "node_type": "nodetool.generators.ListGenerator",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "The model to use for string generation."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The user prompt"
        },
        {
          "name": "input_text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Input Text",
          "description": "The input text to be analyzed by the agent."
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 100000.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "items"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "index"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "list"
        }
      ],
      "basic_fields": [
        "prompt",
        "model"
      ]
    },
    {
      "title": "SVGGenerator",
      "description": "LLM Agent to create SVG elements based on user prompts.\n    svg, generator, vector, graphics\n\n    Use cases:\n    - Creating vector graphics from text descriptions\n    - Generating scalable illustrations\n    - Creating custom icons and diagrams",
      "namespace": "nodetool.generators",
      "node_type": "nodetool.generators.SVGGenerator",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "The language model to use for SVG generation."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The user prompt for SVG generation"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "Image to use for generation"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "Audio to use for generation"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 8192,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 100000.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "svg_element"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "image",
        "audio",
        "model"
      ]
    },
    {
      "title": "Asset Folder Input",
      "description": "Accepts an asset folder as a parameter for workflows.\n    input, parameter, folder, path, folderpath, local_folder, filesystem",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.AssetFolderInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "folder"
          },
          "default": {},
          "title": "Value",
          "description": "The folder to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "folder"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Audio Input",
      "description": "Accepts a reference to an audio asset for workflows, specified by an 'AudioRef'.  An 'AudioRef' points to audio data that can be used for playback, transcription, analysis, or processing by audio-capable models.\n    input, parameter, audio, sound, voice, speech, asset\n\n    Use cases:\n    - Load an audio file for speech-to-text transcription.\n    - Analyze sound for specific events or characteristics.\n    - Provide audio input to models for tasks like voice recognition or music generation.\n    - Process audio for enhancement or feature extraction.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.AudioInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Value",
          "description": "The audio to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        },
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Boolean Input",
      "description": "Accepts a boolean (true/false) value as a parameter for workflows.  This input is used for binary choices, enabling or disabling features, or controlling conditional logic paths.\n    input, parameter, boolean, bool, toggle, switch, flag\n\n    Use cases:\n    - Toggle features or settings on or off.\n    - Set binary flags to control workflow behavior.\n    - Make conditional choices within a workflow (e.g., proceed if true).",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.BooleanInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Chat Input",
      "description": "Accepts a list of chat messages as input for workflows, typically representing a conversation history.  The input is structured as a sequence of 'Message' objects. The node processes this list to extract elements like the latest message content (text, image, audio, video, document), the history, and any associated tool calls.\n    input, parameter, chat, message, conversation, prompt, history\n\n    Use cases:\n    - Provide user prompts or queries to a language model.\n    - Supply conversational context (history) for multi-turn interactions.\n    - Capture complex inputs that include text alongside other media types or tool requests.\n    - Initiate or continue a chat-based workflow.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.ChatInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "message"
              }
            ]
          },
          "default": [],
          "title": "Value",
          "description": "The chat message to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "message"
              }
            ]
          },
          "name": "history"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "image"
          },
          "name": "image"
        },
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        },
        {
          "type": {
            "type": "video"
          },
          "name": "video"
        },
        {
          "type": {
            "type": "document"
          },
          "name": "document"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tool_name"
              }
            ]
          },
          "name": "tools"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Collection Input",
      "description": "Accepts a reference to a specific data collection, typically within a vector database or similar storage system.\n    The input is a 'Collection' object, which identifies the target collection for operations like data insertion, querying, or similarity search.\n    Keywords: input, parameter, collection, database, vector_store, chroma, index\n\n    Use cases:\n    - Select a target vector database collection for indexing new documents.\n    - Specify a collection to perform a similarity search or query against.\n    - Choose a data source or destination that is represented as a named collection.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.CollectionInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Value",
          "description": "The collection to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "collection"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Color Input",
      "description": "Accepts a color value as a parameter for workflows.\n    input, parameter, color, color_picker, color_input",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.ColorInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "color"
          },
          "default": {},
          "title": "Value",
          "description": "The color to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "color"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Document File Input",
      "description": "Accepts a local file path pointing to a document and converts it into a 'DocumentRef'.  This node is a utility for loading a document directly from the local filesystem for use in workflows. It outputs both the 'DocumentRef' for the loaded document and the original 'FilePath'.  Note: This input type is generally not available in production environments due to filesystem access restrictions.\n    input, parameter, document, file, path, local_file, load\n\n    Use cases:\n    - Directly load a document (e.g., PDF, TXT, DOCX) from a specified local file path.\n    - Convert a local file path into a 'DocumentRef' that can be consumed by other document-processing nodes.\n    - Useful for development or workflows that have legitimate access to the local filesystem.\n    - To provide an existing 'DocumentRef', use 'DocumentInput'.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.DocumentFileInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Value",
          "description": "The path to the document file."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "document"
        },
        {
          "type": {
            "type": "file_path"
          },
          "name": "path"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Document Input",
      "description": "Accepts a reference to a document asset for workflows, specified by a 'DocumentRef'.  A 'DocumentRef' points to a structured document (e.g., PDF, DOCX, TXT) which can be processed or analyzed. This node is used when the workflow needs to operate on a document as a whole entity, potentially including its structure and metadata, rather than just raw text.\n    input, parameter, document, file, asset, reference\n\n    Use cases:\n    - Load a specific document (e.g., PDF, Word, text file) for content extraction or analysis.\n    - Pass a document to models that are designed to process specific document formats.\n    - Manage documents as distinct assets within a workflow.\n    - If you have a local file path and need to convert it to a 'DocumentRef', consider using 'DocumentFileInput'.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.DocumentInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Value",
          "description": "The document to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "File Path Input",
      "description": "Accepts a file path as a parameter for workflows.\n    input, parameter, file, path, filepath, local_file, filesystem",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.FilePathInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Value",
          "description": "The file path to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "file_path"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Float Input",
      "description": "Accepts a floating-point number as a parameter for workflows, typically constrained by a minimum and maximum value.  This input allows for precise numeric settings, such as adjustments, scores, or any value requiring decimal precision.\n    input, parameter, float, number, decimal, range\n\n    Use cases:\n    - Specify a numeric value within a defined range (e.g., 0.0 to 1.0).\n    - Set thresholds, confidence scores, or scaling factors.\n    - Configure continuous parameters like opacity, volume, or temperature.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.FloatInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        },
        {
          "name": "min",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Min"
        },
        {
          "name": "max",
          "type": {
            "type": "float"
          },
          "default": 100,
          "title": "Max"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Folder Path Input",
      "description": "Accepts a folder path as a parameter for workflows.\n    input, parameter, folder, path, folderpath, local_folder, filesystem",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.FolderPathInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Value",
          "description": "The folder path to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "file_path"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Hugging Face Model Input",
      "description": "Accepts a Hugging Face model as a parameter for workflows.\n    input, parameter, model, huggingface, hugging_face, model_name",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.HuggingFaceModelInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "hf.model"
          },
          "default": {},
          "title": "Value",
          "description": "The Hugging Face model to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "hf.model"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Image Input",
      "description": "Accepts a reference to an image asset for workflows, specified by an 'ImageRef'.  An 'ImageRef' points to image data that can be used for display, analysis, or processing by vision models.\n    input, parameter, image, picture, graphic, visual, asset\n\n    Use cases:\n    - Load an image for visual processing or analysis.\n    - Provide an image as input to computer vision models (e.g., object detection, image classification).\n    - Select an image for manipulation, enhancement, or inclusion in a document.\n    - Display an image within a workflow interface.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.ImageInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Value",
          "description": "The image to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Inference Provider Input",
      "description": "Accepts an inference provider as a parameter for workflows.\n    input, parameter, provider, inference, provider_name",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.InferenceProviderInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "enum",
            "values": [
              "",
              "black-forest-labs",
              "cerebras",
              "cohere",
              "fal-ai",
              "featherless-ai",
              "fireworks-ai",
              "groq",
              "hf-inference",
              "hyperbolic",
              "nebius",
              "novita",
              "nscale",
              "openai",
              "replicate",
              "sambanova",
              "together"
            ],
            "type_name": "nodetool.metadata.types.InferenceProvider"
          },
          "default": "",
          "title": "Value",
          "description": "The inference provider to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "enum",
            "values": [
              "",
              "black-forest-labs",
              "cerebras",
              "cohere",
              "fal-ai",
              "featherless-ai",
              "fireworks-ai",
              "groq",
              "hf-inference",
              "hyperbolic",
              "nebius",
              "novita",
              "nscale",
              "openai",
              "replicate",
              "sambanova",
              "together"
            ],
            "type_name": "nodetool.metadata.types.InferenceProvider"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Integer Input",
      "description": "Accepts an integer (whole number) as a parameter for workflows, typically constrained by a minimum and maximum value.  This input is used for discrete numeric values like counts, indices, or iteration limits.\n    input, parameter, integer, number, count, index, whole_number\n\n    Use cases:\n    - Specify counts or quantities (e.g., number of items, iterations).\n    - Set index values for accessing elements in a list or array.\n    - Configure discrete numeric parameters like age, steps, or quantity.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.IntegerInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        },
        {
          "name": "min",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Min"
        },
        {
          "name": "max",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Max"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Language Model Input",
      "description": "Accepts a language model as a parameter for workflows.\n    input, parameter, model, language, model_name",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.LanguageModelInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Value",
          "description": "The language model to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "language_model"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Path Input",
      "description": "Accepts a local filesystem path (to a file or directory) as input for workflows.  This input provides a 'FilePath' object. Its usage is typically restricted to non-production environments due to security considerations around direct filesystem access.\n    input, parameter, path, filepath, directory, local_file, filesystem\n\n    Use cases:\n    - Provide a local path to a specific file or directory for processing.\n    - Specify an input or output location on the local filesystem for a development task.\n    - Load local datasets or configuration files not managed as assets.\n    - Not available in production: raises an error if used in a production environment.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.PathInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Value",
          "description": "The path to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "file_path"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Realtime Audio Input",
      "description": "Accepts streaming audio data for workflows.\n    input, parameter, audio, sound, voice, speech, asset",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.RealtimeAudioInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "title": "Value",
          "description": "The value of the input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio to use as input."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        }
      ],
      "basic_fields": [
        "name",
        "value",
        "audio"
      ]
    },
    {
      "title": "String Input",
      "description": "Accepts a string value as a parameter for workflows.\n    input, parameter, string, text, label, name, value\n\n    Use cases:\n    - Define a name for an entity or process.\n    - Specify a label for a component or output.\n    - Enter a short keyword or search term.\n    - Provide a simple configuration value (e.g., an API key, a model name).\n    - If you need to input multi-line text or the content of a file, use 'DocumentFileInput'.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.StringInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "String List Input",
      "description": "Accepts a list of strings as a parameter for workflows.\n    input, parameter, string, text, label, name, value",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.StringListInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "title": "Value",
          "description": "The list of strings to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Video Input",
      "description": "Accepts a reference to a video asset for workflows, specified by a 'VideoRef'.  A 'VideoRef' points to video data that can be used for playback, analysis, frame extraction, or processing by video-capable models.\n    input, parameter, video, movie, clip, visual, asset\n\n    Use cases:\n    - Load a video file for processing or content analysis.\n    - Analyze video content for events, objects, or speech.\n    - Extract frames or audio tracks from a video.\n    - Provide video input to models that understand video data.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.VideoInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Value",
          "description": "The video to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Split Text into Chunks",
      "description": "Splits text into chunks of specified word length.\n    text, chunk, split\n\n    Use cases:\n    - Preparing text for processing by models with input length limits\n    - Creating manageable text segments for parallel processing\n    - Generating summaries of text sections",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Chunk",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "length",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Length",
          "min": 1.0,
          "max": 1000.0
        },
        {
          "name": "overlap",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Overlap"
        },
        {
          "name": "separator",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Separator"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "length",
        "overlap",
        "separator"
      ]
    },
    {
      "title": "Collect",
      "description": "Collects a stream of text inputs into a single string.\n    text, collect, list, stream",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Collect",
      "properties": [
        {
          "name": "input_item",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Input Item"
        },
        {
          "name": "separator",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Separator"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_item",
        "separator"
      ]
    },
    {
      "title": "Concatenate Text",
      "description": "Concatenates two text inputs into a single output.\n    text, concatenation, combine, +\n\n    Use cases:\n    - Joining outputs from multiple text processing nodes\n    - Combining parts of sentences or paragraphs\n    - Merging text data from different sources",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Concat",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ]
    },
    {
      "title": "Contains Text",
      "description": "Checks if text contains a specified substring.\n    text, check, contains, compare, validate, substring, string\n\n    Use cases:\n    - Searching for keywords in text\n    - Filtering content based on presence of terms\n    - Validating text content",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Contains",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "substring",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Substring"
        },
        {
          "name": "case_sensitive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Case Sensitive"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "substring",
        "case_sensitive"
      ]
    },
    {
      "title": "Count Tokens",
      "description": "Counts the number of tokens in text using tiktoken.\n    text, tokens, count, encoding\n\n    Use cases:\n    - Checking text length for LLM input limits\n    - Estimating API costs\n    - Managing token budgets in text processing",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.CountTokens",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "encoding",
          "type": {
            "type": "enum",
            "values": [
              "cl100k_base",
              "p50k_base",
              "r50k_base"
            ],
            "type_name": "nodetool.nodes.nodetool.text.TiktokenEncoding"
          },
          "default": "cl100k_base",
          "title": "Encoding",
          "description": "The tiktoken encoding to use for token counting"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "encoding"
      ]
    },
    {
      "title": "Ends With",
      "description": "Checks if text ends with a specified suffix.\n    text, check, suffix, compare, validate, substring, string\n\n    Use cases:\n    - Validating file extensions\n    - Checking string endings\n    - Filtering text based on ending content",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.EndsWith",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "suffix",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Suffix"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "suffix"
      ]
    },
    {
      "title": "Extract Text",
      "description": "Extracts a substring from input text.\n    text, extract, substring\n\n    Use cases:\n    - Extracting specific portions of text for analysis\n    - Trimming unwanted parts from text data\n    - Focusing on relevant sections of longer documents",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Extract",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start"
        },
        {
          "name": "end",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "End"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "start",
        "end"
      ]
    },
    {
      "title": "Extract JSON",
      "description": "Extracts data from JSON using JSONPath expressions.\n    json, extract, jsonpath\n\n    Use cases:\n    - Retrieving specific fields from complex JSON structures\n    - Filtering and transforming JSON data for analysis\n    - Extracting nested data from API responses or configurations",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.ExtractJSON",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "JSON Text"
        },
        {
          "name": "json_path",
          "type": {
            "type": "str"
          },
          "default": "$.*",
          "title": "JSONPath Expression"
        },
        {
          "name": "find_all",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Find All"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "json_path",
        "find_all"
      ]
    },
    {
      "title": "Extract Regex Groups",
      "description": "Extracts substrings matching regex groups from text.\n    text, regex, extract\n\n    Use cases:\n    - Extracting structured data (e.g., dates, emails) from unstructured text\n    - Parsing specific patterns in log files or documents\n    - Isolating relevant information from complex text formats",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.ExtractRegex",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "regex",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Regex"
        },
        {
          "name": "dotall",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Dotall"
        },
        {
          "name": "ignorecase",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Ignorecase"
        },
        {
          "name": "multiline",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Multiline"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "regex",
        "dotall",
        "ignorecase",
        "multiline"
      ]
    },
    {
      "title": "Find All Regex Matches",
      "description": "Finds all regex matches in text as separate substrings.\n    text, regex, find\n\n    Use cases:\n    - Identifying all occurrences of a pattern in text\n    - Extracting multiple instances of structured data\n    - Analyzing frequency and distribution of specific text patterns",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.FindAllRegex",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "regex",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Regex"
        },
        {
          "name": "dotall",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Dotall"
        },
        {
          "name": "ignorecase",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Ignorecase"
        },
        {
          "name": "multiline",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Multiline"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "regex",
        "dotall",
        "ignorecase",
        "multiline"
      ]
    },
    {
      "title": "Format Text",
      "description": "Replaces placeholders in a string with dynamic inputs using Jinja2 templating.\n    text, template, formatting\n\n    This node is dynamic and can be used to format text with dynamic properties.\n\n    Use cases:\n    - Generating personalized messages with dynamic content\n    - Creating parameterized queries or commands\n    - Formatting and filtering text output based on variable inputs\n\n    Examples:\n    - text: \"Hello, {{ name }}!\"\n    - text: \"Title: {{ title|truncate(20) }}\"\n    - text: \"Name: {{ name|upper }}\"\n\n    Available filters:\n    - truncate(length): Truncates text to given length\n    - upper: Converts text to uppercase\n    - lower: Converts text to lowercase\n    - title: Converts text to title case\n    - trim: Removes whitespace from start/end\n    - replace(old, new): Replaces substring\n    - default(value): Sets default if value is undefined\n    - first: Gets first character/item\n    - last: Gets last character/item\n    - length: Gets length of string/list\n    - sort: Sorts list\n    - join(delimiter): Joins list with delimiter",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.FormatText",
      "properties": [
        {
          "name": "template",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Template",
          "description": "\n    Examples:\n    - text: \"Hello, {{ name }}!\"\n    - text: \"Title: {{ title|truncate(20) }}\"\n    - text: \"Name: {{ name|upper }}\" \n\n    Available filters:\n    - truncate(length): Truncates text to given length\n    - upper: Converts text to uppercase\n    - lower: Converts text to lowercase\n    - title: Converts text to title case\n    - trim: Removes whitespace from start/end\n    - replace(old, new): Replaces substring\n    - default(value): Sets default if value is undefined\n    - first: Gets first character/item\n    - last: Gets last character/item\n    - length: Gets length of string/list\n    - sort: Sorts list\n    - join(delimiter): Joins list with delimiter\n"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "template"
      ]
    },
    {
      "title": "Check Length",
      "description": "Checks if text length meets specified conditions.\n    text, check, length, compare, validate, whitespace, string\n\n    Use cases:\n    - Validating input length requirements\n    - Filtering text by length\n    - Checking content size constraints",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.HasLength",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "min_length",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Minimum Length"
        },
        {
          "name": "max_length",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Maximum Length"
        },
        {
          "name": "exact_length",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Exact Length"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "min_length",
        "max_length",
        "exact_length"
      ]
    },
    {
      "title": "HTML to Text",
      "description": "Converts HTML content to plain text using html2text.\n    html, convert, text, parse, extract\n\n    Use cases:\n    - Converting HTML documents to readable plain text\n    - Extracting text content from web pages\n    - Cleaning HTML markup from text data\n    - Processing HTML emails or documents",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.HtmlToText",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "HTML",
          "description": "HTML content to convert"
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base URL",
          "description": "Base URL for resolving relative links"
        },
        {
          "name": "body_width",
          "type": {
            "type": "int"
          },
          "default": 1000,
          "title": "Body Width",
          "description": "Width for text wrapping"
        },
        {
          "name": "ignore_images",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Ignore Images",
          "description": "Whether to ignore image tags"
        },
        {
          "name": "ignore_mailto_links",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Ignore Mailto Links",
          "description": "Whether to ignore mailto links"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "html",
        "base_url",
        "body_width",
        "ignore_images",
        "ignore_mailto_links"
      ]
    },
    {
      "title": "Is Empty",
      "description": "Checks if text is empty or contains only whitespace.\n    text, check, empty, compare, validate, whitespace, string\n\n    Use cases:\n    - Validating required text fields\n    - Filtering out empty content\n    - Checking for meaningful input",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.IsEmpty",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "trim_whitespace",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Trim Whitespace"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "trim_whitespace"
      ]
    },
    {
      "title": "Join",
      "description": "Joins a list of strings into a single string using a specified separator.\n    text, join, combine, +, add, concatenate\n\n    Use cases:\n    - Combining multiple text elements with a consistent delimiter\n    - Creating comma-separated lists from individual items\n    - Assembling formatted text from array elements",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Join",
      "properties": [
        {
          "name": "strings",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Strings"
        },
        {
          "name": "separator",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Separator"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "strings",
        "separator"
      ]
    },
    {
      "title": "Load Text Assets",
      "description": "Load text files from an asset folder.\n    load, text, file, import\n\n    Use cases:\n    - Loading multiple text files for batch processing\n    - Importing text content from a directory\n    - Processing collections of text documents",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.LoadTextAssets",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {},
          "title": "Folder",
          "description": "The asset folder to load the text files from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "text"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        }
      ],
      "basic_fields": [
        "folder"
      ]
    },
    {
      "title": "Parse JSON String",
      "description": "Parses a JSON string into a Python object.\n    json, parse, convert\n\n    Use cases:\n    - Converting JSON API responses for further processing\n    - Preparing structured data for analysis or storage\n    - Extracting configuration or settings from JSON files",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.ParseJSON",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "JSON string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ]
    },
    {
      "title": "Find Regex Matches",
      "description": "Find all matches of a regex pattern in text.\n    regex, search, pattern, match\n\n    Use cases:\n    - Extract specific patterns from text\n    - Validate text against patterns\n    - Find all occurrences of a pattern",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.RegexMatch",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to search in"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "Regular expression pattern"
        },
        {
          "name": "group",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Group",
          "description": "Capture group to extract (0 for full match)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "pattern",
        "group"
      ]
    },
    {
      "title": "Replace with Regex",
      "description": "Replace text matching a regex pattern.\n    regex, replace, substitute\n\n    Use cases:\n    - Clean or standardize text\n    - Remove unwanted patterns\n    - Transform text formats",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.RegexReplace",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to perform replacements on"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "Regular expression pattern"
        },
        {
          "name": "replacement",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Replacement",
          "description": "Replacement text"
        },
        {
          "name": "count",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Count",
          "description": "Maximum replacements (0 for unlimited)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "pattern",
        "replacement",
        "count"
      ]
    },
    {
      "title": "Split with Regex",
      "description": "Split text using a regex pattern as delimiter.\n    regex, split, tokenize\n\n    Use cases:\n    - Parse structured text\n    - Extract fields from formatted strings\n    - Tokenize text",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.RegexSplit",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to split"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "Regular expression pattern to split on"
        },
        {
          "name": "maxsplit",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Maxsplit",
          "description": "Maximum number of splits (0 for unlimited)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "pattern",
        "maxsplit"
      ]
    },
    {
      "title": "Validate with Regex",
      "description": "Check if text matches a regex pattern.\n    regex, validate, check\n\n    Use cases:\n    - Validate input formats (email, phone, etc)\n    - Check text structure\n    - Filter text based on patterns",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.RegexValidate",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to validate"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "Regular expression pattern"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "pattern"
      ]
    },
    {
      "title": "Replace Text",
      "description": "Replaces a substring in a text with another substring.\n    text, replace, substitute\n\n    Use cases:\n    - Correcting or updating specific text patterns\n    - Sanitizing or normalizing text data\n    - Implementing simple text transformations",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Replace",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "old",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Old"
        },
        {
          "name": "new",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "New"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "old",
        "new"
      ]
    },
    {
      "title": "Save Text",
      "description": "Saves input text to a file in the assets folder.\n    text, save, file\n\n    Use cases:\n    - Persisting processed text results\n    - Creating text files for downstream nodes or external use\n    - Archiving text data within the workflow",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.SaveText",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {},
          "title": "Folder",
          "description": "Name of the output folder."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d-%H-%M-%S.txt",
          "title": "Name",
          "description": "\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "text"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "folder",
        "name"
      ]
    },
    {
      "title": "Save Text File",
      "description": "Saves input text to a file in the assets folder.\n    text, save, file",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.SaveTextFile",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {},
          "title": "Folder",
          "description": "Name of the output folder."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d-%H-%M-%S.txt",
          "title": "Name",
          "description": "\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "text"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "folder",
        "name"
      ]
    },
    {
      "title": "Slice Text",
      "description": "Slices text using Python's slice notation (start:stop:step).\n    text, slice, substring\n\n    Use cases:\n    - Extracting specific portions of text with flexible indexing\n    - Reversing text using negative step\n    - Taking every nth character with step parameter\n\n    Examples:\n    - start=0, stop=5: first 5 characters\n    - start=-5: last 5 characters\n    - step=2: every second character\n    - step=-1: reverse the text",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Slice",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "start",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Start Index"
        },
        {
          "name": "stop",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Stop Index"
        },
        {
          "name": "step",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Step"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "start",
        "stop",
        "step"
      ]
    },
    {
      "title": "Split Text",
      "description": "Separates text into a list of strings based on a specified delimiter.\n    text, split, tokenize\n\n    Use cases:\n    - Parsing CSV or similar delimited data\n    - Breaking down sentences into words or phrases\n    - Extracting specific elements from structured text",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Split",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "delimiter",
          "type": {
            "type": "str"
          },
          "default": ",",
          "title": "Delimiter"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "delimiter"
      ]
    },
    {
      "title": "Starts With",
      "description": "Checks if text starts with a specified prefix.\n    text, check, prefix, compare, validate, substring, string\n\n    Use cases:\n    - Validating string prefixes\n    - Filtering text based on starting content\n    - Checking file name patterns",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.StartsWith",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "prefix",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prefix"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "prefix"
      ]
    },
    {
      "title": "Template",
      "description": "Uses Jinja2 templating to format strings with variables and filters.\n    text, template, formatting, format, combine, concatenate, +, add, variable, replace, filter\n\n    Use cases:\n    - Generating personalized messages with dynamic content\n    - Creating parameterized queries or commands\n    - Formatting and filtering text output based on variable inputs\n\n    Examples:\n    - text: \"Hello, {{ name }}!\"\n    - text: \"Title: {{ title|truncate(20) }}\"\n    - text: \"Name: {{ name|upper }}\"\n\n    Available filters:\n    - truncate(length): Truncates text to given length\n    - upper: Converts text to uppercase\n    - lower: Converts text to lowercase\n    - title: Converts text to title case\n    - trim: Removes whitespace from start/end\n    - replace(old, new): Replaces substring\n    - default(value): Sets default if value is undefined\n    - first: Gets first character/item\n    - last: Gets last character/item\n    - length: Gets length of string/list\n    - sort: Sorts list\n    - join(delimiter): Joins list with delimiter",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Template",
      "properties": [
        {
          "name": "string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "String",
          "description": "\n    Examples:\n    - text: \"Hello, {{ name }}!\"\n    - text: \"Title: {{ title|truncate(20) }}\"\n    - text: \"Name: {{ name|upper }}\"\n\n    Available filters:\n    - truncate(length): Truncates text to given length\n    - upper: Converts text to uppercase\n    - lower: Converts text to lowercase\n    - title: Converts text to title case\n    - trim: Removes whitespace from start/end\n    - replace(old, new): Replaces substring\n    - default(value): Sets default if value is undefined\n    - first: Gets first character/item\n    - last: Gets last character/item\n    - length: Gets length of string/list\n    - sort: Sorts list\n    - join(delimiter): Joins list with delimiter\n"
        },
        {
          "name": "values",
          "type": {
            "type": "any"
          },
          "default": {},
          "title": "Values",
          "description": "\n        The values to replace in the string.\n        - If a string, it will be used as the format string.\n        - If a list, it will be used as the format arguments.\n        - If a dictionary, it will be used as the template variables.\n        - If an object, it will be converted to a dictionary using the object's __dict__ method.\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "string",
        "values"
      ]
    },
    {
      "title": "List Documents",
      "description": "List documents in a directory.\n    files, list, directory",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.ListDocuments",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {
            "path": "~"
          },
          "title": "Folder",
          "description": "Directory to scan"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "*",
          "title": "Pattern",
          "description": "File pattern to match (e.g. *.txt)"
        },
        {
          "name": "recursive",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Recursive",
          "description": "Search subdirectories"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "document"
        }
      ],
      "basic_fields": [
        "folder",
        "pattern",
        "recursive"
      ]
    },
    {
      "title": "Load Document File",
      "description": "Read a document from disk.\n    files, document, read, input, load, file",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.LoadDocumentFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to the document to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Split Markdown",
      "description": "Splits markdown text by headers while preserving header hierarchy in metadata.\n    markdown, split, headers\n\n    Use cases:\n    - Splitting markdown documentation while preserving structure\n    - Processing markdown files for semantic search\n    - Creating context-aware chunks from markdown content",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitMarkdown",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Document"
        },
        {
          "name": "headers_to_split_on",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tuple",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "default": [
            [
              "#",
              "Header 1"
            ],
            [
              "##",
              "Header 2"
            ],
            [
              "###",
              "Header 3"
            ]
          ],
          "title": "Headers To Split On",
          "description": "List of tuples containing (header_symbol, header_name)"
        },
        {
          "name": "strip_headers",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Strip Headers",
          "description": "Whether to remove headers from the output content"
        },
        {
          "name": "return_each_line",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Return Each Line",
          "description": "Whether to split into individual lines instead of header sections"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Chunk Size",
          "description": "Optional maximum chunk size for further splitting"
        },
        {
          "name": "chunk_overlap",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Chunk Overlap",
          "description": "Overlap size when using chunk_size"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "text_chunk"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "document",
        "headers_to_split_on",
        "strip_headers",
        "return_each_line",
        "chunk_size",
        "chunk_overlap"
      ]
    },
    {
      "title": "Save Document File",
      "description": "Write a document to disk.\n    files, document, write, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SaveDocumentFile",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Document",
          "description": "The document to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {},
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Name of the file to save. Supports strftime format codes."
        }
      ],
      "basic_fields": [
        "document",
        "folder",
        "filename"
      ]
    },
    {
      "title": "Split Document",
      "description": "Split text semantically.\n    chroma, embedding, collection, RAG, index, text, markdown, semantic",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitDocument",
      "properties": [
        {
          "name": "embed_model",
          "type": {
            "type": "llama_model"
          },
          "default": {},
          "title": "Embed Model",
          "description": "Embedding model to use"
        },
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Document",
          "description": "Document ID to associate with the text content"
        },
        {
          "name": "buffer_size",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Buffer Size",
          "description": "Buffer size for semantic splitting",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "threshold",
          "type": {
            "type": "int"
          },
          "default": 95,
          "title": "Threshold",
          "description": "Breakpoint percentile threshold for semantic splitting",
          "min": 0.0,
          "max": 100.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "embed_model",
        "document",
        "buffer_size",
        "threshold"
      ]
    },
    {
      "title": "Split HTML",
      "description": "Split HTML content into semantic chunks based on HTML tags.\n    html, text, semantic, tags, parsing",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitHTML",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Document",
          "description": "Document ID to associate with the HTML content"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "document"
      ]
    },
    {
      "title": "Split JSON",
      "description": "Split JSON content into semantic chunks.\n    json, parsing, semantic, structured",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitJSON",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Document",
          "description": "Document ID to associate with the JSON content"
        },
        {
          "name": "include_metadata",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Include Metadata",
          "description": "Whether to include metadata in nodes"
        },
        {
          "name": "include_prev_next_rel",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Include Prev Next Rel",
          "description": "Whether to include prev/next relationships"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "text_chunk"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "document",
        "include_metadata",
        "include_prev_next_rel"
      ]
    },
    {
      "title": "Split Markdown",
      "description": "Splits markdown text by headers while preserving header hierarchy in metadata.\n    markdown, split, headers\n\n    Use cases:\n    - Splitting markdown documentation while preserving structure\n    - Processing markdown files for semantic search\n    - Creating context-aware chunks from markdown content",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitMarkdown",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Document"
        },
        {
          "name": "headers_to_split_on",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tuple",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "default": [
            [
              "#",
              "Header 1"
            ],
            [
              "##",
              "Header 2"
            ],
            [
              "###",
              "Header 3"
            ]
          ],
          "title": "Headers To Split On",
          "description": "List of tuples containing (header_symbol, header_name)"
        },
        {
          "name": "strip_headers",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Strip Headers",
          "description": "Whether to remove headers from the output content"
        },
        {
          "name": "return_each_line",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Return Each Line",
          "description": "Whether to split into individual lines instead of header sections"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Chunk Size",
          "description": "Optional maximum chunk size for further splitting"
        },
        {
          "name": "chunk_overlap",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Chunk Overlap",
          "description": "Overlap size when using chunk_size"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "text_chunk"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "document",
        "headers_to_split_on",
        "strip_headers",
        "return_each_line",
        "chunk_size",
        "chunk_overlap"
      ]
    },
    {
      "title": "Split Recursively",
      "description": "Splits text recursively using LangChain's RecursiveCharacterTextSplitter.\n    text, split, chunks\n\n    Use cases:\n    - Splitting documents while preserving semantic relationships\n    - Creating chunks for language model processing\n    - Handling text in languages with/without word boundaries",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitRecursively",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Document"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 1000,
          "title": "Chunk Size",
          "description": "Maximum size of each chunk in characters"
        },
        {
          "name": "chunk_overlap",
          "type": {
            "type": "int"
          },
          "default": 200,
          "title": "Chunk Overlap",
          "description": "Number of characters to overlap between chunks"
        },
        {
          "name": "separators",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [
            "\n\n",
            "\n",
            "."
          ],
          "title": "Separators",
          "description": "List of separators to use for splitting, in order of preference"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "text_chunk"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "document",
        "chunk_size",
        "chunk_overlap",
        "separators"
      ]
    },
    {
      "title": "Split into Sentences",
      "description": "Splits text into sentences using LangChain's SentenceTransformersTokenTextSplitter.\n    sentences, split, nlp\n\n    Use cases:\n    - Natural sentence-based text splitting\n    - Creating semantically meaningful chunks\n    - Processing text for sentence-level analysis",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitSentences",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Document"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 40,
          "title": "Chunk Size",
          "description": "Maximum number of tokens per chunk"
        },
        {
          "name": "chunk_overlap",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "Chunk Overlap",
          "description": "Number of tokens to overlap between chunks"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "text_chunk"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "document",
        "chunk_size",
        "chunk_overlap"
      ]
    },
    {
      "title": "Audio Mixer",
      "description": "Mix up to 5 audio tracks together with individual volume controls.\n    audio, mix, volume, combine, blend, layer, add, overlay\n\n    Use cases:\n    - Mix multiple audio tracks into a single output\n    - Create layered soundscapes\n    - Combine music, voice, and sound effects\n    - Adjust individual track volumes",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.AudioMixer",
      "properties": [
        {
          "name": "track1",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Track1",
          "description": "First audio track to mix."
        },
        {
          "name": "track2",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Track2",
          "description": "Second audio track to mix."
        },
        {
          "name": "track3",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Track3",
          "description": "Third audio track to mix."
        },
        {
          "name": "track4",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Track4",
          "description": "Fourth audio track to mix."
        },
        {
          "name": "track5",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Track5",
          "description": "Fifth audio track to mix."
        },
        {
          "name": "volume1",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume1",
          "description": "Volume for track 1. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "volume2",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume2",
          "description": "Volume for track 2. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "volume3",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume3",
          "description": "Volume for track 3. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "volume4",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume4",
          "description": "Volume for track 4. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "volume5",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume5",
          "description": "Volume for track 5. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "track1",
        "track2",
        "track3",
        "track4",
        "track5",
        "volume1",
        "volume2",
        "volume3",
        "volume4",
        "volume5"
      ]
    },
    {
      "title": "Concat",
      "description": "Concatenates two audio files together.\n    audio, edit, join, +\n\n    Use cases:\n    - Combine multiple audio clips into a single file\n    - Create longer audio tracks from shorter segments",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.Concat",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "A",
          "description": "The first audio file."
        },
        {
          "name": "b",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "B",
          "description": "The second audio file."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Concat List",
      "description": "Concatenates multiple audio files together in sequence.\n    audio, edit, join, multiple, +\n\n    Use cases:\n    - Combine multiple audio clips into a single file\n    - Create longer audio tracks from multiple segments\n    - Chain multiple audio files in order",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.ConcatList",
      "properties": [
        {
          "name": "audio_files",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "audio"
              }
            ]
          },
          "default": [],
          "title": "Audio Files",
          "description": "List of audio files to concatenate in sequence."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio_files"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Convert To Array",
      "description": "Converts an audio file to a Array for further processing.\n    audio, conversion, tensor\n\n    Use cases:\n    - Prepare audio data for machine learning models\n    - Enable signal processing operations on audio\n    - Convert audio to a format suitable for spectral analysisr",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.ConvertToArray",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio file to convert to a tensor."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio"
      ]
    },
    {
      "title": "Create Silence",
      "description": "Creates a silent audio file with a specified duration.\n    audio, silence, empty\n\n    Use cases:\n    - Generate placeholder audio files\n    - Create audio segments for padding or spacing\n    - Add silence to the beginning or end of audio files",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.CreateSilence",
      "properties": [
        {
          "name": "duration",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Duration",
          "description": "The duration of the silence in seconds.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "duration"
      ]
    },
    {
      "title": "Fade In",
      "description": "Applies a fade-in effect to the beginning of an audio file.\n    audio, edit, transition\n\n    Use cases:\n    - Create smooth introductions to audio tracks\n    - Gradually increase volume at the start of a clip",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.FadeIn",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio file to apply fade-in to."
        },
        {
          "name": "duration",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Duration",
          "description": "Duration of the fade-in effect in seconds.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "duration"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Fade Out",
      "description": "Applies a fade-out effect to the end of an audio file.\n    audio, edit, transition\n\n    Use cases:\n    - Create smooth endings to audio tracks\n    - Gradually decrease volume at the end of a clip",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.FadeOut",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio file to apply fade-out to."
        },
        {
          "name": "duration",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Duration",
          "description": "Duration of the fade-out effect in seconds.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "duration"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Load Audio Assets",
      "description": "Load audio files from an asset folder.\n    load, audio, file, import",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.LoadAudioAssets",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {},
          "title": "Folder",
          "description": "The asset folder to load the audio files from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        }
      ],
      "basic_fields": [
        "folder"
      ]
    },
    {
      "title": "Load Audio File",
      "description": "Read an audio file from disk.\n    audio, input, load, file\n\n    Use cases:\n    - Load audio for processing\n    - Import sound files for editing\n    - Read audio assets for a workflow",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.LoadAudioFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to the audio file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Mono To Stereo",
      "description": "Converts a mono audio signal to stereo.\n    audio, convert, channels\n\n    Use cases:\n    - Expand mono recordings for stereo playback systems\n    - Prepare audio for further stereo processing",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.MonoToStereo",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The mono audio file to convert."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Normalize",
      "description": "Normalizes the volume of an audio file.\n    audio, fix, dynamics, volume\n\n    Use cases:\n    - Ensure consistent volume across multiple audio files\n    - Adjust overall volume level before further processing",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.Normalize",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio file to normalize."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Overlay Audio",
      "description": "Overlays two audio files together.\n    audio, edit, transform\n\n    Use cases:\n    - Mix background music with voice recording\n    - Layer sound effects over an existing audio track",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.OverlayAudio",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "A",
          "description": "The first audio file."
        },
        {
          "name": "b",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "B",
          "description": "The second audio file."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Remove Silence",
      "description": "Removes or shortens silence in an audio file with smooth transitions.\n    audio, edit, clean\n\n    Use cases:\n    - Trim silent parts from beginning/end of recordings\n    - Remove or shorten long pauses between speech segments\n    - Apply crossfade for smooth transitions",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.RemoveSilence",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio file to process."
        },
        {
          "name": "min_length",
          "type": {
            "type": "int"
          },
          "default": 200,
          "title": "Min Length",
          "description": "Minimum length of silence to be processed (in milliseconds).",
          "min": 0.0,
          "max": 10000.0
        },
        {
          "name": "threshold",
          "type": {
            "type": "int"
          },
          "default": -40,
          "title": "Threshold",
          "description": "Silence threshold in dB (relative to full scale). Higher values detect more silence.",
          "min": -60.0,
          "max": 0.0
        },
        {
          "name": "reduction_factor",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Reduction Factor",
          "description": "Factor to reduce silent parts (0.0 to 1.0). 0.0 keeps silence as is, 1.0 removes it completely.",
          "min": 0.0,
          "max": 1.0
        },
        {
          "name": "crossfade",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Crossfade",
          "description": "Duration of crossfade in milliseconds to apply between segments for smooth transitions.",
          "min": 0.0,
          "max": 50.0
        },
        {
          "name": "min_silence_between_parts",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Min Silence Between Parts",
          "description": "Minimum silence duration in milliseconds to maintain between non-silent segments",
          "min": 0.0,
          "max": 500.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "min_length",
        "threshold",
        "reduction_factor",
        "crossfade",
        "min_silence_between_parts"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Repeat",
      "description": "Loops an audio file a specified number of times.\n    audio, edit, repeat\n\n    Use cases:\n    - Create repeating background sounds or music\n    - Extend short audio clips to fill longer durations\n    - Generate rhythmic patterns from short samples",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.Repeat",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio file to loop."
        },
        {
          "name": "loops",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Loops",
          "description": "Number of times to loop the audio. Minimum 1 (plays once), maximum 100.",
          "min": 1.0,
          "max": 100.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "loops"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Reverse",
      "description": "Reverses an audio file.\n    audio, edit, transform\n\n    Use cases:\n    - Create reverse audio effects\n    - Generate backwards speech or music",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.Reverse",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio file to reverse."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Save Audio Asset",
      "description": "Save an audio file to a specified asset folder.\n    audio, folder, name\n\n    Use cases:\n    - Save generated audio files with timestamps\n    - Organize outputs into specific folders\n    - Create backups of generated audio",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.SaveAudio",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {},
          "title": "Folder",
          "description": "The asset folder to save the audio file to. "
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d-%H-%M-%S.opus",
          "title": "Name",
          "description": "\n        The name of the audio file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "folder",
        "name"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Save Audio File",
      "description": "Write an audio file to disk.\n    audio, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.SaveAudioFile",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {},
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "\n        Name of the file to save.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "folder",
        "filename"
      ]
    },
    {
      "title": "Slice Audio",
      "description": "Extracts a section of an audio file.\n    audio, edit, trim\n\n    Use cases:\n    - Cut out a specific clip from a longer audio file\n    - Remove unwanted portions from beginning or end",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.SliceAudio",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio file."
        },
        {
          "name": "start",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Start",
          "description": "The start time in seconds.",
          "min": 0.0
        },
        {
          "name": "end",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "End",
          "description": "The end time in seconds.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "start",
        "end"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Stereo To Mono",
      "description": "Converts a stereo audio signal to mono.\n    audio, convert, channels\n\n    Use cases:\n    - Reduce file size for mono-only applications\n    - Simplify audio for certain processing tasks",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.StereoToMono",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The stereo audio file to convert."
        },
        {
          "name": "method",
          "type": {
            "type": "str"
          },
          "default": "average",
          "title": "Method",
          "description": "Method to use for conversion: 'average', 'left', or 'right'."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "method"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Trim",
      "description": "Trim an audio file to a specified duration.\n    audio, trim, cut\n\n    Use cases:\n    - Remove silence from the beginning or end of audio files\n    - Extract specific segments from audio files\n    - Prepare audio data for machine learning models",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.Trim",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio file to trim."
        },
        {
          "name": "start",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Start",
          "description": "The start time of the trimmed audio in seconds.",
          "min": 0.0
        },
        {
          "name": "end",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "End",
          "description": "The end time of the trimmed audio in seconds.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "start",
        "end"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Audio",
      "description": "Represents an audio file constant in the workflow.\n    audio, file, mp3, wav\n\n    Use cases:\n    - Provide a fixed audio input for audio processing nodes\n    - Reference a specific audio file in the workflow\n    - Set default audio for testing or demonstration purposes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Audio",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Bool",
      "description": "Represents a boolean constant in the workflow.\n    boolean, logic, flag\n\n    Use cases:\n    - Control flow decisions in conditional nodes\n    - Toggle features or behaviors in the workflow\n    - Set default boolean values for configuration",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Bool",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Constant",
      "description": "Base class for fixed-value nodes.\n\n    constant, parameter, default\n\n    Use cases:\n    - Provide static inputs to a workflow\n    - Hold configuration values\n    - Simplify testing with deterministic outputs",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Constant",
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ]
    },
    {
      "title": "Data Frame",
      "description": "Represents a fixed DataFrame constant in the workflow.\n    table, data, dataframe, pandas\n\n    Use cases:\n    - Provide static data for analysis or processing\n    - Define lookup tables or reference data\n    - Set sample data for testing or demonstration",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.DataFrame",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "DataFrame"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Date",
      "description": "Make a date object from year, month, day.\n    date, make, create",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Date",
      "properties": [
        {
          "name": "year",
          "type": {
            "type": "int"
          },
          "default": 1900,
          "title": "Year",
          "description": "Year of the date"
        },
        {
          "name": "month",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Month",
          "description": "Month of the date"
        },
        {
          "name": "day",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Day",
          "description": "Day of the date"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "date"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "year",
        "month",
        "day"
      ]
    },
    {
      "title": "Date Time",
      "description": "Make a datetime object from year, month, day, hour, minute, second.\n    datetime, make, create",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.DateTime",
      "properties": [
        {
          "name": "year",
          "type": {
            "type": "int"
          },
          "default": 1900,
          "title": "Year",
          "description": "Year of the datetime"
        },
        {
          "name": "month",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Month",
          "description": "Month of the datetime"
        },
        {
          "name": "day",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Day",
          "description": "Day of the datetime"
        },
        {
          "name": "hour",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Hour",
          "description": "Hour of the datetime"
        },
        {
          "name": "minute",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Minute",
          "description": "Minute of the datetime"
        },
        {
          "name": "second",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Second",
          "description": "Second of the datetime"
        },
        {
          "name": "microsecond",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Microsecond",
          "description": "Microsecond of the datetime"
        },
        {
          "name": "tzinfo",
          "type": {
            "type": "str"
          },
          "default": "UTC",
          "title": "Tzinfo",
          "description": "Timezone of the datetime"
        },
        {
          "name": "utc_offset",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Utc Offset",
          "description": "UTC offset of the datetime"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "year",
        "month",
        "day",
        "hour",
        "minute",
        "second",
        "microsecond",
        "tzinfo",
        "utc_offset"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Dict",
      "description": "Represents a dictionary constant in the workflow.\n    dictionary, key-value, mapping\n\n    Use cases:\n    - Store configuration settings\n    - Provide structured data inputs\n    - Define parameter sets for other nodes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Dict",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Document",
      "description": "Represents a document constant in the workflow.\n    document, pdf, word, docx",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Document",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Document"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Float",
      "description": "Represents a floating-point number constant in the workflow.\n    number, decimal, float\n\n    Use cases:\n    - Set numerical parameters for calculations\n    - Define thresholds or limits\n    - Provide fixed numerical inputs for processing",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Float",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "Image",
      "description": "Represents an image file constant in the workflow.\n    picture, photo, image\n\n    Use cases:\n    - Provide a fixed image input for image processing nodes\n    - Reference a specific image file in the workflow\n    - Set default image for testing or demonstration purposes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Image",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Integer",
      "description": "Represents an integer constant in the workflow.\n    number, integer, whole\n\n    Use cases:\n    - Set numerical parameters for calculations\n    - Define counts, indices, or sizes\n    - Provide fixed numerical inputs for processing",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Integer",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "JSON",
      "description": "Represents a JSON constant in the workflow.\n    json, object, dictionary",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.JSON",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "json"
          },
          "default": {},
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "json"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "List",
      "description": "Represents a list constant in the workflow.\n    array, sequence, collection\n\n    Use cases:\n    - Store multiple values of the same type\n    - Provide ordered data inputs\n    - Define sequences for iteration in other nodes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.List",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "String",
      "description": "Represents a string constant in the workflow.\n    text, string, characters\n\n    Use cases:\n    - Provide fixed text inputs for processing\n    - Define labels, identifiers, or names\n    - Set default text values for configuration",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.String",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "Video",
      "description": "Represents a video file constant in the workflow.\n    video, movie, mp4, file\n\n    Use cases:\n    - Provide a fixed video input for video processing nodes\n    - Reference a specific video file in the workflow\n    - Set default video for testing or demonstration purposes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Video",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Arg Max",
      "description": "Returns the label associated with the highest value in a dictionary.\n    dictionary, maximum, label, argmax\n\n    Use cases:\n    - Get the most likely class from classification probabilities\n    - Find the category with highest score\n    - Identify the winner in a voting/ranking system",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.ArgMax",
      "properties": [
        {
          "name": "scores",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": {},
          "title": "Scores",
          "description": "Dictionary mapping labels to their corresponding scores/values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "scores"
      ]
    },
    {
      "title": "Combine",
      "description": "Merges two dictionaries, with second dictionary values taking precedence.\n    dictionary, merge, update, +, add, concatenate\n\n    Use cases:\n    - Combine default and custom configurations\n    - Merge partial updates with existing data\n    - Create aggregate data structures",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Combine",
      "properties": [
        {
          "name": "dict_a",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dict A"
        },
        {
          "name": "dict_b",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dict B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dict_a",
        "dict_b"
      ]
    },
    {
      "title": "Filter",
      "description": "Creates a new dictionary with only specified keys from the input.\n    dictionary, filter, select\n\n    Use cases:\n    - Extract relevant fields from a larger data structure\n    - Implement data access controls\n    - Prepare specific data subsets for processing",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Filter",
      "properties": [
        {
          "name": "dictionary",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dictionary"
        },
        {
          "name": "keys",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Keys"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dictionary",
        "keys"
      ]
    },
    {
      "title": "Get Value",
      "description": "Retrieves a value from a dictionary using a specified key.\n    dictionary, get, value, key\n\n    Use cases:\n    - Access a specific item in a configuration dictionary\n    - Retrieve a value from a parsed JSON object\n    - Extract a particular field from a data structure",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.GetValue",
      "properties": [
        {
          "name": "dictionary",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dictionary"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key"
        },
        {
          "name": "default",
          "type": {
            "type": "any"
          },
          "title": "Default"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dictionary",
        "key",
        "default"
      ]
    },
    {
      "title": "Load CSVFile",
      "description": "Read a CSV file from disk.\n    files, csv, read, input, load, file",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.LoadCSVFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to the CSV file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Make Dictionary",
      "description": "Creates a simple dictionary with up to three key-value pairs.\n    dictionary, create, simple\n\n    Use cases:\n    - Create configuration entries\n    - Initialize simple data structures\n    - Build basic key-value mappings",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.MakeDictionary",
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ]
    },
    {
      "title": "Parse JSON",
      "description": "Parses a JSON string into a Python dictionary.\n    json, parse, dictionary\n\n    Use cases:\n    - Process API responses\n    - Load configuration files\n    - Deserialize stored data",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.ParseJSON",
      "properties": [
        {
          "name": "json_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Json String"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "json_string"
      ]
    },
    {
      "title": "Reduce Dictionaries",
      "description": "Reduces a list of dictionaries into one dictionary based on a specified key field.\n    dictionary, reduce, aggregate\n\n    Use cases:\n    - Aggregate data by a specific field\n    - Create summary dictionaries from list of records\n    - Combine multiple data points into a single structure",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.ReduceDictionaries",
      "properties": [
        {
          "name": "dictionaries",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Dictionaries",
          "description": "List of dictionaries to be reduced"
        },
        {
          "name": "key_field",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key Field",
          "description": "The field to use as the key in the resulting dictionary"
        },
        {
          "name": "value_field",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Value Field",
          "description": "Optional field to use as the value. If not specified, the entire dictionary (minus the key field) will be used as the value."
        },
        {
          "name": "conflict_resolution",
          "type": {
            "type": "enum",
            "values": [
              "first",
              "last",
              "error"
            ],
            "type_name": "nodetool.nodes.nodetool.dictionary.ConflictResolution"
          },
          "default": "first",
          "title": "Conflict Resolution",
          "description": "How to handle conflicts when the same key appears multiple times"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "any"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dictionaries",
        "key_field",
        "value_field",
        "conflict_resolution"
      ]
    },
    {
      "title": "Remove",
      "description": "Removes a key-value pair from a dictionary.\n    dictionary, remove, delete\n\n    Use cases:\n    - Delete a specific configuration option\n    - Remove sensitive information before processing\n    - Clean up temporary entries in a data structure",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Remove",
      "properties": [
        {
          "name": "dictionary",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dictionary"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dictionary",
        "key"
      ]
    },
    {
      "title": "Save CSVFile",
      "description": "Write a list of dictionaries to a CSV file.\n    files, csv, write, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.SaveCSVFile",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Data",
          "description": "list of dictionaries to write to CSV"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {},
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Name of the CSV file to save. Supports strftime format codes."
        }
      ],
      "basic_fields": [
        "data",
        "folder",
        "filename"
      ]
    },
    {
      "title": "Update",
      "description": "Updates a dictionary with new key-value pairs.\n    dictionary, add, update\n\n    Use cases:\n    - Extend a configuration with additional settings\n    - Add new entries to a cache or lookup table\n    - Merge user input with existing data",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Update",
      "properties": [
        {
          "name": "dictionary",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dictionary"
        },
        {
          "name": "new_pairs",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "New Pairs"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dictionary",
        "new_pairs"
      ]
    },
    {
      "title": "Zip",
      "description": "Creates a dictionary from parallel lists of keys and values.\n    dictionary, create, zip\n\n    Use cases:\n    - Convert separate data columns into key-value pairs\n    - Create lookups from parallel data structures\n    - Transform list data into associative arrays",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Zip",
      "properties": [
        {
          "name": "keys",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Keys"
        },
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "any"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "keys",
        "values"
      ]
    },
    {
      "title": "Add Audio",
      "description": "Add an audio track to a video, replacing or mixing with existing audio.\n    video, audio, soundtrack, merge\n\n    Use cases:\n    1. Add background music or narration to a silent video\n    2. Replace original audio with a new soundtrack\n    3. Mix new audio with existing video sound",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.AddAudio",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to add audio to."
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio file to add to the video."
        },
        {
          "name": "volume",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume",
          "description": "Volume adjustment for the added audio. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "mix",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Mix",
          "description": "If True, mix new audio with existing. If False, replace existing audio."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "audio",
        "volume",
        "mix"
      ]
    },
    {
      "title": "Add Subtitles",
      "description": "Add subtitles to a video.\n    video, subtitles, text, caption\n\n    Use cases:\n    1. Add translations or closed captions to videos\n    2. Include explanatory text or commentary in educational videos\n    3. Create lyric videos for music content",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.AddSubtitles",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to add subtitles to."
        },
        {
          "name": "chunks",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "audio_chunk"
              }
            ]
          },
          "default": [],
          "title": "Chunks",
          "description": "Audio chunks to add as subtitles."
        },
        {
          "name": "font",
          "type": {
            "type": "font"
          },
          "default": {},
          "title": "Font",
          "description": "The font to use."
        },
        {
          "name": "align",
          "type": {
            "type": "enum",
            "values": [
              "top",
              "center",
              "bottom"
            ],
            "type_name": "nodetool.nodes.nodetool.video.SubtitleTextAlignment"
          },
          "default": "bottom",
          "title": "Align",
          "description": "Vertical alignment of subtitles."
        },
        {
          "name": "font_size",
          "type": {
            "type": "int"
          },
          "default": 24,
          "title": "Font Size",
          "description": "The font size.",
          "min": 1.0,
          "max": 72.0
        },
        {
          "name": "font_color",
          "type": {
            "type": "color"
          },
          "default": {
            "value": "#FFFFFF"
          },
          "title": "Font Color",
          "description": "The font color."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "chunks",
        "font",
        "align",
        "font_size",
        "font_color"
      ]
    },
    {
      "title": "Blur",
      "description": "Apply a blur effect to a video.\n    video, blur, smooth, soften\n\n    Use cases:\n    1. Create a dreamy or soft focus effect\n    2. Obscure or censor specific areas of the video\n    3. Reduce noise or grain in low-quality footage",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Blur",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to apply blur effect."
        },
        {
          "name": "strength",
          "type": {
            "type": "float"
          },
          "default": 5.0,
          "title": "Strength",
          "description": "The strength of the blur effect. Higher values create a stronger blur.",
          "min": 0.0,
          "max": 20.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "strength"
      ]
    },
    {
      "title": "Chroma Key",
      "description": "Apply chroma key (green screen) effect to a video.\n    video, chroma key, green screen, compositing\n\n    Use cases:\n    1. Remove green or blue background from video footage\n    2. Create special effects by compositing video onto new backgrounds\n    3. Produce professional-looking videos for presentations or marketing",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.ChromaKey",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to apply chroma key effect."
        },
        {
          "name": "key_color",
          "type": {
            "type": "color"
          },
          "default": {
            "value": "#00FF00"
          },
          "title": "Key Color",
          "description": "The color to key out (e.g., '#00FF00' for green)."
        },
        {
          "name": "similarity",
          "type": {
            "type": "float"
          },
          "default": 0.3,
          "title": "Similarity",
          "description": "Similarity threshold for the key color.",
          "min": 0.0,
          "max": 1.0
        },
        {
          "name": "blend",
          "type": {
            "type": "float"
          },
          "default": 0.1,
          "title": "Blend",
          "description": "Blending of the keyed area edges.",
          "min": 0.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "key_color",
        "similarity",
        "blend"
      ]
    },
    {
      "title": "Color Balance",
      "description": "Adjust the color balance of a video.\n    video, color, balance, adjustment\n\n    Use cases:\n    1. Correct color casts in video footage\n    2. Enhance specific color tones for artistic effect\n    3. Normalize color balance across multiple video clips",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.ColorBalance",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to adjust color balance."
        },
        {
          "name": "red_adjust",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Red Adjust",
          "description": "Red channel adjustment factor.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "green_adjust",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Green Adjust",
          "description": "Green channel adjustment factor.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "blue_adjust",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Blue Adjust",
          "description": "Blue channel adjustment factor.",
          "min": 0.0,
          "max": 2.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "red_adjust",
        "green_adjust",
        "blue_adjust"
      ]
    },
    {
      "title": "Concat",
      "description": "Concatenate multiple video files into a single video, including audio when available.\n    video, concat, merge, combine, audio, +",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Concat",
      "properties": [
        {
          "name": "video_a",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video A",
          "description": "The first video to concatenate."
        },
        {
          "name": "video_b",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video B",
          "description": "The second video to concatenate."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video_a",
        "video_b"
      ]
    },
    {
      "title": "Denoise",
      "description": "Apply noise reduction to a video.\n    video, denoise, clean, enhance\n\n    Use cases:\n    1. Improve video quality by reducing unwanted noise\n    2. Enhance low-light footage\n    3. Prepare video for further processing or compression",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Denoise",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to denoise."
        },
        {
          "name": "strength",
          "type": {
            "type": "float"
          },
          "default": 5.0,
          "title": "Strength",
          "description": "Strength of the denoising effect. Higher values mean more denoising.",
          "min": 0.0,
          "max": 20.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "strength"
      ]
    },
    {
      "title": "Extract Audio",
      "description": "Separate audio from a video file.\n    video, audio, extract, separate",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.ExtractAudio",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to separate."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video"
      ]
    },
    {
      "title": "Fps",
      "description": "Get the frames per second (FPS) of a video file.\n    video, analysis, frames, fps\n\n    Use cases:\n    1. Analyze video properties for quality assessment\n    2. Determine appropriate playback speed for video editing\n    3. Ensure compatibility with target display systems",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Fps",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to analyze for FPS."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video"
      ]
    },
    {
      "title": "Frame Iterator",
      "description": "Extract frames from a video file using OpenCV.\n    video, frames, extract, sequence\n\n    Use cases:\n    1. Generate image sequences for further processing\n    2. Extract specific frame ranges from a video\n    3. Create thumbnails or previews from video content",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.FrameIterator",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to extract frames from."
        },
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start",
          "description": "The frame to start extracting from."
        },
        {
          "name": "end",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End",
          "description": "The frame to stop extracting from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "frame"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "index"
        },
        {
          "type": {
            "type": "float"
          },
          "name": "fps"
        }
      ],
      "basic_fields": [
        "video",
        "start",
        "end"
      ]
    },
    {
      "title": "Frame To Video",
      "description": "Combine a sequence of frames into a single video file.\n    video, frames, combine, sequence\n\n    Use cases:\n    1. Create time-lapse videos from image sequences\n    2. Compile processed frames back into a video\n    3. Generate animations from individual images",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.FrameToVideo",
      "properties": [
        {
          "name": "frame",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Frame",
          "description": "Collect input frames"
        },
        {
          "name": "fps",
          "type": {
            "type": "float"
          },
          "default": 30,
          "title": "Fps",
          "description": "The FPS of the output video."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "frame",
        "fps"
      ]
    },
    {
      "title": "Load Video Folder",
      "description": "Load video files from an asset folder.\n\n    video, assets, load\n\n    Use cases:\n    - Provide videos for batch processing\n    - Iterate over stored video assets\n    - Prepare clips for editing or analysis",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.LoadVideoAssets",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {},
          "title": "Folder",
          "description": "The asset folder to load the video files from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "video"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        }
      ],
      "basic_fields": [
        "folder"
      ]
    },
    {
      "title": "Load Video File",
      "description": "Read a video file from disk.\n    video, input, load, file\n\n    Use cases:\n    - Load videos for processing\n    - Import video files for editing\n    - Read video assets for a workflow",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.LoadVideoFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the video file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Overlay",
      "description": "Overlay one video on top of another, including audio overlay when available.\n    video, overlay, composite, picture-in-picture, audio",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Overlay",
      "properties": [
        {
          "name": "main_video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Main Video",
          "description": "The main (background) video."
        },
        {
          "name": "overlay_video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Overlay Video",
          "description": "The video to overlay on top."
        },
        {
          "name": "x",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "X",
          "description": "X-coordinate for overlay placement."
        },
        {
          "name": "y",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Y",
          "description": "Y-coordinate for overlay placement."
        },
        {
          "name": "scale",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Scale",
          "description": "Scale factor for the overlay video."
        },
        {
          "name": "overlay_audio_volume",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Overlay Audio Volume",
          "description": "Volume of the overlay audio relative to the main audio.",
          "min": 0.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "main_video",
        "overlay_video",
        "x",
        "y",
        "scale",
        "overlay_audio_volume"
      ]
    },
    {
      "title": "Resize",
      "description": "Resize a video to a specific width and height.\n    video, resize, scale, dimensions\n\n    Use cases:\n    1. Adjust video resolution for different display requirements\n    2. Reduce file size by downscaling video\n    3. Prepare videos for specific platforms with size constraints",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Resize",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to resize."
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Width",
          "description": "The target width. Use -1 to maintain aspect ratio."
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Height",
          "description": "The target height. Use -1 to maintain aspect ratio."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "width",
        "height"
      ]
    },
    {
      "title": "Reverse",
      "description": "Reverse the playback of a video.\n    video, reverse, backwards, effect\n\n    Use cases:\n    1. Create artistic effects by playing video in reverse\n    2. Analyze motion or events in reverse order\n    3. Generate unique transitions or intros for video projects",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Reverse",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to reverse."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video"
      ]
    },
    {
      "title": "Rotate",
      "description": "Rotate a video by a specified angle.\n    video, rotate, orientation, transform\n\n    Use cases:\n    1. Correct orientation of videos taken with a rotated camera\n    2. Create artistic effects by rotating video content\n    3. Adjust video for different display orientations",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Rotate",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to rotate."
        },
        {
          "name": "angle",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Angle",
          "description": "The angle of rotation in degrees.",
          "min": -360.0,
          "max": 360.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "angle"
      ]
    },
    {
      "title": "Saturation",
      "description": "Adjust the color saturation of a video.\n    video, saturation, color, enhance\n\n    Use cases:\n    1. Enhance color vibrancy in dull or flat-looking footage\n    2. Create stylistic effects by over-saturating or desaturating video\n    3. Correct oversaturated footage from certain cameras",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Saturation",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to adjust saturation."
        },
        {
          "name": "saturation",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Saturation",
          "description": "Saturation level. 1.0 is original, <1 decreases saturation, >1 increases saturation.",
          "min": 0.0,
          "max": 3.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "saturation"
      ]
    },
    {
      "title": "Save Video Asset",
      "description": "Save a video to an asset folder.\n    video, save, file, output\n\n    Use cases:\n    1. Export processed video to a specific asset folder\n    2. Save video with a custom name\n    3. Create a copy of a video in a different location",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.SaveVideo",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The video to save."
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {},
          "title": "Folder",
          "description": "The asset folder to save the video in."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d-%H-%M-%S.mp4",
          "title": "Name",
          "description": "\n        Name of the output video.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "folder",
        "name"
      ]
    },
    {
      "title": "Save Video File",
      "description": "Write a video file to disk.\n    video, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.SaveVideoFile",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The video to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {},
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "\n        Name of the file to save.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "folder",
        "filename"
      ]
    },
    {
      "title": "Set Speed",
      "description": "Adjust the playback speed of a video.\n    video, speed, tempo, time\n\n    Use cases:\n    1. Create slow-motion effects by decreasing video speed\n    2. Generate time-lapse videos by increasing playback speed\n    3. Synchronize video duration with audio or other timing requirements",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.SetSpeed",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to adjust speed."
        },
        {
          "name": "speed_factor",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Speed Factor",
          "description": "The speed adjustment factor. Values > 1 speed up, < 1 slow down."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "speed_factor"
      ]
    },
    {
      "title": "Sharpness",
      "description": "Adjust the sharpness of a video.\n    video, sharpen, enhance, detail\n\n    Use cases:\n    1. Enhance detail in slightly out-of-focus footage\n    2. Correct softness introduced by video compression\n    3. Create stylistic effects by over-sharpening",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Sharpness",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to sharpen."
        },
        {
          "name": "luma_amount",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Luma Amount",
          "description": "Amount of sharpening to apply to luma (brightness) channel.",
          "min": 0.0,
          "max": 3.0
        },
        {
          "name": "chroma_amount",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Chroma Amount",
          "description": "Amount of sharpening to apply to chroma (color) channels.",
          "min": 0.0,
          "max": 3.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "luma_amount",
        "chroma_amount"
      ]
    },
    {
      "title": "Stabilize",
      "description": "Apply video stabilization to reduce camera shake and jitter.\n    video, stabilize, smooth, shake-reduction\n\n    Use cases:\n    1. Improve quality of handheld or action camera footage\n    2. Smooth out panning and tracking shots\n    3. Enhance viewer experience by reducing motion sickness",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Stabilize",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to stabilize."
        },
        {
          "name": "smoothing",
          "type": {
            "type": "float"
          },
          "default": 10.0,
          "title": "Smoothing",
          "description": "Smoothing strength. Higher values result in smoother but potentially more cropped video.",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "crop_black",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Crop Black",
          "description": "Whether to crop black borders that may appear after stabilization."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "smoothing",
        "crop_black"
      ]
    },
    {
      "title": "Transition",
      "description": "Create a transition effect between two videos, including audio transition when available.\n    video, transition, effect, merge, audio\n\n    Use cases:\n    1. Create smooth transitions between video clips in a montage\n    2. Add professional-looking effects to video projects\n    3. Blend scenes together for creative storytelling\n    4. Smoothly transition between audio tracks of different video clips",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Transition",
      "properties": [
        {
          "name": "video_a",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video A",
          "description": "The first video in the transition."
        },
        {
          "name": "video_b",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video B",
          "description": "The second video in the transition."
        },
        {
          "name": "transition_type",
          "type": {
            "type": "enum",
            "values": [
              "fade",
              "wipeleft",
              "wiperight",
              "wipeup",
              "wipedown",
              "slideleft",
              "slideright",
              "slideup",
              "slidedown",
              "circlecrop",
              "rectcrop",
              "distance",
              "fadeblack",
              "fadewhite",
              "radial",
              "smoothleft",
              "smoothright",
              "smoothup",
              "smoothdown",
              "circleopen",
              "circleclose",
              "vertopen",
              "vertclose",
              "horzopen",
              "horzclose",
              "dissolve",
              "pixelize",
              "diagtl",
              "diagtr",
              "diagbl",
              "diagbr",
              "hlslice",
              "hrslice",
              "vuslice",
              "vdslice",
              "hblur",
              "fadegrays",
              "wipetl",
              "wipetr",
              "wipebl",
              "wipebr",
              "squeezeh",
              "squeezev",
              "zoomin",
              "fadefast",
              "fadeslow",
              "hlwind",
              "hrwind",
              "vuwind",
              "vdwind",
              "coverleft",
              "coverright",
              "coverup",
              "coverdown",
              "revealleft",
              "revealright",
              "revealup",
              "revealdown"
            ],
            "type_name": "nodetool.nodes.nodetool.video.TransitionType"
          },
          "default": "fade",
          "title": "Transition Type",
          "description": "Type of transition effect"
        },
        {
          "name": "duration",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Duration",
          "description": "Duration of the transition effect in seconds.",
          "min": 0.1,
          "max": 5.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video_a",
        "video_b",
        "transition_type",
        "duration"
      ]
    },
    {
      "title": "Trim",
      "description": "Trim a video to a specific start and end time.\n    video, trim, cut, segment\n\n    Use cases:\n    1. Extract specific segments from a longer video\n    2. Remove unwanted parts from the beginning or end of a video\n    3. Create shorter clips from a full-length video",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Trim",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to trim."
        },
        {
          "name": "start_time",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Start Time",
          "description": "The start time in seconds for the trimmed video."
        },
        {
          "name": "end_time",
          "type": {
            "type": "float"
          },
          "default": -1.0,
          "title": "End Time",
          "description": "The end time in seconds for the trimmed video. Use -1 for the end of the video."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "start_time",
        "end_time"
      ]
    },
    {
      "title": "Batch To List",
      "description": "Convert an image batch to a list of image references.\n    batch, list, images, processing\n\n    Use cases:\n    - Convert comfy batch outputs to list format",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.BatchToList",
      "properties": [
        {
          "name": "batch",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Batch",
          "description": "The batch of images to convert."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "batch"
      ]
    },
    {
      "title": "Crop",
      "description": "Crop an image to specified coordinates.\n    image, crop\n\n    - Remove unwanted borders from images\n    - Focus on particular subjects within an image\n    - Simplify images by removing distractions",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Crop",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to crop."
        },
        {
          "name": "left",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Left",
          "description": "The left coordinate.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "top",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Top",
          "description": "The top coordinate.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "right",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Right",
          "description": "The right coordinate.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "bottom",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Bottom",
          "description": "The bottom coordinate.",
          "min": 0.0,
          "max": 4096.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "left",
        "top",
        "right",
        "bottom"
      ]
    },
    {
      "title": "Fit",
      "description": "Resize an image to fit within specified dimensions while preserving aspect ratio.\n    image, resize, fit\n\n    - Resize images for online publishing requirements\n    - Preprocess images to uniform sizes for machine learning\n    - Control image display sizes for web development",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Fit",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to fit."
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Width",
          "description": "Width to fit to.",
          "min": 1.0,
          "max": 4096.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Height",
          "description": "Height to fit to.",
          "min": 1.0,
          "max": 4096.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "width",
        "height"
      ]
    },
    {
      "title": "Get Metadata",
      "description": "Get metadata about the input image.\n    metadata, properties, analysis, information\n\n    Use cases:\n    - Use width and height for layout calculations\n    - Analyze image properties for processing decisions\n    - Gather information for image cataloging or organization",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.GetMetadata",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The input image."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "format"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "mode"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "width"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "height"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "channels"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Load Image Assets",
      "description": "Load images from an asset folder.\n    load, image, file, import",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.LoadImageAssets",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {},
          "title": "Folder",
          "description": "The asset folder to load the images from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "image"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        }
      ],
      "basic_fields": [
        "folder"
      ]
    },
    {
      "title": "Load Image File",
      "description": "Read an image file from disk.\n    image, input, load, file\n\n    Use cases:\n    - Load images for processing\n    - Import photos for editing\n    - Read image assets for a workflow",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.LoadImageFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to the image file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Load Image Folder",
      "description": "Load all images from a folder, optionally including subfolders.\n    image, load, folder, files\n\n    Use cases:\n    - Batch import images for processing\n    - Build datasets from a directory tree\n    - Iterate over photo collections",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.LoadImageFolder",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {},
          "title": "Folder",
          "description": "Folder to scan for images"
        },
        {
          "name": "include_subdirectories",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Include Subdirectories",
          "description": "Include images in subfolders"
        },
        {
          "name": "extensions",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [
            ".png",
            ".jpg",
            ".jpeg",
            ".bmp",
            ".gif",
            ".webp",
            ".tiff"
          ],
          "title": "Extensions",
          "description": "Image file extensions to include"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "image"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "path"
        }
      ],
      "basic_fields": [
        "folder",
        "include_subdirectories",
        "extensions"
      ]
    },
    {
      "title": "Paste",
      "description": "Paste one image onto another at specified coordinates.\n    paste, composite, positioning, overlay\n\n    Use cases:\n    - Add watermarks or logos to images\n    - Combine multiple image elements\n    - Create collages or montages",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Paste",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to paste into."
        },
        {
          "name": "paste",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Paste",
          "description": "The image to paste."
        },
        {
          "name": "left",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Left",
          "description": "The left coordinate.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "top",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Top",
          "description": "The top coordinate.",
          "min": 0.0,
          "max": 4096.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "paste",
        "left",
        "top"
      ]
    },
    {
      "title": "Resize",
      "description": "Change image dimensions to specified width and height.\n    image, resize\n\n    - Preprocess images for machine learning model inputs\n    - Optimize images for faster web page loading\n    - Create uniform image sizes for layouts",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Resize",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to resize."
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Width",
          "description": "The target width.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Height",
          "description": "The target height.",
          "min": 0.0,
          "max": 4096.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "width",
        "height"
      ]
    },
    {
      "title": "Save Image Asset",
      "description": "Save an image to specified asset folder with customizable name format.\n    save, image, folder, naming\n\n    Use cases:\n    - Save generated images with timestamps\n    - Organize outputs into specific folders\n    - Create backups of processed images",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.SaveImage",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to save."
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {},
          "title": "Folder",
          "description": "The asset folder to save the image in."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d_%H-%M-%S.png",
          "title": "Name",
          "description": "\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "folder",
        "name"
      ]
    },
    {
      "title": "Save Image File",
      "description": "Write an image to disk.\n    image, output, save, file\n\n    Use cases:\n    - Save processed images\n    - Export edited photos\n    - Archive image results",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.SaveImageFile",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {},
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "\n        The name of the image file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        },
        {
          "name": "overwrite",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Overwrite",
          "description": "Overwrite the file if it already exists, otherwise file will be renamed"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "folder",
        "filename",
        "overwrite"
      ]
    },
    {
      "title": "Scale",
      "description": "Enlarge or shrink an image by a scale factor.\n    image, resize, scale\n\n    - Adjust image dimensions for display galleries\n    - Standardize image sizes for machine learning datasets\n    - Create thumbnail versions of images",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Scale",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to scale."
        },
        {
          "name": "scale",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Scale",
          "description": "The scale factor.",
          "min": 0.0,
          "max": 10.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "scale"
      ]
    },
    {
      "title": "Add Column",
      "description": "Add list of values as new column to dataframe.\n    dataframe, column, list\n\n    Use cases:\n    - Incorporate external data into existing dataframe\n    - Add calculated results as new column\n    - Augment dataframe with additional features",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.AddColumn",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Dataframe",
          "description": "Dataframe object to add a new column to."
        },
        {
          "name": "column_name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Column Name",
          "description": "The name of the new column to be added to the dataframe."
        },
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values",
          "description": "A list of any type of elements which will be the new column's values."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "column_name",
        "values"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Aggregate",
      "description": "Aggregate dataframe by one or more columns.\n    aggregate, groupby, group, sum, mean, count, min, max, std, var, median, first, last\n\n    Use cases:\n    - Prepare data for aggregation operations\n    - Analyze data by categories\n    - Create summary statistics by groups",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Aggregate",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Dataframe",
          "description": "The DataFrame to group."
        },
        {
          "name": "columns",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Columns",
          "description": "Comma-separated column names to group by."
        },
        {
          "name": "aggregation",
          "type": {
            "type": "str"
          },
          "default": "sum",
          "title": "Aggregation",
          "description": "Aggregation function: sum, mean, count, min, max, std, var, median, first, last"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "columns",
        "aggregation"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Append",
      "description": "Append two dataframes along rows.\n    append, concat, rows\n\n    Use cases:\n    - Combine data from multiple time periods\n    - Merge datasets with same structure\n    - Aggregate data from different sources",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Append",
      "properties": [
        {
          "name": "dataframe_a",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Dataframe A",
          "description": "First DataFrame to be appended."
        },
        {
          "name": "dataframe_b",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Dataframe B",
          "description": "Second DataFrame to be appended."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe_a",
        "dataframe_b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Drop Duplicates",
      "description": "Remove duplicate rows from dataframe.\n    duplicates, unique, clean\n\n    Use cases:\n    - Clean dataset by removing redundant entries\n    - Ensure data integrity in analysis\n    - Prepare data for unique value operations",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.DropDuplicates",
      "properties": [
        {
          "name": "df",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Df",
          "description": "The input DataFrame."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "df"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Drop NA",
      "description": "Remove rows with NA values from dataframe.\n    na, missing, clean\n\n    Use cases:\n    - Clean dataset by removing incomplete entries\n    - Prepare data for analysis requiring complete cases\n    - Improve data quality for modeling",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.DropNA",
      "properties": [
        {
          "name": "df",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Df",
          "description": "The input DataFrame."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "df"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Column",
      "description": "Convert dataframe column to list.\n    dataframe, column, list\n\n    Use cases:\n    - Extract data for use in other processing steps\n    - Prepare column data for plotting or analysis\n    - Convert categorical data to list for encoding",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.ExtractColumn",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Dataframe",
          "description": "The input dataframe."
        },
        {
          "name": "column_name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Column Name",
          "description": "The name of the column to be converted to a list."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "column_name"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Fill NA",
      "description": "Fill missing values in dataframe.\n    fillna, missing, impute\n\n    Use cases:\n    - Handle missing data\n    - Prepare data for analysis\n    - Improve data quality",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.FillNA",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Dataframe",
          "description": "The DataFrame with missing values."
        },
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "default": 0,
          "title": "Value",
          "description": "Value to use for filling missing values."
        },
        {
          "name": "method",
          "type": {
            "type": "str"
          },
          "default": "value",
          "title": "Method",
          "description": "Method for filling: value, forward, backward, mean, median"
        },
        {
          "name": "columns",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Columns",
          "description": "Comma-separated column names to fill. Leave empty for all columns."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "value",
        "method",
        "columns"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Filter",
      "description": "Filter dataframe based on condition.\n    filter, query, condition\n\n    Example conditions:\n    age > 30\n    age > 30 and salary < 50000\n    name == 'John Doe'\n    100 <= price <= 200\n    status in ['Active', 'Pending']\n    not (age < 18)\n\n    Use cases:\n    - Extract subset of data meeting specific criteria\n    - Remove outliers or invalid data points\n    - Focus analysis on relevant data segments",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Filter",
      "properties": [
        {
          "name": "df",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Df",
          "description": "The DataFrame to filter."
        },
        {
          "name": "condition",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Condition",
          "description": "The filtering condition to be applied to the DataFrame, e.g. column_name > 5."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "df",
        "condition"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Find Row",
      "description": "Find the first row in a dataframe that matches a given condition.\n    filter, query, condition, single row\n\n    Example conditions:\n    age > 30\n    age > 30 and salary < 50000\n    name == 'John Doe'\n    100 <= price <= 200\n    status in ['Active', 'Pending']\n    not (age < 18)\n\n    Use cases:\n    - Retrieve specific record based on criteria\n    - Find first occurrence of a particular condition\n    - Extract single data point for further analysis",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.FindRow",
      "properties": [
        {
          "name": "df",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Df",
          "description": "The DataFrame to search."
        },
        {
          "name": "condition",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Condition",
          "description": "The condition to filter the DataFrame, e.g. 'column_name == value'."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "df",
        "condition"
      ],
      "expose_as_tool": true
    },
    {
      "title": "From List",
      "description": "Convert list of dicts to dataframe.\n    list, dataframe, convert\n\n    Use cases:\n    - Transform list data into structured dataframe\n    - Prepare list data for analysis or visualization\n    - Convert API responses to dataframe format",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.FromList",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values",
          "description": "List of values to be converted, each value will be a row."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Import CSV",
      "description": "Convert CSV string to dataframe.\n    csv, dataframe, import\n\n    Use cases:\n    - Import CSV data from string input\n    - Convert CSV responses from APIs to dataframe",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.ImportCSV",
      "properties": [
        {
          "name": "csv_data",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "CSV Data",
          "description": "String input of CSV formatted text."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "csv_data"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Convert JSON to DataFrame",
      "description": "Transforms a JSON string into a pandas DataFrame.\n    json, dataframe, conversion\n\n    Use cases:\n    - Converting API responses to tabular format\n    - Preparing JSON data for analysis or visualization\n    - Structuring unstructured JSON data for further processing",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.JSONToDataframe",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "JSON"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Join",
      "description": "Join two dataframes on specified column.\n    join, merge, column\n\n    Use cases:\n    - Combine data from related tables\n    - Enrich dataset with additional information\n    - Link data based on common identifiers",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Join",
      "properties": [
        {
          "name": "dataframe_a",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Dataframe A",
          "description": "First DataFrame to be merged."
        },
        {
          "name": "dataframe_b",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Dataframe B",
          "description": "Second DataFrame to be merged."
        },
        {
          "name": "join_on",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Join On",
          "description": "The column name on which to join the two dataframes."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe_a",
        "dataframe_b",
        "join_on"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Load CSV Assets",
      "description": "Load dataframes from an asset folder.\n    load, dataframe, file, import\n\n    Use cases:\n    - Load multiple dataframes from a folder\n    - Process multiple datasets in sequence\n    - Batch import of data files",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.LoadCSVAssets",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {},
          "title": "Folder",
          "description": "The asset folder to load the dataframes from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "dataframe"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        }
      ],
      "basic_fields": [
        "folder"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Load CSVFile",
      "description": "Load CSV file from file path.\n    csv, dataframe, import",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.LoadCSVFile",
      "properties": [
        {
          "name": "file_path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "File Path",
          "description": "The path to the CSV file to load."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "file_path"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Load CSVURL",
      "description": "Load CSV file from URL.\n    csv, dataframe, import",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.LoadCSVURL",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL of the CSV file to load."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Merge",
      "description": "Merge two dataframes along columns.\n    merge, concat, columns\n\n    Use cases:\n    - Combine data from multiple sources\n    - Add new features to existing dataframe\n    - Merge time series data from different periods",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Merge",
      "properties": [
        {
          "name": "dataframe_a",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Dataframe A",
          "description": "First DataFrame to be merged."
        },
        {
          "name": "dataframe_b",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Dataframe B",
          "description": "Second DataFrame to be merged."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe_a",
        "dataframe_b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Pivot",
      "description": "Pivot dataframe to reshape data.\n    pivot, reshape, transform\n\n    Use cases:\n    - Transform long data to wide format\n    - Create cross-tabulation tables\n    - Reorganize data for visualization",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Pivot",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Dataframe",
          "description": "The DataFrame to pivot."
        },
        {
          "name": "index",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Index",
          "description": "Column name to use as index (rows)."
        },
        {
          "name": "columns",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Columns",
          "description": "Column name to use as columns."
        },
        {
          "name": "values",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Values",
          "description": "Column name to use as values."
        },
        {
          "name": "aggfunc",
          "type": {
            "type": "str"
          },
          "default": "sum",
          "title": "Aggfunc",
          "description": "Aggregation function: sum, mean, count, min, max, first, last"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "index",
        "columns",
        "values",
        "aggfunc"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Rename",
      "description": "Rename columns in dataframe.\n    rename, columns, names\n\n    Use cases:\n    - Standardize column names\n    - Make column names more descriptive\n    - Prepare data for specific requirements",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Rename",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Dataframe",
          "description": "The DataFrame to rename columns."
        },
        {
          "name": "rename_map",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Rename Map",
          "description": "Column rename mapping in format: old1:new1,old2:new2"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "rename_map"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Row Iterator",
      "description": "Iterate over rows of a dataframe.",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.RowIterator",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Dataframe",
          "description": "The input dataframe."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "dict"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "index"
        }
      ],
      "basic_fields": [
        "dataframe"
      ]
    },
    {
      "title": "Save CSVDataframe File",
      "description": "Write a pandas DataFrame to a CSV file.\n    files, csv, write, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.SaveCSVDataframeFile",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Dataframe",
          "description": "DataFrame to write to CSV"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {},
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Name of the CSV file to save. Supports strftime format codes."
        }
      ],
      "basic_fields": [
        "dataframe",
        "folder",
        "filename"
      ]
    },
    {
      "title": "Save Dataframe",
      "description": "Save dataframe in specified folder.\n    csv, folder, save\n\n    Use cases:\n    - Export processed data for external use\n    - Create backups of dataframes",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.SaveDataframe",
      "properties": [
        {
          "name": "df",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Df"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {},
          "title": "Folder",
          "description": "Name of the output folder."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "output.csv",
          "title": "Name",
          "description": "\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "df",
        "folder",
        "name"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Select Column",
      "description": "Select specific columns from dataframe.\n    dataframe, columns, filter\n\n    Use cases:\n    - Extract relevant features for analysis\n    - Reduce dataframe size by removing unnecessary columns\n    - Prepare data for specific visualizations or models",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.SelectColumn",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Dataframe",
          "description": "a dataframe from which columns are to be selected"
        },
        {
          "name": "columns",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Columns",
          "description": "comma separated list of column names"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "columns"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Slice",
      "description": "Slice a dataframe by rows using start and end indices.\n    slice, subset, rows\n\n    Use cases:\n    - Extract a specific range of rows from a large dataset\n    - Create training and testing subsets for machine learning\n    - Analyze data in smaller chunks",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Slice",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Dataframe",
          "description": "The input dataframe to be sliced."
        },
        {
          "name": "start_index",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Index",
          "description": "The starting index of the slice (inclusive)."
        },
        {
          "name": "end_index",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Index",
          "description": "The ending index of the slice (exclusive). Use -1 for the last row."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "start_index",
        "end_index"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Sort By Column",
      "description": "Sort dataframe by specified column.\n    sort, order, column\n\n    Use cases:\n    - Arrange data in ascending or descending order\n    - Identify top or bottom values in dataset\n    - Prepare data for rank-based analysis",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.SortByColumn",
      "properties": [
        {
          "name": "df",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Df"
        },
        {
          "name": "column",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Column",
          "description": "The column to sort the DataFrame by."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "df",
        "column"
      ]
    },
    {
      "title": "To List",
      "description": "Convert dataframe to list of dictionaries.\n    dataframe, list, convert\n\n    Use cases:\n    - Convert dataframe data for API consumption\n    - Transform data for JSON serialization\n    - Prepare data for document-based storage",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.ToList",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Dataframe",
          "description": "The input dataframe to convert."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Array Output",
      "description": "Output node for generic array data, typically numerical ('NPArray').\n    array, numerical, list, tensor, vector, matrix\n\n    Use cases:\n    - Outputting results from machine learning models (e.g., embeddings, predictions).\n    - Representing complex numerical data structures.\n    - Passing arrays of numbers between processing steps.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.ArrayOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "np_array"
          },
          "default": {},
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Audio Output",
      "description": "Output node for audio content references ('AudioRef').\n    audio, sound, media, voice, speech, asset, reference\n\n    Use cases:\n    - Displaying or returning processed or generated audio.\n    - Passing audio data (as an 'AudioRef') between workflow nodes.\n    - Returning results of audio analysis (e.g., transcription reference, audio features).",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.AudioOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Boolean Output",
      "description": "Output node for a single boolean value.\n    boolean, true, false, flag, condition, flow-control, branch, else, switch, toggle\n\n    Use cases:\n    - Returning binary results (yes/no, true/false)\n    - Controlling conditional logic in workflows\n    - Indicating success/failure of operations",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.BooleanOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Dataframe Output",
      "description": "Output node for structured data references, typically tabular ('DataframeRef').\n    dataframe, table, structured, csv, tabular_data, rows, columns\n\n    Use cases:\n    - Outputting tabular data results from analysis or queries.\n    - Passing structured datasets between processing or analysis steps.\n    - Displaying data in a table format or making it available for download.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.DataframeOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Dictionary Output",
      "description": "Output node for key-value pair data (dictionary).\n    dictionary, key-value, mapping, object, json_object, struct\n\n    Use cases:\n    - Returning multiple named values as a single structured output.\n    - Passing complex data structures or configurations between nodes.\n    - Organizing heterogeneous output data into a named map.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.DictionaryOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Document Output",
      "description": "Output node for document content references ('DocumentRef').\n    document, file, pdf, text_file, asset, reference\n\n    Use cases:\n    - Displaying or returning processed or generated documents.\n    - Passing document data (as a 'DocumentRef') between workflow nodes.\n    - Returning results of document analysis or manipulation.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.DocumentOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Float Output",
      "description": "Output node for a single float value.\n    float, decimal, number\n\n    Use cases:\n    - Returning decimal results (e.g. percentages, ratios)\n    - Passing floating-point parameters between nodes\n    - Displaying numeric metrics with decimal precision",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.FloatOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Image Output",
      "description": "Output node for a single image reference ('ImageRef').\n    image, picture, visual, asset, reference\n\n    Use cases:\n    - Displaying a single processed or generated image.\n    - Passing image data (as an 'ImageRef') between workflow nodes.\n    - Returning image analysis results encapsulated in an 'ImageRef'.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.ImageOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Integer Output",
      "description": "Output node for a single integer value.\n    integer, number, count\n\n    Use cases:\n    - Returning numeric results (e.g. counts, indices)\n    - Passing integer parameters between nodes\n    - Displaying numeric metrics",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.IntegerOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "List Output",
      "description": "Output node for a list of arbitrary values.\n    list, output, any\n\n    Use cases:\n    - Returning multiple results from a workflow\n    - Aggregating outputs from multiple nodes",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.ListOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "String Output",
      "description": "Output node for a string value.\n    string, text, output, label, name\n\n    Use cases:\n    - Returning short text results or messages.\n    - Passing concise string parameters or identifiers between nodes.\n    - Displaying brief textual outputs.\n    - For multi-line text or structured document content, use appropriate output nodes if available or consider how data is structured.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.StringOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Video Output",
      "description": "Output node for video content references ('VideoRef').\n    video, media, clip, asset, reference\n\n    Use cases:\n    - Displaying processed or generated video content.\n    - Passing video data (as a 'VideoRef') between workflow steps.\n    - Returning results of video analysis encapsulated in a 'VideoRef'.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.VideoOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Grounded Search",
      "description": "Search the web using Google's Gemini API with grounding capabilities.\n    google, search, grounded, web, gemini, ai\n\n    This node uses Google's Gemini API to perform web searches and return structured results\n    with source information. Requires a Gemini API key.\n\n    Use cases:\n    - Research current events and latest information\n    - Find reliable sources for fact-checking\n    - Gather web-based information with citations\n    - Get up-to-date information beyond the model's training data",
      "namespace": "gemini.text",
      "node_type": "gemini.text.GroundedSearch",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "The search query to execute"
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gemini-2.5-pro",
              "gemini-2.5-flash",
              "gemini-2.0-flash",
              "gemini-1.5-pro",
              "gemini-1.5-flash"
            ],
            "type_name": "nodetool.nodes.gemini.text.GeminiModel"
          },
          "default": "gemini-2.0-flash",
          "title": "Model",
          "description": "The Gemini model to use for search"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "results"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "source"
              }
            ]
          },
          "name": "sources"
        }
      ],
      "basic_fields": [
        "query",
        "model"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Text To Speech",
      "description": "Generate speech audio from text using Google's Gemini text-to-speech models.\n    google, text-to-speech, tts, audio, speech, voice, ai\n\n    This node converts text input into natural-sounding speech audio using Google's\n    advanced text-to-speech models with support for multiple voices and speech styles.\n\n    Use cases:\n    - Create voiceovers for videos and presentations\n    - Generate audio content for podcasts and audiobooks\n    - Add voice narration to applications\n    - Create accessibility features with speech output\n    - Generate multilingual audio content",
      "namespace": "gemini.audio",
      "node_type": "gemini.audio.TextToSpeech",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to convert to speech."
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gemini-2.5-flash-preview-tts",
              "gemini-2.5-pro-preview-tts"
            ],
            "type_name": "nodetool.nodes.gemini.audio.TTSModel"
          },
          "default": "gemini-2.5-flash-preview-tts",
          "title": "Model",
          "description": "The text-to-speech model to use"
        },
        {
          "name": "voice_name",
          "type": {
            "type": "enum",
            "values": [
              "Zephyr",
              "Puck",
              "Nova",
              "Quest",
              "Echo",
              "Fable",
              "Orbit",
              "Chime",
              "Kore",
              "Zenith",
              "Cosmos",
              "Sage",
              "Breeze",
              "Glimmer",
              "Drift",
              "Pearl",
              "Flux",
              "Prism",
              "Vega",
              "Lyra",
              "Ripple",
              "Azure",
              "Juno",
              "River",
              "Sterling",
              "Atlas",
              "Beacon",
              "Ember",
              "Harmony",
              "Spirit"
            ],
            "type_name": "nodetool.nodes.gemini.audio.VoiceName"
          },
          "default": "Kore",
          "title": "Voice Name",
          "description": "The voice to use for speech generation"
        },
        {
          "name": "style_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Style Prompt",
          "description": "Optional style prompt to control speech characteristics (e.g., 'Say cheerfully', 'Speak with excitement')"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "model",
        "voice_name",
        "style_prompt"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Image To Video",
      "description": "Generate videos from images using Google's Veo models.\n    google, video, generation, image-to-video, veo, ai, animation\n\n    This node uses Google's Veo models to animate static images into dynamic videos.\n    Supports 720p resolution at 24fps with 8-second duration and native audio generation.\n\n    Use cases:\n    - Animate still artwork and photographs\n    - Create dynamic social media content from images\n    - Generate product showcase videos from photos\n    - Transform static graphics into engaging animations\n    - Create video presentations from slide images",
      "namespace": "gemini.video",
      "node_type": "gemini.video.ImageToVideo",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to animate into a video"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text prompt describing the desired animation"
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "veo-3.0-generate-preview",
              "veo-3.0-fast-generate-preview",
              "veo-2.0-generate-001"
            ],
            "type_name": "nodetool.nodes.gemini.video.VeoModel"
          },
          "default": "veo-3.0-generate-preview",
          "title": "Model",
          "description": "The Veo model to use for video generation"
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "16:9",
              "9:16"
            ],
            "type_name": "nodetool.nodes.gemini.video.VeoAspectRatio"
          },
          "default": "16:9",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated video"
        },
        {
          "name": "negative_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Negative Prompt",
          "description": "Negative prompt to guide what to avoid in the video"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "prompt",
        "model",
        "aspect_ratio",
        "negative_prompt"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Text To Video",
      "description": "Generate videos from text prompts using Google's Veo models.\n    google, video, generation, text-to-video, veo, ai\n\n    This node uses Google's Veo models to generate high-quality videos from text descriptions.\n    Supports 720p resolution at 24fps with 8-second duration and native audio generation.\n\n    Use cases:\n    - Create cinematic clips from text descriptions\n    - Generate social media video content\n    - Produce marketing and promotional videos\n    - Visualize creative concepts and storyboards\n    - Create animated content with accompanying audio",
      "namespace": "gemini.video",
      "node_type": "gemini.video.TextToVideo",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the video to generate"
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "veo-3.0-generate-preview",
              "veo-3.0-fast-generate-preview",
              "veo-2.0-generate-001"
            ],
            "type_name": "nodetool.nodes.gemini.video.VeoModel"
          },
          "default": "veo-3.0-generate-preview",
          "title": "Model",
          "description": "The Veo model to use for video generation"
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "16:9",
              "9:16"
            ],
            "type_name": "nodetool.nodes.gemini.video.VeoAspectRatio"
          },
          "default": "16:9",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated video"
        },
        {
          "name": "negative_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Negative Prompt",
          "description": "Negative prompt to guide what to avoid in the video"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "model",
        "aspect_ratio",
        "negative_prompt"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Image Generation",
      "description": "Generate an image using Google's Imagen model via the Gemini API.\n    google, image generation, ai, imagen\n\n    Use cases:\n    - Create images from text descriptions\n    - Generate assets for creative projects\n    - Explore AI-powered image synthesis",
      "namespace": "gemini.image",
      "node_type": "gemini.image.ImageGeneration",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the image to generate."
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gemini-2.0-flash-preview-image-generation",
              "gemini-2.5-flash-image-preview",
              "imagen-3.0-generate-001",
              "imagen-3.0-generate-002",
              "imagen-4.0-generate-preview-06-06",
              "imagen-4.0-ultra-generate-preview-06-06"
            ],
            "type_name": "nodetool.nodes.gemini.image.ImageGenerationModel"
          },
          "default": "imagen-3.0-generate-002",
          "title": "Model",
          "description": "The image generation model to use"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to use as a base for the generation."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "model",
        "image"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Finance",
      "description": "Retrieve financial market data from Google Finance.\n    google, finance, stocks, market, serp",
      "namespace": "search.google",
      "node_type": "search.google.GoogleFinance",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "Stock symbol or company name to search for"
        },
        {
          "name": "window",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Window",
          "description": "Time window for financial data (e.g., '1d', '5d', '1m', '3m', '6m', '1y', '5y')"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "query",
        "window"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Images",
      "description": "Search Google Images to retrieve live image results.\n    google, images, serp, visual, reverse, search",
      "namespace": "search.google",
      "node_type": "search.google.GoogleImages",
      "properties": [
        {
          "name": "keyword",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Keyword",
          "description": "Search query or keyword for images"
        },
        {
          "name": "image_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Image Url",
          "description": "URL of image for reverse image search"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 20,
          "title": "Num Results",
          "description": "Maximum number of image results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "keyword",
        "image_url",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Jobs",
      "description": "Search Google Jobs for job listings.\n    google, jobs, employment, careers, serp",
      "namespace": "search.google",
      "node_type": "search.google.GoogleJobs",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "Job title, skills, or company name to search for"
        },
        {
          "name": "location",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Location",
          "description": "Geographic location for job search"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Num Results",
          "description": "Maximum number of job results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "job_result"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "query",
        "location",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Lens",
      "description": "Search with an image URL using Google Lens to find visual matches and related content.\n    google, lens, visual, image, search, serp",
      "namespace": "search.google",
      "node_type": "search.google.GoogleLens",
      "properties": [
        {
          "name": "image_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Image Url",
          "description": "URL of the image to analyze with Google Lens"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Num Results",
          "description": "Maximum number of visual search results to return"
        }
      ],
      "basic_fields": [
        "image_url",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Maps",
      "description": "Search Google Maps for places or get details about a specific place.\n    google, maps, places, locations, serp",
      "namespace": "search.google",
      "node_type": "search.google.GoogleMaps",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "Place name, address, or location query"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Num Results",
          "description": "Maximum number of map results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "local_result"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "query",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google News",
      "description": "Search Google News to retrieve live news articles.\n    google, news, serp, articles",
      "namespace": "search.google",
      "node_type": "search.google.GoogleNews",
      "properties": [
        {
          "name": "keyword",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Keyword",
          "description": "Search query or keyword for news articles"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Num Results",
          "description": "Maximum number of news results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "news_result"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "keyword",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Search",
      "description": "Search Google to retrieve organic search results.\n    google, search, serp, web",
      "namespace": "search.google",
      "node_type": "search.google.GoogleSearch",
      "properties": [
        {
          "name": "keyword",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Keyword",
          "description": "Search query or keyword to search for"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Num Results",
          "description": "Maximum number of results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "organic_result"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "keyword",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Shopping",
      "description": "Search Google Shopping for products.\n    google, shopping, products, ecommerce, serp",
      "namespace": "search.google",
      "node_type": "search.google.GoogleShopping",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "Product name or description to search for"
        },
        {
          "name": "country",
          "type": {
            "type": "str"
          },
          "default": "us",
          "title": "Country",
          "description": "Country code for shopping search (e.g., 'us', 'uk', 'ca')"
        },
        {
          "name": "min_price",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Min Price",
          "description": "Minimum price filter for products"
        },
        {
          "name": "max_price",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Max Price",
          "description": "Maximum price filter for products"
        },
        {
          "name": "condition",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Condition",
          "description": "Product condition filter (e.g., 'new', 'used', 'refurbished')"
        },
        {
          "name": "sort_by",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Sort By",
          "description": "Sort order for results (e.g., 'price_low_to_high', 'price_high_to_low', 'review_score')"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Num Results",
          "description": "Maximum number of shopping results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "shopping_result"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "query",
        "country",
        "min_price",
        "max_price",
        "condition",
        "sort_by",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Add Label",
      "description": "Adds a label to a Gmail message.\n    email, gmail, label",
      "namespace": "lib.mail",
      "node_type": "lib.mail.AddLabel",
      "properties": [
        {
          "name": "message_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Message Id",
          "description": "Message ID to label"
        },
        {
          "name": "label",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Label",
          "description": "Label to add to the message"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "message_id",
        "label"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Email Fields",
      "description": "Decomposes an email into its individual components.\n    email, decompose, extract\n\n    Takes an Email object and returns its individual fields:\n    - id: Message ID\n    - subject: Email subject\n    - sender: Sender address\n    - date: Datetime of email\n    - body: Email body content",
      "namespace": "lib.mail",
      "node_type": "lib.mail.EmailFields",
      "properties": [
        {
          "name": "email",
          "type": {
            "type": "email"
          },
          "default": {},
          "title": "Email",
          "description": "Email object to decompose"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "id"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "subject"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "sender"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "date"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "body"
        }
      ],
      "basic_fields": [
        "email"
      ]
    },
    {
      "title": "Gmail Search",
      "description": "Searches Gmail using Gmail-specific search operators and yields matching emails.\n    email, gmail, search\n\n    Use cases:\n    - Search for emails based on specific criteria\n    - Retrieve emails from a specific sender\n    - Filter emails by subject, sender, or date",
      "namespace": "lib.mail",
      "node_type": "lib.mail.GmailSearch",
      "properties": [
        {
          "name": "from_address",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "From Address",
          "description": "Sender's email address to search for"
        },
        {
          "name": "to_address",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "To Address",
          "description": "Recipient's email address to search for"
        },
        {
          "name": "subject",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Subject",
          "description": "Text to search for in email subject"
        },
        {
          "name": "body",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Body",
          "description": "Text to search for in email body"
        },
        {
          "name": "date_filter",
          "type": {
            "type": "enum",
            "values": [
              "SINCE_ONE_HOUR",
              "SINCE_ONE_DAY",
              "SINCE_ONE_WEEK",
              "SINCE_ONE_MONTH",
              "SINCE_ONE_YEAR"
            ],
            "type_name": "nodetool.nodes.lib.mail.DateFilter"
          },
          "default": "SINCE_ONE_DAY",
          "title": "Date Filter",
          "description": "Date filter to search for"
        },
        {
          "name": "keywords",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Keywords",
          "description": "Custom keywords or labels to search for"
        },
        {
          "name": "folder",
          "type": {
            "type": "enum",
            "values": [
              "INBOX",
              "[Gmail]/Sent Mail",
              "[Gmail]/Drafts",
              "[Gmail]/Spam",
              "[Gmail]/Trash"
            ],
            "type_name": "nodetool.nodes.lib.mail.GmailFolder"
          },
          "default": "INBOX",
          "title": "Folder",
          "description": "Email folder to search in"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "General text to search for anywhere in the email"
        },
        {
          "name": "max_results",
          "type": {
            "type": "int"
          },
          "default": 50,
          "title": "Max Results",
          "description": "Maximum number of emails to return"
        },
        {
          "name": "retry_attempts",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "Retry Attempts",
          "description": "Maximum retry attempts for Gmail operations"
        },
        {
          "name": "retry_base_delay",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Retry Base Delay",
          "description": "Base delay (seconds) for exponential backoff"
        },
        {
          "name": "retry_max_delay",
          "type": {
            "type": "float"
          },
          "default": 5.0,
          "title": "Retry Max Delay",
          "description": "Maximum delay (seconds) for exponential backoff"
        },
        {
          "name": "retry_factor",
          "type": {
            "type": "float"
          },
          "default": 2.0,
          "title": "Retry Factor",
          "description": "Exponential growth factor for backoff"
        },
        {
          "name": "retry_jitter",
          "type": {
            "type": "float"
          },
          "default": 0.1,
          "title": "Retry Jitter",
          "description": "Random jitter (seconds) added to each backoff"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "email"
          },
          "name": "email"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "message_id"
        }
      ],
      "basic_fields": [
        "from_address",
        "subject",
        "body",
        "date_filter",
        "max_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Move To Archive",
      "description": "Moves specified emails to Gmail archive.\n    email, gmail, archive",
      "namespace": "lib.mail",
      "node_type": "lib.mail.MoveToArchive",
      "properties": [
        {
          "name": "message_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Message Id",
          "description": "Message ID to archive"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "message_id"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Send Email",
      "description": "Send a plain text email via SMTP.\n    email, smtp, send\n\n    Use cases:\n    - Send simple notification messages\n    - Automate email reports",
      "namespace": "lib.mail",
      "node_type": "lib.mail.SendEmail",
      "properties": [
        {
          "name": "smtp_server",
          "type": {
            "type": "str"
          },
          "default": "smtp.gmail.com",
          "title": "Smtp Server",
          "description": "SMTP server hostname"
        },
        {
          "name": "smtp_port",
          "type": {
            "type": "int"
          },
          "default": 587,
          "title": "Smtp Port",
          "description": "SMTP server port"
        },
        {
          "name": "username",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Username",
          "description": "SMTP username"
        },
        {
          "name": "password",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Password",
          "description": "SMTP password"
        },
        {
          "name": "from_address",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "From Address",
          "description": "Sender email address"
        },
        {
          "name": "to_address",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "To Address",
          "description": "Recipient email address"
        },
        {
          "name": "subject",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Subject",
          "description": "Email subject"
        },
        {
          "name": "body",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Body",
          "description": "Email body"
        },
        {
          "name": "retry_attempts",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "Retry Attempts",
          "description": "Maximum retry attempts for SMTP send"
        },
        {
          "name": "retry_base_delay",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Retry Base Delay",
          "description": "Base delay (seconds) for exponential backoff"
        },
        {
          "name": "retry_max_delay",
          "type": {
            "type": "float"
          },
          "default": 5.0,
          "title": "Retry Max Delay",
          "description": "Maximum delay (seconds) for exponential backoff"
        },
        {
          "name": "retry_factor",
          "type": {
            "type": "float"
          },
          "default": 2.0,
          "title": "Retry Factor",
          "description": "Exponential growth factor for backoff"
        },
        {
          "name": "retry_jitter",
          "type": {
            "type": "float"
          },
          "default": 0.1,
          "title": "Retry Jitter",
          "description": "Random jitter (seconds) added to each backoff"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "smtp_server",
        "smtp_port",
        "username",
        "password",
        "from_address",
        "to_address",
        "subject",
        "body",
        "retry_attempts",
        "retry_base_delay",
        "retry_max_delay",
        "retry_factor",
        "retry_jitter"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Gzip Compress",
      "description": "Compress bytes using gzip.\n    gzip, compress, bytes\n\n    Use cases:\n    - Reduce size of binary data\n    - Store assets in compressed form\n    - Prepare data for network transfer",
      "namespace": "lib.gzip",
      "node_type": "lib.gzip.GzipCompress",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "bytes"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Data",
          "description": "Data to compress"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Gzip Decompress",
      "description": "Decompress gzip data.\n    gzip, decompress, bytes\n\n    Use cases:\n    - Restore compressed files\n    - Read data from gzip archives\n    - Process network payloads",
      "namespace": "lib.gzip",
      "node_type": "lib.gzip.GzipDecompress",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "bytes"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Data",
          "description": "Gzip data to decompress"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Feed Metadata",
      "description": "Extracts metadata from an RSS feed.\n    rss, metadata, feed\n\n    Use cases:\n    - Get feed information\n    - Validate feed details\n    - Extract feed metadata",
      "namespace": "lib.rss",
      "node_type": "lib.rss.ExtractFeedMetadata",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL of the RSS feed"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "Fetch RSS Feed",
      "description": "Fetches and parses an RSS feed from a URL.\n    rss, feed, network\n\n    Use cases:\n    - Monitor news feeds\n    - Aggregate content from multiple sources\n    - Process blog updates",
      "namespace": "lib.rss",
      "node_type": "lib.rss.FetchRSSFeed",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL of the RSS feed to fetch"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "title"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "link"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "published"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "summary"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "author"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Dedent Text",
      "description": "Removes any common leading whitespace from every line in text.\n    textwrap, dedent, whitespace",
      "namespace": "lib.textwrap",
      "node_type": "lib.textwrap.Dedent",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ]
    },
    {
      "title": "Fill Text",
      "description": "Wraps text to a specified width, returning a formatted string.\n    textwrap, fill, wrap",
      "namespace": "lib.textwrap",
      "node_type": "lib.textwrap.Fill",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 70,
          "title": "Width",
          "min": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "width"
      ]
    },
    {
      "title": "Indent Text",
      "description": "Adds a prefix to the beginning of each line in the text.\n    textwrap, indent, prefix",
      "namespace": "lib.textwrap",
      "node_type": "lib.textwrap.Indent",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "prefix",
          "type": {
            "type": "str"
          },
          "default": "    ",
          "title": "Prefix"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "prefix"
      ]
    },
    {
      "title": "Shorten Text",
      "description": "Shortens text to fit within a width, using a placeholder if truncated.\n    textwrap, shorten, truncate",
      "namespace": "lib.textwrap",
      "node_type": "lib.textwrap.Shorten",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 70,
          "title": "Width",
          "min": 1.0
        },
        {
          "name": "placeholder",
          "type": {
            "type": "str"
          },
          "default": "...",
          "title": "Placeholder"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "width",
        "placeholder"
      ]
    },
    {
      "title": "Wrap Text",
      "description": "Wraps text to a specified width, returning a list of lines.\n    textwrap, wrap, lines",
      "namespace": "lib.textwrap",
      "node_type": "lib.textwrap.Wrap",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 70,
          "title": "Width",
          "min": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "width"
      ]
    },
    {
      "title": "Decode Base64",
      "description": "Decodes Base64 text to plain string.\n    base64, decode, string\n\n    Use cases:\n    - Read encoded data\n    - Extract original text from Base64",
      "namespace": "lib.base64",
      "node_type": "lib.base64.Decode",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Data",
          "description": "Base64 encoded text"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Encode Base64",
      "description": "Encodes text to Base64 format.\n    base64, encode, string\n\n    Use cases:\n    - Prepare text for transmission\n    - Embed data in JSON or HTML",
      "namespace": "lib.base64",
      "node_type": "lib.base64.Encode",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to encode"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Hash File",
      "description": "Compute the cryptographic hash of a file.\n    hash, hashlib, digest, file\n\n    Use cases:\n    - Verify downloaded files\n    - Detect file changes\n    - Identify duplicates",
      "namespace": "lib.hashlib",
      "node_type": "lib.hashlib.HashFile",
      "properties": [
        {
          "name": "file",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "File",
          "description": "The file to hash"
        },
        {
          "name": "algorithm",
          "type": {
            "type": "str"
          },
          "default": "md5",
          "title": "Algorithm",
          "description": "Hash algorithm name (e.g. md5, sha1, sha256)"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 8192,
          "title": "Chunk Size",
          "description": "Read size for hashing in bytes",
          "min": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "file",
        "algorithm",
        "chunk_size"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Hash String",
      "description": "Compute the cryptographic hash of a string using hashlib.\n    hash, hashlib, digest, string\n\n    Use cases:\n    - Generate deterministic identifiers\n    - Verify data integrity\n    - Create fingerprints for caching",
      "namespace": "lib.hashlib",
      "node_type": "lib.hashlib.HashString",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to hash"
        },
        {
          "name": "algorithm",
          "type": {
            "type": "str"
          },
          "default": "md5",
          "title": "Algorithm",
          "description": "Hash algorithm name (e.g. md5, sha1, sha256)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "algorithm"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Create Tar",
      "description": "Create a tar archive from a directory.\n    files, tar, create\n\n    Use cases:\n    - Package multiple files into a single archive\n    - Backup directories\n    - Prepare archives for distribution",
      "namespace": "lib.tar",
      "node_type": "lib.tar.CreateTar",
      "properties": [
        {
          "name": "source_folder",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Source Folder",
          "description": "Folder to archive"
        },
        {
          "name": "tar_path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Tar Path",
          "description": "Output tar file path"
        },
        {
          "name": "gzip",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Gzip",
          "description": "Use gzip compression"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "file_path"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "source_folder",
        "tar_path",
        "gzip"
      ]
    },
    {
      "title": "Extract Tar",
      "description": "Extract a tar archive to a folder.\n    files, tar, extract\n\n    Use cases:\n    - Unpack archived data\n    - Restore backups\n    - Retrieve files for processing",
      "namespace": "lib.tar",
      "node_type": "lib.tar.ExtractTar",
      "properties": [
        {
          "name": "tar_path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Tar Path",
          "description": "Tar archive to extract"
        },
        {
          "name": "output_folder",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Output Folder",
          "description": "Folder to extract into"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "file_path"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "tar_path",
        "output_folder"
      ]
    },
    {
      "title": "List Tar",
      "description": "List contents of a tar archive.\n    files, tar, list\n\n    Use cases:\n    - Inspect archives without extracting\n    - Preview tar contents\n    - Verify archive contents",
      "namespace": "lib.tar",
      "node_type": "lib.tar.ListTar",
      "properties": [
        {
          "name": "tar_path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Tar Path",
          "description": "Tar archive to inspect"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "tar_path"
      ]
    },
    {
      "title": "Escape",
      "description": "Escape special characters in text into HTML-safe sequences.\n    html, escape, entities, convert\n\n    Use cases:\n    - Prepare text for inclusion in HTML\n    - Prevent cross-site scripting in user content\n    - Encode strings for web output",
      "namespace": "lib.html",
      "node_type": "lib.html.Escape",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to escape"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Unescape",
      "description": "Convert HTML entities back to normal text.\n    html, unescape, entities, decode\n\n    Use cases:\n    - Decode HTML-encoded data\n    - Process text scraped from the web\n    - Convert form submissions to plain text",
      "namespace": "lib.html",
      "node_type": "lib.html.Unescape",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The HTML text to unescape"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Absolute Path",
      "description": "Return the absolute path of a file or directory.\n    files, path, absolute\n\n    Use cases:\n    - Convert relative paths to absolute\n    - Get full system path\n    - Resolve path references",
      "namespace": "lib.os",
      "node_type": "lib.os.AbsolutePath",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to convert to absolute"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "file_path"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Accessed Time",
      "description": "Get file last accessed timestamp.\n    files, metadata, accessed, time",
      "namespace": "lib.os",
      "node_type": "lib.os.AccessedTime",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Basename",
      "description": "Get the base name component of a file path.\n    files, path, basename\n\n    Use cases:\n    - Extract filename from full path\n    - Get file name without directory\n    - Process file names independently",
      "namespace": "lib.os",
      "node_type": "lib.os.Basename",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "File path to get basename from"
        },
        {
          "name": "remove_extension",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Remove Extension",
          "description": "Remove file extension from basename"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path",
        "remove_extension"
      ]
    },
    {
      "title": "Copy File",
      "description": "Copy a file from source to destination path.\n    files, copy, manage\n\n    Use cases:\n    - Create file backups\n    - Duplicate files for processing\n    - Copy files to new locations",
      "namespace": "lib.os",
      "node_type": "lib.os.CopyFile",
      "properties": [
        {
          "name": "source_path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Source Path",
          "description": "Source file path"
        },
        {
          "name": "destination_path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Destination Path",
          "description": "Destination file path"
        }
      ],
      "basic_fields": [
        "source_path",
        "destination_path"
      ]
    },
    {
      "title": "Create Directory",
      "description": "Create a new directory at specified path.\n    files, directory, create\n\n    Use cases:\n    - Set up directory structure for file organization\n    - Create output directories for processed files",
      "namespace": "lib.os",
      "node_type": "lib.os.CreateDirectory",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Directory path to create"
        },
        {
          "name": "exist_ok",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Exist Ok",
          "description": "Don't error if directory already exists"
        }
      ],
      "basic_fields": [
        "path",
        "exist_ok"
      ]
    },
    {
      "title": "Created Time",
      "description": "Get file creation timestamp.\n    files, metadata, created, time",
      "namespace": "lib.os",
      "node_type": "lib.os.CreatedTime",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Dirname",
      "description": "Get the directory name component of a file path.\n    files, path, dirname\n\n    Use cases:\n    - Extract directory path from full path\n    - Get parent directory\n    - Process directory paths",
      "namespace": "lib.os",
      "node_type": "lib.os.Dirname",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "File path to get dirname from"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "File Exists",
      "description": "Check if a file or directory exists at the specified path.\n    files, check, exists\n\n    Use cases:\n    - Validate file presence before processing\n    - Implement conditional logic based on file existence",
      "namespace": "lib.os",
      "node_type": "lib.os.FileExists",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to check for existence"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "File Extension",
      "description": "Get file extension.\n    files, metadata, extension",
      "namespace": "lib.os",
      "node_type": "lib.os.FileExtension",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "File Name",
      "description": "Get file name without path.\n    files, metadata, name",
      "namespace": "lib.os",
      "node_type": "lib.os.FileName",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "File Name Match",
      "description": "Match a filename against a pattern using Unix shell-style wildcards.\n    files, pattern, match, filter\n\n    Use cases:\n    - Filter files by name pattern\n    - Validate file naming conventions\n    - Match file extensions",
      "namespace": "lib.os",
      "node_type": "lib.os.FileNameMatch",
      "properties": [
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Filename to check"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "*",
          "title": "Pattern",
          "description": "Pattern to match against (e.g. *.txt, data_*.csv)"
        },
        {
          "name": "case_sensitive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Case Sensitive",
          "description": "Whether the pattern matching should be case-sensitive"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "filename",
        "pattern",
        "case_sensitive"
      ]
    },
    {
      "title": "Filter File Names",
      "description": "Filter a list of filenames using Unix shell-style wildcards.\n    files, pattern, filter, list\n\n    Use cases:\n    - Filter multiple files by pattern\n    - Batch process files matching criteria\n    - Select files by extension",
      "namespace": "lib.os",
      "node_type": "lib.os.FilterFileNames",
      "properties": [
        {
          "name": "filenames",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Filenames",
          "description": "list of filenames to filter"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "*",
          "title": "Pattern",
          "description": "Pattern to filter by (e.g. *.txt, data_*.csv)"
        },
        {
          "name": "case_sensitive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Case Sensitive",
          "description": "Whether the pattern matching should be case-sensitive"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "filenames",
        "pattern",
        "case_sensitive"
      ]
    },
    {
      "title": "Get Directory",
      "description": "Get directory containing the file.\n    files, metadata, directory",
      "namespace": "lib.os",
      "node_type": "lib.os.GetDirectory",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Get Environment Variable",
      "description": "Gets an environment variable value.\n    environment, variable, system\n\n    Use cases:\n    - Access configuration\n    - Get system settings",
      "namespace": "lib.os",
      "node_type": "lib.os.GetEnvironmentVariable",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "Environment variable name"
        },
        {
          "name": "default",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Default",
          "description": "Default value if not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "none"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "default"
      ]
    },
    {
      "title": "Get File Size",
      "description": "Get file size in bytes.\n    files, metadata, size",
      "namespace": "lib.os",
      "node_type": "lib.os.GetFileSize",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Get Path Info",
      "description": "Gets information about a path.\n    path, info, metadata\n\n    Use cases:\n    - Extract path components\n    - Parse file paths",
      "namespace": "lib.os",
      "node_type": "lib.os.GetPathInfo",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Get System Info",
      "description": "Gets system information.\n    system, info, platform\n\n    Use cases:\n    - Check system compatibility\n    - Platform-specific logic",
      "namespace": "lib.os",
      "node_type": "lib.os.GetSystemInfo",
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ]
    },
    {
      "title": "Is Directory",
      "description": "Check if path is a directory.\n    files, metadata, type",
      "namespace": "lib.os",
      "node_type": "lib.os.IsDirectory",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Is File",
      "description": "Check if path is a file.\n    files, metadata, type",
      "namespace": "lib.os",
      "node_type": "lib.os.IsFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Join Paths",
      "description": "Joins path components.\n    path, join, combine\n\n    Use cases:\n    - Build file paths\n    - Create cross-platform paths",
      "namespace": "lib.os",
      "node_type": "lib.os.JoinPaths",
      "properties": [
        {
          "name": "paths",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Paths",
          "description": "Path components to join"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "file_path"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "paths"
      ]
    },
    {
      "title": "List Files",
      "description": "list files in a directory matching a pattern.\n    files, list, directory\n\n    Use cases:\n    - Get files for batch processing\n    - Filter files by extension or pattern",
      "namespace": "lib.os",
      "node_type": "lib.os.ListFiles",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {
            "path": "~"
          },
          "title": "Folder",
          "description": "Directory to scan"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "*",
          "title": "Pattern",
          "description": "File pattern to match (e.g. *.txt)"
        },
        {
          "name": "include_subdirectories",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Include Subdirectories",
          "description": "Search subdirectories"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "file_path"
          },
          "name": "file"
        }
      ],
      "basic_fields": [
        "folder",
        "pattern",
        "include_subdirectories"
      ]
    },
    {
      "title": "Modified Time",
      "description": "Get file last modified timestamp.\n    files, metadata, modified, time",
      "namespace": "lib.os",
      "node_type": "lib.os.ModifiedTime",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Move File",
      "description": "Move a file from source to destination path.\n    files, move, manage\n\n    Use cases:\n    - Organize files into directories\n    - Process and archive files\n    - Relocate completed files",
      "namespace": "lib.os",
      "node_type": "lib.os.MoveFile",
      "properties": [
        {
          "name": "source_path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Source Path",
          "description": "Source file path"
        },
        {
          "name": "destination_path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Destination Path",
          "description": "Destination file path"
        }
      ],
      "basic_fields": [
        "source_path",
        "destination_path"
      ]
    },
    {
      "title": "Normalize Path",
      "description": "Normalizes a path.\n    path, normalize, clean\n\n    Use cases:\n    - Standardize paths\n    - Remove redundant separators",
      "namespace": "lib.os",
      "node_type": "lib.os.NormalizePath",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to normalize"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "file_path"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Open Workspace Directory",
      "description": "Open the workspace directory.\n    files, workspace, directory",
      "namespace": "lib.os",
      "node_type": "lib.os.OpenWorkspaceDirectory",
      "outputs": [
        {
          "type": {
            "type": "none"
          },
          "name": "output"
        }
      ]
    },
    {
      "title": "Path To String",
      "description": "Convert a FilePath object to a string.\n    files, path, string, convert\n\n    Use cases:\n    - Get raw string path from FilePath object\n    - Convert FilePath for string operations\n    - Extract path string for external use",
      "namespace": "lib.os",
      "node_type": "lib.os.PathToString",
      "properties": [
        {
          "name": "file_path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "File Path",
          "description": "FilePath object to convert to string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "file_path"
      ]
    },
    {
      "title": "Relative Path",
      "description": "Return a relative path to a target from a start directory.\n    files, path, relative\n\n    Use cases:\n    - Create relative path references\n    - Generate portable paths\n    - Compare file locations",
      "namespace": "lib.os",
      "node_type": "lib.os.RelativePath",
      "properties": [
        {
          "name": "target_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Target Path",
          "description": "Target path to convert to relative"
        },
        {
          "name": "start_path",
          "type": {
            "type": "str"
          },
          "default": ".",
          "title": "Start Path",
          "description": "Start path for relative conversion"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "file_path"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "target_path",
        "start_path"
      ]
    },
    {
      "title": "Set Environment Variable",
      "description": "Sets an environment variable.\n    environment, variable, system\n\n    Use cases:\n    - Configure runtime settings\n    - Set up process environment",
      "namespace": "lib.os",
      "node_type": "lib.os.SetEnvironmentVariable",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "Environment variable name"
        },
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value",
          "description": "Environment variable value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "none"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Show Notification",
      "description": "Shows a system notification.\n    notification, system, alert\n\n    Use cases:\n    - Alert user of completed tasks\n    - Show process status\n    - Display important messages",
      "namespace": "lib.os",
      "node_type": "lib.os.ShowNotification",
      "properties": [
        {
          "name": "title",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Title",
          "description": "Title of the notification"
        },
        {
          "name": "message",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Message",
          "description": "Content of the notification"
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Timeout",
          "description": "How long the notification should stay visible (in seconds)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "none"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "title",
        "message",
        "timeout"
      ]
    },
    {
      "title": "Split Extension",
      "description": "Split a path into root and extension components.\n    files, path, extension, split\n\n    Use cases:\n    - Extract file extension\n    - Process filename without extension\n    - Handle file types",
      "namespace": "lib.os",
      "node_type": "lib.os.SplitExtension",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to split"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Split Path",
      "description": "Split a path into directory and file components.\n    files, path, split\n\n    Use cases:\n    - Separate directory from filename\n    - Process path components separately\n    - Extract path parts",
      "namespace": "lib.os",
      "node_type": "lib.os.SplitPath",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to split"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Workspace Directory",
      "description": "Get the workspace directory.\n    files, workspace, directory",
      "namespace": "lib.os",
      "node_type": "lib.os.WorkspaceDirectory",
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ]
    },
    {
      "title": "Get Close Matches",
      "description": "Finds close matches for a word within a list of possibilities.\n    difflib, fuzzy, match\n\n    Use cases:\n    - Suggest alternatives for misspelled words\n    - Map user input to valid options\n    - Provide recommendations based on partial text",
      "namespace": "lib.difflib",
      "node_type": "lib.difflib.GetCloseMatches",
      "properties": [
        {
          "name": "word",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Word",
          "description": "Word to match"
        },
        {
          "name": "possibilities",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Possibilities",
          "description": "List of possible words"
        },
        {
          "name": "n",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "N",
          "description": "Maximum number of matches to return",
          "min": 1.0
        },
        {
          "name": "cutoff",
          "type": {
            "type": "float"
          },
          "default": 0.6,
          "title": "Cutoff",
          "description": "Minimum similarity ratio",
          "min": 0.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "word",
        "possibilities",
        "n",
        "cutoff"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Sequence Similarity Ratio",
      "description": "Calculates the similarity ratio between two strings.\n    difflib, similarity, ratio, compare\n\n    Use cases:\n    - Fuzzy string matching\n    - Compare document versions\n    - Evaluate similarity of user input",
      "namespace": "lib.difflib",
      "node_type": "lib.difflib.SimilarityRatio",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "A",
          "description": "First string to compare"
        },
        {
          "name": "b",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "B",
          "description": "Second string to compare"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Unified Diff",
      "description": "Generates a unified diff between two texts.\n    difflib, diff, compare\n\n    Use cases:\n    - Display differences between versions of text files\n    - Highlight changes in user submitted documents\n    - Compare code snippets",
      "namespace": "lib.difflib",
      "node_type": "lib.difflib.UnifiedDiff",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "A",
          "description": "Original text"
        },
        {
          "name": "b",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "B",
          "description": "Modified text"
        },
        {
          "name": "fromfile",
          "type": {
            "type": "str"
          },
          "default": "a",
          "title": "Fromfile",
          "description": "Name of the original file"
        },
        {
          "name": "tofile",
          "type": {
            "type": "str"
          },
          "default": "b",
          "title": "Tofile",
          "description": "Name of the modified file"
        },
        {
          "name": "lineterm",
          "type": {
            "type": "str"
          },
          "default": "\n",
          "title": "Lineterm",
          "description": "Line terminator"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b",
        "fromfile",
        "tofile",
        "lineterm"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Simple Http Server",
      "description": "Starts a simple HTTP server inside Docker and streams logs.\n    http, server, web\n\n    Emits the reachable endpoint URL on the \"endpoint\" output when ready,\n    then streams stdout/stderr lines on the corresponding outputs.",
      "namespace": "lib.http_server",
      "node_type": "lib.http_server.SimpleHttpServer",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "str"
          },
          "default": "python:3.11-slim",
          "title": "Image",
          "description": "Docker image to run the server in"
        },
        {
          "name": "container_port",
          "type": {
            "type": "int"
          },
          "default": 8000,
          "title": "Container Port",
          "description": "Port the server listens on inside the container"
        },
        {
          "name": "command",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Command",
          "description": "Startup command. If empty, uses 'python -m http.server <container_port> --bind 0.0.0.0'"
        },
        {
          "name": "timeout_seconds",
          "type": {
            "type": "int"
          },
          "default": 600,
          "title": "Timeout Seconds",
          "description": "Max lifetime of the server container (seconds)"
        },
        {
          "name": "ready_timeout_seconds",
          "type": {
            "type": "int"
          },
          "default": 15,
          "title": "Ready Timeout Seconds",
          "description": "Seconds to wait for server readiness"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "endpoint"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "image",
        "container_port",
        "command",
        "timeout_seconds",
        "ready_timeout_seconds"
      ]
    },
    {
      "title": "Random Bool",
      "description": "Return a random boolean value.\n    random, boolean, coinflip, bool\n\n    Use cases:\n    - Make random yes/no decisions\n    - Simulate coin flips\n    - Introduce randomness in control flow",
      "namespace": "lib.random",
      "node_type": "lib.random.RandomBool",
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "expose_as_tool": true
    },
    {
      "title": "Random Choice",
      "description": "Select a random element from a list.\n    random, choice, select, pick\n\n    Use cases:\n    - Choose a random sample from options\n    - Implement simple lottery behaviour\n    - Pick a random item from user input",
      "namespace": "lib.random",
      "node_type": "lib.random.RandomChoice",
      "properties": [
        {
          "name": "options",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Options",
          "description": "List of options"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "options"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Random Float",
      "description": "Generate a random floating point number within a range.\n    random, float, number, rand, uniform\n\n    Use cases:\n    - Create random probabilities\n    - Generate noisy data for testing\n    - Produce random values for simulations",
      "namespace": "lib.random",
      "node_type": "lib.random.RandomFloat",
      "properties": [
        {
          "name": "minimum",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Minimum",
          "description": "Minimum value"
        },
        {
          "name": "maximum",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Maximum",
          "description": "Maximum value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "minimum",
        "maximum"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Random Int",
      "description": "Generate a random integer within a range.\n    random, integer, number, rand, randint\n\n    Use cases:\n    - Pick a random index or identifier\n    - Create randomized counters or IDs\n    - Sample integers for testing",
      "namespace": "lib.random",
      "node_type": "lib.random.RandomInt",
      "properties": [
        {
          "name": "minimum",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Minimum",
          "description": "Minimum value (inclusive)"
        },
        {
          "name": "maximum",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Maximum",
          "description": "Maximum value (inclusive)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "minimum",
        "maximum"
      ],
      "expose_as_tool": true
    },
    {
      "title": "FTPBase",
      "description": "Base node for FTP operations.\n    ftp, network, transfer\n\n    Use cases:\n    - Provide shared connection parameters\n    - Reuse login logic across FTP nodes\n    - Hide base class from UI",
      "namespace": "lib.ftplib",
      "node_type": "lib.ftplib.FTPBase",
      "properties": [
        {
          "name": "host",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Host",
          "description": "FTP server host"
        },
        {
          "name": "username",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Username",
          "description": "Username for authentication"
        },
        {
          "name": "password",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Password",
          "description": "Password for authentication"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "host",
        "username",
        "password"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Download File",
      "description": "Download a file from an FTP server.\n    ftp, download, file\n\n    Use cases:\n    - Retrieve remote files for processing\n    - Backup data from an FTP server\n    - Integrate legacy FTP systems",
      "namespace": "lib.ftplib",
      "node_type": "lib.ftplib.FTPDownloadFile",
      "properties": [
        {
          "name": "host",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Host",
          "description": "FTP server host"
        },
        {
          "name": "username",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Username",
          "description": "Username for authentication"
        },
        {
          "name": "password",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Password",
          "description": "Password for authentication"
        },
        {
          "name": "remote_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Remote Path",
          "description": "Remote file path to download"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "host",
        "username",
        "password",
        "remote_path"
      ],
      "expose_as_tool": true
    },
    {
      "title": "List Directory",
      "description": "List files in a directory on an FTP server.\n    ftp, list, directory\n\n    Use cases:\n    - Browse remote directories\n    - Check available files before download\n    - Monitor FTP server contents",
      "namespace": "lib.ftplib",
      "node_type": "lib.ftplib.FTPListDirectory",
      "properties": [
        {
          "name": "host",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Host",
          "description": "FTP server host"
        },
        {
          "name": "username",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Username",
          "description": "Username for authentication"
        },
        {
          "name": "password",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Password",
          "description": "Password for authentication"
        },
        {
          "name": "directory",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Directory",
          "description": "Remote directory to list"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "host",
        "username",
        "password",
        "directory"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Upload File",
      "description": "Upload a file to an FTP server.\n    ftp, upload, file\n\n    Use cases:\n    - Transfer files to an FTP server\n    - Automate backups to a remote system\n    - Integrate with legacy FTP workflows",
      "namespace": "lib.ftplib",
      "node_type": "lib.ftplib.FTPUploadFile",
      "properties": [
        {
          "name": "host",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Host",
          "description": "FTP server host"
        },
        {
          "name": "username",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Username",
          "description": "Username for authentication"
        },
        {
          "name": "password",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Password",
          "description": "Password for authentication"
        },
        {
          "name": "remote_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Remote Path",
          "description": "Remote file path to upload to"
        },
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Document",
          "description": "Document to upload"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "none"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "host",
        "username",
        "password",
        "remote_path",
        "document"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Compress",
      "description": "Compress binary data using the zlib algorithm.\n    zlib, compress, deflate, binary\n\n    Use cases:\n    - Reduce size of binary data\n    - Prepare payloads for transmission\n    - Store data in compressed form",
      "namespace": "lib.zlib",
      "node_type": "lib.zlib.Compress",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "bytes"
          },
          "default": "",
          "title": "Data",
          "description": "Data to compress"
        },
        {
          "name": "level",
          "type": {
            "type": "int"
          },
          "default": 9,
          "title": "Level",
          "description": "Compression level",
          "min": 0.0,
          "max": 9.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "level"
      ]
    },
    {
      "title": "Decompress",
      "description": "Decompress zlib-compressed binary data.\n    zlib, decompress, inflate, binary\n\n    Use cases:\n    - Restore compressed payloads\n    - Read previously compressed files\n    - Handle zlib streams from external services",
      "namespace": "lib.zlib",
      "node_type": "lib.zlib.Decompress",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "bytes"
          },
          "default": "",
          "title": "Data",
          "description": "Data to decompress"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data"
      ]
    },
    {
      "title": "Browser",
      "description": "Fetches content from a web page using a headless browser.\n    browser, web, scraping, content, fetch\n\n    Use cases:\n    - Extract content from JavaScript-heavy websites\n    - Retrieve text content from web pages\n    - Get metadata from web pages\n    - Save extracted content to files",
      "namespace": "lib.browser",
      "node_type": "lib.browser.Browser",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to navigate to"
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 20000,
          "title": "Timeout",
          "description": "Timeout in milliseconds for page navigation"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "success"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "content"
        },
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "metadata"
        }
      ],
      "basic_fields": [
        "url",
        "timeout"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Browser Navigation",
      "description": "Navigates and interacts with web pages in a browser session.\n    browser, navigation, interaction, click, extract\n\n    Use cases:\n    - Perform complex web interactions\n    - Navigate through multi-step web processes\n    - Extract content after interaction",
      "namespace": "lib.browser",
      "node_type": "lib.browser.BrowserNavigation",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to navigate to (required for 'goto' action)"
        },
        {
          "name": "action",
          "type": {
            "type": "enum",
            "values": [
              "click",
              "goto",
              "back",
              "forward",
              "reload",
              "extract"
            ],
            "type_name": "nodetool.nodes.lib.browser.Action"
          },
          "default": "goto",
          "title": "Action",
          "description": "Navigation or extraction action to perform"
        },
        {
          "name": "selector",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Selector",
          "description": "CSS selector for the element to interact with or extract from"
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 30000,
          "title": "Timeout",
          "description": "Timeout in milliseconds for the action"
        },
        {
          "name": "wait_for",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Wait For",
          "description": "Optional selector to wait for after performing the action"
        },
        {
          "name": "extract_type",
          "type": {
            "type": "enum",
            "values": [
              "text",
              "html",
              "value",
              "attribute"
            ],
            "type_name": "nodetool.nodes.lib.browser.ExtractType"
          },
          "default": "text",
          "title": "Extract Type",
          "description": "Type of content to extract (for 'extract' action)"
        },
        {
          "name": "attribute",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Attribute",
          "description": "Attribute name to extract (when extract_type is 'attribute')"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url",
        "action",
        "selector",
        "timeout",
        "wait_for",
        "extract_type",
        "attribute"
      ]
    },
    {
      "title": "Browser Use",
      "description": "Browser agent tool that uses browser_use under the hood.\n\n    This module provides a tool for running browser-based agents using the browser_use library.\n    The agent can perform complex web automation tasks like form filling, navigation, data extraction,\n    and multi-step workflows using natural language instructions.\n\n    Use cases:\n    - Perform complex web automation tasks based on natural language.\n    - Automate form filling and data entry.\n    - Scrape data after complex navigation or interaction sequences.\n    - Automate multi-step web workflows.",
      "namespace": "lib.browser",
      "node_type": "lib.browser.BrowserUse",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gpt-4o",
              "claude-3-5-sonnet"
            ],
            "type_name": "nodetool.nodes.lib.browser.BrowserUseModel"
          },
          "default": "gpt-4o",
          "title": "Model",
          "description": "The model to use for the browser agent."
        },
        {
          "name": "task",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Task",
          "description": "Natural language description of the browser task to perform. Can include complex multi-step instructions like 'Compare prices between websites', 'Fill out forms', or 'Extract specific data'."
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 300,
          "title": "Timeout",
          "description": "Maximum time in seconds to allow for task completion. Complex tasks may require longer timeouts.",
          "min": 1.0,
          "max": 3600.0
        },
        {
          "name": "use_remote_browser",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Use Remote Browser",
          "description": "Use a remote browser instead of a local one"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "success"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "task"
        },
        {
          "type": {
            "type": "any"
          },
          "name": "result"
        },
        {
          "type": {
            "type": "str",
            "optional": true
          },
          "name": "error"
        }
      ],
      "basic_fields": [
        "model",
        "task",
        "timeout",
        "use_remote_browser"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Download File",
      "description": "Downloads a file from a URL and saves it to disk.\n    download, file, web, save\n\n    Use cases:\n    - Download documents, images, or other files from the web\n    - Save data for further processing\n    - Retrieve file assets for analysis",
      "namespace": "lib.browser",
      "node_type": "lib.browser.DownloadFile",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL of the file to download"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Screenshot",
      "description": "Takes a screenshot of a web page or specific element.\n    browser, screenshot, capture, image\n\n    Use cases:\n    - Capture visual representation of web pages\n    - Document specific UI elements\n    - Create visual records of web content",
      "namespace": "lib.browser",
      "node_type": "lib.browser.Screenshot",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to navigate to before taking screenshot"
        },
        {
          "name": "selector",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Selector",
          "description": "Optional CSS selector for capturing a specific element"
        },
        {
          "name": "output_file",
          "type": {
            "type": "file_path"
          },
          "default": {
            "path": "screenshot.png"
          },
          "title": "Output File",
          "description": "Path to save the screenshot (relative to workspace)"
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 30000,
          "title": "Timeout",
          "description": "Timeout in milliseconds for page navigation"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url",
        "selector",
        "output_file",
        "timeout"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Web Fetch",
      "description": "Fetches HTML content from a URL and converts it to text.\n    web, fetch, html, markdown, http\n\n    Use cases:\n    - Extract text content from web pages\n    - Process web content for analysis\n    - Save web content to files",
      "namespace": "lib.browser",
      "node_type": "lib.browser.WebFetch",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to fetch content from"
        },
        {
          "name": "selector",
          "type": {
            "type": "str"
          },
          "default": "body",
          "title": "Selector",
          "description": "CSS selector to extract specific elements"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url",
        "selector"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Convert To Markdown",
      "description": "Converts various document formats to markdown using MarkItDown.\n    markdown, convert, document\n\n    Use cases:\n    - Convert Word documents to markdown\n    - Convert Excel files to markdown tables\n    - Convert PowerPoint to markdown content",
      "namespace": "lib.markitdown",
      "node_type": "lib.markitdown.ConvertToMarkdown",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Document",
          "description": "The document to convert to markdown"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "document"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Get Secret",
      "description": "Get a secret value from configuration.\n    secrets, credentials, configuration",
      "namespace": "lib.secret",
      "node_type": "lib.secret.GetSecret",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "Secret key name"
        },
        {
          "name": "default",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Default",
          "description": "Default value if not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "none"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "default"
      ]
    },
    {
      "title": "Set Secret",
      "description": "Set a secret value and persist it.\n    secrets, credentials, configuration",
      "namespace": "lib.secret",
      "node_type": "lib.secret.SetSecret",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "Secret key name"
        },
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value",
          "description": "Secret value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "none"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Base Url",
      "description": "Extract the base URL from a given URL.\n    url parsing, domain extraction, web utilities\n\n    Use cases:\n    - Get domain name from full URLs\n    - Clean up URLs for comparison\n    - Extract root website addresses\n    - Standardize URL formats",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.BaseUrl",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "URL",
          "description": "The URL to extract the base from"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "Extract Audio",
      "description": "Extract audio elements from HTML content.\n    extract, audio, src\n\n    Use cases:\n    - Collect audio sources from web pages\n    - Analyze audio usage on websites\n    - Create audio playlists",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractAudio",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract audio from."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "The base URL of the page, used to resolve relative audio URLs."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        }
      ],
      "basic_fields": [
        "html",
        "base_url"
      ]
    },
    {
      "title": "Extract Images",
      "description": "Extract images from HTML content.\n    extract, images, src\n\n    Use cases:\n    - Collect images from web pages\n    - Analyze image usage on websites\n    - Create image galleries",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractImages",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract images from."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "The base URL of the page, used to resolve relative image URLs."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "image"
        }
      ],
      "basic_fields": [
        "html",
        "base_url"
      ]
    },
    {
      "title": "Extract Links",
      "description": "Extract links from HTML content.\n    extract, links, urls\n\n    Use cases:\n    - Analyze website structure\n    - Discover related content\n    - Build sitemaps",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractLinks",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract links from."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "The base URL of the page, used to determine internal/external links."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "href"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "type"
        }
      ],
      "basic_fields": [
        "html",
        "base_url"
      ]
    },
    {
      "title": "Extract Metadata",
      "description": "Extract metadata from HTML content.\n    extract, metadata, seo\n\n    Use cases:\n    - Analyze SEO elements\n    - Gather page information\n    - Extract structured data",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractMetadata",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract metadata from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "title"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "description"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "keywords"
        }
      ],
      "basic_fields": [
        "html"
      ]
    },
    {
      "title": "Extract Videos",
      "description": "Extract videos from HTML content.\n    extract, videos, src\n\n    Use cases:\n    - Collect video sources from web pages\n    - Analyze video usage on websites\n    - Create video playlists",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractVideos",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract videos from."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "The base URL of the page, used to resolve relative video URLs."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "video"
        }
      ],
      "basic_fields": [
        "html",
        "base_url"
      ]
    },
    {
      "title": "Convert HTML to Text",
      "description": "Converts HTML to plain text by removing tags and decoding entities using BeautifulSoup.\n    html, text, convert\n\n    Use cases:\n    - Cleaning HTML content for text analysis\n    - Extracting readable content from web pages\n    - Preparing HTML data for natural language processing",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.HTMLToText",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "HTML"
        },
        {
          "name": "preserve_linebreaks",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Preserve Line Breaks",
          "description": "Convert block-level elements to newlines"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "preserve_linebreaks"
      ]
    },
    {
      "title": "Website Content Extractor",
      "description": "Extract main content from a website, removing navigation, ads, and other non-essential elements.\n    scrape, web scraping, content extraction, text analysis\n\n    Use cases:\n    - Clean web content for further analysis\n    - Extract article text from news websites\n    - Prepare web content for summarization",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.WebsiteContentExtractor",
      "properties": [
        {
          "name": "html_content",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html Content",
          "description": "The raw HTML content of the website."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "html_content"
      ]
    },
    {
      "title": "Extract Bullet Lists",
      "description": "Extracts bulleted lists from markdown.\n    markdown, lists, bullets, extraction\n\n    Use cases:\n    - Extract unordered list items\n    - Analyze bullet point structures\n    - Convert bullet lists to structured data",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractBulletLists",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "markdown"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Code Blocks",
      "description": "Extracts code blocks and their languages from markdown.\n    markdown, code, extraction\n\n    Use cases:\n    - Extract code samples for analysis\n    - Collect programming examples\n    - Analyze code snippets in documentation",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractCodeBlocks",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "markdown"
      ]
    },
    {
      "title": "Extract Headers",
      "description": "Extracts headers and creates a document structure/outline.\n    markdown, headers, structure\n\n    Use cases:\n    - Generate table of contents\n    - Analyze document structure\n    - Extract main topics from documents",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractHeaders",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        },
        {
          "name": "max_level",
          "type": {
            "type": "int"
          },
          "default": 6,
          "title": "Max Level",
          "description": "Maximum header level to extract (1-6)",
          "min": 1.0,
          "max": 6.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "markdown",
        "max_level"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Links",
      "description": "Extracts all links from markdown text.\n    markdown, links, extraction\n\n    Use cases:\n    - Extract references and citations from academic documents\n    - Build link graphs from markdown documentation\n    - Analyze external resources referenced in markdown files",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractLinks",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        },
        {
          "name": "include_titles",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Include Titles",
          "description": "Whether to include link titles in output"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "markdown",
        "include_titles"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Numbered Lists",
      "description": "Extracts numbered lists from markdown.\n    markdown, lists, numbered, extraction\n\n    Use cases:\n    - Extract ordered list items\n    - Analyze enumerated structures\n    - Convert numbered lists to structured data",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractNumberedLists",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "markdown"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Tables",
      "description": "Extracts tables from markdown and converts them to structured data.\n    markdown, tables, data\n\n    Use cases:\n    - Extract tabular data from markdown\n    - Convert markdown tables to structured formats\n    - Analyze tabulated information",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractTables",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "markdown"
      ],
      "expose_as_tool": true
    },
    {
      "title": "DELETE Request",
      "description": "Remove a resource from a server using an HTTP DELETE request.\n    http, delete, request, url\n\n    Use cases:\n    - Delete user accounts\n    - Remove API resources\n    - Cancel subscriptions\n    - Clear cache entries",
      "namespace": "lib.http",
      "node_type": "lib.http.DeleteRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Download Dataframe",
      "description": "Download data from a URL and return as a dataframe.\n    http, get, request, url, dataframe, csv, json, data\n\n    Use cases:\n    - Download CSV data and convert to dataframe\n    - Fetch JSON data and convert to dataframe\n    - Retrieve tabular data from APIs\n    - Process data files from URLs",
      "namespace": "lib.http",
      "node_type": "lib.http.DownloadDataframe",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "file_format",
          "type": {
            "type": "enum",
            "values": [
              "csv",
              "json",
              "tsv"
            ],
            "type_name": "nodetool.nodes.lib.http.FileFormat"
          },
          "default": "csv",
          "title": "File Format",
          "description": "The format of the data file (csv, json, tsv)."
        },
        {
          "name": "columns",
          "type": {
            "type": "record_type"
          },
          "default": {},
          "title": "Columns",
          "description": "The columns of the dataframe."
        },
        {
          "name": "encoding",
          "type": {
            "type": "str"
          },
          "default": "utf-8",
          "title": "Encoding",
          "description": "The encoding of the text file."
        },
        {
          "name": "delimiter",
          "type": {
            "type": "str"
          },
          "default": ",",
          "title": "Delimiter",
          "description": "The delimiter for CSV/TSV files."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url",
        "columns",
        "file_format"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Download Files",
      "description": "Download files from a list of URLs into a local folder.\n    download, files, urls, batch\n\n    Use cases:\n    - Batch download files from multiple URLs\n    - Create local copies of remote resources\n    - Archive web content\n    - Download datasets",
      "namespace": "lib.http",
      "node_type": "lib.http.DownloadFiles",
      "properties": [
        {
          "name": "urls",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Urls",
          "description": "List of URLs to download."
        },
        {
          "name": "output_folder",
          "type": {
            "type": "file_path"
          },
          "default": {
            "path": "downloads"
          },
          "title": "Output Folder",
          "description": "Local folder path where files will be saved."
        },
        {
          "name": "max_concurrent_downloads",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "Max Concurrent Downloads",
          "description": "Maximum number of concurrent downloads."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "success"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "failed"
        }
      ],
      "basic_fields": [
        "urls",
        "output_folder",
        "max_concurrent_downloads"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Fetch Page",
      "description": "Fetch a web page using Selenium and return its content.\n    selenium, fetch, webpage, http\n\n    Use cases:\n    - Retrieve content from dynamic websites\n    - Capture JavaScript-rendered content\n    - Interact with web applications",
      "namespace": "lib.http",
      "node_type": "lib.http.FetchPage",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to fetch the page from."
        },
        {
          "name": "wait_time",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Wait Time",
          "description": "Maximum time to wait for page load (in seconds)."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "html"
        },
        {
          "type": {
            "type": "bool"
          },
          "name": "success"
        },
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "none"
              }
            ]
          },
          "name": "error_message"
        }
      ],
      "basic_fields": [
        "url",
        "wait_time"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Filter Valid URLs",
      "description": "Filter a list of URLs by checking their validity using HEAD requests.\n    url validation, http, head request\n\n    Use cases:\n    - Clean URL lists by removing broken links\n    - Verify resource availability\n    - Validate website URLs before processing",
      "namespace": "lib.http",
      "node_type": "lib.http.FilterValidURLs",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "urls",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Urls",
          "description": "List of URLs to validate."
        },
        {
          "name": "max_concurrent_requests",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Max Concurrent Requests",
          "description": "Maximum number of concurrent HEAD requests."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "GET Request",
      "description": "Perform an HTTP GET request to retrieve data from a specified URL.\n    http, get, request, url\n\n    Use cases:\n    - Fetch web page content\n    - Retrieve API data\n    - Download files\n    - Check website availability",
      "namespace": "lib.http",
      "node_type": "lib.http.GetRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "GET Binary",
      "description": "Perform an HTTP GET request and return raw binary data.\n    http, get, request, url, binary, download\n\n    Use cases:\n    - Download binary files\n    - Fetch images or media\n    - Retrieve PDF documents\n    - Download any non-text content",
      "namespace": "lib.http",
      "node_type": "lib.http.GetRequestBinary",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "GET Document",
      "description": "Perform an HTTP GET request and return a document\n    http, get, request, url, document\n\n    Use cases:\n    - Download PDF documents\n    - Retrieve Word documents\n    - Fetch Excel files\n    - Download any document format",
      "namespace": "lib.http",
      "node_type": "lib.http.GetRequestDocument",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "HTTPBase",
      "description": "Base node for HTTP requests.\n\n    http, network, request\n\n    Use cases:\n    - Share common fields for HTTP nodes\n    - Add custom request parameters in subclasses\n    - Control visibility of specific request types",
      "namespace": "lib.http",
      "node_type": "lib.http.HTTPBase",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "HEAD Request",
      "description": "Retrieve headers from a resource using an HTTP HEAD request.\n    http, head, request, url\n\n    Use cases:\n    - Check resource existence\n    - Get metadata without downloading content\n    - Verify authentication or permissions",
      "namespace": "lib.http",
      "node_type": "lib.http.HeadRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "Image Downloader",
      "description": "Download images from list of URLs and return a list of ImageRefs.\n    image download, web scraping, data processing\n\n    Use cases:\n    - Prepare image datasets for machine learning tasks\n    - Archive images from web pages\n    - Process and analyze images extracted from websites",
      "namespace": "lib.http",
      "node_type": "lib.http.ImageDownloader",
      "properties": [
        {
          "name": "images",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Images",
          "description": "List of image URLs to download."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "Base URL to prepend to relative image URLs."
        },
        {
          "name": "max_concurrent_downloads",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Max Concurrent Downloads",
          "description": "Maximum number of concurrent image downloads."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "name": "images"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "failed_urls"
        }
      ],
      "basic_fields": [
        "images",
        "base_url",
        "max_concurrent_downloads"
      ],
      "expose_as_tool": true
    },
    {
      "title": "GET JSON",
      "description": "Perform an HTTP GET request and parse the response as JSON.\n    http, get, request, url, json, api\n\n    Use cases:\n    - Fetch data from REST APIs\n    - Retrieve JSON-formatted responses\n    - Interface with JSON web services",
      "namespace": "lib.http",
      "node_type": "lib.http.JSONGetRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "PATCH JSON",
      "description": "Partially update resources with JSON data using an HTTP PATCH request.\n    http, patch, request, url, json, api\n\n    Use cases:\n    - Partial updates to API resources\n    - Modify specific fields without full replacement\n    - Efficient updates for large objects",
      "namespace": "lib.http",
      "node_type": "lib.http.JSONPatchRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Data",
          "description": "The JSON data to send in the PATCH request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "POST JSON",
      "description": "Send JSON data to a server using an HTTP POST request.\n    http, post, request, url, json, api\n\n    Use cases:\n    - Send structured data to REST APIs\n    - Create resources with JSON payloads\n    - Interface with modern web services",
      "namespace": "lib.http",
      "node_type": "lib.http.JSONPostRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Data",
          "description": "The JSON data to send in the POST request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "PUT JSON",
      "description": "Update resources with JSON data using an HTTP PUT request.\n    http, put, request, url, json, api\n\n    Use cases:\n    - Update existing API resources\n    - Replace complete objects in REST APIs\n    - Set configuration with JSON data",
      "namespace": "lib.http",
      "node_type": "lib.http.JSONPutRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Data",
          "description": "The JSON data to send in the PUT request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "POST Request",
      "description": "Send data to a server using an HTTP POST request.\n    http, post, request, url, data\n\n    Use cases:\n    - Submit form data\n    - Create new resources on an API\n    - Upload files\n    - Authenticate users",
      "namespace": "lib.http",
      "node_type": "lib.http.PostRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Data",
          "description": "The data to send in the POST request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "POST Binary",
      "description": "Send data using an HTTP POST request and return raw binary data.\n    http, post, request, url, data, binary\n\n    Use cases:\n    - Upload and receive binary files\n    - Interact with binary APIs\n    - Process image or media uploads\n    - Handle binary file transformations",
      "namespace": "lib.http",
      "node_type": "lib.http.PostRequestBinary",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "bytes"
              }
            ]
          },
          "default": "",
          "title": "Data",
          "description": "The data to send in the POST request. Can be string or binary."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "PUT Request",
      "description": "Update existing resources on a server using an HTTP PUT request.\n    http, put, request, url, data\n\n    Use cases:\n    - Update user profiles\n    - Modify existing API resources\n    - Replace file contents\n    - Set configuration values",
      "namespace": "lib.http",
      "node_type": "lib.http.PutRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Data",
          "description": "The data to send in the PUT request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Add",
      "description": "Adds two numbers.\n    math, add, plus",
      "namespace": "lib.math",
      "node_type": "lib.math.Add",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Cosine",
      "description": "Computes cosine of the given angle in radians.\n    math, cosine, trig",
      "namespace": "lib.math",
      "node_type": "lib.math.Cosine",
      "properties": [
        {
          "name": "angle_rad",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "Angle (rad)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "angle_rad"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Divide",
      "description": "Divides A by B.\n    math, divide, division, quotient",
      "namespace": "lib.math",
      "node_type": "lib.math.Divide",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 1.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Math Function",
      "description": "Performs a selected unary math operation on an input.\n    math, negate, absolute, square, cube, square_root, cube_root, sine, cosine, tangent, arcsine, arccosine, arctangent, log",
      "namespace": "lib.math",
      "node_type": "lib.math.MathFunction",
      "properties": [
        {
          "name": "input",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "Input"
        },
        {
          "name": "operation",
          "type": {
            "type": "enum",
            "values": [
              "negate",
              "absolute",
              "square",
              "cube",
              "square_root",
              "cube_root",
              "sine",
              "cosine",
              "tangent",
              "arcsin",
              "arccos",
              "arctan",
              "log"
            ],
            "type_name": "nodetool.nodes.lib.math.Operation"
          },
          "default": "negate",
          "title": "Operation",
          "description": "Unary operation to perform"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input",
        "operation"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Modulus",
      "description": "Computes A modulo B.\n    math, modulus, modulo, remainder",
      "namespace": "lib.math",
      "node_type": "lib.math.Modulus",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 1.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Multiply",
      "description": "Multiplies two numbers.\n    math, multiply, product",
      "namespace": "lib.math",
      "node_type": "lib.math.Multiply",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Power",
      "description": "Raises base to the given exponent.\n    math, power, exponent",
      "namespace": "lib.math",
      "node_type": "lib.math.Power",
      "properties": [
        {
          "name": "base",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "Base"
        },
        {
          "name": "exponent",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 1.0,
          "title": "Exponent"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "base",
        "exponent"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Sine",
      "description": "Computes sine of the given angle in radians.\n    math, sine, trig",
      "namespace": "lib.math",
      "node_type": "lib.math.Sine",
      "properties": [
        {
          "name": "angle_rad",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "Angle (rad)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "angle_rad"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Sqrt",
      "description": "Computes square root of x.\n    math, sqrt, square_root",
      "namespace": "lib.math",
      "node_type": "lib.math.Sqrt",
      "properties": [
        {
          "name": "x",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "X"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "x"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Subtract",
      "description": "Subtracts B from A.\n    math, subtract, minus",
      "namespace": "lib.math",
      "node_type": "lib.math.Subtract",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Load Bytes File",
      "description": "Read raw bytes from a file on disk.\n    files, bytes, read, input, load, file\n\n    Use cases:\n    - Load binary data for processing\n    - Read binary files for a workflow",
      "namespace": "lib.bytes",
      "node_type": "lib.bytes.LoadBytesFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to the file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Save Bytes File",
      "description": "Write raw bytes to a file on disk.\n    files, bytes, save, output\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "lib.bytes",
      "node_type": "lib.bytes.SaveBytesFile",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "bytes"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Data",
          "description": "The bytes to write to file"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {},
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Name of the file to save. Supports strftime format codes."
        }
      ],
      "basic_fields": [
        "data",
        "folder",
        "filename"
      ]
    },
    {
      "title": "Add Time Delta",
      "description": "Add or subtract time from a datetime.\n    datetime, add, subtract\n\n    Use cases:\n    - Calculate future/past dates\n    - Generate date ranges",
      "namespace": "lib.date",
      "node_type": "lib.date.AddTimeDelta",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Starting datetime"
        },
        {
          "name": "days",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Days",
          "description": "Number of days to add (negative to subtract)",
          "min": -3650.0,
          "max": 3650.0
        },
        {
          "name": "hours",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Hours",
          "description": "Number of hours to add (negative to subtract)",
          "min": -24.0,
          "max": 24.0
        },
        {
          "name": "minutes",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Minutes",
          "description": "Number of minutes to add (negative to subtract)",
          "min": -60.0,
          "max": 60.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_datetime",
        "days",
        "hours",
        "minutes"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Boundary Time",
      "description": "Get the start or end of a time period (day, week, month, year).\n    datetime, start, end, boundary, day, week, month, year\n\n    Use cases:\n    - Get period boundaries for reporting\n    - Normalize dates to period starts/ends",
      "namespace": "lib.date",
      "node_type": "lib.date.BoundaryTime",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Input datetime"
        },
        {
          "name": "period",
          "type": {
            "type": "enum",
            "values": [
              "day",
              "week",
              "month",
              "year"
            ],
            "type_name": "nodetool.nodes.lib.date.PeriodType"
          },
          "default": "day",
          "title": "Period",
          "description": "Time period type"
        },
        {
          "name": "boundary",
          "type": {
            "type": "enum",
            "values": [
              "start",
              "end"
            ],
            "type_name": "nodetool.nodes.lib.date.BoundaryType"
          },
          "default": "start",
          "title": "Boundary",
          "description": "Start or end of period"
        },
        {
          "name": "start_monday",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Start Monday",
          "description": "For week period: Consider Monday as start of week (False for Sunday)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_datetime",
        "period",
        "boundary",
        "start_monday"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Date Difference",
      "description": "Calculate the difference between two dates.\n    datetime, difference, duration\n\n    Use cases:\n    - Calculate time periods\n    - Measure durations",
      "namespace": "lib.date",
      "node_type": "lib.date.DateDifference",
      "properties": [
        {
          "name": "start_date",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Start Date",
          "description": "Start datetime"
        },
        {
          "name": "end_date",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "End Date",
          "description": "End datetime"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "total_seconds"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "days"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "hours"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "minutes"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "seconds"
        }
      ],
      "basic_fields": [
        "start_date",
        "end_date"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Date Range",
      "description": "Generate a list of dates between start and end dates.\n    datetime, range, list\n\n    Use cases:\n    - Generate date sequences\n    - Create date-based iterations",
      "namespace": "lib.date",
      "node_type": "lib.date.DateRange",
      "properties": [
        {
          "name": "start_date",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Start Date",
          "description": "Start date of the range"
        },
        {
          "name": "end_date",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "End Date",
          "description": "End date of the range"
        },
        {
          "name": "step_days",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Step Days",
          "description": "Number of days between each date"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "datetime"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "start_date",
        "end_date",
        "step_days"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Date To Datetime",
      "description": "Convert a Date object to a Datetime object.\n    date, datetime, convert",
      "namespace": "lib.date",
      "node_type": "lib.date.DateToDatetime",
      "properties": [
        {
          "name": "input_date",
          "type": {
            "type": "date"
          },
          "default": {},
          "title": "Input Date",
          "description": "Date to convert"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_date"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Datetime To Date",
      "description": "Convert a Datetime object to a Date object.\n    date, datetime, convert",
      "namespace": "lib.date",
      "node_type": "lib.date.DatetimeToDate",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Datetime to convert"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "date"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_datetime"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Format Date Time",
      "description": "Convert a datetime object to a formatted string.\n    datetime, format, convert\n\n    Use cases:\n    - Standardize date formats\n    - Prepare dates for different systems",
      "namespace": "lib.date",
      "node_type": "lib.date.FormatDateTime",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Datetime object to format"
        },
        {
          "name": "output_format",
          "type": {
            "type": "enum",
            "values": [
              "%Y-%m-%d",
              "%m/%d/%Y",
              "%d/%m/%Y",
              "%B %d, %Y",
              "%Y%m%d",
              "%Y%m%d_%H%M%S",
              "%Y-%m-%dT%H:%M:%S",
              "%Y-%m-%dT%H:%M:%S%z",
              "%Y-%m-%dT%H:%M:%S%z"
            ],
            "type_name": "nodetool.nodes.lib.date.DateFormat"
          },
          "default": "%B %d, %Y",
          "title": "Output Format",
          "description": "Desired output format"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_datetime",
        "output_format"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Get Quarter",
      "description": "Get the quarter number and start/end dates for a given datetime.\n    datetime, quarter, period\n\n    Use cases:\n    - Financial reporting periods\n    - Quarterly analytics",
      "namespace": "lib.date",
      "node_type": "lib.date.GetQuarter",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Input datetime"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "quarter"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "quarter_start"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "quarter_end"
        }
      ],
      "basic_fields": [
        "input_datetime"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Get Weekday",
      "description": "Get the weekday name or number from a datetime.\n    datetime, weekday, name\n\n    Use cases:\n    - Get day names for scheduling\n    - Filter events by weekday",
      "namespace": "lib.date",
      "node_type": "lib.date.GetWeekday",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Input datetime"
        },
        {
          "name": "as_name",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "As Name",
          "description": "Return weekday name instead of number (0-6)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_datetime",
        "as_name"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Is Date In Range",
      "description": "Check if a date falls within a specified range.\n    datetime, range, check\n\n    Use cases:\n    - Validate date ranges\n    - Filter date-based data",
      "namespace": "lib.date",
      "node_type": "lib.date.IsDateInRange",
      "properties": [
        {
          "name": "check_date",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Check Date",
          "description": "Date to check"
        },
        {
          "name": "start_date",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Start Date",
          "description": "Start of date range"
        },
        {
          "name": "end_date",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "End Date",
          "description": "End of date range"
        },
        {
          "name": "inclusive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Inclusive",
          "description": "Include start and end dates in range"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "check_date",
        "start_date",
        "end_date",
        "inclusive"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Now",
      "description": "Get the current date and time.\n    datetime, current, now",
      "namespace": "lib.date",
      "node_type": "lib.date.Now",
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "expose_as_tool": true
    },
    {
      "title": "Parse Date",
      "description": "Parse a date string into components.\n    date, parse, format",
      "namespace": "lib.date",
      "node_type": "lib.date.ParseDate",
      "properties": [
        {
          "name": "date_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Date String",
          "description": "The date string to parse"
        },
        {
          "name": "input_format",
          "type": {
            "type": "enum",
            "values": [
              "%Y-%m-%d",
              "%m/%d/%Y",
              "%d/%m/%Y",
              "%B %d, %Y",
              "%Y%m%d",
              "%Y%m%d_%H%M%S",
              "%Y-%m-%dT%H:%M:%S",
              "%Y-%m-%dT%H:%M:%S%z",
              "%Y-%m-%dT%H:%M:%S%z"
            ],
            "type_name": "nodetool.nodes.lib.date.DateFormat"
          },
          "default": "%Y-%m-%d",
          "title": "Input Format",
          "description": "Format of the input date string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "date"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "date_string",
        "input_format"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Parse Date Time",
      "description": "Parse a date/time string into components.\n    datetime, parse, format\n\n    Use cases:\n    - Extract date components from strings\n    - Convert between date formats",
      "namespace": "lib.date",
      "node_type": "lib.date.ParseDateTime",
      "properties": [
        {
          "name": "datetime_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Datetime String",
          "description": "The datetime string to parse"
        },
        {
          "name": "input_format",
          "type": {
            "type": "enum",
            "values": [
              "%Y-%m-%d",
              "%m/%d/%Y",
              "%d/%m/%Y",
              "%B %d, %Y",
              "%Y%m%d",
              "%Y%m%d_%H%M%S",
              "%Y-%m-%dT%H:%M:%S",
              "%Y-%m-%dT%H:%M:%S%z",
              "%Y-%m-%dT%H:%M:%S%z"
            ],
            "type_name": "nodetool.nodes.lib.date.DateFormat"
          },
          "default": "%Y-%m-%d",
          "title": "Input Format",
          "description": "Format of the input datetime string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "datetime_string",
        "input_format"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Relative Time",
      "description": "Get datetime relative to current time (past or future).\n    datetime, past, future, relative, hours, days, months\n\n    Use cases:\n    - Calculate past or future dates\n    - Generate relative timestamps",
      "namespace": "lib.date",
      "node_type": "lib.date.RelativeTime",
      "properties": [
        {
          "name": "amount",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Amount",
          "description": "Amount of time units",
          "min": 0.0
        },
        {
          "name": "unit",
          "type": {
            "type": "enum",
            "values": [
              "hours",
              "days",
              "months"
            ],
            "type_name": "nodetool.nodes.lib.date.TimeUnitType"
          },
          "default": "days",
          "title": "Unit",
          "description": "Time unit type"
        },
        {
          "name": "direction",
          "type": {
            "type": "enum",
            "values": [
              "past",
              "future"
            ],
            "type_name": "nodetool.nodes.lib.date.TimeDirection"
          },
          "default": "future",
          "title": "Direction",
          "description": "Past or future"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "amount",
        "unit",
        "direction"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Today",
      "description": "Get the current date.\n    date, today, now",
      "namespace": "lib.date",
      "node_type": "lib.date.Today",
      "outputs": [
        {
          "type": {
            "type": "date"
          },
          "name": "output"
        }
      ],
      "expose_as_tool": true
    },
    {
      "title": "Base Get JSONPath",
      "description": "Base class for extracting typed data from a JSON object using a path expression.\n    json, path, extract\n\n    Examples for an object {\"a\": {\"b\": {\"c\": 1}}}\n    \"a.b.c\" -> 1\n    \"a.b\" -> {\"c\": 1}\n    \"a\" -> {\"b\": {\"c\": 1}}\n\n    Use cases:\n    - Navigate complex JSON structures\n    - Extract specific values from nested JSON with type safety",
      "namespace": "lib.json",
      "node_type": "lib.json.BaseGetJSONPath",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path"
      ]
    },
    {
      "title": "Filter JSON",
      "description": "Filter JSON array based on a key-value condition.\n    json, filter, array\n\n    Use cases:\n    - Filter arrays of objects\n    - Search JSON data",
      "namespace": "lib.json",
      "node_type": "lib.json.FilterJSON",
      "properties": [
        {
          "name": "array",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Array",
          "description": "Array of JSON objects to filter"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key",
          "description": "Key to filter on"
        },
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "title": "Value",
          "description": "Value to match"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "array",
        "key",
        "value"
      ]
    },
    {
      "title": "Get JSONPath Bool",
      "description": "Extract a boolean value from a JSON path\n    json, path, extract, boolean",
      "namespace": "lib.json",
      "node_type": "lib.json.GetJSONPathBool",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path",
        "default"
      ]
    },
    {
      "title": "Get JSONPath Dict",
      "description": "Extract a dictionary value from a JSON path\n    json, path, extract, object",
      "namespace": "lib.json",
      "node_type": "lib.json.GetJSONPathDict",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path",
        "default"
      ]
    },
    {
      "title": "Get JSONPath Float",
      "description": "Extract a float value from a JSON path\n    json, path, extract, number",
      "namespace": "lib.json",
      "node_type": "lib.json.GetJSONPathFloat",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path",
        "default"
      ]
    },
    {
      "title": "Get JSONPath Int",
      "description": "Extract an integer value from a JSON path\n    json, path, extract, number",
      "namespace": "lib.json",
      "node_type": "lib.json.GetJSONPathInt",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path",
        "default"
      ]
    },
    {
      "title": "Get JSONPath List",
      "description": "Extract a list value from a JSON path\n    json, path, extract, array",
      "namespace": "lib.json",
      "node_type": "lib.json.GetJSONPathList",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "list"
          },
          "default": [],
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path",
        "default"
      ]
    },
    {
      "title": "Get JSONPath Str",
      "description": "Extract a string value from a JSON path\n    json, path, extract, string",
      "namespace": "lib.json",
      "node_type": "lib.json.GetJSONPathStr",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path",
        "default"
      ]
    },
    {
      "title": "JSON Template",
      "description": "Template JSON strings with variable substitution.\n    json, template, substitute, variables\n\n    Example:\n    template: '{\"name\": \"$user\", \"age\": $age}'\n    values: {\"user\": \"John\", \"age\": 30}\n    result: '{\"name\": \"John\", \"age\": 30}'\n\n    Use cases:\n    - Create dynamic JSON payloads\n    - Generate JSON with variable data\n    - Build API request templates",
      "namespace": "lib.json",
      "node_type": "lib.json.JSONTemplate",
      "properties": [
        {
          "name": "template",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Template",
          "description": "JSON template string with $variable placeholders"
        },
        {
          "name": "values",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Values",
          "description": "Dictionary of values to substitute into the template"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "template",
        "values"
      ]
    },
    {
      "title": "Load JSON Folder",
      "description": "Load JSON files from an asset folder.\n    load, json, file, import",
      "namespace": "lib.json",
      "node_type": "lib.json.LoadJSONAssets",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {},
          "title": "Folder",
          "description": "The asset folder to load the JSON files from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "json"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        }
      ],
      "basic_fields": [
        "folder"
      ]
    },
    {
      "title": "Parse Dict",
      "description": "Parse a JSON string into a Python dictionary.\n    json, parse, decode, dictionary\n\n    Use cases:\n    - Convert JSON API responses to Python dictionaries\n    - Process JSON configuration files\n    - Parse object-like JSON data",
      "namespace": "lib.json",
      "node_type": "lib.json.ParseDict",
      "properties": [
        {
          "name": "json_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Json String",
          "description": "JSON string to parse into a dictionary"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "json_string"
      ]
    },
    {
      "title": "Parse List",
      "description": "Parse a JSON string into a Python list.\n    json, parse, decode, array, list\n\n    Use cases:\n    - Convert JSON array responses to Python lists\n    - Process JSON data collections\n    - Parse array-like JSON data",
      "namespace": "lib.json",
      "node_type": "lib.json.ParseList",
      "properties": [
        {
          "name": "json_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Json String",
          "description": "JSON string to parse into a list"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "json_string"
      ]
    },
    {
      "title": "Stringify JSON",
      "description": "Convert a Python object to a JSON string.\n    json, stringify, encode\n\n    Use cases:\n    - Prepare data for API requests\n    - Save data in JSON format",
      "namespace": "lib.json",
      "node_type": "lib.json.StringifyJSON",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": {},
          "title": "Data",
          "description": "Data to convert to JSON"
        },
        {
          "name": "indent",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Indent",
          "description": "Number of spaces for indentation"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "indent"
      ]
    },
    {
      "title": "Validate JSON",
      "description": "Validate JSON data against a schema.\n    json, validate, schema\n\n    Use cases:\n    - Ensure API payloads match specifications\n    - Validate configuration files",
      "namespace": "lib.json",
      "node_type": "lib.json.ValidateJSON",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "title": "Data",
          "description": "JSON data to validate"
        },
        {
          "name": "json_schema",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Json Schema",
          "description": "JSON schema for validation"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "json_schema"
      ]
    },
    {
      "title": "Extract Markdown",
      "description": "Convert PDF to Markdown format using pymupdf4llm.\n    pdf, markdown, convert\n\n    Use cases:\n    - Convert PDF documents to markdown format\n    - Preserve document structure in markdown\n    - Create editable markdown from PDFs",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractMarkdown",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Pdf",
          "description": "The PDF document to convert to markdown"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Tables",
      "description": "Extract tables from a PDF document using PyMuPDF.\n    pdf, tables, extract, structured\n\n    Use cases:\n    - Extract tabular data from PDFs\n    - Convert PDF tables to structured formats\n    - Analyze table layouts and content",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractTables",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Pdf",
          "description": "The PDF document to extract tables from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Text",
      "description": "Extract plain text from a PDF document using PyMuPDF.\n    pdf, text, extract\n\n    Use cases:\n    - Extract raw text content from PDFs\n    - Convert PDF documents to plain text\n    - Prepare text for further processing",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractText",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Pdf",
          "description": "The PDF document to extract text from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Text Blocks",
      "description": "Extract text blocks with their bounding boxes from a PDF.\n    pdf, text, blocks, layout\n\n    Use cases:\n    - Analyze text layout and structure\n    - Extract text while preserving block-level formatting\n    - Get text position information",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractTextBlocks",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Pdf",
          "description": "The PDF document to extract text blocks from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Text With Style",
      "description": "Extract text with style information (font, size, color) from a PDF.\n    pdf, text, style, formatting\n\n    Use cases:\n    - Preserve text formatting during extraction\n    - Analyze document styling\n    - Extract text with font information",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractTextWithStyle",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Pdf",
          "description": "The PDF document to extract styled text from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Whisper Cpp",
      "description": "Transcribe an audio asset using whispercpp (whisper.cpp bindings) and stream strings.\n    whisper, whispercpp, asr, speech-to-text, streaming, huggingface-cache\n\n    - Model file is loaded from the local Hugging Face cache (repo + filename)\n    - Emits streaming text deltas on `chunk` and final transcript on `text`",
      "namespace": "lib.whispercpp",
      "node_type": "lib.whispercpp.WhisperCpp",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "tiny",
              "tiny-q5_1",
              "tiny-q8_0",
              "tiny.en",
              "tiny.en-q5_1",
              "tiny.en-q8_0",
              "base",
              "base-q5_1",
              "base-q8_0",
              "base.en",
              "base.en-q5_1",
              "base.en-q8_0",
              "small",
              "small-q5_1",
              "small-q8_0",
              "small.en",
              "small.en-q5_1",
              "small.en-q8_0",
              "medium",
              "medium-q5_0",
              "medium-q8_0",
              "medium.en",
              "medium.en-q5_0",
              "medium.en-q8_0",
              "large-v1",
              "large-v2",
              "large-v2-q5_0",
              "large-v2-q8_0",
              "large-v3",
              "large-v3-q5_0",
              "large-v3-turbo",
              "large-v3-turbo-q5_0",
              "large-v3-turbo-q8_0"
            ],
            "type_name": "nodetool.nodes.lib.whispercpp.Model"
          },
          "default": "tiny.en",
          "title": "Model",
          "description": "Model to use from ggerganov/whisper.cpp"
        },
        {
          "name": "n_threads",
          "type": {
            "type": "int"
          },
          "default": 4,
          "title": "N Threads",
          "description": "Decoder CPU threads"
        },
        {
          "name": "length_ms",
          "type": {
            "type": "int"
          },
          "default": 5000,
          "title": "Length Ms",
          "description": "Chunk length in milliseconds for pseudo-streaming"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "Audio to transcribe"
        },
        {
          "name": "chunk",
          "type": {
            "type": "chunk"
          },
          "default": {},
          "title": "Chunk",
          "description": "Chunk to transcribe"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        },
        {
          "type": {
            "type": "float"
          },
          "name": "t0"
        },
        {
          "type": {
            "type": "float"
          },
          "name": "t1"
        },
        {
          "type": {
            "type": "float"
          },
          "name": "probability"
        }
      ],
      "recommended_models": [
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-tiny.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-tiny-q5_1.bin",
          "cache_path": "/Users/mg/.cache/huggingface/hub/models--ggerganov--whisper.cpp/snapshots/5359861c739e955e79d9a303bcbc70fb988958b1/ggml-tiny-q5_1.bin",
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": true,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-tiny-q8_0.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-tiny.en.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-tiny.en-q5_1.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-tiny.en-q8_0.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-base.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-base-q5_1.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-base-q8_0.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-base.en.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-base.en-q5_1.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-base.en-q8_0.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-small.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-small-q5_1.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-small-q8_0.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-small.en.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-small.en-q5_1.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-small.en-q8_0.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-medium.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-medium-q5_0.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-medium-q8_0.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-medium.en.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-medium.en-q5_0.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-medium.en-q8_0.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-large-v1.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-large-v2.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-large-v2-q5_0.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-large-v2-q8_0.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-large-v3.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-large-v3-q5_0.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-large-v3-turbo.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-large-v3-turbo-q5_0.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        },
        {
          "id": "ggerganov/whisper.cpp",
          "type": "hf.model",
          "name": "ggerganov/whisper.cpp",
          "repo_id": "ggerganov/whisper.cpp",
          "path": "ggml-large-v3-turbo-q8_0.bin",
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 31005921914,
          "downloaded": false,
          "pipeline_tag": "automatic-speech-recognition",
          "tags": [
            "automatic-speech-recognition",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 1122,
          "trending_score": null
        }
      ],
      "basic_fields": [
        "model",
        "n_threads",
        "length_ms",
        "audio",
        "chunk"
      ]
    },
    {
      "title": "MLX Whisper",
      "description": "Transcribe an audio asset using MLX Whisper.\n    whisper, mlx, asr, speech-to-text\n\n    - Uses MLX for efficient Apple Silicon acceleration\n    - Emits final transcript on `text` and segments on `segments`",
      "namespace": "lib.mlx_whisper",
      "node_type": "lib.mlx_whisper.MLXWhisper",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "mlx-community/whisper-tiny-mlx",
              "mlx-community/whisper-tiny.en-mlx",
              "mlx-community/whisper-base-mlx",
              "mlx-community/whisper-base.en-mlx",
              "mlx-community/whisper-small-mlx",
              "mlx-community/whisper-small.en-mlx",
              "mlx-community/whisper-medium-mlx",
              "mlx-community/whisper-medium.en-mlx",
              "mlx-community/whisper-large-v3-mlx"
            ],
            "type_name": "nodetool.nodes.lib.mlx_whisper.Model"
          },
          "default": "mlx-community/whisper-tiny.en-mlx",
          "title": "Model",
          "description": "Model to use for transcription"
        },
        {
          "name": "length_ms",
          "type": {
            "type": "int"
          },
          "default": 5000,
          "title": "Length Ms",
          "description": "Chunk length in milliseconds before decode"
        },
        {
          "name": "compression_ratio_threshold",
          "type": {
            "type": "float",
            "optional": true
          },
          "default": 2.4,
          "title": "Compression Ratio Threshold",
          "description": "Threshold for gzip compression ratio; above this, the result is treated as failed."
        },
        {
          "name": "logprob_threshold",
          "type": {
            "type": "float",
            "optional": true
          },
          "default": -1.0,
          "title": "Logprob Threshold",
          "description": "Average log probability threshold; below this, the result is treated as failed."
        },
        {
          "name": "no_speech_threshold",
          "type": {
            "type": "float",
            "optional": true
          },
          "default": 0.6,
          "title": "No Speech Threshold",
          "description": "Threshold for no-speech probability; if exceeded and logprob is low, the segment is considered silent."
        },
        {
          "name": "condition_on_previous_text",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Condition On Previous Text",
          "description": "If True, the previous output is used as a prompt for the next window, improving consistency."
        },
        {
          "name": "word_timestamps",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Word Timestamps",
          "description": "If True, extracts word-level timestamps using cross-attention and dynamic time warping."
        },
        {
          "name": "chunk",
          "type": {
            "type": "chunk"
          },
          "default": {},
          "title": "Chunk",
          "description": "Streaming input chunk. Provide audio chunks (PCM16 base64 or bytes)."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        },
        {
          "type": {
            "type": "list"
          },
          "name": "segments"
        }
      ],
      "recommended_models": [
        {
          "id": "mlx-community/whisper-tiny-mlx",
          "type": "hf.model",
          "name": "mlx-community/whisper-tiny-mlx",
          "repo_id": "mlx-community/whisper-tiny-mlx",
          "path": null,
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 74420620,
          "downloaded": false,
          "pipeline_tag": null,
          "tags": [
            "mlx",
            "whisper",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 153,
          "likes": 2,
          "trending_score": null
        },
        {
          "id": "mlx-community/whisper-tiny.en-mlx",
          "type": "hf.model",
          "name": "mlx-community/whisper-tiny.en-mlx",
          "repo_id": "mlx-community/whisper-tiny.en-mlx",
          "path": null,
          "cache_path": "/Users/mg/.cache/huggingface/hub/models--mlx-community--whisper-tiny.en-mlx/snapshots/5f4dafbb28e62a53c1b10426ff7eed36ca733bf7/config.json",
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 74419890,
          "downloaded": true,
          "pipeline_tag": null,
          "tags": [
            "mlx",
            "whisper",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 253,
          "likes": 0,
          "trending_score": null
        },
        {
          "id": "mlx-community/whisper-base-mlx",
          "type": "hf.model",
          "name": "mlx-community/whisper-base-mlx",
          "repo_id": "mlx-community/whisper-base-mlx",
          "path": null,
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 143726284,
          "downloaded": false,
          "pipeline_tag": null,
          "tags": [
            "mlx",
            "whisper",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 2214,
          "likes": 0,
          "trending_score": null
        },
        {
          "id": "mlx-community/whisper-base.en-mlx",
          "type": "hf.model",
          "name": "mlx-community/whisper-base.en-mlx",
          "repo_id": "mlx-community/whisper-base.en-mlx",
          "path": null,
          "cache_path": "/Users/mg/.cache/huggingface/hub/models--mlx-community--whisper-base.en-mlx/snapshots/aa0678c3466ed62c5c6114ec600a0e1f96820089/config.json",
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 143725218,
          "downloaded": true,
          "pipeline_tag": null,
          "tags": [
            "mlx",
            "whisper",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 41,
          "likes": 0,
          "trending_score": null
        },
        {
          "id": "mlx-community/whisper-small-mlx",
          "type": "hf.model",
          "name": "mlx-community/whisper-small-mlx",
          "repo_id": "mlx-community/whisper-small-mlx",
          "path": null,
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 481309678,
          "downloaded": false,
          "pipeline_tag": null,
          "tags": [
            "mlx",
            "whisper",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 2685,
          "likes": 3,
          "trending_score": null
        },
        {
          "id": "mlx-community/whisper-small.en-mlx",
          "type": "hf.model",
          "name": "mlx-community/whisper-small.en-mlx",
          "repo_id": "mlx-community/whisper-small.en-mlx",
          "path": null,
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 481308292,
          "downloaded": false,
          "pipeline_tag": null,
          "tags": [
            "mlx",
            "whisper",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 64,
          "likes": 0,
          "trending_score": null
        },
        {
          "id": "mlx-community/whisper-medium-mlx",
          "type": "hf.model",
          "name": "mlx-community/whisper-medium-mlx",
          "repo_id": "mlx-community/whisper-medium-mlx",
          "path": null,
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 1524927002,
          "downloaded": false,
          "pipeline_tag": null,
          "tags": [
            "mlx",
            "whisper",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 2426,
          "likes": 3,
          "trending_score": null
        },
        {
          "id": "mlx-community/whisper-medium.en-mlx",
          "type": "hf.model",
          "name": "mlx-community/whisper-medium.en-mlx",
          "repo_id": "mlx-community/whisper-medium.en-mlx",
          "path": null,
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 1524925152,
          "downloaded": false,
          "pipeline_tag": null,
          "tags": [
            "mlx",
            "whisper",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 80,
          "likes": 1,
          "trending_score": null
        },
        {
          "id": "mlx-community/whisper-large-v3-mlx",
          "type": "hf.model",
          "name": "mlx-community/whisper-large-v3-mlx",
          "repo_id": "mlx-community/whisper-large-v3-mlx",
          "path": null,
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 3083522444,
          "downloaded": false,
          "pipeline_tag": null,
          "tags": [
            "mlx",
            "whisper",
            "license:mit",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 2448,
          "likes": 56,
          "trending_score": null
        }
      ],
      "basic_fields": [
        "model",
        "length_ms",
        "compression_ratio_threshold",
        "logprob_threshold",
        "no_speech_threshold",
        "condition_on_previous_text",
        "word_timestamps",
        "chunk"
      ]
    },
    {
      "title": "Encode Query Params",
      "description": "Encode a dictionary of parameters into a query string using\n    ``urllib.parse.urlencode``.\n    urllib, query, encode, params\n\n    Use cases:\n    - Build GET request URLs\n    - Serialize data for APIs\n    - Convert parameters to query strings",
      "namespace": "lib.urllib",
      "node_type": "lib.urllib.EncodeQueryParams",
      "properties": [
        {
          "name": "params",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "str"
              }
            ]
          },
          "title": "Params",
          "description": "Parameters to encode"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "params"
      ]
    },
    {
      "title": "Join URL",
      "description": "Join a base URL with a relative URL using ``urllib.parse.urljoin``.\n    urllib, join, url\n\n    Use cases:\n    - Build absolute links from relative paths\n    - Combine API base with endpoints\n    - Resolve resources from a base URL",
      "namespace": "lib.urllib",
      "node_type": "lib.urllib.JoinURL",
      "properties": [
        {
          "name": "base",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base",
          "description": "Base URL"
        },
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "Relative or absolute URL"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "base",
        "url"
      ]
    },
    {
      "title": "Parse URL",
      "description": "Parse a URL into its components using ``urllib.parse.urlparse``.\n    urllib, parse, url\n\n    Use cases:\n    - Inspect links for validation\n    - Extract host or path information\n    - Analyze query parameters",
      "namespace": "lib.urllib",
      "node_type": "lib.urllib.ParseURL",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to parse"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "Quote URL",
      "description": "Percent-encode a string for safe use in URLs using ``urllib.parse.quote``.\n    urllib, quote, encode\n\n    Use cases:\n    - Escape spaces or special characters\n    - Prepare text for query parameters\n    - Encode file names in URLs",
      "namespace": "lib.urllib",
      "node_type": "lib.urllib.QuoteURL",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to quote"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ]
    },
    {
      "title": "Unquote URL",
      "description": "Decode a percent-encoded URL string using ``urllib.parse.unquote``.\n    urllib, unquote, decode\n\n    Use cases:\n    - Convert encoded URLs to readable form\n    - Parse user input from URLs\n    - Display unescaped paths",
      "namespace": "lib.urllib",
      "node_type": "lib.urllib.UnquoteURL",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Encoded text"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ]
    },
    {
      "title": "List Scheduled Events",
      "description": "Fetch scheduled events for a Calendly user.",
      "namespace": "calendly.events",
      "node_type": "calendly.events.ListScheduledEvents",
      "properties": [
        {
          "name": "user",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "User",
          "description": "User URI to fetch events for"
        },
        {
          "name": "count",
          "type": {
            "type": "int"
          },
          "default": 20,
          "title": "Count",
          "description": "Number of events to return",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "status",
          "type": {
            "type": "str"
          },
          "default": "active",
          "title": "Status",
          "description": "Event status filter"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "calendly_event"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "user",
        "count",
        "status"
      ]
    },
    {
      "title": "Scheduled Event Fields",
      "description": "Extract fields from a CalendlyEvent.",
      "namespace": "calendly.events",
      "node_type": "calendly.events.ScheduledEventFields",
      "properties": [
        {
          "name": "event",
          "type": {
            "type": "calendly_event"
          },
          "default": {},
          "title": "Event",
          "description": "The Calendly event to extract"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "uri"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "start_time"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "end_time"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "location"
        }
      ],
      "basic_fields": [
        "event"
      ]
    },
    {
      "title": "Leann Builder",
      "description": "Create high-performance vector indexes for Retrieval-Augmented Generation (RAG) using LEANN.\n    embedding, collection, RAG, index, text, chunk, batch, vector, search, leann\n\n    Embedding Model Selection: Understanding the Trade-offs\n    Based on extensive testing with LEANN, embedding models fall into three performance tiers:\n\n    \ud83d\ude80 SMALL MODELS (< 100M parameters)\n    - sentence-transformers/all-MiniLM-L6-v2 (22M params)\n    \ud83c\udfaf BEST FOR: Prototyping, simple queries, interactive demos, resource-constrained environments\n\n    \u2696\ufe0f MEDIUM MODELS (100M-500M parameters)\n    - facebook/contriever (110M params)\n    - BAAI/bge-base-en-v1.5 (109M params)\n    \ud83c\udfaf BEST FOR: Production RAG applications, balanced quality-performance needs\n\n    \ud83c\udfc6 LARGE MODELS (500M+ parameters)\n    - Qwen/Qwen3-Embedding-0.6B (600M params)\n    - intfloat/multilingual-e5-large (560M params)\n    \ud83c\udfaf BEST FOR: High-stakes applications, maximum accuracy requirements, production environments\n\n    Index Backend Selection: Optimizing for Scale and Performance\n\n    Choose the right backend based on your dataset size and performance requirements:\n\n    \u26a1 HNSW (Hierarchical Navigable Small World)\n    \ud83c\udfaf BEST FOR: Datasets < 10M vectors, when memory isn't a bottleneck, default recommendation\n\n    \ud83d\ude80 DISKANN (Disk-based Approximate Nearest Neighbor)\n    \ud83c\udfaf BEST FOR: Large datasets (100k+ documents), production environments, when recompute=True",
      "namespace": "vector.leann",
      "node_type": "vector.leann.LeannBuilder",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {},
          "title": "Folder",
          "description": "Output folder where the LEANN index will be stored. Choose a location with sufficient disk space for your dataset."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "Unique identifier for this index. Used for organizing and retrieving specific indexes."
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "sentence-transformers/all-MiniLM-L6-v2",
              "facebook/contriever",
              "BAAI/bge-base-en-v1.5",
              "Qwen/Qwen3-Embedding-0.6B",
              "intfloat/multilingual-e5-large"
            ],
            "type_name": "nodetool.nodes.vector.leann.EmbeddingModel"
          },
          "default": "sentence-transformers/all-MiniLM-L6-v2",
          "title": "Model",
          "description": "Select embedding model based on your quality-speed trade-off. See EmbeddingModel documentation for detailed guidance."
        },
        {
          "name": "backend",
          "type": {
            "type": "enum",
            "values": [
              "hnsw",
              "diskann"
            ],
            "type_name": "nodetool.nodes.vector.leann.Backend"
          },
          "default": "hnsw",
          "title": "Backend",
          "description": "Index backend optimized for your scale. HNSW for most use cases, DiskANN for large datasets. See Backend documentation for details."
        },
        {
          "name": "text_chunks",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "text_chunk"
              }
            ]
          },
          "default": [],
          "title": "Text Chunks",
          "description": "Text chunks to be indexed. Each chunk should contain: text content, unique source_id, and optional metadata for filtering."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "folder",
        "name",
        "model",
        "backend",
        "text_chunks"
      ]
    },
    {
      "title": "Leann Searcher",
      "description": "Search high-performance vector indexes for Retrieval-Augmented Generation (RAG) using LEANN.\n    embedding, collection, RAG, index, text, chunk, batch, vector, search, leann",
      "namespace": "vector.leann",
      "node_type": "vector.leann.LeannSearcher",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {},
          "title": "Folder",
          "description": "The folder where the index is stored"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The name of the index"
        },
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "The query to search for"
        },
        {
          "name": "top_k",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "Top K",
          "description": "The number of results to return"
        },
        {
          "name": "complexity",
          "type": {
            "type": "int"
          },
          "default": 64,
          "title": "Complexity",
          "description": "The complexity of the search"
        },
        {
          "name": "beam_width",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Beam Width",
          "description": "The beam width of the search"
        },
        {
          "name": "prune_ratio",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Prune Ratio",
          "description": "The prune ratio of the search"
        },
        {
          "name": "recompute_embeddings",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Recompute Embeddings",
          "description": "Whether to recompute the embeddings"
        },
        {
          "name": "pruning_strategy",
          "type": {
            "type": "enum",
            "values": [
              "global",
              "local",
              "proportional"
            ],
            "type_name": "nodetool.nodes.vector.leann.PruningStrategy"
          },
          "default": "global",
          "title": "Pruning Strategy",
          "description": "The pruning strategy of the search"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "leann_search_result"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "folder",
        "name",
        "query",
        "top_k",
        "complexity",
        "beam_width",
        "prune_ratio",
        "recompute_embeddings",
        "pruning_strategy"
      ]
    },
    {
      "title": "Add Vectors",
      "description": "Add vectors to a FAISS index.\n    faiss, add, vectors",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.AddVectors",
      "properties": [
        {
          "name": "index",
          "type": {
            "type": "faiss_index"
          },
          "default": {},
          "title": "Index",
          "description": "FAISS index"
        },
        {
          "name": "vectors",
          "type": {
            "type": "np_array"
          },
          "default": {},
          "title": "Vectors",
          "description": "Vectors to add (n, d)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "faiss_index"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "index",
        "vectors"
      ]
    },
    {
      "title": "Add With Ids",
      "description": "Add vectors with explicit integer IDs to a FAISS index.\n    faiss, add, ids, vectors",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.AddWithIds",
      "properties": [
        {
          "name": "index",
          "type": {
            "type": "faiss_index"
          },
          "default": {},
          "title": "Index",
          "description": "FAISS index"
        },
        {
          "name": "vectors",
          "type": {
            "type": "np_array"
          },
          "default": {},
          "title": "Vectors",
          "description": "Vectors to add (n, d)"
        },
        {
          "name": "ids",
          "type": {
            "type": "np_array"
          },
          "default": {},
          "title": "Ids",
          "description": "1-D int64 IDs (n,)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "faiss_index"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "index",
        "vectors",
        "ids"
      ]
    },
    {
      "title": "Create Index Flat IP",
      "description": "Create a FAISS IndexFlatIP (inner product / cosine with normalized vectors).\n    faiss, index, ip, create",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.CreateIndexFlatIP",
      "properties": [
        {
          "name": "dim",
          "type": {
            "type": "int"
          },
          "default": 768,
          "title": "Dim",
          "description": "Embedding dimensionality",
          "min": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "faiss_index"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dim"
      ]
    },
    {
      "title": "Create Index Flat L 2",
      "description": "Create a FAISS IndexFlatL2.\n    faiss, index, l2, create",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.CreateIndexFlatL2",
      "properties": [
        {
          "name": "dim",
          "type": {
            "type": "int"
          },
          "default": 768,
          "title": "Dim",
          "description": "Embedding dimensionality",
          "min": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "faiss_index"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dim"
      ]
    },
    {
      "title": "Create Index IVFFlat",
      "description": "Create a FAISS IndexIVFFlat (inverted file index with flat quantizer).\n    faiss, index, ivf, create",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.CreateIndexIVFFlat",
      "properties": [
        {
          "name": "dim",
          "type": {
            "type": "int"
          },
          "default": 768,
          "title": "Dim",
          "description": "Embedding dimensionality",
          "min": 1.0
        },
        {
          "name": "nlist",
          "type": {
            "type": "int"
          },
          "default": 1024,
          "title": "Nlist",
          "description": "Number of Voronoi cells",
          "min": 1.0
        },
        {
          "name": "metric",
          "type": {
            "type": "enum",
            "values": [
              "L2",
              "IP"
            ],
            "type_name": "nodetool.nodes.vector.faiss.Metric"
          },
          "default": "L2",
          "title": "Metric",
          "description": "Distance metric"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "faiss_index"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dim",
        "nlist",
        "metric"
      ]
    },
    {
      "title": "Faiss",
      "description": "Base class for FAISS nodes.\n\n    vector, faiss, index, search",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.Faiss",
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ]
    },
    {
      "title": "Search",
      "description": "Search a FAISS index with query vectors, returning distances and indices.\n    faiss, search, query, knn",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.Search",
      "properties": [
        {
          "name": "index",
          "type": {
            "type": "faiss_index"
          },
          "default": {},
          "title": "Index",
          "description": "FAISS index"
        },
        {
          "name": "query",
          "type": {
            "type": "np_array"
          },
          "default": {},
          "title": "Query",
          "description": "Query vectors (m, d) or (d,)"
        },
        {
          "name": "k",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "K",
          "description": "Number of nearest neighbors",
          "min": 1.0
        },
        {
          "name": "nprobe",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Nprobe",
          "description": "nprobe for IVF indices"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "distances"
        },
        {
          "type": {
            "type": "np_array"
          },
          "name": "indices"
        }
      ],
      "basic_fields": [
        "index",
        "query",
        "k",
        "nprobe"
      ]
    },
    {
      "title": "Train Index",
      "description": "Train a FAISS index with training vectors (required for IVF indices).\n    faiss, train, index",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.TrainIndex",
      "properties": [
        {
          "name": "index",
          "type": {
            "type": "faiss_index"
          },
          "default": {},
          "title": "Index",
          "description": "FAISS index"
        },
        {
          "name": "vectors",
          "type": {
            "type": "np_array"
          },
          "default": {},
          "title": "Vectors",
          "description": "Training vectors (n, d)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "faiss_index"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "index",
        "vectors"
      ]
    },
    {
      "title": "Chroma",
      "description": "Base class for vector database nodes.\n\n    vector, base, database, chroma, faiss\n\n    Use cases:\n    - Provide shared helpers for vector indexing and queries\n    - Disable caching for subclasses\n    - Convert result IDs into asset references",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.Chroma",
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ]
    },
    {
      "title": "Collection",
      "description": "Get or create a collection.\n    vector, embedding, collection, RAG, get, create, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.Collection",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The name of the collection to create"
        },
        {
          "name": "embedding_model",
          "type": {
            "type": "llama_model"
          },
          "default": {},
          "title": "Embedding Model",
          "description": "Model to use for embedding, search for nomic-embed-text and download it"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "collection"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "embedding_model"
      ]
    },
    {
      "title": "Count",
      "description": "Count the number of documents in a collection.\n    vector, embedding, collection, RAG, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.Count",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to count"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "collection"
      ]
    },
    {
      "title": "Get Documents",
      "description": "Get documents from a chroma collection.\n    vector, embedding, collection, RAG, retrieve, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.GetDocuments",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to get"
        },
        {
          "name": "ids",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Ids",
          "description": "The ids of the documents to get"
        },
        {
          "name": "limit",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Limit",
          "description": "The limit of the documents to get"
        },
        {
          "name": "offset",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Offset",
          "description": "The offset of the documents to get"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "collection",
        "ids",
        "limit",
        "offset"
      ]
    },
    {
      "title": "Hybrid Search",
      "description": "Hybrid search combining semantic and keyword-based search for better retrieval. Uses reciprocal rank fusion to combine results from both methods.\n    vector, RAG, query, semantic, text, similarity, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.HybridSearch",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to query"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to query"
        },
        {
          "name": "n_results",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "N Results",
          "description": "The number of final results to return"
        },
        {
          "name": "k_constant",
          "type": {
            "type": "float"
          },
          "default": 60.0,
          "title": "K Constant",
          "description": "Constant for reciprocal rank fusion (default: 60.0)"
        },
        {
          "name": "min_keyword_length",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "Min Keyword Length",
          "description": "Minimum length for keyword tokens"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "ids"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "metadatas"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "distances"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "scores"
        }
      ],
      "basic_fields": [
        "collection",
        "text",
        "n_results",
        "k_constant",
        "min_keyword_length"
      ]
    },
    {
      "title": "Index Aggregated Text",
      "description": "Index multiple text chunks at once with aggregated embeddings from Ollama.\n    vector, embedding, collection, RAG, index, text, chunk, batch, ollama, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.IndexAggregatedText",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "document",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document",
          "description": "The document to index"
        },
        {
          "name": "document_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document Id",
          "description": "The document ID to associate with the text"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the text"
        },
        {
          "name": "text_chunks",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "union",
                "type_args": [
                  {
                    "type": "text_chunk"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Text Chunks",
          "description": "List of text chunks to index"
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window",
          "description": "The context window size to use for the model",
          "min": 1.0
        },
        {
          "name": "aggregation",
          "type": {
            "type": "enum",
            "values": [
              "mean",
              "max",
              "min",
              "sum"
            ],
            "type_name": "nodetool.nodes.vector.chroma.EmbeddingAggregation"
          },
          "default": "mean",
          "title": "Aggregation",
          "description": "The aggregation method to use for the embeddings."
        }
      ],
      "basic_fields": [
        "collection",
        "document",
        "document_id",
        "metadata",
        "text_chunks",
        "context_window",
        "aggregation"
      ]
    },
    {
      "title": "Index Embedding",
      "description": "Index a single embedding vector into a Chroma collection with optional metadata. Creates a searchable entry that can be queried for similarity matching.\n    vector, index, embedding, chroma, storage, RAG",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.IndexEmbedding",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "embedding",
          "type": {
            "type": "np_array"
          },
          "default": {},
          "title": "Embedding",
          "description": "The embedding to index"
        },
        {
          "name": "index_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Index Id",
          "description": "The ID to associate with the embedding"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the embedding"
        }
      ],
      "basic_fields": [
        "collection",
        "embedding",
        "index_id",
        "metadata"
      ]
    },
    {
      "title": "Index Image",
      "description": "Index a list of image assets or files.\n    vector, embedding, collection, RAG, index, image, batch, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.IndexImage",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": [],
          "title": "Image",
          "description": "List of image assets to index"
        },
        {
          "name": "index_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Index Id",
          "description": "The ID to associate with the image, defaults to the URI of the image"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the image"
        },
        {
          "name": "upsert",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Upsert",
          "description": "Whether to upsert the images"
        }
      ],
      "basic_fields": [
        "collection",
        "image",
        "index_id",
        "metadata",
        "upsert"
      ]
    },
    {
      "title": "Index String",
      "description": "Index a string with a Document ID to a collection.\n    vector, embedding, collection, RAG, index, text, string, chroma\n\n    Use cases:\n    - Index documents for a vector search",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.IndexString",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text content to index"
        },
        {
          "name": "document_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document Id",
          "description": "Document ID to associate with the text content"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the text"
        }
      ],
      "basic_fields": [
        "collection",
        "text",
        "document_id",
        "metadata"
      ]
    },
    {
      "title": "Index Text Chunk",
      "description": "Index a single text chunk.\n    vector, embedding, collection, RAG, index, text, chunk, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.IndexTextChunk",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "text_chunk",
          "type": {
            "type": "text_chunk"
          },
          "default": {},
          "title": "Text Chunk",
          "description": "Text chunk to index"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the text chunk"
        }
      ],
      "basic_fields": [
        "collection",
        "text_chunk",
        "metadata"
      ]
    },
    {
      "title": "Peek",
      "description": "Peek at the documents in a collection.\n    vector, embedding, collection, RAG, preview, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.Peek",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to peek"
        },
        {
          "name": "limit",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Limit",
          "description": "The limit of the documents to peek"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "collection",
        "limit"
      ]
    },
    {
      "title": "Query Image",
      "description": "Query the index for similar images.\n    vector, RAG, query, image, search, similarity, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.QueryImage",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to query"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to query"
        },
        {
          "name": "n_results",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "N Results",
          "description": "The number of results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "ids"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "metadatas"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "distances"
        }
      ],
      "basic_fields": [
        "collection",
        "image",
        "n_results"
      ]
    },
    {
      "title": "Query Text",
      "description": "Query the index for similar text.\n    vector, RAG, query, text, search, similarity, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.QueryText",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to query"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to query"
        },
        {
          "name": "n_results",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "N Results",
          "description": "The number of results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "ids"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "metadatas"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "distances"
        }
      ],
      "basic_fields": [
        "collection",
        "text",
        "n_results"
      ]
    },
    {
      "title": "Remove Overlap",
      "description": "Removes overlapping words between consecutive strings in a list. Splits text into words and matches word sequences for more accurate overlap detection.\n    vector, RAG, query, text, processing, overlap, deduplication",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.RemoveOverlap",
      "properties": [
        {
          "name": "documents",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Documents",
          "description": "List of strings to process for overlap removal"
        },
        {
          "name": "min_overlap_words",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Min Overlap Words",
          "description": "Minimum number of words that must overlap to be considered"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        }
      ],
      "basic_fields": [
        "documents",
        "min_overlap_words"
      ]
    },
    {
      "title": "MFlux Image Generation",
      "description": "Generate images locally using the MFLUX MLX implementation of FLUX.1.\n    mlx, flux, image generation, apple-silicon\n\n    Use cases:\n    - Create high quality images on Apple Silicon without external APIs\n    - Prototype prompts locally before running on cloud inference providers\n    - Experiment with quantized FLUX models (schnell/dev/krea-dev variants)\n\n    Recommended models:\n    - schnell: Fastest model, good for quick generations (2-4 steps)\n    - dev: More powerful model, higher quality (20-25 steps)\n    - krea-dev: Enhanced photorealism with distinctive aesthetics\n    - Freepik/flux.1-lite-8B-alpha: Lighter version of FLUX\n    - Quantized 4-bit models: Reduced memory usage versions of the official models",
      "namespace": "mlx.mflux",
      "node_type": "mlx.mflux.ImageGeneration",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "A vivid concept art piece of a futuristic city at sunset",
          "title": "Prompt",
          "description": "The text prompt describing the image to generate."
        },
        {
          "name": "model",
          "type": {
            "type": "hf.flux"
          },
          "default": {
            "repo_id": "dhairyashil/FLUX.1-schnell-mflux-v0.6.2-4bit"
          },
          "title": "Model",
          "description": "MFLUX model variant to load. Options include official models (schnell, dev, krea-dev), third-party community models (Freepik/flux.1-lite-8B-alpha), and quantized 4-bit versions for reduced memory usage."
        },
        {
          "name": "quantize",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "enum",
                "values": [
                  3,
                  4,
                  5,
                  6,
                  8
                ],
                "type_name": "nodetool.nodes.mlx.mflux.QuantizationLevel"
              },
              {
                "type": "none"
              }
            ]
          },
          "default": 4,
          "title": "Quantize",
          "description": "Optional quantization level for model weights (reduces memory usage)."
        },
        {
          "name": "steps",
          "type": {
            "type": "int"
          },
          "default": 4,
          "title": "Steps",
          "description": "Number of denoising steps for the generation run.",
          "min": 1.0,
          "max": 50.0
        },
        {
          "name": "guidance",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "none"
              }
            ]
          },
          "default": 3.5,
          "title": "Guidance",
          "description": "Classifier-free guidance scale. Used by dev/krea-dev models.",
          "min": 0.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 1024,
          "title": "Height",
          "description": "Height of the generated image in pixels.",
          "min": 256.0,
          "max": 2048.0
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 1024,
          "title": "Width",
          "description": "Width of the generated image in pixels.",
          "min": 256.0,
          "max": 2048.0
        },
        {
          "name": "seed",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Seed",
          "description": "Seed for deterministic generation. Leave as 0 for random."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "recommended_models": [
        {
          "id": "Freepik/flux.1-lite-8B-alpha",
          "type": "hf.flux",
          "name": "Freepik/flux.1-lite-8B-alpha",
          "repo_id": "Freepik/flux.1-lite-8B-alpha",
          "path": null,
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 42642793609,
          "downloaded": false,
          "pipeline_tag": "text-to-image",
          "tags": [
            "diffusers",
            "safetensors",
            "flux",
            "text-to-image",
            "base_model:black-forest-labs/FLUX.1-dev",
            "base_model:finetune:black-forest-labs/FLUX.1-dev",
            "license:other",
            "endpoints_compatible",
            "diffusers:FluxPipeline",
            "region:us"
          ],
          "has_model_index": true,
          "downloads": 1584,
          "likes": 427,
          "trending_score": null
        },
        {
          "id": "dhairyashil/FLUX.1-schnell-mflux-v0.6.2-4bit",
          "type": "hf.flux",
          "name": "dhairyashil/FLUX.1-schnell-mflux-v0.6.2-4bit",
          "repo_id": "dhairyashil/FLUX.1-schnell-mflux-v0.6.2-4bit",
          "path": null,
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 9615583654,
          "downloaded": false,
          "pipeline_tag": "text-to-image",
          "tags": [
            "flux-rectified-flow",
            "text-to-image",
            "diffusion",
            "mflux",
            "en",
            "dataset:custom",
            "license:apache-2.0",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 20,
          "likes": 1,
          "trending_score": null
        },
        {
          "id": "dhairyashil/FLUX.1-dev-mflux-4bit",
          "type": "hf.flux",
          "name": "dhairyashil/FLUX.1-dev-mflux-4bit",
          "repo_id": "dhairyashil/FLUX.1-dev-mflux-4bit",
          "path": null,
          "cache_path": "/Users/mg/.cache/huggingface/hub/models--dhairyashil--FLUX.1-dev-mflux-4bit/snapshots/f15c8a9231c3142976e8a1aa8c6d18b34a442a53/config.json",
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 9621508754,
          "downloaded": true,
          "pipeline_tag": "text-to-image",
          "tags": [
            "flux-rectified-flow",
            "text-to-image",
            "diffusion",
            "mflux",
            "development",
            "en",
            "dataset:custom",
            "license:apache-2.0",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 10,
          "likes": 2,
          "trending_score": null
        },
        {
          "id": "filipstrand/FLUX.1-Krea-dev-mflux-4bit",
          "type": "hf.flux",
          "name": "filipstrand/FLUX.1-Krea-dev-mflux-4bit",
          "repo_id": "filipstrand/FLUX.1-Krea-dev-mflux-4bit",
          "path": null,
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 9614920957,
          "downloaded": false,
          "pipeline_tag": "text-to-image",
          "tags": [
            "mflux",
            "flux",
            "krea-dev",
            "text-to-image",
            "base_model:black-forest-labs/FLUX.1-Krea-dev",
            "base_model:finetune:black-forest-labs/FLUX.1-Krea-dev",
            "license:other",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 3,
          "trending_score": null
        },
        {
          "id": "akx/FLUX.1-Kontext-dev-mflux-4bit",
          "type": "hf.flux",
          "name": "akx/FLUX.1-Kontext-dev-mflux-4bit",
          "repo_id": "akx/FLUX.1-Kontext-dev-mflux-4bit",
          "path": null,
          "cache_path": null,
          "allow_patterns": null,
          "ignore_patterns": null,
          "description": null,
          "readme": null,
          "size_on_disk": 9614920180,
          "downloaded": false,
          "pipeline_tag": null,
          "tags": [
            "mflux",
            "base_model:black-forest-labs/FLUX.1-Kontext-dev",
            "base_model:quantized:black-forest-labs/FLUX.1-Kontext-dev",
            "license:other",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 0,
          "likes": 2,
          "trending_score": null
        }
      ],
      "basic_fields": [
        "prompt",
        "model",
        "quantize",
        "steps",
        "guidance",
        "height",
        "width",
        "seed"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Realtime Agent",
      "description": "Stream responses using the official OpenAI Realtime client. Supports optional audio input and streams text chunks.\n    realtime, streaming, openai, audio-input, text-output\n\n    Uses `AsyncOpenAI().beta.realtime.connect(...)` with the events API:\n    - Sends session settings via `session.update`\n    - Adds user input via `conversation.item.create`\n    - Streams back `response.text.delta` events until `response.done`",
      "namespace": "openai.agents",
      "node_type": "openai.agents.RealtimeAgent",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gpt-4o-realtime-preview",
              "gpt-4o-mini-realtime-preview"
            ],
            "type_name": "nodetool.nodes.openai.agents.Model"
          },
          "default": "gpt-4o-mini-realtime-preview",
          "title": "Model"
        },
        {
          "name": "system",
          "type": {
            "type": "str"
          },
          "default": "\nYou are an AI assistant interacting in real-time. Follow these rules unless explicitly overridden by the user:\n\n1. Respond promptly \u2014 minimize delay. If you do not yet have a complete answer, acknowledge the question and indicate what you are doing to find the answer.\n2. Maintain correctness. Always aim for accuracy; if you\u2019re uncertain, say so and optionally offer to verify.\n3. Be concise but clear. Prioritize key information first, then supporting details if helpful.\n4. Ask clarifying questions when needed. If the user\u2019s request is ambiguous, request clarification rather than guessing.\n5. Be consistent in terminology and definitions. Once you adopt a term or abbreviation, use it consistently in this conversation.\n6. Respect politeness and neutrality. Do not use emotive language unless the conversation tone demands it.\n7. Stay within safe and ethical bounds. Avoid disallowed content; follow OpenAI policies.\n8. Adapt to the user\u2019s style and level. If the user seems technical, use technical detail; if non-technical, explain with simpler language.\n---\nYou are now active. Await the user\u2019s request.\n",
          "title": "System",
          "description": "System instructions for the realtime session"
        },
        {
          "name": "chunk",
          "type": {
            "type": "chunk"
          },
          "default": {},
          "title": "Chunk",
          "description": "The audio chunk to use as input."
        },
        {
          "name": "voice",
          "type": {
            "type": "enum",
            "values": [
              "none",
              "ash",
              "alloy",
              "ballad",
              "coral",
              "echo",
              "fable",
              "onyx",
              "nova",
              "shimmer",
              "sage",
              "verse"
            ],
            "type_name": "nodetool.nodes.openai.agents.Voice"
          },
          "default": "alloy",
          "title": "Voice",
          "description": "The voice for the audio output"
        },
        {
          "name": "speed",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Speed",
          "description": "The speed of the model's spoken response",
          "min": 0.25,
          "max": 1.5
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 0.8,
          "title": "Temperature",
          "description": "The temperature for the response",
          "min": 0.6,
          "max": 1.2
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        },
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        }
      ],
      "basic_fields": [
        "model",
        "prompt",
        "chunk",
        "speed"
      ]
    },
    {
      "title": "Realtime Transcription",
      "description": "Stream microphone or audio input to OpenAI Realtime and emit transcription.\n\n    Emits:\n      - `chunk` Chunk(content=..., done=False) for transcript deltas\n      - `chunk` Chunk(content=\"\", done=True) to mark segment end\n      - `text` final aggregated transcript when input ends",
      "namespace": "openai.agents",
      "node_type": "openai.agents.RealtimeTranscription",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "Model to use"
        },
        {
          "name": "system",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "System",
          "description": "System instructions (optional)"
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 0.8,
          "title": "Temperature",
          "description": "Decoding temperature"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        }
      ],
      "basic_fields": [
        "model",
        "system",
        "temperature"
      ]
    },
    {
      "title": "Embedding",
      "description": "Generate vector representations of text for semantic analysis.\n    embeddings, similarity, search, clustering, classification\n\n    Uses OpenAI's embedding models to create dense vector representations of text.\n    These vectors capture semantic meaning, enabling:\n    - Semantic search\n    - Text clustering\n    - Document classification\n    - Recommendation systems\n    - Anomaly detection\n    - Measuring text similarity and diversity",
      "namespace": "openai.text",
      "node_type": "openai.text.Embedding",
      "properties": [
        {
          "name": "input",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Input"
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "text-embedding-3-large",
              "text-embedding-3-small"
            ],
            "type_name": "nodetool.nodes.openai.text.EmbeddingModel"
          },
          "default": "text-embedding-3-small",
          "title": "Model"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Chunk Size"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input",
        "model",
        "chunk_size"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Web Search",
      "description": "\ud83d\udd0d OpenAI Web Search - Searches the web using OpenAI's web search capabilities.\n\n    This node uses an OpenAI model equipped with web search functionality\n    (like gpt-4o with search preview) to answer queries based on current web information.\n    Requires an OpenAI API key.",
      "namespace": "openai.text",
      "node_type": "openai.text.WebSearch",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "The search query to execute."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "query"
      ]
    },
    {
      "title": "Text To Speech",
      "description": "Converts text to speech using OpenAI TTS models.\n    audio, tts, text-to-speech, voice, synthesis\n\n    Use cases:\n    - Generate spoken content for videos or podcasts\n    - Create voice-overs for presentations\n    - Assist visually impaired users with text reading\n    - Produce audio versions of written content",
      "namespace": "openai.audio",
      "node_type": "openai.audio.TextToSpeech",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "tts-1",
              "tts-1-hd",
              "gpt-4o-mini-tts"
            ],
            "type_name": "nodetool.nodes.openai.audio.TtsModel"
          },
          "default": "tts-1",
          "title": "Model"
        },
        {
          "name": "voice",
          "type": {
            "type": "enum",
            "values": [
              "alloy",
              "ash",
              "ballad",
              "coral",
              "echo",
              "fable",
              "onyx",
              "nova",
              "sage",
              "shimmer",
              "verse"
            ],
            "type_name": "nodetool.nodes.openai.audio.Voice"
          },
          "default": "alloy",
          "title": "Voice"
        },
        {
          "name": "input",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Input"
        },
        {
          "name": "speed",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Speed",
          "min": 0.25,
          "max": 4.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input",
        "model",
        "voice"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Transcribe",
      "description": "Converts speech to text using OpenAI's speech-to-text API.\n    audio, transcription, speech-to-text, stt, whisper\n\n    Use cases:\n    - Generate accurate transcriptions of audio content\n    - Create searchable text from audio recordings\n    - Support multiple languages for transcription\n    - Enable automated subtitling and captioning",
      "namespace": "openai.audio",
      "node_type": "openai.audio.Transcribe",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "whisper-1",
              "gpt-4o-transcribe",
              "gpt-4o-mini-transcribe"
            ],
            "type_name": "nodetool.nodes.openai.audio.TranscriptionModel"
          },
          "default": "whisper-1",
          "title": "Model",
          "description": "The model to use for transcription."
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio file to transcribe (max 25 MB)."
        },
        {
          "name": "language",
          "type": {
            "type": "enum",
            "values": [
              "auto_detect",
              "spanish",
              "italian",
              "korean",
              "portuguese",
              "english",
              "japanese",
              "german",
              "russian",
              "dutch",
              "polish",
              "catalan",
              "french",
              "indonesian",
              "ukrainian",
              "turkish",
              "malay",
              "swedish",
              "mandarin",
              "finnish",
              "norwegian",
              "romanian",
              "thai",
              "vietnamese",
              "slovak",
              "arabic",
              "czech",
              "croatian",
              "greek",
              "serbian",
              "danish",
              "bulgarian",
              "hungarian",
              "filipino",
              "bosnian",
              "galician",
              "macedonian",
              "hindi",
              "estonian",
              "slovenian",
              "tamil",
              "latvian",
              "azerbaijani",
              "urdu",
              "lithuanian",
              "hebrew",
              "welsh",
              "persian",
              "icelandic",
              "kazakh",
              "afrikaans",
              "kannada",
              "marathi",
              "swahili",
              "telugu",
              "maori",
              "nepali",
              "armenian",
              "belarusian",
              "gujarati",
              "punjabi",
              "bengali"
            ],
            "type_name": "nodetool.nodes.openai.audio.Language"
          },
          "default": "auto_detect",
          "title": "Language",
          "description": "The language of the input audio"
        },
        {
          "name": "timestamps",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Timestamps",
          "description": "Whether to return timestamps for the generated text."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text to guide the model's style or continue a previous audio segment."
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Temperature",
          "description": "The sampling temperature between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.",
          "min": 0.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "audio_chunk"
              }
            ]
          },
          "name": "words"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "audio_chunk"
              }
            ]
          },
          "name": "segments"
        }
      ],
      "basic_fields": [
        "audio",
        "language",
        "timestamps"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Translate",
      "description": "Translates speech in audio to English text.\n    audio, translation, speech-to-text, localization\n\n    Use cases:\n    - Translate foreign language audio content to English\n    - Create English transcripts of multilingual recordings\n    - Assist non-English speakers in understanding audio content\n    - Enable cross-language communication in audio formats",
      "namespace": "openai.audio",
      "node_type": "openai.audio.Translate",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio file to translate."
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Temperature",
          "description": "The temperature to use for the translation."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "temperature"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Create Image",
      "description": "Generates images from textual descriptions.\n    image, t2i, tti, text-to-image, create, generate, picture, photo, art, drawing, illustration\n\n    Use cases:\n    1. Create custom illustrations for articles or presentations\n    2. Generate concept art for creative projects\n    3. Produce visual aids for educational content\n    4. Design unique marketing visuals or product mockups\n    5. Explore artistic ideas and styles programmatically",
      "namespace": "openai.image",
      "node_type": "openai.image.CreateImage",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The prompt to use."
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gpt-image-1"
            ],
            "type_name": "nodetool.nodes.openai.image.Model"
          },
          "default": "gpt-image-1",
          "title": "Model",
          "description": "The model to use for image generation."
        },
        {
          "name": "size",
          "type": {
            "type": "enum",
            "values": [
              "1024x1024",
              "1536x1024",
              "1024x1536"
            ],
            "type_name": "nodetool.nodes.openai.image.Size"
          },
          "default": "1024x1024",
          "title": "Size",
          "description": "The size of the image to generate."
        },
        {
          "name": "background",
          "type": {
            "type": "enum",
            "values": [
              "transparent",
              "opaque",
              "auto"
            ],
            "type_name": "nodetool.nodes.openai.image.Background"
          },
          "default": "auto",
          "title": "Background",
          "description": "The background of the image to generate."
        },
        {
          "name": "quality",
          "type": {
            "type": "enum",
            "values": [
              "high",
              "medium",
              "low"
            ],
            "type_name": "nodetool.nodes.openai.image.Quality"
          },
          "default": "high",
          "title": "Quality",
          "description": "The quality of the image to generate."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "model",
        "size",
        "background",
        "quality"
      ],
      "expose_as_tool": true
    }
  ],
  "assets": [
    {
      "package_name": "nodetool-base",
      "name": "Categorize Mails.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Simple Chat.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Chat with Docs.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Index PDFs.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Daily Digest.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Summarize Paper.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Image To Audio Story.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Data Generator.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Data Visualization Pipeline.jpg",
      "path": ""
    }
  ],
  "examples": [
    {
      "id": "4292f4a879bd11f09d970000262bfb92",
      "name": "Summarize Newsletters",
      "description": "",
      "tags": [
        "email",
        "start"
      ]
    },
    {
      "id": "64bac2e8340f11f097f000007d22ea5d",
      "name": "Chat with Docs",
      "description": "An intelligent document retrieval and question-answering system that leverages vector search and local LLMs to provide accurate, context-aware responses based on your document collection.",
      "tags": [
        "chat",
        "rag"
      ]
    },
    {
      "id": "7c89894e8ce411f083b10000284d49a0",
      "name": "Image Enhance",
      "description": "Improve image quality with basic enhancement tools like sharpening, contrast and color adjustment",
      "tags": [
        "image",
        "start"
      ]
    },
    {
      "id": "43a125a6124611f0b49100005eb1b543",
      "name": "Image To Audio Story",
      "description": "Generate and narrate creative stories from images using AI",
      "tags": [
        "start",
        "multimodal"
      ]
    },
    {
      "id": "06d8221c907e11f0a4240000006ab9b5",
      "name": "Realtime Agent",
      "description": "",
      "tags": []
    },
    {
      "id": "e25d8a38761211f080f7000017889565",
      "name": "Summarize Paper",
      "description": "",
      "tags": [
        "audio",
        "start"
      ]
    },
    {
      "id": "93102bfa8c8a11f0bcd000004fc538b3",
      "name": "Summarize RSS",
      "description": "",
      "tags": []
    },
    {
      "id": "5d2e4a22f33211ef9a370000764c777a",
      "name": "Categorize Mails",
      "description": "Automatically categorize and organize emails using AI",
      "tags": [
        "email",
        "start"
      ]
    },
    {
      "id": "c16e5fd559704602b082f7d58ee3a90f",
      "name": "Meeting Transcript Summarizer",
      "description": "Automatically transcribe a meeting recording and generate concise notes.",
      "tags": [
        "audio",
        "llm"
      ]
    },
    {
      "id": "remove_silence",
      "name": "Remove Silence",
      "description": "Remove silence from audio files.",
      "tags": [
        "audio"
      ]
    },
    {
      "id": "3047c2fa760811f0b24700002df0a13c",
      "name": "Index PDFs",
      "description": "Workflow to index PDFs in a folder into a Chroma collection",
      "tags": [
        "rag",
        "start"
      ]
    },
    {
      "id": "",
      "name": "Execute Python",
      "description": "",
      "tags": [
        "node",
        "advanced"
      ]
    },
    {
      "id": "78483f1ce4d611ef849100004ef921c4",
      "name": "Ingest PDF",
      "description": "",
      "tags": [
        "rag"
      ]
    },
    {
      "id": "data_visualization_pipeline",
      "name": "Data Visualization Pipeline",
      "description": "Transform natural language descriptions into data visualizations with AI-powered data and chart generation. This workflow demonstrates how to create customized charts from text prompts without manual data preparation.",
      "tags": [
        "agents"
      ]
    },
    {
      "id": "",
      "name": "Evaluate Expression",
      "description": "",
      "tags": [
        "node",
        "advanced"
      ]
    },
    {
      "id": "f905ed2212f611f0b622000001bffa9d",
      "name": "Simple Chat",
      "description": "Basic chat interface with tools",
      "tags": [
        "chat",
        "start"
      ]
    },
    {
      "id": "data_generator",
      "name": "Data Generator",
      "description": "Generate structured data using AI agents",
      "tags": [
        "agents"
      ]
    }
  ]
}