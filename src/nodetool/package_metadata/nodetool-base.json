{
  "name": "nodetool-base",
  "description": "Nodetool Base nodes",
  "version": "0.6.2-rc.13",
  "authors": [
    "Matthias Georgi <matti.georgi@gmail.com>"
  ],
  "repo_id": "",
  "nodes": [
    {
      "title": "File Watch Trigger",
      "description": "Trigger node that monitors filesystem changes.\n\n    This trigger uses the watchdog library to monitor a directory or file\n    for changes. When a change is detected, an event is emitted containing:\n    - The path of the changed file\n    - The type of change (created, modified, deleted, moved)\n    - Timestamp of the event\n\n    This trigger is useful for:\n    - Processing files as they arrive in a directory\n    - Triggering workflows on configuration changes\n    - Building file-based automation pipelines",
      "namespace": "nodetool.triggers",
      "node_type": "nodetool.triggers.FileWatchTrigger",
      "properties": [
        {
          "name": "max_events",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Max Events",
          "description": "Maximum number of events to process (0 = unlimited)",
          "min": 0.0
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": ".",
          "title": "Path",
          "description": "Path to watch (file or directory)"
        },
        {
          "name": "recursive",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Recursive",
          "description": "Watch subdirectories recursively"
        },
        {
          "name": "patterns",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [
            "*"
          ],
          "title": "Patterns",
          "description": "File patterns to watch (e.g., ['*.txt', '*.json'])"
        },
        {
          "name": "ignore_patterns",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Ignore Patterns",
          "description": "File patterns to ignore"
        },
        {
          "name": "events",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [
            "created",
            "modified",
            "deleted",
            "moved"
          ],
          "title": "Events",
          "description": "Types of events to watch for"
        },
        {
          "name": "debounce_seconds",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Debounce Seconds",
          "description": "Debounce time to avoid duplicate events",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "event"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "path"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "dest_path"
        },
        {
          "type": {
            "type": "bool"
          },
          "name": "is_directory"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "timestamp"
        }
      ],
      "basic_fields": [
        "max_events",
        "path",
        "recursive",
        "patterns",
        "ignore_patterns",
        "events",
        "debounce_seconds"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Interval Trigger",
      "description": "Trigger node that fires at regular time intervals.\n\n    This trigger emits events at a configured interval, similar to a timer\n    or scheduler. Each event contains:\n    - The tick number (how many times the trigger has fired)\n    - The current timestamp\n    - The configured interval\n\n    This trigger is useful for:\n    - Periodic data collection or polling\n    - Scheduled batch processing\n    - Heartbeat or keepalive workflows\n    - Time-based automation",
      "namespace": "nodetool.triggers",
      "node_type": "nodetool.triggers.IntervalTrigger",
      "properties": [
        {
          "name": "max_events",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Max Events",
          "description": "Maximum number of events to process (0 = unlimited)",
          "min": 0.0
        },
        {
          "name": "interval_seconds",
          "type": {
            "type": "float"
          },
          "default": 60.0,
          "title": "Interval Seconds",
          "description": "Interval between triggers in seconds"
        },
        {
          "name": "initial_delay_seconds",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Initial Delay Seconds",
          "description": "Delay before the first trigger fires",
          "min": 0.0
        },
        {
          "name": "emit_on_start",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Emit On Start",
          "description": "Whether to emit an event immediately on start"
        },
        {
          "name": "include_drift_compensation",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Include Drift Compensation",
          "description": "Compensate for execution time to maintain accurate intervals"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "tick"
        },
        {
          "type": {
            "type": "float"
          },
          "name": "elapsed_seconds"
        },
        {
          "type": {
            "type": "float"
          },
          "name": "interval_seconds"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "timestamp"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "source"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "event_type"
        }
      ],
      "basic_fields": [
        "max_events",
        "interval_seconds",
        "initial_delay_seconds",
        "emit_on_start",
        "include_drift_compensation"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Manual Trigger",
      "description": "Trigger node that waits for manual events pushed via the API.\n\n    This trigger enables interactive workflows where events are pushed\n    programmatically through the workflow runner's input API. Each event\n    pushed to the trigger is emitted and processed by the workflow.\n\n    This trigger is useful for:\n    - Building chatbot-style workflows\n    - Interactive processing pipelines\n    - Manual batch processing\n    - Testing and debugging workflows",
      "namespace": "nodetool.triggers",
      "node_type": "nodetool.triggers.ManualTrigger",
      "properties": [
        {
          "name": "max_events",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Max Events",
          "description": "Maximum number of events to process (0 = unlimited)",
          "min": 0.0
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "manual_trigger",
          "title": "Name",
          "description": "Name for this trigger (used in API calls)"
        },
        {
          "name": "timeout_seconds",
          "type": {
            "type": "float",
            "optional": true
          },
          "default": null,
          "title": "Timeout Seconds",
          "description": "Timeout waiting for events (None = wait forever)",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "data"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "timestamp"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "source"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "event_type"
        }
      ],
      "basic_fields": [
        "max_events",
        "name",
        "timeout_seconds"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Webhook Trigger",
      "description": "Trigger node that starts an HTTP server to receive webhook requests.\n\n    Each incoming HTTP request is emitted as an event containing:\n    - The request body (parsed as JSON if applicable)\n    - Request headers\n    - Query parameters\n    - HTTP method\n\n    This trigger is useful for:\n    - Receiving notifications from external services\n    - Building API endpoints that trigger workflows\n    - Integration with third-party webhook providers",
      "namespace": "nodetool.triggers",
      "node_type": "nodetool.triggers.WebhookTrigger",
      "properties": [
        {
          "name": "max_events",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Max Events",
          "description": "Maximum number of events to process (0 = unlimited)",
          "min": 0.0
        },
        {
          "name": "port",
          "type": {
            "type": "int"
          },
          "default": 8080,
          "title": "Port",
          "description": "Port to listen on for webhook requests",
          "min": 1.0,
          "max": 65535.0
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "/webhook",
          "title": "Path",
          "description": "URL path to listen on"
        },
        {
          "name": "host",
          "type": {
            "type": "str"
          },
          "default": "127.0.0.1",
          "title": "Host",
          "description": "Host address to bind to. Use '0.0.0.0' to listen on all interfaces."
        },
        {
          "name": "methods",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [
            "POST"
          ],
          "title": "Methods",
          "description": "HTTP methods to accept"
        },
        {
          "name": "secret",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Secret",
          "description": "Optional secret for validating requests (checks X-Webhook-Secret header)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "body"
        },
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "headers"
        },
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "query"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "method"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "path"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "timestamp"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "source"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "event_type"
        }
      ],
      "basic_fields": [
        "max_events",
        "port",
        "path",
        "host",
        "methods",
        "secret"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Append",
      "description": "Adds a value to the end of a list.\n    list, add, insert, extend\n\n    Use cases:\n    - Grow a list dynamically\n    - Add new elements to an existing list\n    - Implement a stack-like structure",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Append",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "default": [],
          "title": "Value",
          "description": "The value to append to the list."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "value"
      ]
    },
    {
      "title": "Average",
      "description": "Calculates the arithmetic mean of a list of numbers.\n    list, average, mean, aggregate, math\n\n    Use cases:\n    - Find average value\n    - Calculate mean of numeric data",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Average",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Chunk",
      "description": "Splits a list into smaller chunks of specified size.\n    list, chunk, split, group\n\n    Use cases:\n    - Batch processing\n    - Pagination\n    - Creating sublists of fixed size",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Chunk",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Chunk Size"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "list",
                "type_args": [
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "chunk_size"
      ]
    },
    {
      "title": "Dedupe",
      "description": "Removes duplicate elements from a list, ensuring uniqueness.\n    list, unique, distinct, deduplicate\n\n    Use cases:\n    - Remove redundant entries\n    - Create a set-like structure\n    - Ensure list elements are unique",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Dedupe",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Difference",
      "description": "Finds elements that exist in first list but not in second list.\n    list, set, difference, subtract\n\n    Use cases:\n    - Find unique elements in one list\n    - Remove items present in another list\n    - Identify distinct elements",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Difference",
      "properties": [
        {
          "name": "list1",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List1"
        },
        {
          "name": "list2",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List2"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "list1",
        "list2"
      ]
    },
    {
      "title": "Extend",
      "description": "Merges one list into another, extending the original list.\n    list, merge, concatenate, combine\n\n    Use cases:\n    - Combine multiple lists\n    - Add all elements from one list to another",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Extend",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "other_values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Other Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "other_values"
      ]
    },
    {
      "title": "Flatten",
      "description": "Flattens a nested list structure into a single flat list.\n    list, flatten, nested, structure\n\n    Use cases:\n    - Convert nested lists into a single flat list\n    - Simplify complex list structures\n    - Process hierarchical data as a sequence\n\n    Examples:\n    [[1, 2], [3, 4]] -> [1, 2, 3, 4]\n    [[1, [2, 3]], [4, [5, 6]]] -> [1, 2, 3, 4, 5, 6]",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Flatten",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "max_depth",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Max Depth",
          "min": -1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "max_depth"
      ]
    },
    {
      "title": "Generate Sequence",
      "description": "Iterates over a sequence of numbers.\n    list, range, sequence, numbers",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.GenerateSequence",
      "properties": [
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start"
        },
        {
          "name": "stop",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Stop"
        },
        {
          "name": "step",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Step"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "start",
        "stop",
        "step"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Get Element",
      "description": "Retrieves a single value from a list at a specific index.\n    list, get, extract, value\n\n    Use cases:\n    - Access a specific element by position\n    - Implement array-like indexing\n    - Extract the first or last element",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.GetElement",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "index",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Index"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "index"
      ]
    },
    {
      "title": "Intersection",
      "description": "Finds common elements between two lists.\n    list, set, intersection, common\n\n    Use cases:\n    - Find elements present in both lists\n    - Identify shared items between collections\n    - Filter for matching elements",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Intersection",
      "properties": [
        {
          "name": "list1",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List1"
        },
        {
          "name": "list2",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List2"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "list1",
        "list2"
      ]
    },
    {
      "title": "Length",
      "description": "Calculates the length of a list.\n    list, count, size\n\n    Use cases:\n    - Determine the number of elements in a list\n    - Check if a list is empty\n    - Validate list size constraints",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Length",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "List Range",
      "description": "Generates a list of integers within a specified range.\n    list, range, sequence, numbers\n\n    Use cases:\n    - Create numbered lists\n    - Generate index sequences\n    - Produce arithmetic progressions",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.ListRange",
      "properties": [
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start"
        },
        {
          "name": "stop",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Stop"
        },
        {
          "name": "step",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Step"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "start",
        "stop",
        "step"
      ]
    },
    {
      "title": "Maximum",
      "description": "Finds the largest value in a list of numbers.\n    list, max, maximum, aggregate, math\n\n    Use cases:\n    - Find highest value\n    - Get largest number in dataset",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Maximum",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Minimum",
      "description": "Finds the smallest value in a list of numbers.\n    list, min, minimum, aggregate, math\n\n    Use cases:\n    - Find lowest value\n    - Get smallest number in dataset",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Minimum",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Product",
      "description": "Calculates the product of all numbers in a list.\n    list, product, multiply, aggregate, math\n\n    Use cases:\n    - Multiply all numbers together\n    - Calculate compound values",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Product",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Randomize",
      "description": "Randomly shuffles the elements of a list.\n    list, shuffle, random, order\n\n    Use cases:\n    - Randomize the order of items in a playlist\n    - Implement random sampling without replacement\n    - Create randomized data sets for testing",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Randomize",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Reverse",
      "description": "Inverts the order of elements in a list.\n    list, reverse, invert, flip\n\n    Use cases:\n    - Reverse the order of a sequence",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Reverse",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Save List",
      "description": "Saves a list to a text file, placing each element on a new line.\n    list, save, file, serialize\n\n    Use cases:\n    - Export list data to a file\n    - Create a simple text-based database\n    - Generate line-separated output",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.SaveList",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "text.txt",
          "title": "Name",
          "description": "\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "text"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "name"
      ]
    },
    {
      "title": "Select Elements",
      "description": "Selects specific values from a list using index positions.\n    list, select, index, extract\n\n    Use cases:\n    - Pick specific elements by their positions\n    - Rearrange list elements\n    - Create a new list from selected indices",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.SelectElements",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "indices",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "int"
              }
            ]
          },
          "default": [],
          "title": "Indices"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "indices"
      ]
    },
    {
      "title": "Slice",
      "description": "Extracts a subset from a list using start, stop, and step indices.\n    list, slice, subset, extract\n\n    Use cases:\n    - Get a portion of a list\n    - Implement pagination\n    - Extract every nth element",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Slice",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start"
        },
        {
          "name": "stop",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Stop"
        },
        {
          "name": "step",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Step"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "start",
        "stop",
        "step"
      ]
    },
    {
      "title": "Sort",
      "description": "Sorts the elements of a list in ascending or descending order.\n    list, sort, order, arrange\n\n    Use cases:\n    - Organize data in a specific order\n    - Prepare data for binary search or other algorithms\n    - Rank items based on their values",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Sort",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "order",
          "type": {
            "type": "enum",
            "values": [
              "ascending",
              "descending"
            ],
            "type_name": "nodetool.nodes.nodetool.list.Sort.SortOrder"
          },
          "default": "ascending",
          "title": "Order"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "order"
      ]
    },
    {
      "title": "Sum",
      "description": "Calculates the sum of a list of numbers.\n    list, sum, aggregate, math\n\n    Use cases:\n    - Calculate total of numeric values\n    - Add up all elements in a list",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Sum",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Union",
      "description": "Combines unique elements from two lists.\n    list, set, union, combine\n\n    Use cases:\n    - Merge lists while removing duplicates\n    - Combine collections uniquely\n    - Create comprehensive set of items",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Union",
      "properties": [
        {
          "name": "list1",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List1"
        },
        {
          "name": "list2",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List2"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "list1",
        "list2"
      ]
    },
    {
      "title": "Collect",
      "description": "Collect items until the end of the stream and return them as a list.\n    collector, aggregate, list, stream\n\n    Use cases:\n    - Gather results from multiple processing steps\n    - Collect streaming data into batches\n    - Aggregate outputs from parallel operations",
      "namespace": "nodetool.control",
      "node_type": "nodetool.control.Collect",
      "properties": [
        {
          "name": "input_item",
          "type": {
            "type": "any"
          },
          "default": [],
          "title": "Input Item",
          "description": "The input item to collect."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_item"
      ]
    },
    {
      "title": "For Each",
      "description": "Iterate over a list and emit each item sequentially.\n    iterator, loop, list, sequence\n\n    Use cases:\n    - Process each item of a collection in order\n    - Drive downstream nodes with individual elements",
      "namespace": "nodetool.control",
      "node_type": "nodetool.control.ForEach",
      "properties": [
        {
          "name": "input_list",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Input List",
          "description": "The list of items to iterate over."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "index"
        }
      ],
      "basic_fields": [
        "input_list"
      ],
      "is_streaming_output": true
    },
    {
      "title": "If",
      "description": "Conditionally executes one of two branches based on a condition.\n    control, flow, condition, logic, else, true, false, switch, toggle, flow-control\n\n    Use cases:\n    - Branch workflow based on conditions\n    - Handle different cases in data processing\n    - Implement decision logic",
      "namespace": "nodetool.control",
      "node_type": "nodetool.control.If",
      "properties": [
        {
          "name": "condition",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Condition",
          "description": "The condition to evaluate"
        },
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "default": [],
          "title": "Value",
          "description": "The value to pass to the next node"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "if_true"
        },
        {
          "type": {
            "type": "any"
          },
          "name": "if_false"
        }
      ],
      "basic_fields": [
        "condition",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Reroute",
      "description": "Pass data through unchanged for tidier workflow layouts.\n    reroute, passthrough, organize, tidy, flow, connection, redirect\n\n    Use cases:\n    - Organize complex workflows by routing connections\n    - Create cleaner visual layouts\n    - Redirect data flow without modification",
      "namespace": "nodetool.control",
      "node_type": "nodetool.control.Reroute",
      "properties": [
        {
          "name": "input_value",
          "type": {
            "type": "any"
          },
          "default": [],
          "title": "Input Value",
          "description": "Value to pass through unchanged"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Execute Bash",
      "description": "Executes Bash script with safety restrictions.\n    bash, shell, code, execute",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecuteBash",
      "properties": [
        {
          "name": "code",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Code",
          "description": "Bash script to execute as-is. Dynamic inputs are provided as env vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'."
        },
        {
          "name": "image",
          "type": {
            "type": "enum",
            "values": [
              "bash:5.2",
              "debian:12",
              "ubuntu:22.04",
              "ubuntu:24.04",
              "jupyter/scipy-notebook:latest"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecuteBash.BashImage"
          },
          "default": "ubuntu:22.04",
          "title": "Image",
          "description": "Docker image to use for execution"
        },
        {
          "name": "execution_mode",
          "type": {
            "type": "enum",
            "values": [
              "docker",
              "subprocess"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutionMode"
          },
          "default": "docker",
          "title": "Execution Mode",
          "description": "Execution mode: 'docker' or 'subprocess'"
        },
        {
          "name": "stdin",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Stdin",
          "description": "String to write to process stdin before any streaming input. Use newlines to separate lines."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "code",
        "image",
        "execution_mode",
        "stdin"
      ],
      "is_dynamic": true,
      "is_streaming_output": true,
      "supports_dynamic_outputs": true
    },
    {
      "title": "Execute Command",
      "description": "Executes a single shell command inside a Docker container.\n    command, execute, shell, bash, sh\n\n    IMPORTANT: Only enabled in non-production environments",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecuteCommand",
      "properties": [
        {
          "name": "command",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Command",
          "description": "Single command to run via the selected shell. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'."
        },
        {
          "name": "image",
          "type": {
            "type": "enum",
            "values": [
              "bash:5.2",
              "alpine:3",
              "ubuntu:22.04",
              "ubuntu:24.04"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecuteCommand.CommandImage"
          },
          "default": "bash:5.2",
          "title": "Image",
          "description": "Docker image to use for execution"
        },
        {
          "name": "execution_mode",
          "type": {
            "type": "enum",
            "values": [
              "docker",
              "subprocess"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutionMode"
          },
          "default": "docker",
          "title": "Execution Mode",
          "description": "Execution mode: 'docker' or 'subprocess'"
        },
        {
          "name": "stdin",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Stdin",
          "description": "String to write to process stdin before any streaming input. Use newlines to separate lines."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "command",
        "image",
        "execution_mode",
        "stdin"
      ],
      "is_dynamic": true,
      "is_streaming_output": true,
      "supports_dynamic_outputs": true
    },
    {
      "title": "Execute Java Script",
      "description": "Executes JavaScript (Node.js) code with safety restrictions.\n    javascript, nodejs, code, execute",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecuteJavaScript",
      "properties": [
        {
          "name": "code",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Code",
          "description": "JavaScript code to execute as-is under Node.js. Dynamic inputs are provided as local vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'."
        },
        {
          "name": "image",
          "type": {
            "type": "enum",
            "values": [
              "node:22-alpine"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecuteJavaScript.JavaScriptImage"
          },
          "default": "node:22-alpine",
          "title": "Image",
          "description": "Docker image to use for execution"
        },
        {
          "name": "execution_mode",
          "type": {
            "type": "enum",
            "values": [
              "docker",
              "subprocess"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutionMode"
          },
          "default": "docker",
          "title": "Execution Mode",
          "description": "Execution mode: 'docker' or 'subprocess'"
        },
        {
          "name": "stdin",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Stdin",
          "description": "String to write to process stdin before any streaming input. Use newlines to separate lines."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "code",
        "image",
        "execution_mode",
        "stdin"
      ],
      "is_dynamic": true,
      "supports_dynamic_outputs": true
    },
    {
      "title": "Execute Lua",
      "description": "Executes Lua code with a local sandbox (no Docker).\n    lua, code, execute, sandbox",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecuteLua",
      "properties": [
        {
          "name": "code",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Code",
          "description": "Lua code to execute as-is in a restricted environment. Dynamic inputs are provided as variables. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'."
        },
        {
          "name": "executable",
          "type": {
            "type": "enum",
            "values": [
              "lua",
              "luajit"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecuteLua.LuaExecutable"
          },
          "default": "lua",
          "title": "Executable",
          "description": "Lua executable to use"
        },
        {
          "name": "execution_mode",
          "type": {
            "type": "enum",
            "values": [
              "docker",
              "subprocess"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutionMode"
          },
          "default": "subprocess",
          "title": "Execution Mode",
          "description": "Execution mode: 'docker' or 'subprocess'"
        },
        {
          "name": "timeout_seconds",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Timeout Seconds",
          "description": "Max seconds to allow execution before forced stop"
        },
        {
          "name": "stdin",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Stdin",
          "description": "String to write to process stdin before any streaming input. Use newlines to separate lines."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "code",
        "executable",
        "execution_mode",
        "timeout_seconds",
        "stdin"
      ],
      "is_dynamic": true,
      "is_streaming_output": true,
      "supports_dynamic_outputs": true
    },
    {
      "title": "Execute Python",
      "description": "Executes Python code with safety restrictions.\n    python, code, execute\n\n    Use cases:\n    - Run custom data transformations\n    - Prototype node functionality\n    - Debug and testing workflows\n\n    IMPORTANT: Only enabled in non-production environments",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecutePython",
      "properties": [
        {
          "name": "code",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Code",
          "description": "Python code to execute as-is. Dynamic inputs are provided as local vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'."
        },
        {
          "name": "image",
          "type": {
            "type": "enum",
            "values": [
              "python:3.11-slim",
              "jupyter/scipy-notebook:latest"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutePython.PythonImage"
          },
          "default": "python:3.11-slim",
          "title": "Image",
          "description": "Docker image to use for execution"
        },
        {
          "name": "execution_mode",
          "type": {
            "type": "enum",
            "values": [
              "docker",
              "subprocess"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutionMode"
          },
          "default": "docker",
          "title": "Execution Mode",
          "description": "Execution mode: 'docker' or 'subprocess'"
        },
        {
          "name": "stdin",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Stdin",
          "description": "String to write to process stdin before any streaming input. Use newlines to separate lines."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "code",
        "image",
        "execution_mode",
        "stdin"
      ],
      "is_dynamic": true,
      "is_streaming_output": true,
      "supports_dynamic_outputs": true
    },
    {
      "title": "Execute Ruby",
      "description": "Executes Ruby code with safety restrictions.\n    ruby, code, execute",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecuteRuby",
      "properties": [
        {
          "name": "code",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Code",
          "description": "Ruby code to execute as-is. Dynamic inputs are provided as env vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'."
        },
        {
          "name": "image",
          "type": {
            "type": "enum",
            "values": [
              "ruby:3.3-alpine"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecuteRuby.RubyImage"
          },
          "default": "ruby:3.3-alpine",
          "title": "Image",
          "description": "Docker image to use for execution"
        },
        {
          "name": "execution_mode",
          "type": {
            "type": "enum",
            "values": [
              "docker",
              "subprocess"
            ],
            "type_name": "nodetool.nodes.nodetool.code.ExecutionMode"
          },
          "default": "docker",
          "title": "Execution Mode",
          "description": "Execution mode: 'docker' or 'subprocess'"
        },
        {
          "name": "stdin",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Stdin",
          "description": "String to write to process stdin before any streaming input. Use newlines to separate lines."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "stdout"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "stderr"
        }
      ],
      "basic_fields": [
        "code",
        "image",
        "execution_mode",
        "stdin"
      ],
      "is_dynamic": true,
      "is_streaming_output": true,
      "supports_dynamic_outputs": true
    },
    {
      "title": "Filter Number",
      "description": "Filters a stream of numbers based on various numerical conditions.\n    filter, numbers, numeric, stream\n    \n    Use cases:\n    - Filter numbers by comparison (greater than, less than, equal to)\n    - Filter even/odd numbers\n    - Filter positive/negative numbers",
      "namespace": "nodetool.numbers",
      "node_type": "nodetool.numbers.FilterNumber",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Value",
          "description": "Input number stream"
        },
        {
          "name": "filter_type",
          "type": {
            "type": "enum",
            "values": [
              "greater_than",
              "less_than",
              "equal_to",
              "even",
              "odd",
              "positive",
              "negative"
            ],
            "type_name": "nodetool.nodes.nodetool.numbers.FilterNumber.FilterNumberType"
          },
          "default": "greater_than",
          "title": "Filter Type",
          "description": "The type of filter to apply"
        },
        {
          "name": "compare_value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Compare Value",
          "description": "The comparison value (for greater_than, less_than, equal_to)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value",
        "filter_type",
        "compare_value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Filter Number Range",
      "description": "Filters a stream of numbers to find values within a specified range.\n    filter, numbers, range, between, stream\n\n    Use cases:\n    - Find numbers within a specific range\n    - Filter data points within bounds\n    - Implement range-based filtering",
      "namespace": "nodetool.numbers",
      "node_type": "nodetool.numbers.FilterNumberRange",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Value",
          "description": "Input number stream"
        },
        {
          "name": "min_value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Min Value",
          "description": "Minimum value"
        },
        {
          "name": "max_value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Max Value",
          "description": "Maximum value"
        },
        {
          "name": "inclusive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Inclusive",
          "description": "Inclusive bounds"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value",
        "min_value",
        "max_value",
        "inclusive"
      ],
      "is_streaming_output": true
    },
    {
      "title": "All",
      "description": "Checks if all boolean values in a list are True.\n    boolean, all, check, logic, condition, flow-control, branch\n\n\n    Use cases:\n    - Ensure all conditions in a set are met\n    - Implement comprehensive checks\n    - Validate multiple criteria simultaneously",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.All",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "bool"
              }
            ]
          },
          "default": [],
          "title": "Values",
          "description": "List of boolean values to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Compare",
      "description": "Compares two values using a specified comparison operator.\n    compare, condition, logic\n\n    Use cases:\n    - Implement decision points in workflows\n    - Filter data based on specific criteria\n    - Create dynamic thresholds or limits",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.Compare",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0,
          "title": "A",
          "description": "First value to compare"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0,
          "title": "B",
          "description": "Second value to compare"
        },
        {
          "name": "comparison",
          "type": {
            "type": "enum",
            "values": [
              "==",
              "!=",
              ">",
              "<",
              ">=",
              "<="
            ],
            "type_name": "nodetool.nodes.nodetool.boolean.Compare.Comparison"
          },
          "default": "==",
          "title": "Comparison",
          "description": "Comparison operator to use"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b",
        "comparison"
      ]
    },
    {
      "title": "Conditional Switch",
      "description": "Performs a conditional check on a boolean input and returns a value based on the result.\n    if, condition, flow-control, branch, true, false, switch, toggle\n\n    Use cases:\n    - Implement conditional logic in workflows\n    - Create dynamic branches in workflows\n    - Implement decision points in workflows",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.ConditionalSwitch",
      "properties": [
        {
          "name": "condition",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Condition",
          "description": "The condition to check"
        },
        {
          "name": "if_true",
          "type": {
            "type": "any"
          },
          "default": [],
          "title": "If True",
          "description": "The value to return if the condition is true"
        },
        {
          "name": "if_false",
          "type": {
            "type": "any"
          },
          "default": [],
          "title": "If False",
          "description": "The value to return if the condition is false"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "condition",
        "if_true",
        "if_false"
      ]
    },
    {
      "title": "Is In",
      "description": "Checks if a value is present in a list of options.\n    membership, contains, check\n\n    Use cases:\n    - Validate input against a set of allowed values\n    - Implement category or group checks\n    - Filter data based on inclusion criteria",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.IsIn",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "default": [],
          "title": "Value",
          "description": "The value to check for membership"
        },
        {
          "name": "options",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Options",
          "description": "The list of options to check against"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value",
        "options"
      ]
    },
    {
      "title": "Is None",
      "description": "Checks if a value is None.\n    null, none, check\n\n    Use cases:\n    - Validate input presence\n    - Handle optional parameters\n    - Implement null checks in data processing",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.IsNone",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "default": [],
          "title": "Value",
          "description": "The value to check for None"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "Logical Operator",
      "description": "Performs logical operations on two boolean inputs.\n    boolean, logic, operator, condition, flow-control, branch, else, true, false, switch, toggle\n\n    Use cases:\n    - Combine multiple conditions in decision-making\n    - Implement complex logical rules in workflows\n    - Create advanced filters or triggers",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.LogicalOperator",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "A",
          "description": "First boolean input"
        },
        {
          "name": "b",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "B",
          "description": "Second boolean input"
        },
        {
          "name": "operation",
          "type": {
            "type": "enum",
            "values": [
              "and",
              "or",
              "xor",
              "nand",
              "nor"
            ],
            "type_name": "nodetool.nodes.nodetool.boolean.LogicalOperator.BooleanOperation"
          },
          "default": "and",
          "title": "Operation",
          "description": "Logical operation to perform"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b",
        "operation"
      ]
    },
    {
      "title": "Not",
      "description": "Performs logical NOT operation on a boolean input.\n    boolean, logic, not, invert, !, negation, condition, else, true, false, switch, toggle, flow-control, branch\n\n    Use cases:\n    - Invert a condition's result\n    - Implement toggle functionality\n    - Create opposite logic branches",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.Not",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Value",
          "description": "Boolean input to negate"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "Some",
      "description": "Checks if any boolean value in a list is True.\n    boolean, any, check, logic, condition, flow-control, branch\n\n    Use cases:\n    - Check if at least one condition in a set is met\n    - Implement optional criteria checks\n    - Create flexible validation rules",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.Some",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "bool"
              }
            ]
          },
          "default": [],
          "title": "Values",
          "description": "List of boolean values to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Agent",
      "description": "Generate natural language responses using LLM providers and streams output.\n    llm, text-generation, chatbot, question-answering, streaming",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.Agent",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": "",
            "path": null,
            "supported_tasks": []
          },
          "title": "Model",
          "description": "Model to use for execution"
        },
        {
          "name": "system",
          "type": {
            "type": "str"
          },
          "default": "You are a an AI agent. \n\nBehavior\n- Understand the user's intent and the context of the task.\n- Break down the task into smaller steps.\n- Be precise, concise, and actionable.\n- Use tools to accomplish your goal. \n\nTool preambles\n- Outline the next step(s) you will perform.\n- After acting, summarize the outcome.\n\nRendering\n- Use Markdown to display media assets.\n- Display images, audio, and video assets using the appropriate Markdown.\n\nFile handling\n- Inputs and outputs are files in the /workspace directory.\n- Write outputs of code execution to the /workspace directory.\n",
          "title": "System",
          "description": "The system prompt for the LLM"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The prompt for the LLM"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to analyze"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio to analyze"
        },
        {
          "name": "history",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "message"
              }
            ]
          },
          "default": [],
          "title": "Messages",
          "description": "The messages for the LLM"
        },
        {
          "name": "thread_id",
          "type": {
            "type": "str",
            "optional": true
          },
          "default": "",
          "title": "Thread ID",
          "description": "Optional thread ID for persistent conversation history. If provided, messages will be loaded from and saved to this thread."
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 8192,
          "title": "Max Tokens",
          "min": 1.0,
          "max": 100000.0
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window (Ollama)",
          "min": 1.0,
          "max": 65536.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        },
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        }
      ],
      "recommended_models": [
        {
          "id": "gpt-oss:20b",
          "type": "llama_model",
          "name": "GPT - OSS",
          "repo_id": "gpt-oss:20b",
          "description": "OpenAI's open-weight model excels at multi-tool routing and reasoning.",
          "size_on_disk": 15032385536
        },
        {
          "id": "qwen3-vl:4b",
          "type": "llama_model",
          "name": "Qwen3 VL - 4B",
          "repo_id": "qwen3-vl:4b",
          "description": "The most powerful vision-language model in the Qwen model family to date.",
          "size_on_disk": 3543348019
        },
        {
          "id": "qwen3-vl:8b",
          "type": "llama_model",
          "name": "Qwen3 VL - 8B",
          "repo_id": "qwen3-vl:8b",
          "description": "The most powerful vision-language model in the Qwen model family to date.",
          "size_on_disk": 6549825126
        },
        {
          "id": "gemma3:1b",
          "type": "llama_model",
          "name": "Gemma3 - 1B",
          "repo_id": "gemma3:1b",
          "description": "Gemma3 1B is a small model that can process text and images.",
          "size_on_disk": 875099586
        },
        {
          "id": "gemma3:4b",
          "type": "llama_model",
          "name": "Gemma3 - 4B",
          "repo_id": "gemma3:4b",
          "description": "Gemma3 4B is a small model that can process text and images.",
          "size_on_disk": 3543348019
        },
        {
          "id": "llama3.2:3b",
          "type": "llama_model",
          "name": "Llama 3.2 - 3B",
          "repo_id": "llama3.2:3b",
          "description": "Compact Llama 3.2 variant keeps latency low while following tool schemas accurately.",
          "size_on_disk": 2040109465
        },
        {
          "id": "qwen3:4b",
          "type": "llama_model",
          "name": "Qwen3 - 4B",
          "repo_id": "qwen3:4b",
          "description": "Qwen3 4B ships strong function-calling primitives and dependable multi-turn tool use.",
          "size_on_disk": 2684354560
        },
        {
          "id": "qwen3:8b",
          "type": "llama_model",
          "name": "Qwen3 - 8B",
          "repo_id": "qwen3:8b",
          "description": "Qwen3 8B ships strong function-calling primitives and dependable multi-turn tool use.",
          "size_on_disk": 5583457484
        },
        {
          "id": "deepseek-r1:8b",
          "type": "mistral_model",
          "name": "Deepseek R1 - 8B",
          "repo_id": "deepseek-r1:8",
          "description": "DeepSeek R1 8B balances reasoning with precise function calls for iterative agents.",
          "size_on_disk": 5583457484
        },
        {
          "id": "ggml-org/gpt-oss-20b-GGUF:gpt-oss-20b-mxfp4.gguf",
          "type": "llama_cpp_model",
          "name": "GPT-OSS 20B (GGUF)",
          "repo_id": "ggml-org/gpt-oss-20b-GGUF",
          "path": "gpt-oss-20b-mxfp4.gguf",
          "description": "OpenAI's open-weight model in efficient MXFP4 format for llama.cpp.",
          "size_on_disk": 9191230013,
          "tags": [
            "gguf",
            "base_model:openai/gpt-oss-20b",
            "base_model:quantized:openai/gpt-oss-20b",
            "endpoints_compatible",
            "region:us",
            "conversational"
          ],
          "has_model_index": false,
          "downloads": 94468,
          "likes": 113
        },
        {
          "id": "ggml-org/gemma-3-4b-it-GGUF:gemma-3-4b-it-Q4_K_M.gguf",
          "type": "llama_cpp_model",
          "name": "Gemma 3 4B IT (GGUF)",
          "repo_id": "ggml-org/gemma-3-4b-it-GGUF",
          "path": "gemma-3-4b-it-Q4_K_M.gguf",
          "description": "Google's Gemma 3 4B in Q4_K_M quantization for efficient inference.",
          "size_on_disk": 3113851289,
          "pipeline_tag": "image-text-to-text",
          "tags": [
            "gguf",
            "image-text-to-text",
            "arxiv:1905.07830",
            "arxiv:1905.10044",
            "arxiv:1911.11641",
            "arxiv:1904.09728",
            "arxiv:1705.03551",
            "arxiv:1911.01547",
            "arxiv:1907.10641",
            "arxiv:1903.00161",
            "arxiv:2009.03300",
            "arxiv:2304.06364",
            "arxiv:2103.03874",
            "arxiv:2110.14168",
            "arxiv:2311.12022",
            "arxiv:2108.07732",
            "arxiv:2107.03374",
            "arxiv:2210.03057",
            "arxiv:2106.03193",
            "arxiv:1910.11856",
            "arxiv:2502.12404",
            "arxiv:2502.21228",
            "arxiv:2404.16816",
            "arxiv:2104.12756",
            "arxiv:2311.16502",
            "arxiv:2203.10244",
            "arxiv:2404.12390",
            "arxiv:1810.12440",
            "arxiv:1908.02660",
            "arxiv:2312.11805",
            "base_model:google/gemma-3-4b-it",
            "base_model:quantized:google/gemma-3-4b-it",
            "license:gemma",
            "endpoints_compatible",
            "region:us",
            "conversational"
          ],
          "has_model_index": false,
          "downloads": 18924,
          "likes": 44
        },
        {
          "id": "ggml-org/gemma-3-12b-it-GGUF:gemma-3-12b-it-Q4_K_M.gguf",
          "type": "llama_cpp_model",
          "name": "Gemma 3 12B IT (GGUF)",
          "repo_id": "ggml-org/gemma-3-12b-it-GGUF",
          "path": "gemma-3-12b-it-Q4_K_M.gguf",
          "description": "Google's Gemma 3 12B in Q4_K_M quantization with strong reasoning.",
          "size_on_disk": 7838315315,
          "pipeline_tag": "image-text-to-text",
          "tags": [
            "gguf",
            "image-text-to-text",
            "arxiv:1905.07830",
            "arxiv:1905.10044",
            "arxiv:1911.11641",
            "arxiv:1904.09728",
            "arxiv:1705.03551",
            "arxiv:1911.01547",
            "arxiv:1907.10641",
            "arxiv:1903.00161",
            "arxiv:2009.03300",
            "arxiv:2304.06364",
            "arxiv:2103.03874",
            "arxiv:2110.14168",
            "arxiv:2311.12022",
            "arxiv:2108.07732",
            "arxiv:2107.03374",
            "arxiv:2210.03057",
            "arxiv:2106.03193",
            "arxiv:1910.11856",
            "arxiv:2502.12404",
            "arxiv:2502.21228",
            "arxiv:2404.16816",
            "arxiv:2104.12756",
            "arxiv:2311.16502",
            "arxiv:2203.10244",
            "arxiv:2404.12390",
            "arxiv:1810.12440",
            "arxiv:1908.02660",
            "arxiv:2312.11805",
            "base_model:google/gemma-3-12b-it",
            "base_model:quantized:google/gemma-3-12b-it",
            "license:gemma",
            "endpoints_compatible",
            "region:us",
            "conversational"
          ],
          "has_model_index": false,
          "downloads": 3037,
          "likes": 30
        },
        {
          "id": "ggml-org/Kimi-VL-A3B-Thinking-2506-GGUF:Kimi-VL-A3B-Thinking-2506-Q4_K_M.gguf",
          "type": "llama_cpp_model",
          "name": "Kimi VL A3B Thinking (GGUF)",
          "repo_id": "ggml-org/Kimi-VL-A3B-Thinking-2506-GGUF",
          "path": "Kimi-VL-A3B-Thinking-2506-Q4_K_M.gguf",
          "description": "Moonshot AI's vision-language model with enhanced reasoning capabilities.",
          "size_on_disk": 2362232012,
          "tags": [
            "gguf",
            "base_model:moonshotai/Kimi-VL-A3B-Thinking-2506",
            "base_model:quantized:moonshotai/Kimi-VL-A3B-Thinking-2506",
            "endpoints_compatible",
            "region:us",
            "conversational"
          ],
          "has_model_index": false,
          "downloads": 2812,
          "likes": 25
        },
        {
          "id": "ggml-org/Qwen3-Coder-30B-A3B-Instruct-Q8_0-GGUF:qwen3-coder-30b-a3b-instruct-q8_0.gguf",
          "type": "llama_cpp_model",
          "name": "Qwen3 Coder 30B A3B (GGUF)",
          "repo_id": "ggml-org/Qwen3-Coder-30B-A3B-Instruct-Q8_0-GGUF",
          "path": "qwen3-coder-30b-a3b-instruct-q8_0.gguf",
          "description": "MoE coding model with 3B active params, excellent for code generation.",
          "size_on_disk": 3865470566,
          "pipeline_tag": "text-generation",
          "tags": [
            "transformers",
            "gguf",
            "llama-cpp",
            "gguf-my-repo",
            "text-generation",
            "base_model:Qwen/Qwen3-Coder-30B-A3B-Instruct",
            "base_model:quantized:Qwen/Qwen3-Coder-30B-A3B-Instruct",
            "license:apache-2.0",
            "endpoints_compatible",
            "region:us",
            "conversational"
          ],
          "has_model_index": false,
          "downloads": 2881,
          "likes": 7
        },
        {
          "id": "ggml-org/Qwen3-0.6B-GGUF:Qwen3-0.6B-Q4_0.gguf",
          "type": "llama_cpp_model",
          "name": "Qwen3 0.6B (GGUF)",
          "repo_id": "ggml-org/Qwen3-0.6B-GGUF",
          "path": "Qwen3-0.6B-Q4_0.gguf",
          "description": "Ultra-lightweight Qwen3 for edge devices and fast inference.",
          "size_on_disk": 429496729,
          "tags": [
            "gguf",
            "base_model:Qwen/Qwen3-0.6B",
            "base_model:quantized:Qwen/Qwen3-0.6B",
            "license:apache-2.0",
            "endpoints_compatible",
            "region:us",
            "conversational"
          ],
          "has_model_index": false,
          "downloads": 42747,
          "likes": 11
        },
        {
          "id": "ggml-org/gemma-3-270m-GGUF:gemma-3-270m-Q8_0.gguf",
          "type": "llama_cpp_model",
          "name": "Gemma 3 270M (GGUF)",
          "repo_id": "ggml-org/gemma-3-270m-GGUF",
          "path": "gemma-3-270m-Q8_0.gguf",
          "description": "Tiny Gemma 3 for ultra-fast inference on CPU.",
          "size_on_disk": 375809638,
          "tags": [
            "gguf",
            "base_model:google/gemma-3-270m",
            "base_model:quantized:google/gemma-3-270m",
            "endpoints_compatible",
            "region:us"
          ],
          "has_model_index": false,
          "downloads": 1021,
          "likes": 17
        },
        {
          "id": "ggml-org/gemma-3-27b-it-GGUF:gemma-3-27b-it-Q4_K_M.gguf",
          "type": "llama_cpp_model",
          "name": "Gemma 3 27B IT (GGUF)",
          "repo_id": "ggml-org/gemma-3-27b-it-GGUF",
          "path": "gemma-3-27b-it-Q4_K_M.gguf",
          "description": "Google's largest Gemma 3 with strong reasoning and tool use.",
          "size_on_disk": 16965120819,
          "pipeline_tag": "image-text-to-text",
          "tags": [
            "gguf",
            "image-text-to-text",
            "arxiv:1905.07830",
            "arxiv:1905.10044",
            "arxiv:1911.11641",
            "arxiv:1904.09728",
            "arxiv:1705.03551",
            "arxiv:1911.01547",
            "arxiv:1907.10641",
            "arxiv:1903.00161",
            "arxiv:2009.03300",
            "arxiv:2304.06364",
            "arxiv:2103.03874",
            "arxiv:2110.14168",
            "arxiv:2311.12022",
            "arxiv:2108.07732",
            "arxiv:2107.03374",
            "arxiv:2210.03057",
            "arxiv:2106.03193",
            "arxiv:1910.11856",
            "arxiv:2502.12404",
            "arxiv:2502.21228",
            "arxiv:2404.16816",
            "arxiv:2104.12756",
            "arxiv:2311.16502",
            "arxiv:2203.10244",
            "arxiv:2404.12390",
            "arxiv:1810.12440",
            "arxiv:1908.02660",
            "arxiv:2312.11805",
            "base_model:google/gemma-3-27b-it",
            "base_model:quantized:google/gemma-3-27b-it",
            "license:gemma",
            "endpoints_compatible",
            "region:us",
            "conversational"
          ],
          "has_model_index": false,
          "downloads": 2335,
          "likes": 23
        }
      ],
      "basic_fields": [
        "prompt",
        "model",
        "image",
        "audio"
      ],
      "is_streaming_output": true,
      "supports_dynamic_outputs": true
    },
    {
      "title": "Classifier",
      "description": "Classify text into predefined or dynamic categories using LLM.\n    classification, nlp, categorization\n\n    Use cases:\n    - Sentiment analysis\n    - Topic classification\n    - Intent detection\n    - Content categorization",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.Classifier",
      "properties": [
        {
          "name": "system_prompt",
          "type": {
            "type": "str"
          },
          "default": "\nYou are a precise classifier.\n\nGoal\n- Select exactly one category from the list provided by the user.\n\nOutput format (MANDATORY)\n- Return ONLY a single JSON object with this exact schema and nothing else:\n  {\"category\": \"<one-of-the-allowed-categories>\"}\n- No prose, no Markdown, no code fences, no explanations, no extra keys.\n\nSelection criteria\n- Choose the single best category that captures the main intent of the text.\n- If multiple categories seem plausible, pick the most probable one; do not return multiple.\n- If none fit perfectly, choose the closest allowed category. If the list includes \"Other\" or \"Unknown\", prefer it when appropriate.\n- Be robust to casing, punctuation, emojis, and minor typos. Handle negation correctly (e.g., \"not spam\" \u2260 spam).\n- Never invent categories that are not in the provided list.\n\nBehavior\n- Be deterministic for the same input.\n- Do not ask clarifying questions; make the best choice with what's given.\n",
          "title": "System Prompt",
          "description": "The system prompt for the classifier"
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": "",
            "path": null,
            "supported_tasks": []
          },
          "title": "Model",
          "description": "Model to use for classification"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to classify"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "Optional image to classify in context"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "Optional audio to classify in context"
        },
        {
          "name": "categories",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Categories",
          "description": "List of possible categories. If empty, LLM will determine categories."
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window (Ollama)",
          "min": 1.0,
          "max": 65536.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "recommended_models": [
        {
          "id": "phi3.5:latest",
          "type": "llama_model",
          "name": "Phi3.5",
          "repo_id": "phi3.5:latest",
          "description": "Reliable small model for intent and sentiment classification when VRAM is tight.",
          "size_on_disk": 2362232012
        },
        {
          "id": "mistral-small:latest",
          "type": "llama_model",
          "name": "Mistral Small",
          "repo_id": "mistral-small:latest",
          "description": "Fast MoE model that keeps category predictions consistent across batches.",
          "size_on_disk": 7730941132
        },
        {
          "id": "granite3.1-moe:1b",
          "type": "llama_model",
          "name": "Granite 3.1 MOE - 1B",
          "repo_id": "granite3.1-moe:1b",
          "description": "IBM Granite 1B excels at classification and routing tasks on CPUs and edge devices.",
          "size_on_disk": 751619276
        },
        {
          "id": "qwen3:1.7b",
          "type": "llama_model",
          "name": "Qwen3 - 1.7B",
          "repo_id": "qwen3:1.7b",
          "description": "Compact Qwen variant provides multilingual label understanding with low latency.",
          "size_on_disk": 1073741824
        },
        {
          "id": "gemma3:1b",
          "type": "llama_model",
          "name": "Gemma3 - 1B",
          "repo_id": "gemma3:1b",
          "description": "Gemma 3 1B offers deterministic small-footprint classification for mobile scenarios.",
          "size_on_disk": 805306368
        },
        {
          "id": "deepseek-r1:1.5b",
          "type": "llama_model",
          "name": "Deepseek R1 - 1.5B",
          "repo_id": "deepseek-r1:1.5b",
          "description": "Reasoning-focused DeepSeek variant is great for multi-step label decisions.",
          "size_on_disk": 912680550
        },
        {
          "id": "ggml-org/gemma-3-4b-it-GGUF:gemma-3-4b-it-Q4_K_M.gguf",
          "type": "llama_cpp_model",
          "name": "Gemma 3 4B IT (GGUF)",
          "repo_id": "ggml-org/gemma-3-4b-it-GGUF",
          "path": "gemma-3-4b-it-Q4_K_M.gguf",
          "description": "Efficient Gemma 3 for classification via llama.cpp.",
          "size_on_disk": 3113851289,
          "pipeline_tag": "image-text-to-text",
          "tags": [
            "gguf",
            "image-text-to-text",
            "arxiv:1905.07830",
            "arxiv:1905.10044",
            "arxiv:1911.11641",
            "arxiv:1904.09728",
            "arxiv:1705.03551",
            "arxiv:1911.01547",
            "arxiv:1907.10641",
            "arxiv:1903.00161",
            "arxiv:2009.03300",
            "arxiv:2304.06364",
            "arxiv:2103.03874",
            "arxiv:2110.14168",
            "arxiv:2311.12022",
            "arxiv:2108.07732",
            "arxiv:2107.03374",
            "arxiv:2210.03057",
            "arxiv:2106.03193",
            "arxiv:1910.11856",
            "arxiv:2502.12404",
            "arxiv:2502.21228",
            "arxiv:2404.16816",
            "arxiv:2104.12756",
            "arxiv:2311.16502",
            "arxiv:2203.10244",
            "arxiv:2404.12390",
            "arxiv:1810.12440",
            "arxiv:1908.02660",
            "arxiv:2312.11805",
            "base_model:google/gemma-3-4b-it",
            "base_model:quantized:google/gemma-3-4b-it",
            "license:gemma",
            "endpoints_compatible",
            "region:us",
            "conversational"
          ],
          "has_model_index": false,
          "downloads": 18924,
          "likes": 44
        }
      ],
      "basic_fields": [
        "text",
        "categories",
        "model",
        "image",
        "audio"
      ]
    },
    {
      "title": "Create Thread",
      "description": "Create a new conversation thread and return its ID.\n    threads, chat, conversation, context\n\n    Use this to seed a thread_id that downstream Agent nodes can reuse for\n    persistent history across the graph or multiple runs.",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.CreateThread",
      "properties": [
        {
          "name": "title",
          "type": {
            "type": "str",
            "optional": true
          },
          "default": "Agent Conversation",
          "title": "Title",
          "description": "Optional title for the new thread"
        },
        {
          "name": "thread_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Thread Id",
          "description": "Optional custom thread ID. If provided and owned by the user, it will be reused; otherwise a new thread is created."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "thread_id"
        }
      ],
      "basic_fields": [
        "title",
        "thread_id"
      ]
    },
    {
      "title": "Extractor",
      "description": "Extract structured data from text content using LLM providers.\n    data-extraction, structured-data, nlp, parsing\n\n    Specialized for extracting structured information:\n    - Converting unstructured text into structured data\n    - Identifying and extracting specific fields from documents\n    - Parsing text according to predefined schemas\n    - Creating structured records from natural language content",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.Extractor",
      "properties": [
        {
          "name": "system_prompt",
          "type": {
            "type": "str"
          },
          "default": "\nYou are a precise structured data extractor.\n\nGoal\n- Extract exactly the fields described in <JSON_SCHEMA> from the content in <TEXT> (and any attached media).\n\nOutput format (MANDATORY)\n- Output exactly ONE fenced code block labeled json containing ONLY the JSON object:\n\n  ```json\n  { ...single JSON object matching <JSON_SCHEMA>... }\n  ```\n\n- No additional prose before or after the block.\n\nExtraction rules\n- Use only information found in <TEXT> or attached media. Do not invent facts.\n- Preserve source values; normalize internal whitespace and trim leading/trailing spaces.\n- If a required field is missing or not explicitly stated, return the closest reasonable default consistent with its type:\n  - string: \"\"\n  - number: 0\n  - boolean: false\n  - array/object: empty value of that type (only if allowed by the schema)\n- Dates/times: prefer ISO 8601 when the schema type is string and the value represents a date/time.\n- If multiple candidates exist, choose the most precise and unambiguous one.\n\nValidation\n- Ensure the final JSON validates against <JSON_SCHEMA> exactly.\n",
          "title": "System Prompt",
          "description": "The system prompt for the data extractor"
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": "",
            "path": null,
            "supported_tasks": []
          },
          "title": "Model",
          "description": "Model to use for data extraction"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to extract data from"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "Optional image to assist extraction"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "Optional audio to assist extraction"
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window (Ollama)",
          "min": 1.0,
          "max": 65536.0
        }
      ],
      "recommended_models": [
        {
          "id": "phi3.5:latest",
          "type": "llama_model",
          "name": "Phi3.5",
          "repo_id": "phi3.5:latest",
          "description": "Small Phi variant excels at JSON-style outputs and faithful field extraction on laptops.",
          "size_on_disk": 2362232012
        },
        {
          "id": "mistral-small:latest",
          "type": "llama_model",
          "name": "Mistral Small",
          "repo_id": "mistral-small:latest",
          "description": "MoE architecture keeps structured extraction consistent while staying resource efficient.",
          "size_on_disk": 7730941132
        },
        {
          "id": "granite3.1-moe:3b",
          "type": "llama_model",
          "name": "Granite 3.1 MOE - 3B",
          "repo_id": "granite3.1-moe:3b",
          "description": "Granite MoE models are tuned for business document parsing and schema-following tasks.",
          "size_on_disk": 1717986918
        },
        {
          "id": "gemma3:4b",
          "type": "llama_model",
          "name": "Gemma3 - 4B",
          "repo_id": "gemma3:4b",
          "description": "Gemma 3 4B handles multilingual extraction and adheres to required JSON schemas.",
          "size_on_disk": 2791728742
        },
        {
          "id": "qwen2.5-coder:3b",
          "type": "llama_model",
          "name": "Qwen2.5-Coder - 3B",
          "repo_id": "qwen2.5-coder:3b",
          "description": "Code-focused Qwen variant generates precise structured outputs and respects schema rules.",
          "size_on_disk": 1932735283
        },
        {
          "id": "deepseek-r1:7b",
          "type": "llama_model",
          "name": "Deepseek R1 - 7B",
          "repo_id": "deepseek-r1:7b",
          "description": "Reasoning-oriented DeepSeek shines when extraction needs cross-field validation.",
          "size_on_disk": 4617089843
        },
        {
          "id": "ggml-org/gemma-3-4b-it-GGUF:gemma-3-4b-it-Q4_K_M.gguf",
          "type": "llama_cpp_model",
          "name": "Gemma 3 4B IT (GGUF)",
          "repo_id": "ggml-org/gemma-3-4b-it-GGUF",
          "path": "gemma-3-4b-it-Q4_K_M.gguf",
          "description": "Efficient Gemma 3 for extraction via llama.cpp.",
          "size_on_disk": 3113851289,
          "pipeline_tag": "image-text-to-text",
          "tags": [
            "gguf",
            "image-text-to-text",
            "arxiv:1905.07830",
            "arxiv:1905.10044",
            "arxiv:1911.11641",
            "arxiv:1904.09728",
            "arxiv:1705.03551",
            "arxiv:1911.01547",
            "arxiv:1907.10641",
            "arxiv:1903.00161",
            "arxiv:2009.03300",
            "arxiv:2304.06364",
            "arxiv:2103.03874",
            "arxiv:2110.14168",
            "arxiv:2311.12022",
            "arxiv:2108.07732",
            "arxiv:2107.03374",
            "arxiv:2210.03057",
            "arxiv:2106.03193",
            "arxiv:1910.11856",
            "arxiv:2502.12404",
            "arxiv:2502.21228",
            "arxiv:2404.16816",
            "arxiv:2104.12756",
            "arxiv:2311.16502",
            "arxiv:2203.10244",
            "arxiv:2404.12390",
            "arxiv:1810.12440",
            "arxiv:1908.02660",
            "arxiv:2312.11805",
            "base_model:google/gemma-3-4b-it",
            "base_model:quantized:google/gemma-3-4b-it",
            "license:gemma",
            "endpoints_compatible",
            "region:us",
            "conversational"
          ],
          "has_model_index": false,
          "downloads": 18924,
          "likes": 44
        }
      ],
      "basic_fields": [
        "text",
        "model",
        "image",
        "audio"
      ],
      "supports_dynamic_outputs": true
    },
    {
      "title": "Research Agent",
      "description": "Autonomous research agent that gathers information from the web and synthesizes findings.\n    research, web-search, data-gathering, agent, automation\n\n    Uses dynamic outputs to define the structure of research results.\n    The agent will:\n    - Search the web for relevant information\n    - Browse and extract content from web pages\n    - Organize findings in the workspace\n    - Return structured results matching your output schema\n\n    Perfect for:\n    - Market research and competitive analysis\n    - Literature reviews and fact-finding\n    - Data collection from multiple sources\n    - Automated research workflows",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.ResearchAgent",
      "properties": [
        {
          "name": "objective",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Objective",
          "description": "The research objective or question to investigate"
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": "",
            "path": null,
            "supported_tasks": []
          },
          "title": "Model",
          "description": "Model to use for research and synthesis"
        },
        {
          "name": "system_prompt",
          "type": {
            "type": "str"
          },
          "default": "You are a research assistant.\n\nGoal\n- Conduct thorough research on the given objective\n- Use tools to gather information from multiple sources\n- Write intermediate findings to the workspace for reference\n- Synthesize information into the structured output format specified\n\nTools Available\n- google_search: Search the web for information\n- browser: Navigate to URLs and extract content\n- write_file: Save research findings to files\n- read_file: Read previously saved research files\n- list_directory: List files in the workspace\n\nWorkflow\n1. Break down the research objective into specific queries\n2. Use google_search to find relevant sources\n3. Use browser to extract content from promising URLs\n4. Save important findings using write_file\n5. Synthesize all findings into the requested output format\n\nOutput Format\n- Return a structured JSON object matching the defined output schema\n- Be thorough and cite sources where appropriate\n- Ensure all required fields are populated with accurate information\n",
          "title": "System Prompt",
          "description": "System prompt guiding the agent's research behavior"
        },
        {
          "name": "tools",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tool_name"
              }
            ]
          },
          "default": [
            {
              "name": "google_search"
            },
            {
              "name": "browser"
            }
          ],
          "title": "Tools",
          "description": "Additional research tools to enable (workspace tools are always included)"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 8192,
          "title": "Max Tokens",
          "description": "Maximum tokens for agent responses",
          "min": 1.0,
          "max": 100000.0
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 8192,
          "title": "Context Window",
          "description": "Context window size",
          "min": 1.0,
          "max": 131072.0
        }
      ],
      "recommended_models": [
        {
          "id": "gpt-oss:20b",
          "type": "llama_model",
          "name": "GPT - OSS",
          "repo_id": "gpt-oss:20b",
          "description": "Open-weight GPT-4o derivative handles research workflows with tool calling.",
          "size_on_disk": 34359738368
        },
        {
          "id": "qwen3:14b",
          "type": "llama_model",
          "name": "Qwen3 - 14B",
          "repo_id": "qwen3:14b",
          "description": "Qwen3 14B provides strong tool use and synthesis for local research agents.",
          "size_on_disk": 30064771072
        },
        {
          "id": "ggml-org/gpt-oss-20b-GGUF:gpt-oss-20b-mxfp4.gguf",
          "type": "llama_cpp_model",
          "name": "GPT-OSS 20B (GGUF)",
          "repo_id": "ggml-org/gpt-oss-20b-GGUF",
          "path": "gpt-oss-20b-mxfp4.gguf",
          "description": "OpenAI's open-weight model for research via llama.cpp.",
          "size_on_disk": 9191230013,
          "tags": [
            "gguf",
            "base_model:openai/gpt-oss-20b",
            "base_model:quantized:openai/gpt-oss-20b",
            "endpoints_compatible",
            "region:us",
            "conversational"
          ],
          "has_model_index": false,
          "downloads": 94468,
          "likes": 113
        },
        {
          "id": "ggml-org/gemma-3-12b-it-GGUF:gemma-3-12b-it-Q4_K_M.gguf",
          "type": "llama_cpp_model",
          "name": "Gemma 3 12B IT (GGUF)",
          "repo_id": "ggml-org/gemma-3-12b-it-GGUF",
          "path": "gemma-3-12b-it-Q4_K_M.gguf",
          "description": "Google's Gemma 3 12B for research with strong reasoning.",
          "size_on_disk": 7838315315,
          "pipeline_tag": "image-text-to-text",
          "tags": [
            "gguf",
            "image-text-to-text",
            "arxiv:1905.07830",
            "arxiv:1905.10044",
            "arxiv:1911.11641",
            "arxiv:1904.09728",
            "arxiv:1705.03551",
            "arxiv:1911.01547",
            "arxiv:1907.10641",
            "arxiv:1903.00161",
            "arxiv:2009.03300",
            "arxiv:2304.06364",
            "arxiv:2103.03874",
            "arxiv:2110.14168",
            "arxiv:2311.12022",
            "arxiv:2108.07732",
            "arxiv:2107.03374",
            "arxiv:2210.03057",
            "arxiv:2106.03193",
            "arxiv:1910.11856",
            "arxiv:2502.12404",
            "arxiv:2502.21228",
            "arxiv:2404.16816",
            "arxiv:2104.12756",
            "arxiv:2311.16502",
            "arxiv:2203.10244",
            "arxiv:2404.12390",
            "arxiv:1810.12440",
            "arxiv:1908.02660",
            "arxiv:2312.11805",
            "base_model:google/gemma-3-12b-it",
            "base_model:quantized:google/gemma-3-12b-it",
            "license:gemma",
            "endpoints_compatible",
            "region:us",
            "conversational"
          ],
          "has_model_index": false,
          "downloads": 3037,
          "likes": 30
        }
      ],
      "basic_fields": [
        "objective",
        "model",
        "tools"
      ],
      "supports_dynamic_outputs": true
    },
    {
      "title": "Summarizer",
      "description": "Generate concise summaries of text content using LLM providers with streaming output.\n    text, summarization, nlp, content, streaming\n\n    Specialized for creating high-quality summaries with real-time streaming:\n    - Condensing long documents into key points\n    - Creating executive summaries with live output\n    - Extracting main ideas from text as they're generated\n    - Maintaining factual accuracy while reducing length",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.Summarizer",
      "properties": [
        {
          "name": "system_prompt",
          "type": {
            "type": "str"
          },
          "default": "\n        You are an expert summarizer. Your task is to create clear, accurate, and concise summaries using Markdown for structuring. \n        Follow these guidelines:\n        1. Identify and include only the most important information.\n        2. Maintain factual accuracy - do not add or modify information.\n        3. Use clear, direct language.\n        4. Aim for approximately {self.max_tokens} tokens.\n        ",
          "title": "System Prompt",
          "description": "The system prompt for the summarizer"
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": "",
            "path": null,
            "supported_tasks": []
          },
          "title": "Model",
          "description": "Model to use for summarization"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to summarize"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "Optional image to condition the summary"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "Optional audio to condition the summary"
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window (Ollama)",
          "min": 1.0,
          "max": 65536.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        }
      ],
      "recommended_models": [
        {
          "id": "phi3.5:latest",
          "type": "llama_model",
          "name": "Phi3.5",
          "repo_id": "phi3.5:latest",
          "description": "Lightweight 3.8B model tuned for crisp instruction following and compact summaries on modest hardware.",
          "size_on_disk": 2362232012
        },
        {
          "id": "mistral-small:latest",
          "type": "llama_model",
          "name": "Mistral Small",
          "repo_id": "mistral-small:latest",
          "description": "Efficient mixture-of-experts model that delivers reliable abstractive summaries with low latency.",
          "size_on_disk": 7730941132
        },
        {
          "id": "llama3.2:3b",
          "type": "llama_model",
          "name": "Llama 3.2 - 3B",
          "repo_id": "llama3.2:3b",
          "description": "Compact Llama variant that balances coverage and brevity for everyday summarization workloads.",
          "size_on_disk": 2040109465
        },
        {
          "id": "gemma3:4b",
          "type": "llama_model",
          "name": "Gemma3 - 4B",
          "repo_id": "gemma3:4b",
          "description": "Google's 4B multimodal model performs strong factual summaries while staying resource friendly.",
          "size_on_disk": 2791728742
        },
        {
          "id": "granite3.1-moe:3b",
          "type": "llama_model",
          "name": "Granite 3.1 MOE - 3B",
          "repo_id": "granite3.1-moe:3b",
          "description": "IBM Granite MoE delivers focused meeting notes and bullet summaries with minimal VRAM needs.",
          "size_on_disk": 1717986918
        },
        {
          "id": "qwen3:4b",
          "type": "llama_model",
          "name": "Qwen3 - 4B",
          "repo_id": "qwen3:4b",
          "description": "Qwen3 4B offers multilingual summarization with tight, well-structured outputs.",
          "size_on_disk": 2684354560
        },
        {
          "id": "ggml-org/gemma-3-4b-it-GGUF:gemma-3-4b-it-Q4_K_M.gguf",
          "type": "llama_cpp_model",
          "name": "Gemma 3 4B IT (GGUF)",
          "repo_id": "ggml-org/gemma-3-4b-it-GGUF",
          "path": "gemma-3-4b-it-Q4_K_M.gguf",
          "description": "Efficient Gemma 3 for summarization via llama.cpp.",
          "size_on_disk": 3113851289,
          "pipeline_tag": "image-text-to-text",
          "tags": [
            "gguf",
            "image-text-to-text",
            "arxiv:1905.07830",
            "arxiv:1905.10044",
            "arxiv:1911.11641",
            "arxiv:1904.09728",
            "arxiv:1705.03551",
            "arxiv:1911.01547",
            "arxiv:1907.10641",
            "arxiv:1903.00161",
            "arxiv:2009.03300",
            "arxiv:2304.06364",
            "arxiv:2103.03874",
            "arxiv:2110.14168",
            "arxiv:2311.12022",
            "arxiv:2108.07732",
            "arxiv:2107.03374",
            "arxiv:2210.03057",
            "arxiv:2106.03193",
            "arxiv:1910.11856",
            "arxiv:2502.12404",
            "arxiv:2502.21228",
            "arxiv:2404.16816",
            "arxiv:2104.12756",
            "arxiv:2311.16502",
            "arxiv:2203.10244",
            "arxiv:2404.12390",
            "arxiv:1810.12440",
            "arxiv:1908.02660",
            "arxiv:2312.11805",
            "base_model:google/gemma-3-4b-it",
            "base_model:quantized:google/gemma-3-4b-it",
            "license:gemma",
            "endpoints_compatible",
            "region:us",
            "conversational"
          ],
          "has_model_index": false,
          "downloads": 18924,
          "likes": 44
        }
      ],
      "basic_fields": [
        "text",
        "model",
        "image",
        "audio"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Chart Generator",
      "description": "LLM Agent to create Plotly Express charts based on natural language descriptions.\n    llm, data visualization, charts\n\n    Use cases:\n    - Generating interactive charts from natural language descriptions\n    - Creating data visualizations with minimal configuration\n    - Converting data analysis requirements into visual representations",
      "namespace": "nodetool.generators",
      "node_type": "nodetool.generators.ChartGenerator",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": "",
            "path": null,
            "supported_tasks": []
          },
          "title": "Model",
          "description": "The model to use for chart generation."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Natural language description of the desired chart"
        },
        {
          "name": "data",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Data",
          "description": "The data to visualize"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 100000.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "plotly_config"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "data",
        "model"
      ]
    },
    {
      "title": "Data Generator",
      "description": "LLM Agent to create a dataframe based on a user prompt.\n    llm, dataframe creation, data structuring\n\n    Use cases:\n    - Generating structured data from natural language descriptions\n    - Creating sample datasets for testing or demonstration\n    - Converting unstructured text into tabular format",
      "namespace": "nodetool.generators",
      "node_type": "nodetool.generators.DataGenerator",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": "",
            "path": null,
            "supported_tasks": []
          },
          "title": "Model",
          "description": "The model to use for data generation."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The user prompt"
        },
        {
          "name": "input_text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Input Text",
          "description": "The input text to be analyzed by the agent."
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 100000.0
        },
        {
          "name": "columns",
          "type": {
            "type": "record_type"
          },
          "default": {
            "type": "record_type",
            "columns": []
          },
          "title": "Columns",
          "description": "The columns to use in the dataframe."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "record"
        },
        {
          "type": {
            "type": "dataframe"
          },
          "name": "dataframe"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "index"
        }
      ],
      "basic_fields": [
        "prompt",
        "model",
        "columns"
      ],
      "is_streaming_output": true
    },
    {
      "title": "List Generator",
      "description": "LLM Agent to create a stream of strings based on a user prompt.\n    llm, text streaming\n\n    Use cases:\n    - Generating text from natural language descriptions\n    - Streaming responses from an LLM",
      "namespace": "nodetool.generators",
      "node_type": "nodetool.generators.ListGenerator",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": "",
            "path": null,
            "supported_tasks": []
          },
          "title": "Model",
          "description": "The model to use for string generation."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The user prompt"
        },
        {
          "name": "input_text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Input Text",
          "description": "The input text to be analyzed by the agent."
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 100000.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "item"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "index"
        }
      ],
      "basic_fields": [
        "prompt",
        "model"
      ],
      "is_streaming_output": true
    },
    {
      "title": "SVGGenerator",
      "description": "LLM Agent to create SVG elements based on user prompts.\n    svg, generator, vector, graphics\n\n    Use cases:\n    - Creating vector graphics from text descriptions\n    - Generating scalable illustrations\n    - Creating custom icons and diagrams",
      "namespace": "nodetool.generators",
      "node_type": "nodetool.generators.SVGGenerator",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": "",
            "path": null,
            "supported_tasks": []
          },
          "title": "Model",
          "description": "The language model to use for SVG generation."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The user prompt for SVG generation"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "Image to use for generation"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "Audio to use for generation"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 8192,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 100000.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "svg_element"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "image",
        "audio",
        "model"
      ]
    },
    {
      "title": "Structured Output Generator",
      "description": "Generate structured JSON objects from instructions using LLM providers.\n    data-generation, structured-data, json, synthesis\n\n    Specialized for creating structured information:\n    - Generating JSON that follows dynamic schemas\n    - Fabricating records from requirements and guidance\n    - Simulating sample data for downstream workflows\n    - Producing consistent structured outputs for testing",
      "namespace": "nodetool.generators",
      "node_type": "nodetool.generators.StructuredOutputGenerator",
      "properties": [
        {
          "name": "system_prompt",
          "type": {
            "type": "str"
          },
          "default": "\nYou are a structured data generator focused on JSON outputs.\n\nGoal\n- Produce a high-quality JSON object that matches <JSON_SCHEMA> using the guidance in <INSTRUCTIONS> and any supplemental <CONTEXT>.\n\nOutput format (MANDATORY)\n- Output exactly ONE fenced code block labeled json containing ONLY the JSON object:\n\n  ```json\n  { ...single JSON object matching <JSON_SCHEMA>... }\n  ```\n\n- No additional prose before or after the block.\n\nGeneration rules\n- Invent plausible, internally consistent values when not explicitly provided.\n- Honor all constraints from <JSON_SCHEMA> (types, enums, ranges, formats).\n- Prefer ISO 8601 for dates/times when applicable.\n- Ensure numbers respect reasonable magnitudes and relationships described in <INSTRUCTIONS>.\n- Avoid referencing external sources; rely solely on the provided guidance.\n\nValidation\n- Ensure the final JSON validates against <JSON_SCHEMA> exactly.\n",
          "title": "System Prompt",
          "description": "The system prompt guiding JSON generation."
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": "",
            "path": null,
            "supported_tasks": []
          },
          "title": "Model",
          "description": "Model to use for structured generation."
        },
        {
          "name": "instructions",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Instructions",
          "description": "Detailed instructions for the structured output."
        },
        {
          "name": "context",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Context",
          "description": "Optional context to ground the generation."
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 16384.0
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window (Ollama)",
          "min": 1.0,
          "max": 65536.0
        }
      ],
      "basic_fields": [
        "instructions",
        "context",
        "model"
      ],
      "supports_dynamic_outputs": true
    },
    {
      "title": "Asset Folder Input",
      "description": "Accepts an asset folder as a parameter for workflows.\n    input, parameter, folder, path, folderpath, local_folder, filesystem",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.AssetFolderInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value",
          "description": "The folder to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "folder"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Audio Input",
      "description": "Accepts a reference to an audio asset for workflows, specified by an 'AudioRef'.  An 'AudioRef' points to audio data that can be used for playback, transcription, analysis, or processing by audio-capable models.\n    input, parameter, audio, sound, voice, speech, asset\n\n    Use cases:\n    - Load an audio file for speech-to-text transcription.\n    - Analyze sound for specific events or characteristics.\n    - Provide audio input to models for tasks like voice recognition or music generation.\n    - Process audio for enhancement or feature extraction.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.AudioInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value",
          "description": "The audio to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Boolean Input",
      "description": "Accepts a boolean (true/false) value as a parameter for workflows.  This input is used for binary choices, enabling or disabling features, or controlling conditional logic paths.\n    input, parameter, boolean, bool, toggle, switch, flag\n\n    Use cases:\n    - Toggle features or settings on or off.\n    - Set binary flags to control workflow behavior.\n    - Make conditional choices within a workflow (e.g., proceed if true).",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.BooleanInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Color Input",
      "description": "Accepts a color value as a parameter for workflows.\n    input, parameter, color, color_picker, color_input",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.ColorInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": null
          },
          "title": "Value",
          "description": "The color to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "color"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Dataframe Input",
      "description": "Accepts a reference to a dataframe asset for workflows.\n    input, parameter, dataframe, table, data",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.DataframeInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Value",
          "description": "The dataframe to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Document File Input",
      "description": "Accepts a local file path pointing to a document and converts it into a 'DocumentRef'.\n    input, parameter, document, file, path, local_file, load\n\n    Use cases:\n    - Directly load a document (e.g., PDF, TXT, DOCX) from a specified local file path.\n    - Convert a local file path into a 'DocumentRef' that can be consumed by other document-processing nodes.\n    - Useful for development or workflows that have legitimate access to the local filesystem.\n    - To provide an existing 'DocumentRef', use 'DocumentInput'.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.DocumentFileInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value",
          "description": "The path to the document file.",
          "json_schema_extra": {
            "type": "file_path"
          }
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "document"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "path"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Document Input",
      "description": "Accepts a reference to a document asset for workflows, specified by a 'DocumentRef'.  A 'DocumentRef' points to a structured document (e.g., PDF, DOCX, TXT) which can be processed or analyzed. This node is used when the workflow needs to operate on a document as a whole entity, potentially including its structure and metadata, rather than just raw text.\n    input, parameter, document, file, asset, reference\n\n    Use cases:\n    - Load a specific document (e.g., PDF, Word, text file) for content extraction or analysis.\n    - Pass a document to models that are designed to process specific document formats.\n    - Manage documents as distinct assets within a workflow.\n    - If you have a local file path and need to convert it to a 'DocumentRef', consider using 'DocumentFileInput'.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.DocumentInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value",
          "description": "The document to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "File Path Input",
      "description": "Accepts a local filesystem path (to a file or directory) as input for workflows.\n    input, parameter, path, filepath, directory, local_file, filesystem\n\n    Use cases:\n    - Provide a local path to a specific file or directory for processing.\n    - Specify an input or output location on the local filesystem for a development task.\n    - Load local datasets or configuration files not managed as assets.\n    - Not available in production: raises an error if used in a production environment.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.FilePathInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value",
          "description": "The path to use as input.",
          "json_schema_extra": {
            "type": "file_path"
          }
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Float Input",
      "description": "Accepts a floating-point number as a parameter for workflows, typically constrained by a minimum and maximum value.  This input allows for precise numeric settings, such as adjustments, scores, or any value requiring decimal precision.\n    input, parameter, float, number, decimal, range\n\n    Use cases:\n    - Specify a numeric value within a defined range (e.g., 0.0 to 1.0).\n    - Set thresholds, confidence scores, or scaling factors.\n    - Configure continuous parameters like opacity, volume, or temperature.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.FloatInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        },
        {
          "name": "min",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Min"
        },
        {
          "name": "max",
          "type": {
            "type": "float"
          },
          "default": 100,
          "title": "Max"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Folder Path Input",
      "description": "Accepts a folder path as a parameter for workflows.\n    input, parameter, folder, path, folderpath, local_folder, filesystem",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.FolderPathInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value",
          "description": "The folder path to use as input.",
          "json_schema_extra": {
            "type": "folder_path"
          }
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Hugging Face Model Input",
      "description": "Accepts a Hugging Face model as a parameter for workflows.\n    input, parameter, model, huggingface, hugging_face, model_name",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.HuggingFaceModelInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "hf.model"
          },
          "default": {
            "type": "hf.model",
            "repo_id": "",
            "path": null,
            "variant": null,
            "allow_patterns": null,
            "ignore_patterns": null
          },
          "title": "Value",
          "description": "The Hugging Face model to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "hf.model"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Image Input",
      "description": "Accepts a reference to an image asset for workflows, specified by an 'ImageRef'.  An 'ImageRef' points to image data that can be used for display, analysis, or processing by vision models.\n    input, parameter, image, picture, graphic, visual, asset\n\n    Use cases:\n    - Load an image for visual processing or analysis.\n    - Provide an image as input to computer vision models (e.g., object detection, image classification).\n    - Select an image for manipulation, enhancement, or inclusion in a document.\n    - Display an image within a workflow interface.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.ImageInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value",
          "description": "The image to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Image Model Input",
      "description": "Accepts an image generation model as a parameter for workflows.\n    input, parameter, model, image, generation",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.ImageModelInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "image_model"
          },
          "default": {
            "type": "image_model",
            "provider": "empty",
            "id": "",
            "name": "",
            "path": null,
            "supported_tasks": []
          },
          "title": "Value",
          "description": "The image generation model to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image_model"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Integer Input",
      "description": "Accepts an integer (whole number) as a parameter for workflows, typically constrained by a minimum and maximum value.  This input is used for discrete numeric values like counts, indices, or iteration limits.\n    input, parameter, integer, number, count, index, whole_number\n\n    Use cases:\n    - Specify counts or quantities (e.g., number of items, iterations).\n    - Set index values for accessing elements in a list or array.\n    - Configure discrete numeric parameters like age, steps, or quantity.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.IntegerInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        },
        {
          "name": "min",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Min"
        },
        {
          "name": "max",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Max"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Language Model Input",
      "description": "Accepts a language model as a parameter for workflows.\n    input, parameter, model, language, model_name",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.LanguageModelInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": "",
            "path": null,
            "supported_tasks": []
          },
          "title": "Value",
          "description": "The language model to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "language_model"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Realtime Audio Input",
      "description": "Accepts streaming audio data for workflows.\n    input, parameter, audio, sound, voice, speech, asset",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.RealtimeAudioInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value",
          "description": "The audio to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        }
      ],
      "basic_fields": [
        "name",
        "value",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "String Input",
      "description": "Accepts a string value as a parameter for workflows.\n    input, parameter, string, text, label, name, value\n\n    Use cases:\n    - Define a name for an entity or process.\n    - Specify a label for a component or output.\n    - Enter a short keyword or search term.\n    - Provide a simple configuration value (e.g., an API key, a model name).\n    - If you need to input multi-line text or the content of a file, use 'DocumentFileInput'.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.StringInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "String List Input",
      "description": "Accepts a list of strings as a parameter for workflows.\n    input, parameter, string, text, label, name, value",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.StringListInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Value",
          "description": "The list of strings to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Video Input",
      "description": "Accepts a reference to a video asset for workflows, specified by a 'VideoRef'.  A 'VideoRef' points to video data that can be used for playback, analysis, frame extraction, or processing by video-capable models.\n    input, parameter, video, movie, clip, visual, asset\n\n    Use cases:\n    - Load a video file for processing or content analysis.\n    - Analyze video content for events, objects, or speech.\n    - Extract frames or audio tracks from a video.\n    - Provide video input to models that understand video data.",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.VideoInput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Value",
          "description": "The video to use as input."
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the input for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ]
    },
    {
      "title": "Automatic Speech Recognition",
      "description": "Transcribe audio to text using automatic speech recognition models.\n    audio, speech, recognition, transcription, ASR, whisper\n\n    Use cases:\n    - Transcribe recorded audio to text\n    - Generate subtitles from video audio\n    - Convert voice notes to written text\n    - Process meeting recordings\n    - Enable voice-based data entry",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.AutomaticSpeechRecognition",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "asr_model"
          },
          "default": {
            "type": "asr_model",
            "provider": "fal_ai",
            "id": "openai/whisper-large-v3",
            "name": "",
            "path": null
          },
          "title": "Model"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio to transcribe"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        }
      ],
      "basic_fields": [
        "model",
        "audio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Capitalize Text",
      "description": "Capitalizes only the first character.\n    text, transform, capitalize, format\n\n    Use cases:\n    - Formatting short labels or sentences\n    - Cleaning up LLM output before UI rendering\n    - Quickly fixing lowercase starts after concatenation",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.CapitalizeText",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ]
    },
    {
      "title": "Split Text into Chunks",
      "description": "Splits text into chunks of specified word length.\n    text, chunk, split\n\n    Use cases:\n    - Preparing text for processing by models with input length limits\n    - Creating manageable text segments for parallel processing\n    - Generating summaries of text sections",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Chunk",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "length",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Length",
          "min": 1.0,
          "max": 1000.0
        },
        {
          "name": "overlap",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Overlap"
        },
        {
          "name": "separator",
          "type": {
            "type": "str"
          },
          "default": " ",
          "title": "Separator"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "length",
        "overlap",
        "separator"
      ]
    },
    {
      "title": "Collapse Whitespace",
      "description": "Collapses consecutive whitespace into single separators.\n    text, whitespace, normalize, clean, remove\n\n    Use cases:\n    - Normalizing pasted text from PDFs or chat logs\n    - Cleaning prompts with erratic spacing\n    - Converting multi-line input into succinct sentences",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.CollapseWhitespace",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "preserve_newlines",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Preserve Newlines",
          "description": "Keep newline characters instead of replacing them"
        },
        {
          "name": "replacement",
          "type": {
            "type": "str"
          },
          "default": " ",
          "title": "Replacement",
          "description": "String used to replace whitespace runs"
        },
        {
          "name": "trim_edges",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Trim Edges",
          "description": "Strip whitespace before collapsing"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "preserve_newlines",
        "replacement",
        "trim_edges"
      ]
    },
    {
      "title": "Collect",
      "description": "Collects a stream of text inputs into a single concatenated string.\n    text, collect, list, stream, aggregate\n\n    Use cases:\n    - Combine multiple streaming text outputs\n    - Accumulate results from iterative processes\n    - Build composite text from multiple sources\n    - Aggregate log messages or status updates",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Collect",
      "properties": [
        {
          "name": "input_item",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Input Item"
        },
        {
          "name": "separator",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Separator"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_item",
        "separator"
      ]
    },
    {
      "title": "Compare Text",
      "description": "Compares two text values and reports ordering.\n    text, compare, equality, sort, equals, =\n\n    Use cases:\n    - Checking if two strings are identical before branching\n    - Determining lexical order for sorting or deduplication\n    - Normalizing casing/spacing before compares",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Compare",
      "properties": [
        {
          "name": "text_a",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "First Text"
        },
        {
          "name": "text_b",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Second Text"
        },
        {
          "name": "case_sensitive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Case Sensitive",
          "description": "Compare without lowercasing"
        },
        {
          "name": "trim_whitespace",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Trim Whitespace",
          "description": "Strip leading/trailing whitespace before comparing"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text_a",
        "text_b",
        "case_sensitive",
        "trim_whitespace"
      ]
    },
    {
      "title": "Concatenate Text",
      "description": "Concatenates two text inputs into a single output.\n    text, concatenation, combine, +\n\n    Use cases:\n    - Joining outputs from multiple text processing nodes\n    - Combining parts of sentences or paragraphs\n    - Merging text data from different sources",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Concat",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ]
    },
    {
      "title": "Contains Text",
      "description": "Checks if text contains a specified substring.\n    text, compare, validate, substring, string\n\n    Use cases:\n    - Ensuring safety or guard phrases appear\n    - Rejecting inputs when banned terms exist\n    - Matching multiple keywords with any/all logic",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Contains",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "substring",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Substring"
        },
        {
          "name": "search_values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Search Values",
          "description": "Optional list of additional substrings to check"
        },
        {
          "name": "case_sensitive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Case Sensitive"
        },
        {
          "name": "match_mode",
          "type": {
            "type": "enum",
            "values": [
              "any",
              "all",
              "none"
            ],
            "type_name": "nodetool.nodes.nodetool.text.Contains.MatchMode"
          },
          "default": "any",
          "title": "Match Mode",
          "description": "ANY requires one match, ALL needs every value, NONE ensures none"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "substring",
        "search_values",
        "case_sensitive",
        "match_mode"
      ]
    },
    {
      "title": "Count Tokens",
      "description": "Counts the number of tokens in text using tiktoken.\n    text, tokens, count, encoding\n\n    Use cases:\n    - Checking text length for LLM input limits\n    - Estimating API costs\n    - Managing token budgets in text processing",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.CountTokens",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "encoding",
          "type": {
            "type": "enum",
            "values": [
              "cl100k_base",
              "p50k_base",
              "r50k_base"
            ],
            "type_name": "nodetool.nodes.nodetool.text.CountTokens.TiktokenEncoding"
          },
          "default": "cl100k_base",
          "title": "Encoding",
          "description": "The tiktoken encoding to use for token counting"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "encoding"
      ]
    },
    {
      "title": "Ends With",
      "description": "Checks if text ends with a specified suffix.\n    text, check, suffix, compare, validate, substring, string\n\n    Use cases:\n    - Validating file extensions\n    - Checking string endings\n    - Filtering text based on ending content",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.EndsWith",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "suffix",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Suffix"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "suffix"
      ]
    },
    {
      "title": "Equals",
      "description": "Checks if two text inputs are equal.\n    text, compare, equals, match, =\n\n    Use cases:\n    - Branching workflows when user input matches an expected value\n    - Guarding against duplicates before saving assets\n    - Quickly comparing normalized prompts or identifiers",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Equals",
      "properties": [
        {
          "name": "text_a",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "First Text"
        },
        {
          "name": "text_b",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Second Text"
        },
        {
          "name": "case_sensitive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Case Sensitive",
          "description": "Disable lowercasing before compare"
        },
        {
          "name": "trim_whitespace",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Trim Whitespace",
          "description": "Strip leading/trailing whitespace prior to comparison"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text_a",
        "text_b",
        "case_sensitive",
        "trim_whitespace"
      ]
    },
    {
      "title": "Extract Text",
      "description": "Extracts a substring from input text.\n    text, extract, substring\n\n    Use cases:\n    - Extracting specific portions of text for analysis\n    - Trimming unwanted parts from text data\n    - Focusing on relevant sections of longer documents",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Extract",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start"
        },
        {
          "name": "end",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "End"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "start",
        "end"
      ]
    },
    {
      "title": "Extract JSON",
      "description": "Extracts data from JSON using JSONPath expressions.\n    json, extract, jsonpath\n\n    Use cases:\n    - Retrieving specific fields from complex JSON structures\n    - Filtering and transforming JSON data for analysis\n    - Extracting nested data from API responses or configurations",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.ExtractJSON",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "JSON Text"
        },
        {
          "name": "json_path",
          "type": {
            "type": "str"
          },
          "default": "$.*",
          "title": "JSONPath Expression"
        },
        {
          "name": "find_all",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Find All"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "json_path",
        "find_all"
      ]
    },
    {
      "title": "Extract Regex Groups",
      "description": "Extracts substrings matching regex groups from text.\n    text, regex, extract\n\n    Use cases:\n    - Extracting structured data (e.g., dates, emails) from unstructured text\n    - Parsing specific patterns in log files or documents\n    - Isolating relevant information from complex text formats",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.ExtractRegex",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "regex",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Regex"
        },
        {
          "name": "dotall",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Dotall"
        },
        {
          "name": "ignorecase",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Ignorecase"
        },
        {
          "name": "multiline",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Multiline"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "regex",
        "dotall",
        "ignorecase",
        "multiline"
      ]
    },
    {
      "title": "Filter Regex String",
      "description": "Filters a stream of strings using regular expressions.\n    filter, regex, pattern, text, stream\n\n    Use cases:\n    - Filter strings using complex patterns\n    - Extract strings matching specific formats (emails, dates, etc.)",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.FilterRegexString",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value",
          "description": "Input string stream"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "The regular expression pattern to match against."
        },
        {
          "name": "full_match",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Full Match",
          "description": "Whether to match the entire string or find pattern anywhere in string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value",
        "pattern",
        "full_match"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Filter String",
      "description": "Filters a stream of strings based on various criteria.\n    filter, strings, text, stream\n\n    Use cases:\n    - Filter strings by length\n    - Filter strings containing specific text\n    - Filter strings by prefix/suffix",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.FilterString",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value",
          "description": "Input string stream"
        },
        {
          "name": "filter_type",
          "type": {
            "type": "enum",
            "values": [
              "contains",
              "starts_with",
              "ends_with",
              "length_greater",
              "length_less",
              "exact_length"
            ],
            "type_name": "nodetool.nodes.nodetool.text.FilterString.FilterType"
          },
          "default": "contains",
          "title": "Filter Type",
          "description": "The type of filter to apply"
        },
        {
          "name": "criteria",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Criteria",
          "description": "The filtering criteria (text to match or length as string)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value",
        "filter_type",
        "criteria"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Find All Regex Matches",
      "description": "Finds all regex matches in text as separate substrings.\n    text, regex, find\n\n    Use cases:\n    - Identifying all occurrences of a pattern in text\n    - Extracting multiple instances of structured data\n    - Analyzing frequency and distribution of specific text patterns",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.FindAllRegex",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "regex",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Regex"
        },
        {
          "name": "dotall",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Dotall"
        },
        {
          "name": "ignorecase",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Ignorecase"
        },
        {
          "name": "multiline",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Multiline"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "regex",
        "dotall",
        "ignorecase",
        "multiline"
      ]
    },
    {
      "title": "Format Text",
      "description": "Replaces placeholders in a string with dynamic inputs using Jinja2 templating.\n    text, template, formatting\n\n    This node is dynamic and can be used to format text with dynamic properties.\n\n    Use cases:\n    - Generating personalized messages with dynamic content\n    - Creating parameterized queries or commands\n    - Formatting and filtering text output based on variable inputs\n\n    Examples:\n    - text: \"Hello, {{ name }}!\"\n    - text: \"Title: {{ title|truncate(20) }}\"\n    - text: \"Name: {{ name|upper }}\"\n\n    Available filters:\n    - truncate(length): Truncates text to given length\n    - upper: Converts text to uppercase\n    - lower: Converts text to lowercase\n    - title: Converts text to title case\n    - trim: Removes whitespace from start/end\n    - replace(old, new): Replaces substring\n    - default(value): Sets default if value is undefined\n    - first: Gets first character/item\n    - last: Gets last character/item\n    - length: Gets length of string/list\n    - sort: Sorts list\n    - join(delimiter): Joins list with delimiter",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.FormatText",
      "properties": [
        {
          "name": "template",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Template",
          "description": "\n    Examples:\n    - text: \"Hello, {{ name }}!\"\n    - text: \"Title: {{ title|truncate(20) }}\"\n    - text: \"Name: {{ name|upper }}\" \n\n    Available filters:\n    - truncate(length): Truncates text to given length\n    - upper: Converts text to uppercase\n    - lower: Converts text to lowercase\n    - title: Converts text to title case\n    - trim: Removes whitespace from start/end\n    - replace(old, new): Replaces substring\n    - default(value): Sets default if value is undefined\n    - first: Gets first character/item\n    - last: Gets last character/item\n    - length: Gets length of string/list\n    - sort: Sorts list\n    - join(delimiter): Joins list with delimiter\n"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "template"
      ],
      "is_dynamic": true
    },
    {
      "title": "Check Length",
      "description": "Checks if text length meets specified conditions.\n    text, check, length, compare, validate, whitespace, string\n\n    Use cases:\n    - Validating input length requirements\n    - Filtering text by length\n    - Checking content size constraints",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.HasLength",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "min_length",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Minimum Length"
        },
        {
          "name": "max_length",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Maximum Length"
        },
        {
          "name": "exact_length",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Exact Length"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "min_length",
        "max_length",
        "exact_length"
      ]
    },
    {
      "title": "HTML to Text",
      "description": "Converts HTML content to plain text using html2text.\n    html, convert, text, parse, extract\n\n    Use cases:\n    - Converting HTML documents to readable plain text\n    - Extracting text content from web pages\n    - Cleaning HTML markup from text data\n    - Processing HTML emails or documents",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.HtmlToText",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "HTML",
          "description": "HTML content to convert"
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base URL",
          "description": "Base URL for resolving relative links"
        },
        {
          "name": "body_width",
          "type": {
            "type": "int"
          },
          "default": 1000,
          "title": "Body Width",
          "description": "Width for text wrapping"
        },
        {
          "name": "ignore_images",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Ignore Images",
          "description": "Whether to ignore image tags"
        },
        {
          "name": "ignore_mailto_links",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Ignore Mailto Links",
          "description": "Whether to ignore mailto links"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "html",
        "base_url",
        "body_width",
        "ignore_images",
        "ignore_mailto_links"
      ]
    },
    {
      "title": "Index Of",
      "description": "Finds the position of a substring in text.\n    text, search, find, substring\n\n    Use cases:\n    - Locating markers to drive downstream slices\n    - Building quick validations before parsing\n    - Detecting repeated terms by scanning from the end",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.IndexOf",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "substring",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Substring"
        },
        {
          "name": "case_sensitive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Case Sensitive"
        },
        {
          "name": "start_index",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Index",
          "description": "Index to begin the search from",
          "min": 0.0
        },
        {
          "name": "end_index",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "End Index",
          "description": "Optional exclusive end index for the search"
        },
        {
          "name": "search_from_end",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Search From End",
          "description": "Use the last occurrence instead of the first"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "substring",
        "case_sensitive",
        "start_index",
        "end_index",
        "search_from_end"
      ]
    },
    {
      "title": "Is Empty",
      "description": "Checks if text is empty or contains only whitespace.\n    text, check, empty, compare, validate, whitespace, string\n\n    Use cases:\n    - Validating required text fields\n    - Filtering out empty content\n    - Checking for meaningful input",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.IsEmpty",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "trim_whitespace",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Trim Whitespace"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "trim_whitespace"
      ]
    },
    {
      "title": "Join",
      "description": "Joins a list of strings into a single string using a specified separator.\n    text, join, combine, +, add, concatenate\n\n    Use cases:\n    - Combining multiple text elements with a consistent delimiter\n    - Creating comma-separated lists from individual items\n    - Assembling formatted text from array elements",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Join",
      "properties": [
        {
          "name": "strings",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Strings"
        },
        {
          "name": "separator",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Separator"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "strings",
        "separator"
      ]
    },
    {
      "title": "Measure Length",
      "description": "Measures text length as characters, words, or lines.\n    text, analyze, length, count\n\n    Use cases:\n    - Quickly gating prompts by size before LLM calls\n    - Showing word or line counts in mini apps\n    - Tracking character budgets for UI copy",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Length",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "measure",
          "type": {
            "type": "enum",
            "values": [
              "characters",
              "words",
              "lines"
            ],
            "type_name": "nodetool.nodes.nodetool.text.Length.Measure"
          },
          "default": "characters",
          "title": "Measure",
          "description": "Choose whether to count characters, words, or lines"
        },
        {
          "name": "trim_whitespace",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Trim Whitespace",
          "description": "Strip whitespace before counting"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "measure",
        "trim_whitespace"
      ]
    },
    {
      "title": "Load Text Assets",
      "description": "Load text files from an asset folder.\n    load, text, file, import\n\n    Use cases:\n    - Loading multiple text files for batch processing\n    - Importing text content from a directory\n    - Processing collections of text documents",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.LoadTextAssets",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The asset folder to load the text files from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "text"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        }
      ],
      "basic_fields": [
        "folder"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Pad Text",
      "description": "Pads text to a target length.\n    text, pad, length, format\n\n    Use cases:\n    - Aligning tabular text outputs\n    - Creating fixed-width fields for legacy systems\n    - Left-padding numbers with zeros",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.PadText",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "length",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Target Length",
          "min": 0.0
        },
        {
          "name": "pad_character",
          "type": {
            "type": "str"
          },
          "default": " ",
          "title": "Pad Character",
          "description": "Single character to use for padding"
        },
        {
          "name": "direction",
          "type": {
            "type": "enum",
            "values": [
              "left",
              "right",
              "both"
            ],
            "type_name": "nodetool.nodes.nodetool.text.PadText.PadDirection"
          },
          "default": "right",
          "title": "Direction",
          "description": "Where padding should be applied"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "length",
        "pad_character",
        "direction"
      ]
    },
    {
      "title": "Parse JSON String",
      "description": "Parses a JSON string into a Python object.\n    json, parse, convert\n\n    Use cases:\n    - Converting JSON API responses for further processing\n    - Preparing structured data for analysis or storage\n    - Extracting configuration or settings from JSON files",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.ParseJSON",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "JSON string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ]
    },
    {
      "title": "Find Regex Matches",
      "description": "Find all matches of a regex pattern in text.\n    regex, search, pattern, match\n\n    Use cases:\n    - Extract specific patterns from text\n    - Validate text against patterns\n    - Find all occurrences of a pattern",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.RegexMatch",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to search in"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "Regular expression pattern"
        },
        {
          "name": "group",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Group",
          "description": "Capture group to extract (0 for full match)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "pattern",
        "group"
      ]
    },
    {
      "title": "Replace with Regex",
      "description": "Replace text matching a regex pattern.\n    regex, replace, substitute\n\n    Use cases:\n    - Clean or standardize text\n    - Remove unwanted patterns\n    - Transform text formats",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.RegexReplace",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to perform replacements on"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "Regular expression pattern"
        },
        {
          "name": "replacement",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Replacement",
          "description": "Replacement text"
        },
        {
          "name": "count",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Count",
          "description": "Maximum replacements (0 for unlimited)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "pattern",
        "replacement",
        "count"
      ]
    },
    {
      "title": "Split with Regex",
      "description": "Split text using a regex pattern as delimiter.\n    regex, split, tokenize\n\n    Use cases:\n    - Parse structured text\n    - Extract fields from formatted strings\n    - Tokenize text",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.RegexSplit",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to split"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "Regular expression pattern to split on"
        },
        {
          "name": "maxsplit",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Maxsplit",
          "description": "Maximum number of splits (0 for unlimited)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "pattern",
        "maxsplit"
      ]
    },
    {
      "title": "Validate with Regex",
      "description": "Check if text matches a regex pattern.\n    regex, validate, check\n\n    Use cases:\n    - Validate input formats (email, phone, etc)\n    - Check text structure\n    - Filter text based on patterns",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.RegexValidate",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to validate"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "Regular expression pattern"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "pattern"
      ]
    },
    {
      "title": "Remove Punctuation",
      "description": "Removes punctuation characters from text.\n    text, cleanup, punctuation, normalize\n\n    Use cases:\n    - Cleaning transcripts before keyword search\n    - Preparing identifiers for filesystem safe names\n    - Simplifying comparisons by stripping symbols",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.RemovePunctuation",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "replacement",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Replacement",
          "description": "String to insert where punctuation was removed"
        },
        {
          "name": "punctuation",
          "type": {
            "type": "str"
          },
          "default": "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~",
          "title": "Punctuation Characters",
          "description": "Characters that should be removed or replaced"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "replacement",
        "punctuation"
      ]
    },
    {
      "title": "Replace Text",
      "description": "Replaces a substring in a text with another substring.\n    text, replace, substitute\n\n    Use cases:\n    - Correcting or updating specific text patterns\n    - Sanitizing or normalizing text data\n    - Implementing simple text transformations",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Replace",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "old",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Old"
        },
        {
          "name": "new",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "New"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "old",
        "new"
      ]
    },
    {
      "title": "Save Text",
      "description": "Saves input text to a file in the assets folder.\n    text, save, file\n\n    Use cases:\n    - Persisting processed text results\n    - Creating text files for downstream nodes or external use\n    - Archiving text data within the workflow",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.SaveText",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "Name of the output folder."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d-%H-%M-%S.txt",
          "title": "Name",
          "description": "\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "text"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "folder",
        "name"
      ]
    },
    {
      "title": "Save Text File",
      "description": "Saves input text to a file in the assets folder.\n    text, save, file",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.SaveTextFile",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Path to the output folder."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d-%H-%M-%S.txt",
          "title": "Name",
          "description": "\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "text"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "folder",
        "name"
      ]
    },
    {
      "title": "Slice Text",
      "description": "Slices text using Python's slice notation (start:stop:step).\n    text, slice, substring\n\n    Use cases:\n    - Extracting specific portions of text with flexible indexing\n    - Reversing text using negative step\n    - Taking every nth character with step parameter\n\n    Examples:\n    - start=0, stop=5: first 5 characters\n    - start=-5: last 5 characters\n    - step=2: every second character\n    - step=-1: reverse the text",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Slice",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Index"
        },
        {
          "name": "stop",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Stop Index"
        },
        {
          "name": "step",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Step"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "start",
        "stop",
        "step"
      ]
    },
    {
      "title": "Slugify",
      "description": "Converts text into a slug suitable for URLs or IDs.\n    text, slug, normalize, id\n\n    Use cases:\n    - Generating workflow IDs from titles\n    - Creating asset filenames from prompts\n    - Producing URL-safe paths for mini apps",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Slugify",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "separator",
          "type": {
            "type": "str"
          },
          "default": "-",
          "title": "Separator"
        },
        {
          "name": "lowercase",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Lowercase"
        },
        {
          "name": "allow_unicode",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Allow Unicode",
          "description": "Keep unicode letters instead of converting to ASCII"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "separator",
        "lowercase",
        "allow_unicode"
      ]
    },
    {
      "title": "Split Text",
      "description": "Separates text into a list of strings based on a specified delimiter.\n    text, split, tokenize\n\n    Use cases:\n    - Parsing CSV or similar delimited data\n    - Breaking down sentences into words or phrases\n    - Extracting specific elements from structured text",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Split",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "delimiter",
          "type": {
            "type": "str"
          },
          "default": ",",
          "title": "Delimiter"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "delimiter"
      ]
    },
    {
      "title": "Starts With",
      "description": "Checks if text starts with a specified prefix.\n    text, check, prefix, compare, validate, substring, string\n\n    Use cases:\n    - Validating string prefixes\n    - Filtering text based on starting content\n    - Checking file name patterns",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.StartsWith",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "prefix",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prefix"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "prefix"
      ]
    },
    {
      "title": "Strip Accents",
      "description": "Removes accent marks while keeping base characters.\n    text, cleanup, accents, normalize\n\n    Use cases:\n    - Creating ASCII-only identifiers from user input\n    - Normalizing prompts that mix accented and plain characters\n    - Simplifying comparisons against datasets lacking accents",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.StripAccents",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "preserve_non_ascii",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Preserve Non-ASCII",
          "description": "Keep non-ASCII characters that are not accents"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "preserve_non_ascii"
      ]
    },
    {
      "title": "Surround With",
      "description": "Wraps text with the provided prefix and suffix.\n    text, format, surround, decorate\n\n    Use cases:\n    - Adding quotes or brackets before exporting values\n    - Ensuring prompts include guard rails or markup tokens\n    - Building template strings without using Format nodes",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.SurroundWith",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "prefix",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prefix"
        },
        {
          "name": "suffix",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Suffix"
        },
        {
          "name": "skip_if_wrapped",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Skip If Already Wrapped",
          "description": "Do not add duplicates if the text is already wrapped"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "prefix",
        "suffix",
        "skip_if_wrapped"
      ]
    },
    {
      "title": "Template",
      "description": "Uses Jinja2 templating to format strings with variables and filters. This node is dynamic and can be used to format text with dynamic inputs.\n    text, template, formatting, format, combine, concatenate, +, add, variable, replace, filter\n\n    Use cases:\n    - Generating personalized messages with dynamic content\n    - Creating parameterized queries or commands\n    - Formatting and filtering text output based on variable inputs\n\n    Examples:\n    - text: \"Hello, {{ name }}!\"\n    - text: \"Title: {{ title|truncate(20) }}\"\n    - text: \"Name: {{ name|upper }}\"\n\n    Available filters:\n    - truncate(length): Truncates text to given length\n    - upper: Converts text to uppercase\n    - lower: Converts text to lowercase\n    - title: Converts text to title case\n    - trim: Removes whitespace from start/end\n    - replace(old, new): Replaces substring\n    - default(value): Sets default if value is undefined\n    - first: Gets first character/item\n    - last: Gets last character/item\n    - length: Gets length of string/list\n    - sort: Sorts list\n    - join(delimiter): Joins list with delimiter",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Template",
      "properties": [
        {
          "name": "string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "String",
          "description": "\n    Examples:\n    - text: \"Hello, {{ name }}!\"\n    - text: \"Title: {{ title|truncate(20) }}\"\n    - text: \"Name: {{ name|upper }}\"\n\n    Available filters:\n    - truncate(length): Truncates text to given length\n    - upper: Converts text to uppercase\n    - lower: Converts text to lowercase\n    - title: Converts text to title case\n    - trim: Removes whitespace from start/end\n    - replace(old, new): Replaces substring\n    - default(value): Sets default if value is undefined\n    - first: Gets first character/item\n    - last: Gets last character/item\n    - length: Gets length of string/list\n    - sort: Sorts list\n    - join(delimiter): Joins list with delimiter\n"
        },
        {
          "name": "values",
          "type": {
            "type": "any"
          },
          "default": {},
          "title": "Values",
          "description": "\n        The values to replace in the string.\n        - If a string, it will be used as the format string.\n        - If a list, it will be used as the format arguments.\n        - If a dictionary, it will be used as the template variables.\n        - If an object, it will be converted to a dictionary using the object's __dict__ method.\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "string",
        "values"
      ],
      "is_dynamic": true
    },
    {
      "title": "To Lowercase",
      "description": "Converts text to lowercase.\n    text, transform, lowercase, format\n\n    Use cases:\n    - Preparing data for case-insensitive comparisons\n    - Generating lowercase filenames or IDs\n    - Normalizing prompts before hashing",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.ToLowercase",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ]
    },
    {
      "title": "To String",
      "description": "Converts any input value to its string representation.\n    text, string, convert, repr, str, cast\n\n    Use cases:\n    - Convert numbers, objects, or complex types to strings\n    - Prepare data for text output or logging\n    - Debug values by viewing their representations\n    - Standardize data types in text workflows",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.ToString",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "default": [],
          "title": "Value"
        },
        {
          "name": "mode",
          "type": {
            "type": "enum",
            "values": [
              "str",
              "repr"
            ],
            "type_name": "nodetool.nodes.nodetool.text.ToString.Mode"
          },
          "default": "str",
          "title": "Mode",
          "description": "Conversion mode: use `str(value)` or `repr(value)`."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value",
        "mode"
      ]
    },
    {
      "title": "To Title Case",
      "description": "Converts text to title case.\n    text, transform, titlecase, format\n\n    Use cases:\n    - Cleaning user provided titles before display\n    - Normalizing headings in generated documents\n    - Making list entries easier to scan",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.ToTitlecase",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ]
    },
    {
      "title": "To Uppercase",
      "description": "Converts text to uppercase.\n    text, transform, uppercase, format\n\n    Use cases:\n    - Normalizing identifiers before comparison\n    - Preparing titles that must display in all caps\n    - Converting prompts to a consistent casing convention",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.ToUppercase",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ]
    },
    {
      "title": "Trim Whitespace",
      "description": "Trims whitespace from the start and/or end of text.\n    text, whitespace, clean, remove\n\n    Use cases:\n    - Cleaning user input before validation\n    - Removing accidental spaces after concatenation\n    - Prepping prompts for exact comparisons",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.TrimWhitespace",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "trim_start",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Trim Start"
        },
        {
          "name": "trim_end",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Trim End"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "trim_start",
        "trim_end"
      ]
    },
    {
      "title": "Truncate Text",
      "description": "Truncates text to a maximum length.\n    text, truncate, length, clip\n\n    Use cases:\n    - Enforcing LLM input limits before sending prompts\n    - Creating previews in UI cards\n    - Guarding downstream systems that expect short strings",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.TruncateText",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "max_length",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Max Length",
          "min": 0.0
        },
        {
          "name": "ellipsis",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Ellipsis",
          "description": "Optional suffix appended when truncation occurs"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "max_length",
        "ellipsis"
      ]
    },
    {
      "title": "List Documents",
      "description": "List documents in a directory.\n    files, list, directory",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.ListDocuments",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "~",
          "title": "Folder",
          "description": "Directory to scan"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "*",
          "title": "Pattern",
          "description": "File pattern to match (e.g. *.txt)"
        },
        {
          "name": "recursive",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Recursive",
          "description": "Search subdirectories"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "document"
        }
      ],
      "basic_fields": [
        "folder",
        "pattern",
        "recursive"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Load Document File",
      "description": "Read a document from disk.\n    files, document, read, input, load, file",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.LoadDocumentFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the document to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Save Document File",
      "description": "Write a document to disk.\n    files, document, write, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SaveDocumentFile",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document",
          "description": "The document to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Name of the file to save. Supports strftime format codes."
        }
      ],
      "basic_fields": [
        "document",
        "folder",
        "filename"
      ]
    },
    {
      "title": "Split Document",
      "description": "Split text semantically.\n    chroma, embedding, collection, RAG, index, text, markdown, semantic",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitDocument",
      "properties": [
        {
          "name": "embed_model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "ollama",
            "id": "embeddinggemma",
            "name": "",
            "path": null,
            "supported_tasks": []
          },
          "title": "Embed Model",
          "description": "Embedding model to use"
        },
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document",
          "description": "Document ID to associate with the text content"
        },
        {
          "name": "buffer_size",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Buffer Size",
          "description": "Buffer size for semantic splitting",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "threshold",
          "type": {
            "type": "int"
          },
          "default": 95,
          "title": "Threshold",
          "description": "Breakpoint percentile threshold for semantic splitting",
          "min": 0.0,
          "max": 100.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "source_id"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "start_index"
        }
      ],
      "recommended_models": [
        {
          "id": "embeddinggemma",
          "type": "embedding_model",
          "name": "Embedding Gemma",
          "repo_id": "embeddinggemma",
          "description": "Embedding model for semantic splitting"
        },
        {
          "id": "nomic-embed-text",
          "type": "embedding_model",
          "name": "Nomic Embed Text",
          "repo_id": "nomic-embed-text",
          "description": "Embedding model for semantic splitting"
        },
        {
          "id": "mxbai-embed-large",
          "type": "embedding_model",
          "name": "MXBai Embed Large",
          "repo_id": "mxbai-embed-large",
          "description": "Embedding model for semantic splitting"
        },
        {
          "id": "bge-m3",
          "type": "embedding_model",
          "name": "BGE M3",
          "repo_id": "bge-m3",
          "description": "Embedding model for semantic splitting"
        },
        {
          "id": "all-minilm",
          "type": "embedding_model",
          "name": "All Minilm",
          "repo_id": "all-minilm",
          "description": "Embedding model for semantic splitting"
        }
      ],
      "basic_fields": [
        "embed_model",
        "document",
        "buffer_size",
        "threshold"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Split HTML",
      "description": "Split HTML content into semantic chunks based on HTML tags.\n    html, text, semantic, tags, parsing",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitHTML",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document",
          "description": "Document ID to associate with the HTML content"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "source_id"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "start_index"
        }
      ],
      "basic_fields": [
        "document"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Split JSON",
      "description": "Split JSON content into semantic chunks.\n    json, parsing, semantic, structured",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitJSON",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document",
          "description": "Document ID to associate with the JSON content"
        },
        {
          "name": "include_metadata",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Include Metadata",
          "description": "Whether to include metadata in nodes"
        },
        {
          "name": "include_prev_next_rel",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Include Prev Next Rel",
          "description": "Whether to include prev/next relationships"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "source_id"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "start_index"
        }
      ],
      "basic_fields": [
        "document",
        "include_metadata",
        "include_prev_next_rel"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Split Markdown",
      "description": "Splits markdown text by headers while preserving header hierarchy in metadata.\n    markdown, split, headers\n\n    Use cases:\n    - Splitting markdown documentation while preserving structure\n    - Processing markdown files for semantic search\n    - Creating context-aware chunks from markdown content",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitMarkdown",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document"
        },
        {
          "name": "headers_to_split_on",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tuple",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "default": [
            [
              "#",
              "Header 1"
            ],
            [
              "##",
              "Header 2"
            ],
            [
              "###",
              "Header 3"
            ]
          ],
          "title": "Headers To Split On",
          "description": "List of tuples containing (header_symbol, header_name)"
        },
        {
          "name": "strip_headers",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Strip Headers",
          "description": "Whether to remove headers from the output content"
        },
        {
          "name": "return_each_line",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Return Each Line",
          "description": "Whether to split into individual lines instead of header sections"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 1000,
          "title": "Chunk Size",
          "description": "Optional maximum chunk size for further splitting"
        },
        {
          "name": "chunk_overlap",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Chunk Overlap",
          "description": "Overlap size when using chunk_size"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "source_id"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "start_index"
        }
      ],
      "basic_fields": [
        "document",
        "headers_to_split_on",
        "strip_headers",
        "return_each_line",
        "chunk_size",
        "chunk_overlap"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Split Recursively",
      "description": "Splits text recursively using LangChain's RecursiveCharacterTextSplitter.\n    text, split, chunks\n\n    Use cases:\n    - Splitting documents while preserving semantic relationships\n    - Creating chunks for language model processing\n    - Handling text in languages with/without word boundaries",
      "namespace": "nodetool.document",
      "node_type": "nodetool.document.SplitRecursively",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 1000,
          "title": "Chunk Size",
          "description": "Maximum size of each chunk in characters"
        },
        {
          "name": "chunk_overlap",
          "type": {
            "type": "int"
          },
          "default": 200,
          "title": "Chunk Overlap",
          "description": "Number of characters to overlap between chunks"
        },
        {
          "name": "separators",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [
            "\n\n",
            "\n",
            "."
          ],
          "title": "Separators",
          "description": "List of separators to use for splitting, in order of preference"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "source_id"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "start_index"
        }
      ],
      "basic_fields": [
        "document",
        "chunk_size",
        "chunk_overlap",
        "separators"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Audio Mixer",
      "description": "Mix up to 5 audio tracks together with individual volume controls.\n    audio, mix, volume, combine, blend, layer, add, overlay\n\n    Use cases:\n    - Mix multiple audio tracks into a single output\n    - Create layered soundscapes\n    - Combine music, voice, and sound effects\n    - Adjust individual track volumes",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.AudioMixer",
      "properties": [
        {
          "name": "track1",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Track1",
          "description": "First audio track to mix."
        },
        {
          "name": "track2",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Track2",
          "description": "Second audio track to mix."
        },
        {
          "name": "track3",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Track3",
          "description": "Third audio track to mix."
        },
        {
          "name": "track4",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Track4",
          "description": "Fourth audio track to mix."
        },
        {
          "name": "track5",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Track5",
          "description": "Fifth audio track to mix."
        },
        {
          "name": "volume1",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume1",
          "description": "Volume for track 1. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "volume2",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume2",
          "description": "Volume for track 2. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "volume3",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume3",
          "description": "Volume for track 3. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "volume4",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume4",
          "description": "Volume for track 4. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "volume5",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume5",
          "description": "Volume for track 5. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "track1",
        "track2",
        "track3",
        "track4",
        "track5",
        "volume1",
        "volume2",
        "volume3",
        "volume4",
        "volume5"
      ]
    },
    {
      "title": "Audio To Numpy",
      "description": "Convert audio to numpy array for processing.\n    audio, numpy, convert, array\n\n    Use cases:\n    - Prepare audio for custom processing\n    - Convert audio for machine learning models\n    - Extract raw audio data for analysis",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.AudioToNumpy",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio to convert to numpy."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "array"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "sample_rate"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "channels"
        }
      ],
      "basic_fields": [
        "audio"
      ]
    },
    {
      "title": "Concat",
      "description": "Concatenates two audio files together.\n    audio, edit, join, +\n\n    Use cases:\n    - Combine multiple audio clips into a single file\n    - Create longer audio tracks from shorter segments",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.Concat",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "A",
          "description": "The first audio file."
        },
        {
          "name": "b",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "B",
          "description": "The second audio file."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Concat List",
      "description": "Concatenates multiple audio files together in sequence.\n    audio, edit, join, multiple, +\n\n    Use cases:\n    - Combine multiple audio clips into a single file\n    - Create longer audio tracks from multiple segments\n    - Chain multiple audio files in order",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.ConcatList",
      "properties": [
        {
          "name": "audio_files",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "audio"
              }
            ]
          },
          "default": [],
          "title": "Audio Files",
          "description": "List of audio files to concatenate in sequence."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio_files"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Convert To Array",
      "description": "Converts an audio file to a Array for further processing.\n    audio, conversion, tensor\n\n    Use cases:\n    - Prepare audio data for machine learning models\n    - Enable signal processing operations on audio\n    - Convert audio to a format suitable for spectral analysisr",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.ConvertToArray",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to convert to a tensor."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio"
      ]
    },
    {
      "title": "Create Silence",
      "description": "Creates a silent audio file with a specified duration.\n    audio, silence, empty\n\n    Use cases:\n    - Generate placeholder audio files\n    - Create audio segments for padding or spacing\n    - Add silence to the beginning or end of audio files",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.CreateSilence",
      "properties": [
        {
          "name": "duration",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Duration",
          "description": "The duration of the silence in seconds.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "duration"
      ]
    },
    {
      "title": "Fade In",
      "description": "Applies a fade-in effect to the beginning of an audio file.\n    audio, edit, transition\n\n    Use cases:\n    - Create smooth introductions to audio tracks\n    - Gradually increase volume at the start of a clip",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.FadeIn",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to apply fade-in to."
        },
        {
          "name": "duration",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Duration",
          "description": "Duration of the fade-in effect in seconds.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "duration"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Fade Out",
      "description": "Applies a fade-out effect to the end of an audio file.\n    audio, edit, transition\n\n    Use cases:\n    - Create smooth endings to audio tracks\n    - Gradually decrease volume at the end of a clip",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.FadeOut",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to apply fade-out to."
        },
        {
          "name": "duration",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Duration",
          "description": "Duration of the fade-out effect in seconds.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "duration"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Load Audio Assets",
      "description": "Load audio files from an asset folder.\n    load, audio, file, import",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.LoadAudioAssets",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The asset folder to load the audio files from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        }
      ],
      "basic_fields": [
        "folder"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Load Audio File",
      "description": "Read an audio file from disk.\n    audio, input, load, file\n\n    Use cases:\n    - Load audio for processing\n    - Import sound files for editing\n    - Read audio assets for a workflow",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.LoadAudioFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the audio file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Load Audio Folder",
      "description": "Load all audio files from a folder, optionally including subfolders.\n    audio, load, folder, files\n\n    Use cases:\n    - Batch import audio for processing\n    - Build datasets from a directory tree\n    - Iterate over audio collections",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.LoadAudioFolder",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Folder to scan for audio files"
        },
        {
          "name": "include_subdirectories",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Include Subdirectories",
          "description": "Include audio in subfolders"
        },
        {
          "name": "extensions",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [
            ".mp3",
            ".wav",
            ".flac",
            ".ogg",
            ".m4a",
            ".aac"
          ],
          "title": "Extensions",
          "description": "Audio file extensions to include"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "path"
        }
      ],
      "basic_fields": [
        "folder",
        "include_subdirectories",
        "extensions"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Mono To Stereo",
      "description": "Converts a mono audio signal to stereo.\n    audio, convert, channels\n\n    Use cases:\n    - Expand mono recordings for stereo playback systems\n    - Prepare audio for further stereo processing",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.MonoToStereo",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The mono audio file to convert."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Normalize",
      "description": "Normalizes the volume of an audio file.\n    audio, fix, dynamics, volume\n\n    Use cases:\n    - Ensure consistent volume across multiple audio files\n    - Adjust overall volume level before further processing",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.Normalize",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to normalize."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Numpy To Audio",
      "description": "Convert numpy array to audio.\n    audio, numpy, convert\n\n    Use cases:\n    - Convert processed audio data back to audio format\n    - Create audio from machine learning model outputs\n    - Generate audio from synthesized waveforms",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.NumpyToAudio",
      "properties": [
        {
          "name": "array",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Array",
          "description": "The numpy array to convert to audio."
        },
        {
          "name": "sample_rate",
          "type": {
            "type": "int"
          },
          "default": 44100,
          "title": "Sample Rate",
          "description": "Sample rate in Hz."
        },
        {
          "name": "channels",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Channels",
          "description": "Number of audio channels (1 or 2)."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "array",
        "sample_rate",
        "channels"
      ]
    },
    {
      "title": "Overlay Audio",
      "description": "Overlays two audio files together.\n    audio, edit, transform\n\n    Use cases:\n    - Mix background music with voice recording\n    - Layer sound effects over an existing audio track",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.OverlayAudio",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "A",
          "description": "The first audio file."
        },
        {
          "name": "b",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "B",
          "description": "The second audio file."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Remove Silence",
      "description": "Removes or shortens silence in an audio file with smooth transitions.\n    audio, edit, clean\n\n    Use cases:\n    - Trim silent parts from beginning/end of recordings\n    - Remove or shorten long pauses between speech segments\n    - Apply crossfade for smooth transitions",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.RemoveSilence",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to process."
        },
        {
          "name": "min_length",
          "type": {
            "type": "int"
          },
          "default": 200,
          "title": "Min Length",
          "description": "Minimum length of silence to be processed (in milliseconds).",
          "min": 0.0,
          "max": 10000.0
        },
        {
          "name": "threshold",
          "type": {
            "type": "int"
          },
          "default": -40,
          "title": "Threshold",
          "description": "Silence threshold in dB (relative to full scale). Higher values detect more silence.",
          "min": -60.0,
          "max": 0.0
        },
        {
          "name": "reduction_factor",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Reduction Factor",
          "description": "Factor to reduce silent parts (0.0 to 1.0). 0.0 keeps silence as is, 1.0 removes it completely.",
          "min": 0.0,
          "max": 1.0
        },
        {
          "name": "crossfade",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Crossfade",
          "description": "Duration of crossfade in milliseconds to apply between segments for smooth transitions.",
          "min": 0.0,
          "max": 50.0
        },
        {
          "name": "min_silence_between_parts",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Min Silence Between Parts",
          "description": "Minimum silence duration in milliseconds to maintain between non-silent segments",
          "min": 0.0,
          "max": 500.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "min_length",
        "threshold",
        "reduction_factor",
        "crossfade",
        "min_silence_between_parts"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Repeat",
      "description": "Loops an audio file a specified number of times.\n    audio, edit, repeat\n\n    Use cases:\n    - Create repeating background sounds or music\n    - Extend short audio clips to fill longer durations\n    - Generate rhythmic patterns from short samples",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.Repeat",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to loop."
        },
        {
          "name": "loops",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Loops",
          "description": "Number of times to loop the audio. Minimum 1 (plays once), maximum 100.",
          "min": 1.0,
          "max": 100.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "loops"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Reverse",
      "description": "Reverses an audio file.\n    audio, edit, transform\n\n    Use cases:\n    - Create reverse audio effects\n    - Generate backwards speech or music",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.Reverse",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to reverse."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Save Audio Asset",
      "description": "Save an audio file to a specified asset folder.\n    audio, folder, name\n\n    Use cases:\n    - Save generated audio files with timestamps\n    - Organize outputs into specific folders\n    - Create backups of generated audio",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.SaveAudio",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The asset folder to save the audio file to. "
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d-%H-%M-%S.opus",
          "title": "Name",
          "description": "\n        The name of the audio file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "folder",
        "name"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Save Audio File",
      "description": "Write an audio file to disk.\n    audio, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.SaveAudioFile",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "\n        Name of the file to save.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "folder",
        "filename"
      ]
    },
    {
      "title": "Slice Audio",
      "description": "Extracts a section of an audio file.\n    audio, edit, trim\n\n    Use cases:\n    - Cut out a specific clip from a longer audio file\n    - Remove unwanted portions from beginning or end",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.SliceAudio",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file."
        },
        {
          "name": "start",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Start",
          "description": "The start time in seconds.",
          "min": 0.0
        },
        {
          "name": "end",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "End",
          "description": "The end time in seconds.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "start",
        "end"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Stereo To Mono",
      "description": "Converts a stereo audio signal to mono.\n    audio, convert, channels\n\n    Use cases:\n    - Reduce file size for mono-only applications\n    - Simplify audio for certain processing tasks",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.StereoToMono",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The stereo audio file to convert."
        },
        {
          "name": "method",
          "type": {
            "type": "str"
          },
          "default": "average",
          "title": "Method",
          "description": "Method to use for conversion: 'average', 'left', or 'right'."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "method"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Text To Speech",
      "description": "Generate speech audio from text using any supported TTS provider.\n    Automatically routes to the appropriate backend (OpenAI, HuggingFace, MLX).\n    audio, generation, AI, text-to-speech, tts, voice\n\n    Use cases:\n    - Create voiceovers for videos and presentations\n    - Generate natural-sounding narration for content\n    - Build voice assistants and chatbots\n    - Convert written content to audio format\n    - Create accessible audio versions of text",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.TextToSpeech",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "tts_model"
          },
          "default": {
            "type": "tts_model",
            "provider": "openai",
            "id": "tts-1",
            "name": "TTS 1",
            "path": null,
            "voices": [
              "alloy",
              "echo",
              "fable",
              "onyx",
              "nova",
              "shimmer"
            ],
            "selected_voice": ""
          },
          "title": "Model",
          "description": "The text-to-speech model to use"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "Hello! This is a text-to-speech demonstration.",
          "title": "Text",
          "description": "Text to convert to speech"
        },
        {
          "name": "speed",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Speed",
          "description": "Speech speed multiplier (0.25 to 4.0)",
          "min": 0.25,
          "max": 4.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        },
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        }
      ],
      "basic_fields": [
        "model",
        "text",
        "voice",
        "speed"
      ],
      "is_streaming_output": true,
      "expose_as_tool": true
    },
    {
      "title": "Trim",
      "description": "Trim an audio file to a specified duration.\n    audio, trim, cut\n\n    Use cases:\n    - Remove silence from the beginning or end of audio files\n    - Extract specific segments from audio files\n    - Prepare audio data for machine learning models",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.Trim",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to trim."
        },
        {
          "name": "start",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Start",
          "description": "The start time of the trimmed audio in seconds.",
          "min": 0.0
        },
        {
          "name": "end",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "End",
          "description": "The end time of the trimmed audio in seconds.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "start",
        "end"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Audio",
      "description": "Represents an audio file constant in the workflow.\n    audio, file, mp3, wav\n\n    Use cases:\n    - Provide a fixed audio input for audio processing nodes\n    - Reference a specific audio file in the workflow\n    - Set default audio for testing or demonstration purposes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Audio",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Bool",
      "description": "Represents a boolean constant in the workflow.\n    boolean, logic, flag\n\n    Use cases:\n    - Control flow decisions in conditional nodes\n    - Toggle features or behaviors in the workflow\n    - Set default boolean values for configuration",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Bool",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Constant",
      "description": "Base class for fixed-value nodes.\n\n    constant, parameter, default\n\n    Use cases:\n    - Provide static inputs to a workflow\n    - Hold configuration values\n    - Simplify testing with deterministic outputs",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Constant"
    },
    {
      "title": "Data Frame",
      "description": "Represents a fixed DataFrame constant in the workflow.\n    table, data, dataframe, pandas\n\n    Use cases:\n    - Provide static data for analysis or processing\n    - Define lookup tables or reference data\n    - Set sample data for testing or demonstration",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.DataFrame",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "DataFrame"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Date",
      "description": "Make a date object from year, month, day.\n    date, make, create",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Date",
      "properties": [
        {
          "name": "year",
          "type": {
            "type": "int"
          },
          "default": 1900,
          "title": "Year",
          "description": "Year of the date"
        },
        {
          "name": "month",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Month",
          "description": "Month of the date"
        },
        {
          "name": "day",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Day",
          "description": "Day of the date"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "date"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "year",
        "month",
        "day"
      ]
    },
    {
      "title": "Date Time",
      "description": "Make a datetime object from year, month, day, hour, minute, second.\n    datetime, make, create",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.DateTime",
      "properties": [
        {
          "name": "year",
          "type": {
            "type": "int"
          },
          "default": 1900,
          "title": "Year",
          "description": "Year of the datetime"
        },
        {
          "name": "month",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Month",
          "description": "Month of the datetime"
        },
        {
          "name": "day",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Day",
          "description": "Day of the datetime"
        },
        {
          "name": "hour",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Hour",
          "description": "Hour of the datetime"
        },
        {
          "name": "minute",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Minute",
          "description": "Minute of the datetime"
        },
        {
          "name": "second",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Second",
          "description": "Second of the datetime"
        },
        {
          "name": "microsecond",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Microsecond",
          "description": "Microsecond of the datetime"
        },
        {
          "name": "tzinfo",
          "type": {
            "type": "str"
          },
          "default": "UTC",
          "title": "Tzinfo",
          "description": "Timezone of the datetime"
        },
        {
          "name": "utc_offset",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Utc Offset",
          "description": "UTC offset of the datetime"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "year",
        "month",
        "day",
        "hour",
        "minute",
        "second",
        "microsecond",
        "tzinfo",
        "utc_offset"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Dict",
      "description": "Represents a dictionary constant in the workflow.\n    dictionary, key-value, mapping\n\n    Use cases:\n    - Store configuration settings\n    - Provide structured data inputs\n    - Define parameter sets for other nodes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Dict",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Document",
      "description": "Represents a document constant in the workflow.\n    document, pdf, word, docx",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Document",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Float",
      "description": "Represents a floating-point number constant in the workflow.\n    number, decimal, float\n\n    Use cases:\n    - Set numerical parameters for calculations\n    - Define thresholds or limits\n    - Provide fixed numerical inputs for processing",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Float",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "Image",
      "description": "Represents an image file constant in the workflow.\n    picture, photo, image\n\n    Use cases:\n    - Provide a fixed image input for image processing nodes\n    - Reference a specific image file in the workflow\n    - Set default image for testing or demonstration purposes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Image",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Integer",
      "description": "Represents an integer constant in the workflow.\n    number, integer, whole\n\n    Use cases:\n    - Set numerical parameters for calculations\n    - Define counts, indices, or sizes\n    - Provide fixed numerical inputs for processing",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Integer",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "JSON",
      "description": "Represents a JSON constant in the workflow.\n    json, object, dictionary",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.JSON",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "json"
          },
          "default": {
            "type": "json",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "json"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "List",
      "description": "Represents a list constant in the workflow.\n    array, sequence, collection\n\n    Use cases:\n    - Store multiple values of the same type\n    - Provide ordered data inputs\n    - Define sequences for iteration in other nodes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.List",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "String",
      "description": "Represents a string constant in the workflow.\n    text, string, characters\n\n    Use cases:\n    - Provide fixed text inputs for processing\n    - Define labels, identifiers, or names\n    - Set default text values for configuration",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.String",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "Video",
      "description": "Represents a video file constant in the workflow.\n    video, movie, mp4, file\n\n    Use cases:\n    - Provide a fixed video input for video processing nodes\n    - Reference a specific video file in the workflow\n    - Set default video for testing or demonstration purposes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Video",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Copy Workspace File",
      "description": "Copy a file within the workspace.\n    workspace, file, copy, duplicate\n\n    Use cases:\n    - Create file backups in workspace\n    - Duplicate files for different processing\n    - Copy files to subdirectories",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.CopyWorkspaceFile",
      "properties": [
        {
          "name": "source",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Source",
          "description": "Relative source path within workspace"
        },
        {
          "name": "destination",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Destination",
          "description": "Relative destination path within workspace"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "source",
        "destination"
      ]
    },
    {
      "title": "Create Workspace Directory",
      "description": "Create a directory in the workspace.\n    workspace, directory, create, folder\n\n    Use cases:\n    - Organize workspace files into directories\n    - Create output directories for generated files\n    - Set up workspace structure",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.CreateWorkspaceDirectory",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path to directory within workspace"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Delete Workspace File",
      "description": "Delete a file or directory from the workspace.\n    workspace, file, delete, remove\n\n    Use cases:\n    - Clean up temporary files\n    - Remove processed files\n    - Clear workspace data",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.DeleteWorkspaceFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path to file or directory within workspace"
        },
        {
          "name": "recursive",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Recursive",
          "description": "Delete directories recursively"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "none"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path",
        "recursive"
      ]
    },
    {
      "title": "Get Workspace Dir",
      "description": "Get the current workspace directory path.\n    workspace, directory, path\n\n    Use cases:\n    - Get the workspace path for reference\n    - Display workspace location\n    - Pass workspace path to other nodes",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.GetWorkspaceDir",
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ]
    },
    {
      "title": "Get Workspace File Info",
      "description": "Get information about a file in the workspace.\n    workspace, file, info, metadata\n\n    Use cases:\n    - Get file size and timestamps\n    - Check file type (file vs directory)\n    - Inspect file metadata",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.GetWorkspaceFileInfo",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path to file within workspace"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Get Workspace File Size",
      "description": "Get file size in bytes for a workspace file.\n    workspace, file, size, bytes\n\n    Use cases:\n    - Check file size before processing\n    - Monitor generated file sizes\n    - Validate file completeness",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.GetWorkspaceFileSize",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path to file within workspace"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Is Workspace Directory",
      "description": "Check if a path in the workspace is a directory.\n    workspace, directory, check, type\n\n    Use cases:\n    - Distinguish directories from files\n    - Validate directory paths\n    - Filter paths by type",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.IsWorkspaceDirectory",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path within workspace to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Is Workspace File",
      "description": "Check if a path in the workspace is a file.\n    workspace, file, check, type\n\n    Use cases:\n    - Distinguish files from directories\n    - Validate file types\n    - Filter paths by type",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.IsWorkspaceFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path within workspace to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Join Workspace Paths",
      "description": "Join path components relative to workspace.\n    workspace, path, join, combine\n\n    Use cases:\n    - Build file paths within workspace\n    - Construct nested paths\n    - Create organized file structures",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.JoinWorkspacePaths",
      "properties": [
        {
          "name": "paths",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Paths",
          "description": "Path components to join (relative to workspace)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "paths"
      ]
    },
    {
      "title": "List Workspace Files",
      "description": "List files in the workspace directory matching a pattern.\n    workspace, files, list, directory\n\n    Use cases:\n    - Get files for batch processing within workspace\n    - Filter workspace files by extension or pattern\n    - Discover generated files in workspace",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.ListWorkspaceFiles",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": ".",
          "title": "Path",
          "description": "Relative path within workspace (use . for workspace root)"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "*",
          "title": "Pattern",
          "description": "File pattern to match (e.g. *.txt, *.json)"
        },
        {
          "name": "recursive",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Recursive",
          "description": "Search subdirectories recursively"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "file"
        }
      ],
      "basic_fields": [
        "path",
        "pattern",
        "recursive"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Move Workspace File",
      "description": "Move or rename a file within the workspace.\n    workspace, file, move, rename\n\n    Use cases:\n    - Rename files in workspace\n    - Move files to subdirectories\n    - Reorganize workspace files",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.MoveWorkspaceFile",
      "properties": [
        {
          "name": "source",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Source",
          "description": "Relative source path within workspace"
        },
        {
          "name": "destination",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Destination",
          "description": "Relative destination path within workspace"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "source",
        "destination"
      ]
    },
    {
      "title": "Read Binary File",
      "description": "Read a binary file from the workspace as base64-encoded string.\n    workspace, file, read, binary\n\n    Use cases:\n    - Read generated binary data\n    - Load binary files for processing\n    - Access non-text files",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.ReadBinaryFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path to file within workspace"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Read Text File",
      "description": "Read a text file from the workspace.\n    workspace, file, read, text\n\n    Use cases:\n    - Read configuration files\n    - Load text data generated by previous nodes\n    - Process text files in workspace",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.ReadTextFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path to file within workspace"
        },
        {
          "name": "encoding",
          "type": {
            "type": "str"
          },
          "default": "utf-8",
          "title": "Encoding",
          "description": "Text encoding (utf-8, ascii, etc.)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path",
        "encoding"
      ]
    },
    {
      "title": "Save Image File",
      "description": "Save an image to a file in the workspace.\n    workspace, image, save, file, output\n\n    Use cases:\n    - Save processed images to workspace\n    - Export edited photos\n    - Archive image results",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.SaveImageFile",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": ".",
          "title": "Folder",
          "description": "Relative folder path within workspace (use . for workspace root)"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "image.png",
          "title": "Filename",
          "description": "\n        The name of the image file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        },
        {
          "name": "overwrite",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Overwrite",
          "description": "Overwrite the file if it already exists, otherwise file will be renamed"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "folder",
        "filename",
        "overwrite"
      ]
    },
    {
      "title": "Save Video File",
      "description": "Save a video file to the workspace.\n    workspace, video, save, file, output\n\n    Use cases:\n    - Save processed videos to workspace\n    - Export video results\n    - Archive video content\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.SaveVideoFile",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The video to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": ".",
          "title": "Folder",
          "description": "Relative folder path within workspace (use . for workspace root)"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "video.mp4",
          "title": "Filename",
          "description": "\n        Name of the file to save.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        },
        {
          "name": "overwrite",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Overwrite",
          "description": "Overwrite the file if it already exists, otherwise file will be renamed"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "folder",
        "filename",
        "overwrite"
      ]
    },
    {
      "title": "Workspace File Exists",
      "description": "Check if a file or directory exists in the workspace.\n    workspace, file, exists, check\n\n    Use cases:\n    - Validate file presence before processing\n    - Implement conditional logic based on file existence\n    - Check for generated files",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.WorkspaceFileExists",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path within workspace to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Write Binary File",
      "description": "Write binary data (base64-encoded) to a file in the workspace.\n    workspace, file, write, binary, save\n\n    Use cases:\n    - Save binary data to workspace\n    - Write decoded base64 data\n    - Export binary results",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.WriteBinaryFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path to file within workspace"
        },
        {
          "name": "content",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Content",
          "description": "Base64-encoded binary content to write"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path",
        "content"
      ]
    },
    {
      "title": "Write Text File",
      "description": "Write text to a file in the workspace.\n    workspace, file, write, text, save\n\n    Use cases:\n    - Save generated text to workspace\n    - Create configuration files\n    - Export processed text data",
      "namespace": "nodetool.workspace",
      "node_type": "nodetool.workspace.WriteTextFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Relative path to file within workspace"
        },
        {
          "name": "content",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Content",
          "description": "Text content to write"
        },
        {
          "name": "encoding",
          "type": {
            "type": "str"
          },
          "default": "utf-8",
          "title": "Encoding",
          "description": "Text encoding (utf-8, ascii, etc.)"
        },
        {
          "name": "append",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Append",
          "description": "Append to file instead of overwriting"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path",
        "content",
        "encoding",
        "append"
      ]
    },
    {
      "title": "Arg Max",
      "description": "Returns the label associated with the highest value in a dictionary.\n    dictionary, maximum, label, argmax\n\n    Use cases:\n    - Get the most likely class from classification probabilities\n    - Find the category with highest score\n    - Identify the winner in a voting/ranking system",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.ArgMax",
      "layout": "small",
      "properties": [
        {
          "name": "scores",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": {},
          "title": "Scores",
          "description": "Dictionary mapping labels to their corresponding scores/values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "scores"
      ]
    },
    {
      "title": "Combine",
      "description": "Merges two dictionaries, with second dictionary values taking precedence.\n    dictionary, merge, update, +, add, concatenate\n\n    Use cases:\n    - Combine default and custom configurations\n    - Merge partial updates with existing data\n    - Create aggregate data structures",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Combine",
      "layout": "small",
      "properties": [
        {
          "name": "dict_a",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dict A"
        },
        {
          "name": "dict_b",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dict B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dict_a",
        "dict_b"
      ]
    },
    {
      "title": "Filter",
      "description": "Creates a new dictionary with only specified keys from the input.\n    dictionary, filter, select\n\n    Use cases:\n    - Extract relevant fields from a larger data structure\n    - Implement data access controls\n    - Prepare specific data subsets for processing",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Filter",
      "properties": [
        {
          "name": "dictionary",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dictionary"
        },
        {
          "name": "keys",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Keys"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dictionary",
        "keys"
      ]
    },
    {
      "title": "Filter Dict By Number",
      "description": "Filters a stream of dictionaries based on numeric values for a specified key.\n    filter, dictionary, numbers, numeric, stream\n\n    Use cases:\n    - Filter dictionaries by numeric comparisons (greater than, less than, equal to)\n    - Filter records with even/odd numeric values",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.FilterDictByNumber",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Value",
          "description": "Input dictionary stream"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key",
          "description": "The dictionary key to check"
        },
        {
          "name": "filter_type",
          "type": {
            "type": "enum",
            "values": [
              "greater_than",
              "less_than",
              "equal_to",
              "even",
              "odd",
              "positive",
              "negative"
            ],
            "type_name": "nodetool.nodes.nodetool.dictionary.FilterDictByNumber.FilterDictNumberType"
          },
          "default": "greater_than",
          "title": "Filter Type"
        },
        {
          "name": "compare_value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Compare Value",
          "description": "Comparison value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value",
        "key",
        "filter_type",
        "compare_value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Filter Dict By Query",
      "description": "Filter a stream of dictionary objects based on a pandas query condition.\n    filter, query, condition, dictionary, stream\n\n    Basic Operators:\n    - Comparison: >, <, >=, <=, ==, !=\n    - Logical: and, or, not\n    - Membership: in, not in\n\n    Use cases:\n    - Filter dictionary objects based on complex criteria\n    - Extract subset of data meeting specific conditions",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.FilterDictByQuery",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Value",
          "description": "Input dictionary stream"
        },
        {
          "name": "condition",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Condition",
          "description": "The filtering condition using pandas query syntax."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value",
        "condition"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Filter Dict By Range",
      "description": "Filters a stream of dictionaries based on a numeric range for a specified key.\n    filter, dictionary, range, between, stream\n\n    Use cases:\n    - Filter records based on numeric ranges (e.g., price range, age range)\n    - Find entries with values within specified bounds",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.FilterDictByRange",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Value",
          "description": "Input dictionary stream"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key",
          "description": "The dictionary key to check for the range"
        },
        {
          "name": "min_value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Min Value",
          "description": "The minimum value (inclusive) of the range"
        },
        {
          "name": "max_value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Max Value",
          "description": "The maximum value (inclusive) of the range"
        },
        {
          "name": "inclusive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Inclusive",
          "description": "If True, includes the min and max values in the results"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value",
        "key",
        "min_value",
        "max_value",
        "inclusive"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Filter Dict By Value",
      "description": "Filters a stream of dictionaries based on their values using various criteria.\n    filter, dictionary, values, stream\n\n    Use cases:\n    - Filter dictionaries by value content\n    - Filter dictionaries by value type\n    - Filter dictionaries by value patterns",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.FilterDictByValue",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Value",
          "description": "Input dictionary stream"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key",
          "description": "The dictionary key to check"
        },
        {
          "name": "filter_type",
          "type": {
            "type": "enum",
            "values": [
              "contains",
              "starts_with",
              "ends_with",
              "equals",
              "type_is",
              "length_greater",
              "length_less",
              "exact_length"
            ],
            "type_name": "nodetool.nodes.nodetool.dictionary.FilterDictByValue.FilterType"
          },
          "default": "contains",
          "title": "Filter Type",
          "description": "The type of filter to apply"
        },
        {
          "name": "criteria",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Criteria",
          "description": "The filtering criteria (text to match, type name, or length as string)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value",
        "key",
        "filter_type",
        "criteria"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Filter Dict Regex",
      "description": "Filters a stream of dictionaries using regular expressions on specified keys.\n    filter, regex, dictionary, pattern, stream\n\n    Use cases:\n    - Filter dictionaries with values matching complex patterns\n    - Search for dictionaries containing emails, dates, or specific formats",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.FilterDictRegex",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Value",
          "description": "Input dictionary stream"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key",
          "description": "The dictionary key to check"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "The regex pattern"
        },
        {
          "name": "full_match",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Full Match",
          "description": "Full match or partial"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value",
        "key",
        "pattern",
        "full_match"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Get Value",
      "description": "Retrieves a value from a dictionary using a specified key.\n    dictionary, get, value, key\n\n    Use cases:\n    - Access a specific item in a configuration dictionary\n    - Retrieve a value from a parsed JSON object\n    - Extract a particular field from a data structure",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.GetValue",
      "layout": "small",
      "properties": [
        {
          "name": "dictionary",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dictionary"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key"
        },
        {
          "name": "default",
          "type": {
            "type": "any"
          },
          "default": [],
          "title": "Default"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dictionary",
        "key",
        "default"
      ]
    },
    {
      "title": "Load CSVFile",
      "description": "Read a CSV file from disk.\n    files, csv, read, input, load, file",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.LoadCSVFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the CSV file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Make Dictionary",
      "description": "Creates a simple dictionary with up to three key-value pairs.\n    dictionary, create, simple\n\n    Use cases:\n    - Create configuration entries\n    - Initialize simple data structures\n    - Build basic key-value mappings",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.MakeDictionary",
      "layout": "small",
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "is_dynamic": true
    },
    {
      "title": "Parse JSON",
      "description": "Parses a JSON string into a Python dictionary.\n    json, parse, dictionary\n\n    Use cases:\n    - Process API responses\n    - Load configuration files\n    - Deserialize stored data",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.ParseJSON",
      "layout": "small",
      "properties": [
        {
          "name": "json_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Json String"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "json_string"
      ]
    },
    {
      "title": "Reduce Dictionaries",
      "description": "Reduces a list of dictionaries into one dictionary based on a specified key field.\n    dictionary, reduce, aggregate\n\n    Use cases:\n    - Aggregate data by a specific field\n    - Create summary dictionaries from list of records\n    - Combine multiple data points into a single structure",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.ReduceDictionaries",
      "properties": [
        {
          "name": "dictionaries",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Dictionaries",
          "description": "List of dictionaries to be reduced"
        },
        {
          "name": "key_field",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key Field",
          "description": "The field to use as the key in the resulting dictionary"
        },
        {
          "name": "value_field",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value Field",
          "description": "Optional field to use as the value. If not specified, the entire dictionary (minus the key field) will be used as the value."
        },
        {
          "name": "conflict_resolution",
          "type": {
            "type": "enum",
            "values": [
              "first",
              "last",
              "error"
            ],
            "type_name": "nodetool.nodes.nodetool.dictionary.ReduceDictionaries.ConflictResolution"
          },
          "default": "first",
          "title": "Conflict Resolution",
          "description": "How to handle conflicts when the same key appears multiple times"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "any"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dictionaries",
        "key_field",
        "value_field",
        "conflict_resolution"
      ]
    },
    {
      "title": "Remove",
      "description": "Removes a key-value pair from a dictionary.\n    dictionary, remove, delete\n\n    Use cases:\n    - Delete a specific configuration option\n    - Remove sensitive information before processing\n    - Clean up temporary entries in a data structure",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Remove",
      "layout": "small",
      "properties": [
        {
          "name": "dictionary",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dictionary"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dictionary",
        "key"
      ]
    },
    {
      "title": "Save CSVFile",
      "description": "Write a list of dictionaries to a CSV file.\n    files, csv, write, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.SaveCSVFile",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Data",
          "description": "list of dictionaries to write to CSV"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Name of the CSV file to save. Supports strftime format codes."
        }
      ],
      "basic_fields": [
        "data",
        "folder",
        "filename"
      ]
    },
    {
      "title": "Update",
      "description": "Updates a dictionary with new key-value pairs.\n    dictionary, add, update\n\n    Use cases:\n    - Extend a configuration with additional settings\n    - Add new entries to a cache or lookup table\n    - Merge user input with existing data",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Update",
      "layout": "small",
      "properties": [
        {
          "name": "dictionary",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dictionary"
        },
        {
          "name": "new_pairs",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "New Pairs"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dictionary",
        "new_pairs"
      ]
    },
    {
      "title": "Zip",
      "description": "Creates a dictionary from parallel lists of keys and values.\n    dictionary, create, zip\n\n    Use cases:\n    - Convert separate data columns into key-value pairs\n    - Create lookups from parallel data structures\n    - Transform list data into associative arrays",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Zip",
      "layout": "small",
      "properties": [
        {
          "name": "keys",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Keys"
        },
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "any"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "keys",
        "values"
      ]
    },
    {
      "title": "Add Audio",
      "description": "Add an audio track to a video, replacing or mixing with existing audio.\n    video, audio, soundtrack, merge\n\n    Use cases:\n    1. Add background music or narration to a silent video\n    2. Replace original audio with a new soundtrack\n    3. Mix new audio with existing video sound",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.AddAudio",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to add audio to."
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to add to the video."
        },
        {
          "name": "volume",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume",
          "description": "Volume adjustment for the added audio. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "mix",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Mix",
          "description": "If True, mix new audio with existing. If False, replace existing audio."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "audio",
        "volume",
        "mix"
      ]
    },
    {
      "title": "Add Subtitles",
      "description": "Add subtitles to a video.\n    video, subtitles, text, caption\n\n    Use cases:\n    1. Add translations or closed captions to videos\n    2. Include explanatory text or commentary in educational videos\n    3. Create lyric videos for music content",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.AddSubtitles",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to add subtitles to."
        },
        {
          "name": "chunks",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "audio_chunk"
              }
            ]
          },
          "default": [],
          "title": "Chunks",
          "description": "Audio chunks to add as subtitles."
        },
        {
          "name": "font",
          "type": {
            "type": "font"
          },
          "default": {
            "type": "font",
            "name": ""
          },
          "title": "Font",
          "description": "The font to use."
        },
        {
          "name": "align",
          "type": {
            "type": "enum",
            "values": [
              "top",
              "center",
              "bottom"
            ],
            "type_name": "nodetool.nodes.nodetool.video.AddSubtitles.SubtitleTextAlignment"
          },
          "default": "bottom",
          "title": "Align",
          "description": "Vertical alignment of subtitles."
        },
        {
          "name": "font_size",
          "type": {
            "type": "int"
          },
          "default": 24,
          "title": "Font Size",
          "description": "The font size.",
          "min": 1.0,
          "max": 72.0
        },
        {
          "name": "font_color",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#FFFFFF"
          },
          "title": "Font Color",
          "description": "The font color."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "chunks",
        "font",
        "align",
        "font_size",
        "font_color"
      ]
    },
    {
      "title": "Blur",
      "description": "Apply a blur effect to a video.\n    video, blur, smooth, soften\n\n    Use cases:\n    1. Create a dreamy or soft focus effect\n    2. Obscure or censor specific areas of the video\n    3. Reduce noise or grain in low-quality footage",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Blur",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to apply blur effect."
        },
        {
          "name": "strength",
          "type": {
            "type": "float"
          },
          "default": 5.0,
          "title": "Strength",
          "description": "The strength of the blur effect. Higher values create a stronger blur.",
          "min": 0.0,
          "max": 20.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "strength"
      ]
    },
    {
      "title": "Chroma Key",
      "description": "Apply chroma key (green screen) effect to a video.\n    video, chroma key, green screen, compositing\n\n    Use cases:\n    1. Remove green or blue background from video footage\n    2. Create special effects by compositing video onto new backgrounds\n    3. Produce professional-looking videos for presentations or marketing",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.ChromaKey",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to apply chroma key effect."
        },
        {
          "name": "key_color",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#00FF00"
          },
          "title": "Key Color",
          "description": "The color to key out (e.g., '#00FF00' for green)."
        },
        {
          "name": "similarity",
          "type": {
            "type": "float"
          },
          "default": 0.3,
          "title": "Similarity",
          "description": "Similarity threshold for the key color.",
          "min": 0.0,
          "max": 1.0
        },
        {
          "name": "blend",
          "type": {
            "type": "float"
          },
          "default": 0.1,
          "title": "Blend",
          "description": "Blending of the keyed area edges.",
          "min": 0.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "key_color",
        "similarity",
        "blend"
      ]
    },
    {
      "title": "Color Balance",
      "description": "Adjust the color balance of a video.\n    video, color, balance, adjustment\n\n    Use cases:\n    1. Correct color casts in video footage\n    2. Enhance specific color tones for artistic effect\n    3. Normalize color balance across multiple video clips",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.ColorBalance",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to adjust color balance."
        },
        {
          "name": "red_adjust",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Red Adjust",
          "description": "Red channel adjustment factor.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "green_adjust",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Green Adjust",
          "description": "Green channel adjustment factor.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "blue_adjust",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Blue Adjust",
          "description": "Blue channel adjustment factor.",
          "min": 0.0,
          "max": 2.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "red_adjust",
        "green_adjust",
        "blue_adjust"
      ]
    },
    {
      "title": "Concat",
      "description": "Concatenate multiple video files into a single video, including audio when available.\n    video, concat, merge, combine, audio, +\n\n    Use cases:\n    - Merge multiple video clips into one continuous video\n    - Combine intro, main content, and outro sequences\n    - Join video segments from different sources\n    - Create video compilations and montages",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Concat",
      "properties": [
        {
          "name": "video_a",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video A",
          "description": "The first video to concatenate."
        },
        {
          "name": "video_b",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video B",
          "description": "The second video to concatenate."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video_a",
        "video_b"
      ]
    },
    {
      "title": "Denoise",
      "description": "Apply noise reduction to a video.\n    video, denoise, clean, enhance\n\n    Use cases:\n    1. Improve video quality by reducing unwanted noise\n    2. Enhance low-light footage\n    3. Prepare video for further processing or compression",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Denoise",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to denoise."
        },
        {
          "name": "strength",
          "type": {
            "type": "float"
          },
          "default": 5.0,
          "title": "Strength",
          "description": "Strength of the denoising effect. Higher values mean more denoising.",
          "min": 0.0,
          "max": 20.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "strength"
      ]
    },
    {
      "title": "Extract Audio",
      "description": "Separate and extract audio track from a video file.\n    video, audio, extract, separate, split\n\n    Use cases:\n    - Extract audio for podcasts or music\n    - Create audio-only versions of video content\n    - Analyze or transcribe video audio separately\n    - Reuse audio in different contexts\n    - Convert video soundtracks to audio files",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.ExtractAudio",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to separate."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video"
      ]
    },
    {
      "title": "Fps",
      "description": "Get the frames per second (FPS) of a video file.\n    video, analysis, frames, fps\n\n    Use cases:\n    1. Analyze video properties for quality assessment\n    2. Determine appropriate playback speed for video editing\n    3. Ensure compatibility with target display systems",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Fps",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to analyze for FPS."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video"
      ]
    },
    {
      "title": "Frame Iterator",
      "description": "Extract frames from a video file using OpenCV.\n    video, frames, extract, sequence\n\n    Use cases:\n    1. Generate image sequences for further processing\n    2. Extract specific frame ranges from a video\n    3. Create thumbnails or previews from video content",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.FrameIterator",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to extract frames from."
        },
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start",
          "description": "The frame to start extracting from."
        },
        {
          "name": "end",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End",
          "description": "The frame to stop extracting from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "frame"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "index"
        },
        {
          "type": {
            "type": "float"
          },
          "name": "fps"
        }
      ],
      "basic_fields": [
        "video",
        "start",
        "end"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Frame To Video",
      "description": "Combine a sequence of frames into a single video file.\n    video, frames, combine, sequence\n\n    Use cases:\n    1. Create time-lapse videos from image sequences\n    2. Compile processed frames back into a video\n    3. Generate animations from individual images",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.FrameToVideo",
      "properties": [
        {
          "name": "frame",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Frame",
          "description": "Collect input frames"
        },
        {
          "name": "fps",
          "type": {
            "type": "float"
          },
          "default": 30,
          "title": "Fps",
          "description": "The FPS of the output video."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "frame",
        "fps"
      ]
    },
    {
      "title": "Image To Video",
      "description": "Generate videos from input images using any supported video provider.\n    Animates static images into dynamic video content with AI-powered motion.\n    video, image-to-video, i2v, animation, AI, generation, sora, veo\n\n    Use cases:\n    - Animate static images into video sequences\n    - Create dynamic content from still photographs\n    - Generate video variations from reference images\n    - Produce animated visual effects from static artwork\n    - Convert product photos into engaging video ads",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.ImageToVideo",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The input image to animate into a video"
        },
        {
          "name": "model",
          "type": {
            "type": "video_model"
          },
          "default": {
            "type": "video_model",
            "provider": "gemini",
            "id": "veo-3.0-fast-generate-001",
            "name": "Veo 3.0 Fast",
            "path": null,
            "supported_tasks": []
          },
          "title": "Model",
          "description": "The video generation model to use"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text prompt to guide the video animation"
        },
        {
          "name": "negative_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Negative Prompt",
          "description": "Text prompt describing what to avoid in the video"
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "16:9",
              "9:16",
              "1:1",
              "4:3",
              "3:4"
            ],
            "type_name": "nodetool.nodes.nodetool.video.ImageToVideo.AspectRatio"
          },
          "default": "16:9",
          "title": "Aspect Ratio",
          "description": "Aspect ratio for the video"
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "480p",
              "720p",
              "1080p"
            ],
            "type_name": "nodetool.nodes.nodetool.video.ImageToVideo.Resolution"
          },
          "default": "720p",
          "title": "Resolution",
          "description": "Video resolution"
        },
        {
          "name": "num_frames",
          "type": {
            "type": "int"
          },
          "default": 60,
          "title": "Num Frames",
          "description": "Number of frames to generate (provider-specific)",
          "min": 1.0,
          "max": 300.0
        },
        {
          "name": "guidance_scale",
          "type": {
            "type": "float"
          },
          "default": 7.5,
          "title": "Guidance Scale",
          "description": "Classifier-free guidance scale (higher = closer to prompt)",
          "min": 0.0,
          "max": 30.0
        },
        {
          "name": "num_inference_steps",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Num Inference Steps",
          "description": "Number of denoising steps",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "seed",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Seed",
          "description": "Random seed for reproducibility (-1 for random)",
          "min": -1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "model",
        "prompt",
        "aspect_ratio",
        "resolution",
        "seed"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Load Video Folder",
      "description": "Load video files from an asset folder.\n\n    video, assets, load\n\n    Use cases:\n    - Provide videos for batch processing\n    - Iterate over stored video assets\n    - Prepare clips for editing or analysis",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.LoadVideoAssets",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The asset folder to load the video files from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "video"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        }
      ],
      "basic_fields": [
        "folder"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Load Video File",
      "description": "Read a video file from disk.\n    video, input, load, file\n\n    Use cases:\n    - Load videos for processing\n    - Import video files for editing\n    - Read video assets for a workflow",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.LoadVideoFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the video file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Overlay",
      "description": "Overlay one video on top of another, including audio overlay when available.\n    video, overlay, composite, picture-in-picture, audio\n\n    Use cases:\n    - Create picture-in-picture effects for commentary videos\n    - Add watermarks or logos to videos\n    - Combine multiple video streams\n    - Create split-screen or multi-view presentations\n    - Layer video effects over main content",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Overlay",
      "properties": [
        {
          "name": "main_video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Main Video",
          "description": "The main (background) video."
        },
        {
          "name": "overlay_video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Overlay Video",
          "description": "The video to overlay on top."
        },
        {
          "name": "x",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "X",
          "description": "X-coordinate for overlay placement."
        },
        {
          "name": "y",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Y",
          "description": "Y-coordinate for overlay placement."
        },
        {
          "name": "scale",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Scale",
          "description": "Scale factor for the overlay video."
        },
        {
          "name": "overlay_audio_volume",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Overlay Audio Volume",
          "description": "Volume of the overlay audio relative to the main audio.",
          "min": 0.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "main_video",
        "overlay_video",
        "x",
        "y",
        "scale",
        "overlay_audio_volume"
      ]
    },
    {
      "title": "Resize",
      "description": "Resize a video to a specific width and height.\n    video, resize, scale, dimensions\n\n    Use cases:\n    1. Adjust video resolution for different display requirements\n    2. Reduce file size by downscaling video\n    3. Prepare videos for specific platforms with size constraints",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Resize",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to resize."
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Width",
          "description": "The target width. Use -1 to maintain aspect ratio."
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Height",
          "description": "The target height. Use -1 to maintain aspect ratio."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "width",
        "height"
      ]
    },
    {
      "title": "Reverse",
      "description": "Reverse the playback of a video.\n    video, reverse, backwards, effect\n\n    Use cases:\n    1. Create artistic effects by playing video in reverse\n    2. Analyze motion or events in reverse order\n    3. Generate unique transitions or intros for video projects",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Reverse",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to reverse."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video"
      ]
    },
    {
      "title": "Rotate",
      "description": "Rotate a video by a specified angle.\n    video, rotate, orientation, transform\n\n    Use cases:\n    1. Correct orientation of videos taken with a rotated camera\n    2. Create artistic effects by rotating video content\n    3. Adjust video for different display orientations",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Rotate",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to rotate."
        },
        {
          "name": "angle",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Angle",
          "description": "The angle of rotation in degrees.",
          "min": -360.0,
          "max": 360.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "angle"
      ]
    },
    {
      "title": "Saturation",
      "description": "Adjust the color saturation of a video.\n    video, saturation, color, enhance\n\n    Use cases:\n    1. Enhance color vibrancy in dull or flat-looking footage\n    2. Create stylistic effects by over-saturating or desaturating video\n    3. Correct oversaturated footage from certain cameras",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Saturation",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to adjust saturation."
        },
        {
          "name": "saturation",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Saturation",
          "description": "Saturation level. 1.0 is original, <1 decreases saturation, >1 increases saturation.",
          "min": 0.0,
          "max": 3.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "saturation"
      ]
    },
    {
      "title": "Save Video Asset",
      "description": "Save a video to an asset folder.\n    video, save, file, output\n\n    Use cases:\n    1. Export processed video to a specific asset folder\n    2. Save video with a custom name\n    3. Create a copy of a video in a different location",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.SaveVideo",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The video to save."
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The asset folder to save the video in."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d-%H-%M-%S.mp4",
          "title": "Name",
          "description": "\n        Name of the output video.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "folder",
        "name"
      ]
    },
    {
      "title": "Save Video File",
      "description": "Write a video file to disk.\n    video, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.SaveVideoFile",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The video to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "\n        Name of the file to save.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "folder",
        "filename"
      ]
    },
    {
      "title": "Set Speed",
      "description": "Adjust the playback speed of a video.\n    video, speed, tempo, time\n\n    Use cases:\n    1. Create slow-motion effects by decreasing video speed\n    2. Generate time-lapse videos by increasing playback speed\n    3. Synchronize video duration with audio or other timing requirements",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.SetSpeed",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to adjust speed."
        },
        {
          "name": "speed_factor",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Speed Factor",
          "description": "The speed adjustment factor. Values > 1 speed up, < 1 slow down."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "speed_factor"
      ]
    },
    {
      "title": "Sharpness",
      "description": "Adjust the sharpness of a video.\n    video, sharpen, enhance, detail\n\n    Use cases:\n    1. Enhance detail in slightly out-of-focus footage\n    2. Correct softness introduced by video compression\n    3. Create stylistic effects by over-sharpening",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Sharpness",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to sharpen."
        },
        {
          "name": "luma_amount",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Luma Amount",
          "description": "Amount of sharpening to apply to luma (brightness) channel.",
          "min": 0.0,
          "max": 3.0
        },
        {
          "name": "chroma_amount",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Chroma Amount",
          "description": "Amount of sharpening to apply to chroma (color) channels.",
          "min": 0.0,
          "max": 3.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "luma_amount",
        "chroma_amount"
      ]
    },
    {
      "title": "Stabilize",
      "description": "Apply video stabilization to reduce camera shake and jitter.\n    video, stabilize, smooth, shake-reduction\n\n    Use cases:\n    1. Improve quality of handheld or action camera footage\n    2. Smooth out panning and tracking shots\n    3. Enhance viewer experience by reducing motion sickness",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Stabilize",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to stabilize."
        },
        {
          "name": "smoothing",
          "type": {
            "type": "float"
          },
          "default": 10.0,
          "title": "Smoothing",
          "description": "Smoothing strength. Higher values result in smoother but potentially more cropped video.",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "crop_black",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Crop Black",
          "description": "Whether to crop black borders that may appear after stabilization."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "smoothing",
        "crop_black"
      ]
    },
    {
      "title": "Text To Video",
      "description": "Generate videos from text prompts using any supported video provider.\n    Automatically routes to the appropriate backend (Gemini Veo, HuggingFace).\n    video, generation, AI, text-to-video, t2v\n\n    Use cases:\n    - Create videos from text descriptions\n    - Generate video content from prompts\n    - Produce short video clips with AI\n    - Switch between providers without changing workflows",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.TextToVideo",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "video_model"
          },
          "default": {
            "type": "video_model",
            "provider": "gemini",
            "id": "veo-3.0-fast-generate-001",
            "name": "Veo 3.0 Fast",
            "path": null,
            "supported_tasks": []
          },
          "title": "Model",
          "description": "The video generation model to use"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "A cat playing with a ball of yarn",
          "title": "Prompt",
          "description": "Text prompt describing the desired video"
        },
        {
          "name": "negative_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Negative Prompt",
          "description": "Text prompt describing what to avoid in the video"
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "16:9",
              "9:16",
              "1:1",
              "4:3",
              "3:4"
            ],
            "type_name": "nodetool.nodes.nodetool.video.TextToVideo.AspectRatio"
          },
          "default": "16:9",
          "title": "Aspect Ratio",
          "description": "Aspect ratio for the video"
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "480p",
              "720p",
              "1080p"
            ],
            "type_name": "nodetool.nodes.nodetool.video.TextToVideo.Resolution"
          },
          "default": "720p",
          "title": "Resolution",
          "description": "Video resolution"
        },
        {
          "name": "num_frames",
          "type": {
            "type": "int"
          },
          "default": 60,
          "title": "Num Frames",
          "description": "Number of frames to generate (provider-specific)",
          "min": 1.0,
          "max": 300.0
        },
        {
          "name": "guidance_scale",
          "type": {
            "type": "float"
          },
          "default": 7.5,
          "title": "Guidance Scale",
          "description": "Classifier-free guidance scale (higher = closer to prompt)",
          "min": 0.0,
          "max": 30.0
        },
        {
          "name": "num_inference_steps",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Num Inference Steps",
          "description": "Number of denoising steps",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "seed",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Seed",
          "description": "Random seed for reproducibility (-1 for random)",
          "min": -1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "prompt",
        "aspect_ratio",
        "resolution",
        "seed"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Transition",
      "description": "Create a transition effect between two videos, including audio transition when available.\n    video, transition, effect, merge, audio\n\n    Use cases:\n    1. Create smooth transitions between video clips in a montage\n    2. Add professional-looking effects to video projects\n    3. Blend scenes together for creative storytelling\n    4. Smoothly transition between audio tracks of different video clips",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Transition",
      "properties": [
        {
          "name": "video_a",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video A",
          "description": "The first video in the transition."
        },
        {
          "name": "video_b",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video B",
          "description": "The second video in the transition."
        },
        {
          "name": "transition_type",
          "type": {
            "type": "enum",
            "values": [
              "fade",
              "wipeleft",
              "wiperight",
              "wipeup",
              "wipedown",
              "slideleft",
              "slideright",
              "slideup",
              "slidedown",
              "circlecrop",
              "rectcrop",
              "distance",
              "fadeblack",
              "fadewhite",
              "radial",
              "smoothleft",
              "smoothright",
              "smoothup",
              "smoothdown",
              "circleopen",
              "circleclose",
              "vertopen",
              "vertclose",
              "horzopen",
              "horzclose",
              "dissolve",
              "pixelize",
              "diagtl",
              "diagtr",
              "diagbl",
              "diagbr",
              "hlslice",
              "hrslice",
              "vuslice",
              "vdslice",
              "hblur",
              "fadegrays",
              "wipetl",
              "wipetr",
              "wipebl",
              "wipebr",
              "squeezeh",
              "squeezev",
              "zoomin",
              "fadefast",
              "fadeslow",
              "hlwind",
              "hrwind",
              "vuwind",
              "vdwind",
              "coverleft",
              "coverright",
              "coverup",
              "coverdown",
              "revealleft",
              "revealright",
              "revealup",
              "revealdown"
            ],
            "type_name": "nodetool.nodes.nodetool.video.Transition.TransitionType"
          },
          "default": "fade",
          "title": "Transition Type",
          "description": "Type of transition effect"
        },
        {
          "name": "duration",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Duration",
          "description": "Duration of the transition effect in seconds.",
          "min": 0.1,
          "max": 5.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video_a",
        "video_b",
        "transition_type",
        "duration"
      ]
    },
    {
      "title": "Trim",
      "description": "Trim a video to a specific start and end time.\n    video, trim, cut, segment\n\n    Use cases:\n    1. Extract specific segments from a longer video\n    2. Remove unwanted parts from the beginning or end of a video\n    3. Create shorter clips from a full-length video",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Trim",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The input video to trim."
        },
        {
          "name": "start_time",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Start Time",
          "description": "The start time in seconds for the trimmed video."
        },
        {
          "name": "end_time",
          "type": {
            "type": "float"
          },
          "default": -1.0,
          "title": "End Time",
          "description": "The end time in seconds for the trimmed video. Use -1 for the end of the video."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "start_time",
        "end_time"
      ]
    },
    {
      "title": "Batch To List",
      "description": "Convert an image batch to a list of image references.\n    batch, list, images, processing\n\n    Use cases:\n    - Convert comfy batch outputs to list format",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.BatchToList",
      "properties": [
        {
          "name": "batch",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Batch",
          "description": "The batch of images to convert."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "batch"
      ]
    },
    {
      "title": "Crop",
      "description": "Crop an image to specified coordinates.\n    image, crop\n\n    - Remove unwanted borders from images\n    - Focus on particular subjects within an image\n    - Simplify images by removing distractions",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Crop",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to crop."
        },
        {
          "name": "left",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Left",
          "description": "The left coordinate.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "top",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Top",
          "description": "The top coordinate.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "right",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Right",
          "description": "The right coordinate.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "bottom",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Bottom",
          "description": "The bottom coordinate.",
          "min": 0.0,
          "max": 4096.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "left",
        "top",
        "right",
        "bottom"
      ]
    },
    {
      "title": "Fit",
      "description": "Resize an image to fit within specified dimensions while preserving aspect ratio.\n    image, resize, fit\n\n    - Resize images for online publishing requirements\n    - Preprocess images to uniform sizes for machine learning\n    - Control image display sizes for web development",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Fit",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to fit."
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Width",
          "description": "Width to fit to.",
          "min": 1.0,
          "max": 4096.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Height",
          "description": "Height to fit to.",
          "min": 1.0,
          "max": 4096.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "width",
        "height"
      ]
    },
    {
      "title": "Get Metadata",
      "description": "Get metadata about the input image.\n    metadata, properties, analysis, information\n\n    Use cases:\n    - Use width and height for layout calculations\n    - Analyze image properties for processing decisions\n    - Gather information for image cataloging or organization",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.GetMetadata",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The input image."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "format"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "mode"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "width"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "height"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "channels"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Image To Image",
      "description": "Transform images using text prompts with any supported image provider.\n    Automatically routes to the appropriate backend (HuggingFace, FAL, MLX).\n    image, transformation, AI, image-to-image, i2i\n\n    Use cases:\n    - Modify existing images with text instructions\n    - Style transfer and artistic modifications\n    - Image enhancement and refinement\n    - Creative image edits guided by prompts",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.ImageToImage",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "image_model"
          },
          "default": {
            "type": "image_model",
            "provider": "huggingface_fal_ai",
            "id": "fal-ai/flux/dev",
            "name": "FLUX.1 Dev",
            "path": null,
            "supported_tasks": []
          },
          "title": "Model",
          "description": "The image generation model to use"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "Input image to transform"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "A photorealistic version of the input image",
          "title": "Prompt",
          "description": "Text prompt describing the desired transformation"
        },
        {
          "name": "negative_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Negative Prompt",
          "description": "Text prompt describing what to avoid"
        },
        {
          "name": "strength",
          "type": {
            "type": "float"
          },
          "default": 0.8,
          "title": "Strength",
          "description": "How much to transform the input image (0.0 = no change, 1.0 = maximum change)",
          "min": 0.0,
          "max": 1.0
        },
        {
          "name": "guidance_scale",
          "type": {
            "type": "float"
          },
          "default": 7.5,
          "title": "Guidance Scale",
          "description": "Classifier-free guidance scale",
          "min": 0.0,
          "max": 30.0
        },
        {
          "name": "num_inference_steps",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Num Inference Steps",
          "description": "Number of denoising steps",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "target_width",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Target Width",
          "description": "Target width of the output image",
          "min": 64.0,
          "max": 2048.0
        },
        {
          "name": "target_height",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Target Height",
          "description": "Target height of the output image",
          "min": 64.0,
          "max": 2048.0
        },
        {
          "name": "seed",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Seed",
          "description": "Random seed for reproducibility (-1 for random)",
          "min": -1.0
        },
        {
          "name": "scheduler",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Scheduler",
          "description": "Scheduler to use (provider-specific)"
        },
        {
          "name": "safety_check",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Safety Check",
          "description": "Enable safety checker"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "image",
        "prompt",
        "strength",
        "seed"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Load Image Assets",
      "description": "Load images from an asset folder.\n    load, image, file, import",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.LoadImageAssets",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The asset folder to load the images from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "image"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        }
      ],
      "basic_fields": [
        "folder"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Load Image File",
      "description": "Read an image file from disk.\n    image, input, load, file\n\n    Use cases:\n    - Load images for processing\n    - Import photos for editing\n    - Read image assets for a workflow",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.LoadImageFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the image file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Load Image Folder",
      "description": "Load all images from a folder, optionally including subfolders.\n    image, load, folder, files\n\n    Use cases:\n    - Batch import images for processing\n    - Build datasets from a directory tree\n    - Iterate over photo collections",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.LoadImageFolder",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Folder to scan for images"
        },
        {
          "name": "include_subdirectories",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Include Subdirectories",
          "description": "Include images in subfolders"
        },
        {
          "name": "extensions",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [
            ".png",
            ".jpg",
            ".jpeg",
            ".bmp",
            ".gif",
            ".webp",
            ".tiff"
          ],
          "title": "Extensions",
          "description": "Image file extensions to include"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "Pattern to match image files"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "image"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "path"
        }
      ],
      "basic_fields": [
        "folder",
        "include_subdirectories",
        "extensions",
        "pattern"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Paste",
      "description": "Paste one image onto another at specified coordinates.\n    paste, composite, positioning, overlay\n\n    Use cases:\n    - Add watermarks or logos to images\n    - Combine multiple image elements\n    - Create collages or montages",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Paste",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to paste into."
        },
        {
          "name": "paste",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Paste",
          "description": "The image to paste."
        },
        {
          "name": "left",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Left",
          "description": "The left coordinate.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "top",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Top",
          "description": "The top coordinate.",
          "min": 0.0,
          "max": 4096.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "paste",
        "left",
        "top"
      ]
    },
    {
      "title": "Resize",
      "description": "Change image dimensions to specified width and height.\n    image, resize\n\n    - Preprocess images for machine learning model inputs\n    - Optimize images for faster web page loading\n    - Create uniform image sizes for layouts",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Resize",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to resize."
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Width",
          "description": "The target width.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Height",
          "description": "The target height.",
          "min": 0.0,
          "max": 4096.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "width",
        "height"
      ]
    },
    {
      "title": "Save Image Asset",
      "description": "Save an image to specified asset folder with customizable name format.\n    save, image, folder, naming\n\n    Use cases:\n    - Save generated images with timestamps\n    - Organize outputs into specific folders\n    - Create backups of processed images",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.SaveImage",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to save."
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The asset folder to save the image in."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d_%H-%M-%S.png",
          "title": "Name",
          "description": "\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "folder",
        "name"
      ]
    },
    {
      "title": "Save Image File",
      "description": "Write an image to disk.\n    image, output, save, file\n\n    Use cases:\n    - Save processed images\n    - Export edited photos\n    - Archive image results",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.SaveImageFile",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "\n        The name of the image file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        },
        {
          "name": "overwrite",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Overwrite",
          "description": "Overwrite the file if it already exists, otherwise file will be renamed"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "folder",
        "filename",
        "overwrite"
      ]
    },
    {
      "title": "Scale",
      "description": "Enlarge or shrink an image by a scale factor.\n    image, resize, scale\n\n    - Adjust image dimensions for display galleries\n    - Standardize image sizes for machine learning datasets\n    - Create thumbnail versions of images",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Scale",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to scale."
        },
        {
          "name": "scale",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Scale",
          "description": "The scale factor.",
          "min": 0.0,
          "max": 10.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "scale"
      ]
    },
    {
      "title": "Text To Image",
      "description": "Generate images from text prompts using any supported image provider.\n    Automatically routes to the appropriate backend (HuggingFace, FAL, MLX).\n    image, generation, AI, text-to-image, t2i\n\n    Use cases:\n    - Create images from text descriptions\n    - Switch between providers without changing workflows\n    - Generate images with different AI models\n    - Cost-optimize by choosing different providers",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.TextToImage",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "image_model"
          },
          "default": {
            "type": "image_model",
            "provider": "huggingface_fal_ai",
            "id": "fal-ai/flux/schnell",
            "name": "FLUX.1 Schnell",
            "path": null,
            "supported_tasks": []
          },
          "title": "Model",
          "description": "The image generation model to use"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "A cat holding a sign that says hello world",
          "title": "Prompt",
          "description": "Text prompt describing the desired image"
        },
        {
          "name": "negative_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Negative Prompt",
          "description": "Text prompt describing what to avoid in the image"
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Width",
          "description": "Width of the generated image",
          "min": 64.0,
          "max": 2048.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Height",
          "description": "Height of the generated image",
          "min": 64.0,
          "max": 2048.0
        },
        {
          "name": "guidance_scale",
          "type": {
            "type": "float"
          },
          "default": 7.5,
          "title": "Guidance Scale",
          "description": "Classifier-free guidance scale (higher = closer to prompt)",
          "min": 0.0,
          "max": 30.0
        },
        {
          "name": "num_inference_steps",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Num Inference Steps",
          "description": "Number of denoising steps",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "seed",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Seed",
          "description": "Random seed for reproducibility (-1 for random)",
          "min": -1.0
        },
        {
          "name": "safety_check",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Safety Check",
          "description": "Enable safety checker to filter inappropriate content"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "model",
        "prompt",
        "width",
        "height",
        "seed"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Add Column",
      "description": "Add list of values as new column to dataframe.\n    dataframe, column, list\n\n    Use cases:\n    - Incorporate external data into existing dataframe\n    - Add calculated results as new column\n    - Augment dataframe with additional features",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.AddColumn",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "Dataframe object to add a new column to."
        },
        {
          "name": "column_name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Column Name",
          "description": "The name of the new column to be added to the dataframe."
        },
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values",
          "description": "A list of any type of elements which will be the new column's values."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "column_name",
        "values"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Aggregate",
      "description": "Aggregate dataframe by one or more columns.\n    aggregate, groupby, group, sum, mean, count, min, max, std, var, median, first, last\n\n    Use cases:\n    - Prepare data for aggregation operations\n    - Analyze data by categories\n    - Create summary statistics by groups",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Aggregate",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "The DataFrame to group."
        },
        {
          "name": "columns",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Columns",
          "description": "Comma-separated column names to group by."
        },
        {
          "name": "aggregation",
          "type": {
            "type": "str"
          },
          "default": "sum",
          "title": "Aggregation",
          "description": "Aggregation function: sum, mean, count, min, max, std, var, median, first, last"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "columns",
        "aggregation"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Append",
      "description": "Append two dataframes along rows.\n    append, concat, rows\n\n    Use cases:\n    - Combine data from multiple time periods\n    - Merge datasets with same structure\n    - Aggregate data from different sources",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Append",
      "properties": [
        {
          "name": "dataframe_a",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe A",
          "description": "First DataFrame to be appended."
        },
        {
          "name": "dataframe_b",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe B",
          "description": "Second DataFrame to be appended."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe_a",
        "dataframe_b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Drop Duplicates",
      "description": "Remove duplicate rows from dataframe.\n    duplicates, unique, clean\n\n    Use cases:\n    - Clean dataset by removing redundant entries\n    - Ensure data integrity in analysis\n    - Prepare data for unique value operations",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.DropDuplicates",
      "properties": [
        {
          "name": "df",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Df",
          "description": "The input DataFrame."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "df"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Drop NA",
      "description": "Remove rows with NA values from dataframe.\n    na, missing, clean\n\n    Use cases:\n    - Clean dataset by removing incomplete entries\n    - Prepare data for analysis requiring complete cases\n    - Improve data quality for modeling",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.DropNA",
      "properties": [
        {
          "name": "df",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Df",
          "description": "The input DataFrame."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "df"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Column",
      "description": "Convert dataframe column to list.\n    dataframe, column, list\n\n    Use cases:\n    - Extract data for use in other processing steps\n    - Prepare column data for plotting or analysis\n    - Convert categorical data to list for encoding",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.ExtractColumn",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "The input dataframe."
        },
        {
          "name": "column_name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Column Name",
          "description": "The name of the column to be converted to a list."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "column_name"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Fill NA",
      "description": "Fill missing values in dataframe.\n    fillna, missing, impute\n\n    Use cases:\n    - Handle missing data\n    - Prepare data for analysis\n    - Improve data quality",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.FillNA",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "The DataFrame with missing values."
        },
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "default": 0,
          "title": "Value",
          "description": "Value to use for filling missing values."
        },
        {
          "name": "method",
          "type": {
            "type": "str"
          },
          "default": "value",
          "title": "Method",
          "description": "Method for filling: value, forward, backward, mean, median"
        },
        {
          "name": "columns",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Columns",
          "description": "Comma-separated column names to fill. Leave empty for all columns."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "value",
        "method",
        "columns"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Filter",
      "description": "Filter dataframe based on condition.\n    filter, query, condition\n\n    Example conditions:\n    age > 30\n    age > 30 and salary < 50000\n    name == 'John Doe'\n    100 <= price <= 200\n    status in ['Active', 'Pending']\n    not (age < 18)\n\n    Use cases:\n    - Extract subset of data meeting specific criteria\n    - Remove outliers or invalid data points\n    - Focus analysis on relevant data segments",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Filter",
      "properties": [
        {
          "name": "df",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Df",
          "description": "The DataFrame to filter."
        },
        {
          "name": "condition",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Condition",
          "description": "The filtering condition to be applied to the DataFrame, e.g. column_name > 5."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "df",
        "condition"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Filter None",
      "description": "Filters out None values from a stream.\n    filter, none, null, stream\n\n    Use cases:\n    - Clean data by removing null values\n    - Get only valid entries\n    - Remove placeholder values",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.FilterNone",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "default": [],
          "title": "Value",
          "description": "Input stream"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Find Row",
      "description": "Find the first row in a dataframe that matches a given condition.\n    filter, query, condition, single row\n\n    Example conditions:\n    age > 30\n    age > 30 and salary < 50000\n    name == 'John Doe'\n    100 <= price <= 200\n    status in ['Active', 'Pending']\n    not (age < 18)\n\n    Use cases:\n    - Retrieve specific record based on criteria\n    - Find first occurrence of a particular condition\n    - Extract single data point for further analysis",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.FindRow",
      "properties": [
        {
          "name": "df",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Df",
          "description": "The DataFrame to search."
        },
        {
          "name": "condition",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Condition",
          "description": "The condition to filter the DataFrame, e.g. 'column_name == value'."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "df",
        "condition"
      ],
      "expose_as_tool": true
    },
    {
      "title": "From List",
      "description": "Convert list of dicts to dataframe.\n    list, dataframe, convert\n\n    Use cases:\n    - Transform list data into structured dataframe\n    - Prepare list data for analysis or visualization\n    - Convert API responses to dataframe format",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.FromList",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values",
          "description": "List of values to be converted, each value will be a row."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Import CSV",
      "description": "Convert CSV string to dataframe.\n    csv, dataframe, import\n\n    Use cases:\n    - Import CSV data from string input\n    - Convert CSV responses from APIs to dataframe",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.ImportCSV",
      "properties": [
        {
          "name": "csv_data",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "CSV Data",
          "description": "String input of CSV formatted text."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "csv_data"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Convert JSON to DataFrame",
      "description": "Transforms a JSON string into a pandas DataFrame.\n    json, dataframe, conversion\n\n    Use cases:\n    - Converting API responses to tabular format\n    - Preparing JSON data for analysis or visualization\n    - Structuring unstructured JSON data for further processing",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.JSONToDataframe",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "JSON"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Join",
      "description": "Join two dataframes on specified column.\n    join, merge, column\n\n    Use cases:\n    - Combine data from related tables\n    - Enrich dataset with additional information\n    - Link data based on common identifiers",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Join",
      "properties": [
        {
          "name": "dataframe_a",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe A",
          "description": "First DataFrame to be merged."
        },
        {
          "name": "dataframe_b",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe B",
          "description": "Second DataFrame to be merged."
        },
        {
          "name": "join_on",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Join On",
          "description": "The column name on which to join the two dataframes."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe_a",
        "dataframe_b",
        "join_on"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Load CSV Assets",
      "description": "Load dataframes from an asset folder.\n    load, dataframe, file, import\n\n    Use cases:\n    - Load multiple dataframes from a folder\n    - Process multiple datasets in sequence\n    - Batch import of data files",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.LoadCSVAssets",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The asset folder to load the dataframes from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "dataframe"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        }
      ],
      "basic_fields": [
        "folder"
      ],
      "is_streaming_output": true,
      "expose_as_tool": true
    },
    {
      "title": "Load CSVFile",
      "description": "Load CSV file from file path.\n    csv, dataframe, import",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.LoadCSVFile",
      "properties": [
        {
          "name": "file_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "File Path",
          "description": "The path to the CSV file to load."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "file_path"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Load CSVURL",
      "description": "Load CSV file from URL.\n    csv, dataframe, import",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.LoadCSVURL",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL of the CSV file to load."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Merge",
      "description": "Merge two dataframes along columns.\n    merge, concat, columns\n\n    Use cases:\n    - Combine data from multiple sources\n    - Add new features to existing dataframe\n    - Merge time series data from different periods",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Merge",
      "properties": [
        {
          "name": "dataframe_a",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe A",
          "description": "First DataFrame to be merged."
        },
        {
          "name": "dataframe_b",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe B",
          "description": "Second DataFrame to be merged."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe_a",
        "dataframe_b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Pivot",
      "description": "Pivot dataframe to reshape data.\n    pivot, reshape, transform\n\n    Use cases:\n    - Transform long data to wide format\n    - Create cross-tabulation tables\n    - Reorganize data for visualization",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Pivot",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "The DataFrame to pivot."
        },
        {
          "name": "index",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Index",
          "description": "Column name to use as index (rows)."
        },
        {
          "name": "columns",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Columns",
          "description": "Column name to use as columns."
        },
        {
          "name": "values",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Values",
          "description": "Column name to use as values."
        },
        {
          "name": "aggfunc",
          "type": {
            "type": "str"
          },
          "default": "sum",
          "title": "Aggfunc",
          "description": "Aggregation function: sum, mean, count, min, max, first, last"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "index",
        "columns",
        "values",
        "aggfunc"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Rename",
      "description": "Rename columns in dataframe.\n    rename, columns, names\n\n    Use cases:\n    - Standardize column names\n    - Make column names more descriptive\n    - Prepare data for specific requirements",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Rename",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "The DataFrame to rename columns."
        },
        {
          "name": "rename_map",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Rename Map",
          "description": "Column rename mapping in format: old1:new1,old2:new2"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "rename_map"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Row Iterator",
      "description": "Iterate over rows of a dataframe.",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.RowIterator",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "The input dataframe."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "dict"
        },
        {
          "type": {
            "type": "any"
          },
          "name": "index"
        }
      ],
      "basic_fields": [
        "dataframe"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Save CSVDataframe File",
      "description": "Write a pandas DataFrame to a CSV file.\n    files, csv, write, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.SaveCSVDataframeFile",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "DataFrame to write to CSV"
        },
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Name of the CSV file to save. Supports strftime format codes."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "folder",
        "filename"
      ]
    },
    {
      "title": "Save Dataframe",
      "description": "Save dataframe in specified folder.\n    csv, folder, save\n\n    Use cases:\n    - Export processed data for external use\n    - Create backups of dataframes",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.SaveDataframe",
      "properties": [
        {
          "name": "df",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Df"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "Name of the output folder."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "output.csv",
          "title": "Name",
          "description": "\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "df",
        "folder",
        "name"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Schema",
      "description": "Define a schema for a dataframe.\n    schema, dataframe, create",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Schema",
      "properties": [
        {
          "name": "columns",
          "type": {
            "type": "record_type"
          },
          "default": {
            "type": "record_type",
            "columns": []
          },
          "title": "Columns",
          "description": "The columns to use in the dataframe."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "record_type"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "columns"
      ]
    },
    {
      "title": "Select Column",
      "description": "Select specific columns from dataframe.\n    dataframe, columns, filter\n\n    Use cases:\n    - Extract relevant features for analysis\n    - Reduce dataframe size by removing unnecessary columns\n    - Prepare data for specific visualizations or models",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.SelectColumn",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "a dataframe from which columns are to be selected"
        },
        {
          "name": "columns",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Columns",
          "description": "comma separated list of column names"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "columns"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Slice",
      "description": "Slice a dataframe by rows using start and end indices.\n    slice, subset, rows\n\n    Use cases:\n    - Extract a specific range of rows from a large dataset\n    - Create training and testing subsets for machine learning\n    - Analyze data in smaller chunks",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.Slice",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "The input dataframe to be sliced."
        },
        {
          "name": "start_index",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Index",
          "description": "The starting index of the slice (inclusive)."
        },
        {
          "name": "end_index",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Index",
          "description": "The ending index of the slice (exclusive). Use -1 for the last row."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe",
        "start_index",
        "end_index"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Sort By Column",
      "description": "Sort dataframe by specified column.\n    sort, order, column\n\n    Use cases:\n    - Arrange data in ascending or descending order\n    - Identify top or bottom values in dataset\n    - Prepare data for rank-based analysis",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.SortByColumn",
      "properties": [
        {
          "name": "df",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Df"
        },
        {
          "name": "column",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Column",
          "description": "The column to sort the DataFrame by."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "df",
        "column"
      ]
    },
    {
      "title": "To List",
      "description": "Convert dataframe to list of dictionaries.\n    dataframe, list, convert\n\n    Use cases:\n    - Convert dataframe data for API consumption\n    - Transform data for JSON serialization\n    - Prepare data for document-based storage",
      "namespace": "nodetool.data",
      "node_type": "nodetool.data.ToList",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "The input dataframe to convert."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dataframe"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Array Output",
      "description": "Output node for generic array data, typically numerical ('NPArray').\n    array, numerical, list, tensor, vector, matrix\n\n    Use cases:\n    - Outputting results from machine learning models (e.g., embeddings, predictions).\n    - Representing complex numerical data structures.\n    - Passing arrays of numbers between processing steps.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.ArrayOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Audio Output",
      "description": "Output node for audio content references ('AudioRef').\n    audio, sound, media, voice, speech, asset, reference\n\n    Use cases:\n    - Displaying or returning processed or generated audio.\n    - Passing audio data (as an 'AudioRef') between workflow nodes.\n    - Returning results of audio analysis (e.g., transcription reference, audio features).",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.AudioOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Boolean Output",
      "description": "Output node for a single boolean value.\n    boolean, true, false, flag, condition, flow-control, branch, else, switch, toggle\n\n    Use cases:\n    - Returning binary results (yes/no, true/false)\n    - Controlling conditional logic in workflows\n    - Indicating success/failure of operations",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.BooleanOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Dataframe Output",
      "description": "Output node for structured data references, typically tabular ('DataframeRef').\n    dataframe, table, structured, csv, tabular_data, rows, columns\n\n    Use cases:\n    - Outputting tabular data results from analysis or queries.\n    - Passing structured datasets between processing or analysis steps.\n    - Displaying data in a table format or making it available for download.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.DataframeOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Dictionary Output",
      "description": "Output node for key-value pair data (dictionary).\n    dictionary, key-value, mapping, object, json_object, struct\n\n    Use cases:\n    - Returning multiple named values as a single structured output.\n    - Passing complex data structures or configurations between nodes.\n    - Organizing heterogeneous output data into a named map.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.DictionaryOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Document Output",
      "description": "Output node for document content references ('DocumentRef').\n    document, file, pdf, text_file, asset, reference\n\n    Use cases:\n    - Displaying or returning processed or generated documents.\n    - Passing document data (as a 'DocumentRef') between workflow nodes.\n    - Returning results of document analysis or manipulation.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.DocumentOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "File Path Output",
      "description": "Output node for a file path.\n    file, path, file_path",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.FilePathOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "file_path"
          },
          "default": {
            "type": "file_path",
            "path": ""
          },
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Float Output",
      "description": "Output node for a single float value.\n    float, decimal, number\n\n    Use cases:\n    - Returning decimal results (e.g. percentages, ratios)\n    - Passing floating-point parameters between nodes\n    - Displaying numeric metrics with decimal precision",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.FloatOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Folder Path Output",
      "description": "Output node for a folder path.\n    folder, path, folder_path",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.FolderPathOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "folder_path"
          },
          "default": {
            "type": "folder_path",
            "path": ""
          },
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Image Output",
      "description": "Output node for a single image reference ('ImageRef').\n    image, picture, visual, asset, reference\n\n    Use cases:\n    - Displaying a single processed or generated image.\n    - Passing image data (as an 'ImageRef') between workflow nodes.\n    - Returning image analysis results encapsulated in an 'ImageRef'.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.ImageOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Integer Output",
      "description": "Output node for a single integer value.\n    integer, number, count\n\n    Use cases:\n    - Returning numeric results (e.g. counts, indices)\n    - Passing integer parameters between nodes\n    - Displaying numeric metrics",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.IntegerOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "List Output",
      "description": "Output node for a list of arbitrary values.\n    list, output, any\n\n    Use cases:\n    - Returning multiple results from a workflow\n    - Aggregating outputs from multiple nodes",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.ListOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "String Output",
      "description": "Output node for a string value.\n    string, text, output, label, name\n\n    Use cases:\n    - Returning short text results or messages.\n    - Passing concise string parameters or identifiers between nodes.\n    - Displaying brief textual outputs.\n    - For multi-line text or structured document content, use appropriate output nodes if available or consider how data is structured.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.StringOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Video Output",
      "description": "Output node for video content references ('VideoRef').\n    video, media, clip, asset, reference\n\n    Use cases:\n    - Displaying processed or generated video content.\n    - Passing video data (as a 'VideoRef') between workflow steps.\n    - Returning results of video analysis encapsulated in a 'VideoRef'.",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.VideoOutput",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "value",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Value"
        },
        {
          "name": "description",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Description",
          "description": "The description of the output for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Grounded Search",
      "description": "Search the web using Google's Gemini API with grounding capabilities.\n    google, search, grounded, web, gemini, ai\n\n    This node uses Google's Gemini API to perform web searches and return structured results\n    with source information. Requires a Gemini API key.\n\n    Use cases:\n    - Research current events and latest information\n    - Find reliable sources for fact-checking\n    - Gather web-based information with citations\n    - Get up-to-date information beyond the model's training data",
      "namespace": "gemini.text",
      "node_type": "gemini.text.GroundedSearch",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "The search query to execute"
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gemini-2.5-pro",
              "gemini-2.5-flash",
              "gemini-2.0-flash",
              "gemini-1.5-pro",
              "gemini-1.5-flash"
            ],
            "type_name": "nodetool.nodes.gemini.text.GeminiModel"
          },
          "default": "gemini-2.0-flash",
          "title": "Model",
          "description": "The Gemini model to use for search"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "results"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "source"
              }
            ]
          },
          "name": "sources"
        }
      ],
      "basic_fields": [
        "query",
        "model"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Text To Speech",
      "description": "Generate speech audio from text using Google's Gemini text-to-speech models.\n    google, text-to-speech, tts, audio, speech, voice, ai\n\n    This node converts text input into natural-sounding speech audio using Google's\n    advanced text-to-speech models with support for multiple voices and speech styles.\n\n    Supported voices:\n    - achernar, achird, algenib, algieba, alnilam\n    - aoede, autonoe, callirrhoe, charon, despina\n    - enceladus, erinome, fenrir, gacrux, iapetus\n    - kore, laomedeia, leda, orus, puck\n    - pulcherrima, rasalgethi, sadachbia, sadaltager, schedar\n    - sulafat, umbriel, vindemiatrix, zephyr, zubenelgenubi\n\n    Use cases:\n    - Create voiceovers for videos and presentations\n    - Generate audio content for podcasts and audiobooks\n    - Add voice narration to applications\n    - Create accessibility features with speech output\n    - Generate multilingual audio content",
      "namespace": "gemini.audio",
      "node_type": "gemini.audio.TextToSpeech",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to convert to speech."
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gemini-2.5-flash-preview-tts",
              "gemini-2.5-pro-preview-tts"
            ],
            "type_name": "nodetool.nodes.gemini.audio.TTSModel"
          },
          "default": "gemini-2.5-flash-preview-tts",
          "title": "Model",
          "description": "The text-to-speech model to use"
        },
        {
          "name": "voice_name",
          "type": {
            "type": "enum",
            "values": [
              "achernar",
              "achird",
              "algenib",
              "algieba",
              "alnilam",
              "aoede",
              "autonoe",
              "callirrhoe",
              "charon",
              "despina",
              "enceladus",
              "erinome",
              "fenrir",
              "gacrux",
              "iapetus",
              "kore",
              "laomedeia",
              "leda",
              "orus",
              "puck",
              "pulcherrima",
              "rasalgethi",
              "sadachbia",
              "sadaltager",
              "schedar",
              "sulafat",
              "umbriel",
              "vindemiatrix",
              "zephyr",
              "zubenelgenubi"
            ],
            "type_name": "nodetool.nodes.gemini.audio.VoiceName"
          },
          "default": "kore",
          "title": "Voice Name",
          "description": "The voice to use for speech generation"
        },
        {
          "name": "style_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Style Prompt",
          "description": "Optional style prompt to control speech characteristics (e.g., 'Say cheerfully', 'Speak with excitement')"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "model",
        "voice_name",
        "style_prompt"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Image To Video",
      "description": "Generate videos from images using Google's Veo models.\n    google, video, generation, image-to-video, veo, ai, animation\n\n    This node uses Google's Veo models to animate static images into dynamic videos.\n    Supports 720p resolution at 24fps with 8-second duration and native audio generation.\n\n    Use cases:\n    - Animate still artwork and photographs\n    - Create dynamic social media content from images\n    - Generate product showcase videos from photos\n    - Transform static graphics into engaging animations\n    - Create video presentations from slide images",
      "namespace": "gemini.video",
      "node_type": "gemini.video.ImageToVideo",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to animate into a video"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text prompt describing the desired animation"
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "veo-3.0-generate-preview",
              "veo-3.0-fast-generate-preview",
              "veo-2.0-generate-001"
            ],
            "type_name": "nodetool.nodes.gemini.video.VeoModel"
          },
          "default": "veo-3.0-generate-preview",
          "title": "Model",
          "description": "The Veo model to use for video generation"
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "16:9",
              "9:16"
            ],
            "type_name": "nodetool.nodes.gemini.video.VeoAspectRatio"
          },
          "default": "16:9",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated video"
        },
        {
          "name": "negative_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Negative Prompt",
          "description": "Negative prompt to guide what to avoid in the video"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "prompt",
        "model",
        "aspect_ratio",
        "negative_prompt"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Text To Video",
      "description": "Generate videos from text prompts using Google's Veo models.\n    google, video, generation, text-to-video, veo, ai\n\n    This node uses Google's Veo models to generate high-quality videos from text descriptions.\n    Supports 720p resolution at 24fps with 8-second duration and native audio generation.\n\n    Use cases:\n    - Create cinematic clips from text descriptions\n    - Generate social media video content\n    - Produce marketing and promotional videos\n    - Visualize creative concepts and storyboards\n    - Create animated content with accompanying audio",
      "namespace": "gemini.video",
      "node_type": "gemini.video.TextToVideo",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the video to generate"
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "veo-3.0-generate-preview",
              "veo-3.0-fast-generate-preview",
              "veo-2.0-generate-001"
            ],
            "type_name": "nodetool.nodes.gemini.video.VeoModel"
          },
          "default": "veo-3.0-generate-preview",
          "title": "Model",
          "description": "The Veo model to use for video generation"
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "16:9",
              "9:16"
            ],
            "type_name": "nodetool.nodes.gemini.video.VeoAspectRatio"
          },
          "default": "16:9",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated video"
        },
        {
          "name": "negative_prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Negative Prompt",
          "description": "Negative prompt to guide what to avoid in the video"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "model",
        "aspect_ratio",
        "negative_prompt"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Image Generation",
      "description": "Generate an image using Google's Imagen model via the Gemini API.\n    google, image generation, ai, imagen\n\n    Use cases:\n    - Create images from text descriptions\n    - Generate assets for creative projects\n    - Explore AI-powered image synthesis",
      "namespace": "gemini.image",
      "node_type": "gemini.image.ImageGeneration",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the image to generate."
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gemini-2.0-flash-preview-image-generation",
              "gemini-2.5-flash-image-preview",
              "imagen-3.0-generate-001",
              "imagen-3.0-generate-002",
              "imagen-4.0-generate-preview-06-06",
              "imagen-4.0-ultra-generate-preview-06-06"
            ],
            "type_name": "nodetool.nodes.gemini.image.ImageGenerationModel"
          },
          "default": "imagen-3.0-generate-002",
          "title": "Model",
          "description": "The image generation model to use"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to use as a base for the generation."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "model",
        "image"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Finance",
      "description": "Retrieve financial market data and stock information from Google Finance.\n    google, finance, stocks, market, serp, trading\n\n    Use cases:\n    - Track stock prices and market performance\n    - Monitor financial instruments and indices\n    - Gather historical market data\n    - Build financial analysis workflows\n    - Research investment opportunities",
      "namespace": "search.google",
      "node_type": "search.google.GoogleFinance",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "Stock symbol or company name to search for"
        },
        {
          "name": "window",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Window",
          "description": "Time window for financial data (e.g., '1d', '5d', '1m', '3m', '6m', '1y', '5y')"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "query",
        "window"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Images",
      "description": "Search Google Images to find visual content or perform reverse image search.\n    google, images, serp, visual, reverse, search\n\n    Use cases:\n    - Find images related to a topic or keyword\n    - Perform reverse image searches to find sources\n    - Gather visual assets for projects\n    - Identify similar or related images\n    - Research visual trends and styles",
      "namespace": "search.google",
      "node_type": "search.google.GoogleImages",
      "properties": [
        {
          "name": "keyword",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Keyword",
          "description": "Search query or keyword for images"
        },
        {
          "name": "image_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Image Url",
          "description": "URL of image for reverse image search"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 20,
          "title": "Num Results",
          "description": "Maximum number of image results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "keyword",
        "image_url",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Jobs",
      "description": "Search Google Jobs for employment opportunities and job listings.\n    google, jobs, employment, careers, serp, hiring\n\n    Use cases:\n    - Find job opportunities matching specific criteria\n    - Monitor job market trends\n    - Aggregate job listings for career sites\n    - Research salary ranges and requirements\n    - Track hiring patterns in industries",
      "namespace": "search.google",
      "node_type": "search.google.GoogleJobs",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "Job title, skills, or company name to search for"
        },
        {
          "name": "location",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Location",
          "description": "Geographic location for job search"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Num Results",
          "description": "Maximum number of job results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "job_result"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "query",
        "location",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Lens",
      "description": "Analyze images using Google Lens to find visual matches and related content.\n    google, lens, visual, image, search, serp, identify\n\n    Use cases:\n    - Identify objects, products, or landmarks in images\n    - Find visually similar images\n    - Discover where images appear online\n    - Get information about items shown in photos\n    - Research products and shopping options",
      "namespace": "search.google",
      "node_type": "search.google.GoogleLens",
      "properties": [
        {
          "name": "image_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Image Url",
          "description": "URL of the image to analyze with Google Lens"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Num Results",
          "description": "Maximum number of visual search results to return"
        }
      ],
      "basic_fields": [
        "image_url",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Maps",
      "description": "Search Google Maps for places, businesses, and get location details.\n    google, maps, places, locations, serp, geography\n\n    Use cases:\n    - Find businesses and points of interest\n    - Get location information and addresses\n    - Research geographic areas and neighborhoods\n    - Build location-based applications\n    - Gather place reviews and ratings",
      "namespace": "search.google",
      "node_type": "search.google.GoogleMaps",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "Place name, address, or location query"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Num Results",
          "description": "Maximum number of map results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "local_result"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "query",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google News",
      "description": "Search Google News to retrieve current news articles and headlines.\n    google, news, serp, articles, journalism\n\n    Use cases:\n    - Monitor breaking news and current events\n    - Track news coverage on specific topics\n    - Gather articles for research and analysis\n    - Build news aggregation workflows\n    - Monitor brand mentions in media",
      "namespace": "search.google",
      "node_type": "search.google.GoogleNews",
      "properties": [
        {
          "name": "keyword",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Keyword",
          "description": "Search query or keyword for news articles"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Num Results",
          "description": "Maximum number of news results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "news_result"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "keyword",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Search",
      "description": "Search Google to retrieve organic search results from the web.\n    google, search, serp, web, query\n\n    Use cases:\n    - Find relevant websites and pages on any topic\n    - Research information and gather sources\n    - Discover recent content and trending topics\n    - Gather search engine optimization (SEO) insights\n    - Automate web research workflows",
      "namespace": "search.google",
      "node_type": "search.google.GoogleSearch",
      "properties": [
        {
          "name": "keyword",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Keyword",
          "description": "Search query or keyword to search for"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Num Results",
          "description": "Maximum number of results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "organic_result"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "keyword",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Google Shopping",
      "description": "Search Google Shopping for products with filters and pricing information.\n    google, shopping, products, ecommerce, serp, prices\n\n    Use cases:\n    - Find products and compare prices\n    - Research product availability and options\n    - Monitor pricing trends\n    - Build price comparison tools\n    - Gather product information for e-commerce",
      "namespace": "search.google",
      "node_type": "search.google.GoogleShopping",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "Product name or description to search for"
        },
        {
          "name": "country",
          "type": {
            "type": "str"
          },
          "default": "us",
          "title": "Country",
          "description": "Country code for shopping search (e.g., 'us', 'uk', 'ca')"
        },
        {
          "name": "min_price",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Min Price",
          "description": "Minimum price filter for products"
        },
        {
          "name": "max_price",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Max Price",
          "description": "Maximum price filter for products"
        },
        {
          "name": "condition",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Condition",
          "description": "Product condition filter (e.g., 'new', 'used', 'refurbished')"
        },
        {
          "name": "sort_by",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Sort By",
          "description": "Sort order for results (e.g., 'price_low_to_high', 'price_high_to_low', 'review_score')"
        },
        {
          "name": "num_results",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Num Results",
          "description": "Maximum number of shopping results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "shopping_result"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "query",
        "country",
        "min_price",
        "max_price",
        "condition",
        "sort_by",
        "num_results"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Add Label",
      "description": "Adds a label to a Gmail message.\n    email, gmail, label",
      "namespace": "lib.mail",
      "node_type": "lib.mail.AddLabel",
      "properties": [
        {
          "name": "message_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Message Id",
          "description": "Message ID to label"
        },
        {
          "name": "label",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Label",
          "description": "Label to add to the message"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "message_id",
        "label"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Email Fields",
      "description": "Decomposes an email into its individual components.\n    email, decompose, extract\n\n    Takes an Email object and returns its individual fields:\n    - id: Message ID\n    - subject: Email subject\n    - sender: Sender address\n    - date: Datetime of email\n    - body: Email body content",
      "namespace": "lib.mail",
      "node_type": "lib.mail.EmailFields",
      "properties": [
        {
          "name": "email",
          "type": {
            "type": "email"
          },
          "default": {
            "type": "email",
            "id": "",
            "sender": "",
            "subject": "",
            "date": {
              "type": "datetime",
              "year": 0,
              "month": 0,
              "day": 0,
              "hour": 0,
              "minute": 0,
              "second": 0,
              "microsecond": 0,
              "tzinfo": "UTC",
              "utc_offset": 0
            },
            "body": ""
          },
          "title": "Email",
          "description": "Email object to decompose"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "id"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "subject"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "sender"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "date"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "body"
        }
      ],
      "basic_fields": [
        "email"
      ]
    },
    {
      "title": "Gmail Search",
      "description": "Searches Gmail using Gmail-specific search operators and yields matching emails.\n    email, gmail, search\n\n    Use cases:\n    - Search for emails based on specific criteria\n    - Retrieve emails from a specific sender\n    - Filter emails by subject, sender, or date",
      "namespace": "lib.mail",
      "node_type": "lib.mail.GmailSearch",
      "properties": [
        {
          "name": "from_address",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "From Address",
          "description": "Sender's email address to search for"
        },
        {
          "name": "to_address",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "To Address",
          "description": "Recipient's email address to search for"
        },
        {
          "name": "subject",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Subject",
          "description": "Text to search for in email subject"
        },
        {
          "name": "body",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Body",
          "description": "Text to search for in email body"
        },
        {
          "name": "date_filter",
          "type": {
            "type": "enum",
            "values": [
              "SINCE_ONE_HOUR",
              "SINCE_ONE_DAY",
              "SINCE_ONE_WEEK",
              "SINCE_ONE_MONTH",
              "SINCE_ONE_YEAR"
            ],
            "type_name": "nodetool.nodes.lib.mail.GmailSearch.DateFilter"
          },
          "default": "SINCE_ONE_DAY",
          "title": "Date Filter",
          "description": "Date filter to search for"
        },
        {
          "name": "keywords",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Keywords",
          "description": "Custom keywords or labels to search for"
        },
        {
          "name": "folder",
          "type": {
            "type": "enum",
            "values": [
              "INBOX",
              "[Gmail]/Sent Mail",
              "[Gmail]/Drafts",
              "[Gmail]/Spam",
              "[Gmail]/Trash"
            ],
            "type_name": "nodetool.nodes.lib.mail.GmailSearch.GmailFolder"
          },
          "default": "INBOX",
          "title": "Folder",
          "description": "Email folder to search in"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "General text to search for anywhere in the email"
        },
        {
          "name": "max_results",
          "type": {
            "type": "int"
          },
          "default": 50,
          "title": "Max Results",
          "description": "Maximum number of emails to return"
        },
        {
          "name": "retry_attempts",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "Retry Attempts",
          "description": "Maximum retry attempts for Gmail operations"
        },
        {
          "name": "retry_base_delay",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Retry Base Delay",
          "description": "Base delay (seconds) for exponential backoff"
        },
        {
          "name": "retry_max_delay",
          "type": {
            "type": "float"
          },
          "default": 5.0,
          "title": "Retry Max Delay",
          "description": "Maximum delay (seconds) for exponential backoff"
        },
        {
          "name": "retry_factor",
          "type": {
            "type": "float"
          },
          "default": 2.0,
          "title": "Retry Factor",
          "description": "Exponential growth factor for backoff"
        },
        {
          "name": "retry_jitter",
          "type": {
            "type": "float"
          },
          "default": 0.1,
          "title": "Retry Jitter",
          "description": "Random jitter (seconds) added to each backoff"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "email"
          },
          "name": "email"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "message_id"
        }
      ],
      "basic_fields": [
        "from_address",
        "subject",
        "body",
        "date_filter",
        "max_results"
      ],
      "is_streaming_output": true,
      "expose_as_tool": true
    },
    {
      "title": "Move To Archive",
      "description": "Moves specified emails to Gmail archive.\n    email, gmail, archive",
      "namespace": "lib.mail",
      "node_type": "lib.mail.MoveToArchive",
      "properties": [
        {
          "name": "message_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Message Id",
          "description": "Message ID to archive"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "message_id"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Send Email",
      "description": "Send a plain text email via SMTP.\n    email, smtp, send\n\n    Use cases:\n    - Send simple notification messages\n    - Automate email reports",
      "namespace": "lib.mail",
      "node_type": "lib.mail.SendEmail",
      "properties": [
        {
          "name": "smtp_server",
          "type": {
            "type": "str"
          },
          "default": "smtp.gmail.com",
          "title": "Smtp Server",
          "description": "SMTP server hostname"
        },
        {
          "name": "smtp_port",
          "type": {
            "type": "int"
          },
          "default": 587,
          "title": "Smtp Port",
          "description": "SMTP server port"
        },
        {
          "name": "username",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Username",
          "description": "SMTP username"
        },
        {
          "name": "password",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Password",
          "description": "SMTP password"
        },
        {
          "name": "from_address",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "From Address",
          "description": "Sender email address"
        },
        {
          "name": "to_address",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "To Address",
          "description": "Recipient email address"
        },
        {
          "name": "subject",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Subject",
          "description": "Email subject"
        },
        {
          "name": "body",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Body",
          "description": "Email body"
        },
        {
          "name": "retry_attempts",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "Retry Attempts",
          "description": "Maximum retry attempts for SMTP send"
        },
        {
          "name": "retry_base_delay",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Retry Base Delay",
          "description": "Base delay (seconds) for exponential backoff"
        },
        {
          "name": "retry_max_delay",
          "type": {
            "type": "float"
          },
          "default": 5.0,
          "title": "Retry Max Delay",
          "description": "Maximum delay (seconds) for exponential backoff"
        },
        {
          "name": "retry_factor",
          "type": {
            "type": "float"
          },
          "default": 2.0,
          "title": "Retry Factor",
          "description": "Exponential growth factor for backoff"
        },
        {
          "name": "retry_jitter",
          "type": {
            "type": "float"
          },
          "default": 0.1,
          "title": "Retry Jitter",
          "description": "Random jitter (seconds) added to each backoff"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "smtp_server",
        "smtp_port",
        "username",
        "password",
        "from_address",
        "to_address",
        "subject",
        "body",
        "retry_attempts",
        "retry_base_delay",
        "retry_max_delay",
        "retry_factor",
        "retry_jitter"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Add Heading",
      "description": "Adds a heading to the document\n    document, docx, heading, format",
      "namespace": "lib.docx",
      "node_type": "lib.docx.AddHeading",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document",
          "description": "The document to add the heading to"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The heading text"
        },
        {
          "name": "level",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Level",
          "description": "Heading level (1-9)",
          "min": 1.0,
          "max": 9.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "document",
        "text",
        "level"
      ]
    },
    {
      "title": "Add Image",
      "description": "Adds an image to the document\n    document, docx, image, format",
      "namespace": "lib.docx",
      "node_type": "lib.docx.AddImage",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document",
          "description": "The document to add the image to"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to add"
        },
        {
          "name": "width",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Width",
          "description": "Image width in inches"
        },
        {
          "name": "height",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Height",
          "description": "Image height in inches"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "document",
        "image",
        "width",
        "height"
      ]
    },
    {
      "title": "Add Page Break",
      "description": "Adds a page break to the document\n    document, docx, format, layout",
      "namespace": "lib.docx",
      "node_type": "lib.docx.AddPageBreak",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document",
          "description": "The document to add the page break to"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "document"
      ]
    },
    {
      "title": "Add Paragraph",
      "description": "Adds a paragraph of text to the document\n    document, docx, text, format",
      "namespace": "lib.docx",
      "node_type": "lib.docx.AddParagraph",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document",
          "description": "The document to add the paragraph to"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The paragraph text"
        },
        {
          "name": "alignment",
          "type": {
            "type": "enum",
            "values": [
              "LEFT",
              "CENTER",
              "RIGHT",
              "JUSTIFY"
            ],
            "type_name": "nodetool.nodes.lib.docx.ParagraphAlignment"
          },
          "default": "LEFT",
          "title": "Alignment",
          "description": "Text alignment"
        },
        {
          "name": "bold",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Bold",
          "description": "Make text bold"
        },
        {
          "name": "italic",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Italic",
          "description": "Make text italic"
        },
        {
          "name": "font_size",
          "type": {
            "type": "int"
          },
          "default": 12,
          "title": "Font Size",
          "description": "Font size in points"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "document",
        "text",
        "alignment",
        "bold",
        "italic",
        "font_size"
      ]
    },
    {
      "title": "Add Table",
      "description": "Adds a table to the document\n    document, docx, table, format",
      "namespace": "lib.docx",
      "node_type": "lib.docx.AddTable",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document",
          "description": "The document to add the table to"
        },
        {
          "name": "data",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Data",
          "description": "The data to add to the table"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "document",
        "data"
      ]
    },
    {
      "title": "Create Document",
      "description": "Creates a new Word document\n    document, docx, file, create",
      "namespace": "lib.docx",
      "node_type": "lib.docx.CreateDocument",
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ]
    },
    {
      "title": "Load Word Document",
      "description": "Loads a Word document from disk\n    document, docx, file, load, input",
      "namespace": "lib.docx",
      "node_type": "lib.docx.LoadWordDocument",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the document to load"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Save Document",
      "description": "Writes the document to a file\n    document, docx, file, save, output",
      "namespace": "lib.docx",
      "node_type": "lib.docx.SaveDocument",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document",
          "description": "The document to write"
        },
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {
            "type": "file_path",
            "path": ""
          },
          "title": "Path",
          "description": "The folder to write the document to."
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "\n        The filename to write the document to.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "basic_fields": [
        "document",
        "path",
        "filename"
      ]
    },
    {
      "title": "Set Document Properties",
      "description": "Sets document metadata properties\n    document, docx, metadata, properties",
      "namespace": "lib.docx",
      "node_type": "lib.docx.SetDocumentProperties",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document",
          "description": "The document to modify"
        },
        {
          "name": "title",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Title",
          "description": "Document title"
        },
        {
          "name": "author",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Author",
          "description": "Document author"
        },
        {
          "name": "subject",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Subject",
          "description": "Document subject"
        },
        {
          "name": "keywords",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Keywords",
          "description": "Document keywords"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "document",
        "title",
        "author",
        "subject",
        "keywords"
      ]
    },
    {
      "title": "Combine Image Grid",
      "description": "Combine a grid of image tiles into a single image.\n    image, grid, combine, tiles\n\n    Use cases:\n    - Reassemble processed image chunks\n    - Create composite images from smaller parts\n    - Merge tiled image data from distributed processing",
      "namespace": "lib.grid",
      "node_type": "lib.grid.CombineImageGrid",
      "properties": [
        {
          "name": "tiles",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "default": [],
          "title": "Tiles",
          "description": "List of image tiles to combine."
        },
        {
          "name": "columns",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Columns",
          "description": "Number of columns in the grid.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "tiles",
        "columns"
      ]
    },
    {
      "title": "Slice Image Grid",
      "description": "Slice an image into a grid of tiles.\n    image, grid, slice, tiles\n\n    Use cases:\n    - Prepare large images for processing in smaller chunks\n    - Create image puzzles or mosaic effects\n    - Distribute image processing tasks across multiple workers",
      "namespace": "lib.grid",
      "node_type": "lib.grid.SliceImageGrid",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to slice into a grid."
        },
        {
          "name": "columns",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Columns",
          "description": "Number of columns in the grid.",
          "min": 0.0
        },
        {
          "name": "rows",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Rows",
          "description": "Number of rows in the grid.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "columns",
        "rows"
      ]
    },
    {
      "title": "Extract Feed Metadata",
      "description": "Extracts metadata from an RSS feed.\n    rss, metadata, feed\n\n    Use cases:\n    - Get feed information\n    - Validate feed details\n    - Extract feed metadata",
      "namespace": "lib.rss",
      "node_type": "lib.rss.ExtractFeedMetadata",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL of the RSS feed"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "Fetch RSS Feed",
      "description": "Fetches and parses an RSS feed from a URL.\n    rss, feed, network\n\n    Use cases:\n    - Monitor news feeds\n    - Aggregate content from multiple sources\n    - Process blog updates",
      "namespace": "lib.rss",
      "node_type": "lib.rss.FetchRSSFeed",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL of the RSS feed to fetch"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "title"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "link"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "published"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "summary"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "author"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "is_streaming_output": true,
      "expose_as_tool": true
    },
    {
      "title": "Extract Images",
      "description": "Extract images from a PDF file.\n    pdf, image, extract\n\n    Use cases:\n    - Extract embedded images from PDF documents\n    - Save PDF images as separate files\n    - Process PDF images for analysis",
      "namespace": "lib.pdfplumber",
      "node_type": "lib.pdfplumber.ExtractImages",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": "",
          "title": "Pdf",
          "description": "The PDF file to extract images from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "The start page to extract"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": 4,
          "title": "End Page",
          "description": "The end page to extract"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ]
    },
    {
      "title": "Extract Page Metadata",
      "description": "Extract metadata from PDF pages like dimensions, rotation, etc.\n    pdf, metadata, pages\n\n    Use cases:\n    - Analyze page layouts\n    - Get page dimensions\n    - Check page orientations",
      "namespace": "lib.pdfplumber",
      "node_type": "lib.pdfplumber.ExtractPageMetadata",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": "",
          "title": "Pdf",
          "description": "The PDF file to analyze"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "The start page to extract. 0-based indexing"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": 4,
          "title": "End Page",
          "description": "The end page to extract. -1 for all pages"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ]
    },
    {
      "title": "Extract Tables",
      "description": "Extract tables from a PDF file into dataframes.\n    pdf, tables, dataframe, extract\n\n    Use cases:\n    - Extract tabular data from PDF documents\n    - Convert PDF tables to structured data formats\n    - Process PDF tables for analysis\n    - Import PDF reports into data analysis pipelines",
      "namespace": "lib.pdfplumber",
      "node_type": "lib.pdfplumber.ExtractTables",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Pdf",
          "description": "The PDF document to extract tables from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract tables from (0-based, None for first page)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": 4,
          "title": "End Page",
          "description": "Last page to extract tables from (0-based, None for last page)"
        },
        {
          "name": "table_settings",
          "type": {
            "type": "dict"
          },
          "default": {
            "vertical_strategy": "text",
            "horizontal_strategy": "text",
            "snap_tolerance": 3,
            "join_tolerance": 3,
            "edge_min_length": 3,
            "min_words_vertical": 3,
            "min_words_horizontal": 1,
            "keep_blank_chars": false,
            "text_tolerance": 3,
            "text_x_tolerance": 3,
            "text_y_tolerance": 3
          },
          "title": "Table Settings",
          "description": "Settings for table extraction algorithm"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dataframe"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page",
        "table_settings"
      ]
    },
    {
      "title": "Extract Text",
      "description": "Extract text content from a PDF file.\n    pdf, text, extract\n\n    Use cases:\n    - Convert PDF documents to plain text\n    - Extract content for analysis\n    - Enable text search in PDF documents",
      "namespace": "lib.pdfplumber",
      "node_type": "lib.pdfplumber.ExtractText",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Pdf",
          "description": "The PDF file to extract text from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "The start page to extract. 0-based indexing"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": 4,
          "title": "End Page",
          "description": "The end page to extract. -1 for all pages"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ]
    },
    {
      "title": "Get Page Count",
      "description": "Get the total number of pages in a PDF file.\n    pdf, pages, count\n\n    Use cases:\n    - Check document length\n    - Plan batch processing",
      "namespace": "lib.pdfplumber",
      "node_type": "lib.pdfplumber.GetPageCount",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": "",
          "title": "Pdf",
          "description": "The PDF file to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf"
      ]
    },
    {
      "title": "Delete",
      "description": "Delete records from a Supabase table.\n    supabase, database, delete, remove",
      "namespace": "lib.supabase",
      "node_type": "lib.supabase.Delete",
      "properties": [
        {
          "name": "table_name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Table Name",
          "description": "Table to delete from"
        },
        {
          "name": "filters",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tuple",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "enum",
                    "values": [
                      "eq",
                      "ne",
                      "gt",
                      "gte",
                      "lt",
                      "lte",
                      "in",
                      "like",
                      "contains"
                    ],
                    "type_name": "nodetool.nodes.lib.supabase.FilterOp"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Filters",
          "description": "Filters to select rows to delete (required for safety)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "table_name",
        "filters"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Insert",
      "description": "Insert record(s) into a Supabase table.\n    supabase, database, insert, add, record",
      "namespace": "lib.supabase",
      "node_type": "lib.supabase.Insert",
      "properties": [
        {
          "name": "table_name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Table Name",
          "description": "Table to insert into"
        },
        {
          "name": "records",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "list",
                "type_args": [
                  {
                    "type": "dict",
                    "type_args": [
                      {
                        "type": "str"
                      },
                      {
                        "type": "any"
                      }
                    ]
                  }
                ]
              },
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Records",
          "description": "One or multiple rows to insert"
        },
        {
          "name": "return_rows",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Return Rows",
          "description": "Return inserted rows (uses select('*'))"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "table_name",
        "records",
        "return_rows"
      ],
      "expose_as_tool": true
    },
    {
      "title": "RPC",
      "description": "Call a PostgreSQL function via Supabase RPC.\n    supabase, database, rpc, function",
      "namespace": "lib.supabase",
      "node_type": "lib.supabase.RPC",
      "properties": [
        {
          "name": "function",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Function",
          "description": "RPC function name"
        },
        {
          "name": "params",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Params",
          "description": "Function params"
        },
        {
          "name": "to_dataframe",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "To Dataframe",
          "description": "Return DataframeRef if result is a list of records"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "function",
        "params",
        "to_dataframe"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Select",
      "description": "Query records from a Supabase table.\n    supabase, database, query, select",
      "namespace": "lib.supabase",
      "node_type": "lib.supabase.Select",
      "properties": [
        {
          "name": "table_name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Table Name",
          "description": "Table to query"
        },
        {
          "name": "columns",
          "type": {
            "type": "record_type"
          },
          "default": {
            "type": "record_type",
            "columns": []
          },
          "title": "Columns",
          "description": "Columns to select"
        },
        {
          "name": "filters",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tuple",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "enum",
                    "values": [
                      "eq",
                      "ne",
                      "gt",
                      "gte",
                      "lt",
                      "lte",
                      "in",
                      "like",
                      "contains"
                    ],
                    "type_name": "nodetool.nodes.lib.supabase.FilterOp"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Filters",
          "description": "List of typed filters to apply"
        },
        {
          "name": "order_by",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Order By",
          "description": "Column to order by"
        },
        {
          "name": "descending",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Descending",
          "description": "Order direction"
        },
        {
          "name": "limit",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Limit",
          "description": "Max rows to return (0 = no limit)"
        },
        {
          "name": "to_dataframe",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "To Dataframe",
          "description": "Return a DataframeRef instead of list of dicts"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "table_name",
        "columns",
        "filters",
        "order_by",
        "descending",
        "limit",
        "to_dataframe"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Update",
      "description": "Update records in a Supabase table.\n    supabase, database, update, modify, change",
      "namespace": "lib.supabase",
      "node_type": "lib.supabase.Update",
      "properties": [
        {
          "name": "table_name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Table Name",
          "description": "Table to update"
        },
        {
          "name": "values",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Values",
          "description": "New values"
        },
        {
          "name": "filters",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tuple",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "enum",
                    "values": [
                      "eq",
                      "ne",
                      "gt",
                      "gte",
                      "lt",
                      "lte",
                      "in",
                      "like",
                      "contains"
                    ],
                    "type_name": "nodetool.nodes.lib.supabase.FilterOp"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Filters",
          "description": "Filters to select rows to update"
        },
        {
          "name": "return_rows",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Return Rows",
          "description": "Return updated rows (uses select('*'))"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "table_name",
        "values",
        "filters",
        "return_rows"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Upsert",
      "description": "Insert or update (upsert) records in a Supabase table.\n    supabase, database, upsert, merge",
      "namespace": "lib.supabase",
      "node_type": "lib.supabase.Upsert",
      "properties": [
        {
          "name": "table_name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Table Name",
          "description": "Table to upsert into"
        },
        {
          "name": "records",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "list",
                "type_args": [
                  {
                    "type": "dict",
                    "type_args": [
                      {
                        "type": "str"
                      },
                      {
                        "type": "any"
                      }
                    ]
                  }
                ]
              },
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Records",
          "description": "One or multiple rows to upsert"
        },
        {
          "name": "return_rows",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Return Rows",
          "description": "Return upserted rows (uses select('*'))"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "table_name",
        "records",
        "return_rows"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Convert File",
      "description": "Converts between different document formats using pandoc.\n    convert, document, format, pandoc\n\n    Use cases:\n    - Convert between various document formats (Markdown, HTML, LaTeX, etc.)\n    - Generate documentation in different formats\n    - Create publication-ready documents",
      "namespace": "lib.pandoc",
      "node_type": "lib.pandoc.ConvertFile",
      "properties": [
        {
          "name": "input_path",
          "type": {
            "type": "file_path"
          },
          "default": {
            "type": "file_path",
            "path": ""
          },
          "title": "Input Path",
          "description": "Path to the input file"
        },
        {
          "name": "input_format",
          "type": {
            "type": "enum",
            "values": [
              "biblatex",
              "bibtex",
              "bits",
              "commonmark",
              "commonmark_x",
              "creole",
              "csljson",
              "csv",
              "djot",
              "docbook",
              "docx",
              "dokuwiki",
              "endnotexml",
              "epub",
              "fb2",
              "gfm",
              "haddock",
              "html",
              "ipynb",
              "jats",
              "jira",
              "json",
              "latex",
              "man",
              "markdown",
              "markdown_github",
              "markdown_mmd",
              "markdown_phpextra",
              "markdown_strict",
              "mdoc",
              "mediawiki",
              "muse",
              "native",
              "odt",
              "opml",
              "org",
              "ris",
              "rst",
              "rtf",
              "t2t",
              "textile",
              "tikiwiki",
              "tsv",
              "twiki",
              "typst",
              "vimwiki"
            ],
            "type_name": "nodetool.nodes.lib.pandoc.InputFormat"
          },
          "default": "markdown",
          "title": "Input Format",
          "description": "Input format"
        },
        {
          "name": "output_format",
          "type": {
            "type": "enum",
            "values": [
              "asciidoc",
              "asciidoctor",
              "beamer",
              "context",
              "docbook4",
              "docbook5",
              "docx",
              "epub2",
              "epub3",
              "pdf",
              "plain",
              "pptx",
              "slideous",
              "slidy",
              "dzslides",
              "revealjs",
              "s5",
              "tei",
              "texinfo",
              "zimwiki"
            ],
            "type_name": "nodetool.nodes.lib.pandoc.OutputFormat"
          },
          "default": "pdf",
          "title": "Output Format",
          "description": "Output format"
        },
        {
          "name": "extra_args",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Extra Args",
          "description": "Additional pandoc arguments"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_path",
        "input_format",
        "output_format",
        "extra_args"
      ]
    },
    {
      "title": "Convert Text",
      "description": "Converts text content between different document formats using pandoc.\n    convert, text, format, pandoc\n\n    Use cases:\n    - Convert text content between various formats (Markdown, HTML, LaTeX, etc.)\n    - Transform content without saving to disk\n    - Process text snippets in different formats",
      "namespace": "lib.pandoc",
      "node_type": "lib.pandoc.ConvertText",
      "properties": [
        {
          "name": "content",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Content",
          "description": "Text content to convert"
        },
        {
          "name": "input_format",
          "type": {
            "type": "enum",
            "values": [
              "biblatex",
              "bibtex",
              "bits",
              "commonmark",
              "commonmark_x",
              "creole",
              "csljson",
              "csv",
              "djot",
              "docbook",
              "docx",
              "dokuwiki",
              "endnotexml",
              "epub",
              "fb2",
              "gfm",
              "haddock",
              "html",
              "ipynb",
              "jats",
              "jira",
              "json",
              "latex",
              "man",
              "markdown",
              "markdown_github",
              "markdown_mmd",
              "markdown_phpextra",
              "markdown_strict",
              "mdoc",
              "mediawiki",
              "muse",
              "native",
              "odt",
              "opml",
              "org",
              "ris",
              "rst",
              "rtf",
              "t2t",
              "textile",
              "tikiwiki",
              "tsv",
              "twiki",
              "typst",
              "vimwiki"
            ],
            "type_name": "nodetool.nodes.lib.pandoc.InputFormat"
          },
          "default": "markdown",
          "title": "Input Format",
          "description": "Input format"
        },
        {
          "name": "output_format",
          "type": {
            "type": "enum",
            "values": [
              "asciidoc",
              "asciidoctor",
              "beamer",
              "context",
              "docbook4",
              "docbook5",
              "docx",
              "epub2",
              "epub3",
              "pdf",
              "plain",
              "pptx",
              "slideous",
              "slidy",
              "dzslides",
              "revealjs",
              "s5",
              "tei",
              "texinfo",
              "zimwiki"
            ],
            "type_name": "nodetool.nodes.lib.pandoc.OutputFormat"
          },
          "default": "docx",
          "title": "Output Format",
          "description": "Output format"
        },
        {
          "name": "extra_args",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Extra Args",
          "description": "Additional pandoc arguments"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "content",
        "input_format",
        "output_format",
        "extra_args"
      ]
    },
    {
      "title": "Absolute Path",
      "description": "Return the absolute path of a file or directory.\n    files, path, absolute\n\n    Use cases:\n    - Convert relative paths to absolute\n    - Get full system path\n    - Resolve path references",
      "namespace": "lib.os",
      "node_type": "lib.os.AbsolutePath",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to convert to absolute"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Accessed Time",
      "description": "Get file last accessed timestamp.\n    files, metadata, accessed, time",
      "namespace": "lib.os",
      "node_type": "lib.os.AccessedTime",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Basename",
      "description": "Get the base name component of a file path.\n    files, path, basename\n\n    Use cases:\n    - Extract filename from full path\n    - Get file name without directory\n    - Process file names independently",
      "namespace": "lib.os",
      "node_type": "lib.os.Basename",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "File path to get basename from"
        },
        {
          "name": "remove_extension",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Remove Extension",
          "description": "Remove file extension from basename"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path",
        "remove_extension"
      ]
    },
    {
      "title": "Copy File",
      "description": "Copy a file from source to destination path.\n    files, copy, manage\n\n    Use cases:\n    - Create file backups\n    - Duplicate files for processing\n    - Copy files to new locations",
      "namespace": "lib.os",
      "node_type": "lib.os.CopyFile",
      "properties": [
        {
          "name": "source_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Source Path",
          "description": "Source file path"
        },
        {
          "name": "destination_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Destination Path",
          "description": "Destination file path"
        }
      ],
      "basic_fields": [
        "source_path",
        "destination_path"
      ]
    },
    {
      "title": "Create Directory",
      "description": "Create a new directory at specified path.\n    files, directory, create\n\n    Use cases:\n    - Set up directory structure for file organization\n    - Create output directories for processed files",
      "namespace": "lib.os",
      "node_type": "lib.os.CreateDirectory",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Directory path to create"
        },
        {
          "name": "exist_ok",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Exist Ok",
          "description": "Don't error if directory already exists"
        }
      ],
      "basic_fields": [
        "path",
        "exist_ok"
      ]
    },
    {
      "title": "Created Time",
      "description": "Get file creation timestamp.\n    files, metadata, created, time",
      "namespace": "lib.os",
      "node_type": "lib.os.CreatedTime",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Dirname",
      "description": "Get the directory name component of a file path.\n    files, path, dirname\n\n    Use cases:\n    - Extract directory path from full path\n    - Get parent directory\n    - Process directory paths",
      "namespace": "lib.os",
      "node_type": "lib.os.Dirname",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "File path to get dirname from"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "File Exists",
      "description": "Check if a file or directory exists at the specified path.\n    files, check, exists\n\n    Use cases:\n    - Validate file presence before processing\n    - Implement conditional logic based on file existence",
      "namespace": "lib.os",
      "node_type": "lib.os.FileExists",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to check for existence"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "File Extension",
      "description": "Get file extension.\n    files, metadata, extension",
      "namespace": "lib.os",
      "node_type": "lib.os.FileExtension",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "File Name",
      "description": "Get file name without path.\n    files, metadata, name",
      "namespace": "lib.os",
      "node_type": "lib.os.FileName",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "File Name Match",
      "description": "Match a filename against a pattern using Unix shell-style wildcards.\n    files, pattern, match, filter\n\n    Use cases:\n    - Filter files by name pattern\n    - Validate file naming conventions\n    - Match file extensions",
      "namespace": "lib.os",
      "node_type": "lib.os.FileNameMatch",
      "properties": [
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Filename to check"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "*",
          "title": "Pattern",
          "description": "Pattern to match against (e.g. *.txt, data_*.csv)"
        },
        {
          "name": "case_sensitive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Case Sensitive",
          "description": "Whether the pattern matching should be case-sensitive"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "filename",
        "pattern",
        "case_sensitive"
      ]
    },
    {
      "title": "Filter File Names",
      "description": "Filter a list of filenames using Unix shell-style wildcards.\n    files, pattern, filter, list\n\n    Use cases:\n    - Filter multiple files by pattern\n    - Batch process files matching criteria\n    - Select files by extension",
      "namespace": "lib.os",
      "node_type": "lib.os.FilterFileNames",
      "properties": [
        {
          "name": "filenames",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Filenames",
          "description": "list of filenames to filter"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "*",
          "title": "Pattern",
          "description": "Pattern to filter by (e.g. *.txt, data_*.csv)"
        },
        {
          "name": "case_sensitive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Case Sensitive",
          "description": "Whether the pattern matching should be case-sensitive"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "filenames",
        "pattern",
        "case_sensitive"
      ]
    },
    {
      "title": "Get Directory",
      "description": "Get directory containing the file.\n    files, metadata, directory",
      "namespace": "lib.os",
      "node_type": "lib.os.GetDirectory",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Get File Size",
      "description": "Get file size in bytes.\n    files, metadata, size",
      "namespace": "lib.os",
      "node_type": "lib.os.GetFileSize",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Get Path Info",
      "description": "Gets information about a path.\n    path, info, metadata\n\n    Use cases:\n    - Extract path components\n    - Parse file paths",
      "namespace": "lib.os",
      "node_type": "lib.os.GetPathInfo",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Is Directory",
      "description": "Check if path is a directory.\n    files, metadata, type",
      "namespace": "lib.os",
      "node_type": "lib.os.IsDirectory",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Is File",
      "description": "Check if path is a file.\n    files, metadata, type",
      "namespace": "lib.os",
      "node_type": "lib.os.IsFile",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Join Paths",
      "description": "Joins path components.\n    path, join, combine\n\n    Use cases:\n    - Build file paths\n    - Create cross-platform paths",
      "namespace": "lib.os",
      "node_type": "lib.os.JoinPaths",
      "properties": [
        {
          "name": "paths",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Paths",
          "description": "Path components to join"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "paths"
      ]
    },
    {
      "title": "List Files",
      "description": "list files in a directory matching a pattern.\n    files, list, directory\n\n    Use cases:\n    - Get files for batch processing\n    - Filter files by extension or pattern",
      "namespace": "lib.os",
      "node_type": "lib.os.ListFiles",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "str"
          },
          "default": "~",
          "title": "Folder",
          "description": "Directory to scan"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "*",
          "title": "Pattern",
          "description": "File pattern to match (e.g. *.txt)"
        },
        {
          "name": "include_subdirectories",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Include Subdirectories",
          "description": "Search subdirectories"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "file"
        }
      ],
      "basic_fields": [
        "folder",
        "pattern",
        "include_subdirectories"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Modified Time",
      "description": "Get file last modified timestamp.\n    files, metadata, modified, time",
      "namespace": "lib.os",
      "node_type": "lib.os.ModifiedTime",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Move File",
      "description": "Move a file from source to destination path.\n    files, move, manage\n\n    Use cases:\n    - Organize files into directories\n    - Process and archive files\n    - Relocate completed files",
      "namespace": "lib.os",
      "node_type": "lib.os.MoveFile",
      "properties": [
        {
          "name": "source_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Source Path",
          "description": "Source file path"
        },
        {
          "name": "destination_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Destination Path",
          "description": "Destination file path"
        }
      ],
      "basic_fields": [
        "source_path",
        "destination_path"
      ]
    },
    {
      "title": "Normalize Path",
      "description": "Normalizes a path.\n    path, normalize, clean\n\n    Use cases:\n    - Standardize paths\n    - Remove redundant separators",
      "namespace": "lib.os",
      "node_type": "lib.os.NormalizePath",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to normalize"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Open Workspace Directory",
      "description": "Open the workspace directory.\n    files, workspace, directory",
      "namespace": "lib.os",
      "node_type": "lib.os.OpenWorkspaceDirectory",
      "outputs": [
        {
          "type": {
            "type": "none"
          },
          "name": "output"
        }
      ]
    },
    {
      "title": "Path To String",
      "description": "Convert a FilePath object to a string.\n    files, path, string, convert\n\n    Use cases:\n    - Get raw string path from FilePath object\n    - Convert FilePath for string operations\n    - Extract path string for external use",
      "namespace": "lib.os",
      "node_type": "lib.os.PathToString",
      "properties": [
        {
          "name": "file_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "File Path",
          "description": "File path to convert to string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "file_path"
      ]
    },
    {
      "title": "Relative Path",
      "description": "Return a relative path to a target from a start directory.\n    files, path, relative\n\n    Use cases:\n    - Create relative path references\n    - Generate portable paths\n    - Compare file locations",
      "namespace": "lib.os",
      "node_type": "lib.os.RelativePath",
      "properties": [
        {
          "name": "target_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Target Path",
          "description": "Target path to convert to relative"
        },
        {
          "name": "start_path",
          "type": {
            "type": "str"
          },
          "default": ".",
          "title": "Start Path",
          "description": "Start path for relative conversion"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "target_path",
        "start_path"
      ]
    },
    {
      "title": "Show Notification",
      "description": "Shows a system notification.\n    notification, system, alert\n\n    Use cases:\n    - Alert user of completed tasks\n    - Show process status\n    - Display important messages",
      "namespace": "lib.os",
      "node_type": "lib.os.ShowNotification",
      "properties": [
        {
          "name": "title",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Title",
          "description": "Title of the notification"
        },
        {
          "name": "message",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Message",
          "description": "Content of the notification"
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Timeout",
          "description": "How long the notification should stay visible (in seconds)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "none"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "title",
        "message",
        "timeout"
      ]
    },
    {
      "title": "Split Extension",
      "description": "Split a path into root and extension components.\n    files, path, extension, split\n\n    Use cases:\n    - Extract file extension\n    - Process filename without extension\n    - Handle file types",
      "namespace": "lib.os",
      "node_type": "lib.os.SplitExtension",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to split"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Split Path",
      "description": "Split a path into directory and file components.\n    files, path, split\n\n    Use cases:\n    - Separate directory from filename\n    - Process path components separately\n    - Extract path parts",
      "namespace": "lib.os",
      "node_type": "lib.os.SplitPath",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to split"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path"
      ]
    },
    {
      "title": "Workspace Directory",
      "description": "Get the workspace directory.\n    files, workspace, directory",
      "namespace": "lib.os",
      "node_type": "lib.os.WorkspaceDirectory",
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ]
    },
    {
      "title": "Chart Renderer",
      "description": "Node responsible for rendering chart configurations into image format using seaborn.\n    chart, seaborn, plot, visualization, data",
      "namespace": "lib.seaborn",
      "node_type": "lib.seaborn.ChartRenderer",
      "properties": [
        {
          "name": "chart_config",
          "type": {
            "type": "chart_config"
          },
          "default": {
            "type": "chart_config",
            "title": "",
            "x_label": "",
            "y_label": "",
            "legend": true,
            "data": {
              "type": "chart_data",
              "series": [],
              "row": null,
              "col": null,
              "col_wrap": null
            },
            "height": null,
            "aspect": null,
            "x_lim": null,
            "y_lim": null,
            "x_scale": null,
            "y_scale": null,
            "legend_position": "auto",
            "palette": null,
            "hue_order": null,
            "hue_norm": null,
            "sizes": null,
            "size_order": null,
            "size_norm": null,
            "marginal_kws": null,
            "joint_kws": null,
            "diag_kind": null,
            "corner": false,
            "center": null,
            "vmin": null,
            "vmax": null,
            "cmap": null,
            "annot": false,
            "fmt": ".2g",
            "square": false
          },
          "title": "Chart Config",
          "description": "The chart configuration to render."
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 640,
          "title": "Width",
          "description": "The width of the chart in pixels.",
          "min": 0.0,
          "max": 10000.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 480,
          "title": "Height",
          "description": "The height of the chart in pixels.",
          "min": 0.0,
          "max": 10000.0
        },
        {
          "name": "data",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Data",
          "description": "The data to visualize as a pandas DataFrame."
        },
        {
          "name": "despine",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Despine",
          "description": "Whether to remove top and right spines."
        },
        {
          "name": "trim_margins",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Trim Margins",
          "description": "Whether to use tight layout for margins."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "chart_config",
        "width",
        "height",
        "data",
        "despine",
        "trim_margins"
      ]
    },
    {
      "title": "Auto Fit Columns",
      "description": "Automatically adjusts column widths to fit content.\n    excel, format, columns\n\n    Use cases:\n    - Improve spreadsheet readability\n    - Professional presentation",
      "namespace": "lib.excel",
      "node_type": "lib.excel.AutoFitColumns",
      "properties": [
        {
          "name": "workbook",
          "type": {
            "type": "excel"
          },
          "default": {
            "type": "excel",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Workbook",
          "description": "The Excel workbook to format"
        },
        {
          "name": "sheet_name",
          "type": {
            "type": "str"
          },
          "default": "Sheet1",
          "title": "Sheet Name",
          "description": "Target worksheet name"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "workbook",
        "sheet_name"
      ]
    },
    {
      "title": "Create Workbook",
      "description": "Creates a new Excel workbook.\n    excel, workbook, create\n\n    Use cases:\n    - Initialize new Excel files\n    - Start spreadsheet creation workflows",
      "namespace": "lib.excel",
      "node_type": "lib.excel.CreateWorkbook",
      "properties": [
        {
          "name": "sheet_name",
          "type": {
            "type": "str"
          },
          "default": "Sheet1",
          "title": "Sheet Name",
          "description": "Name for the first worksheet"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "excel"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "sheet_name"
      ]
    },
    {
      "title": "Data Frame To Excel",
      "description": "Writes a DataFrame to an Excel worksheet.\n    excel, dataframe, export\n\n    Use cases:\n    - Export data analysis results\n    - Create reports from data",
      "namespace": "lib.excel",
      "node_type": "lib.excel.DataFrameToExcel",
      "properties": [
        {
          "name": "workbook",
          "type": {
            "type": "excel"
          },
          "default": {
            "type": "excel",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Workbook",
          "description": "The Excel workbook to write to"
        },
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {
            "type": "dataframe",
            "uri": "",
            "asset_id": null,
            "data": null,
            "columns": null
          },
          "title": "Dataframe",
          "description": "DataFrame to write"
        },
        {
          "name": "sheet_name",
          "type": {
            "type": "str"
          },
          "default": "Sheet1",
          "title": "Sheet Name",
          "description": "Target worksheet name"
        },
        {
          "name": "start_cell",
          "type": {
            "type": "str"
          },
          "default": "A1",
          "title": "Start Cell",
          "description": "Starting cell for data"
        },
        {
          "name": "include_header",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Include Header",
          "description": "Include column headers"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "workbook",
        "dataframe",
        "sheet_name",
        "start_cell",
        "include_header"
      ]
    },
    {
      "title": "Excel To Data Frame",
      "description": "Reads an Excel worksheet into a pandas DataFrame.\n    excel, dataframe, import\n\n    Use cases:\n    - Import Excel data for analysis\n    - Process spreadsheet contents",
      "namespace": "lib.excel",
      "node_type": "lib.excel.ExcelToDataFrame",
      "properties": [
        {
          "name": "workbook",
          "type": {
            "type": "excel"
          },
          "default": {
            "type": "excel",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Workbook",
          "description": "The Excel workbook to read from"
        },
        {
          "name": "sheet_name",
          "type": {
            "type": "str"
          },
          "default": "Sheet1",
          "title": "Sheet Name",
          "description": "Source worksheet name"
        },
        {
          "name": "has_header",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Has Header",
          "description": "First row contains headers"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "workbook",
        "sheet_name",
        "has_header"
      ]
    },
    {
      "title": "Format Cells",
      "description": "Applies formatting to a range of cells.\n    excel, format, style\n\n    Use cases:\n    - Highlight important data\n    - Create professional looking reports",
      "namespace": "lib.excel",
      "node_type": "lib.excel.FormatCells",
      "properties": [
        {
          "name": "workbook",
          "type": {
            "type": "excel"
          },
          "default": {
            "type": "excel",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Workbook",
          "description": "The Excel workbook to format"
        },
        {
          "name": "sheet_name",
          "type": {
            "type": "str"
          },
          "default": "Sheet1",
          "title": "Sheet Name",
          "description": "Target worksheet name"
        },
        {
          "name": "cell_range",
          "type": {
            "type": "str"
          },
          "default": "A1:B10",
          "title": "Cell Range",
          "description": "Cell range to format (e.g. 'A1:B10')"
        },
        {
          "name": "bold",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Bold",
          "description": "Make text bold"
        },
        {
          "name": "background_color",
          "type": {
            "type": "str"
          },
          "default": "FFFF00",
          "title": "Background Color",
          "description": "Background color in hex format (e.g. 'FFFF00' for yellow)"
        },
        {
          "name": "text_color",
          "type": {
            "type": "str"
          },
          "default": "000000",
          "title": "Text Color",
          "description": "Text color in hex format"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "workbook",
        "sheet_name",
        "cell_range",
        "bold",
        "background_color",
        "text_color"
      ]
    },
    {
      "title": "Save Workbook",
      "description": "Saves an Excel workbook to disk.\n    excel, save, export\n\n    Use cases:\n    - Export final spreadsheet\n    - Save work in progress",
      "namespace": "lib.excel",
      "node_type": "lib.excel.SaveWorkbook",
      "properties": [
        {
          "name": "workbook",
          "type": {
            "type": "excel"
          },
          "default": {
            "type": "excel",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Workbook",
          "description": "The Excel workbook to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "file_path"
          },
          "default": {
            "type": "file_path",
            "path": ""
          },
          "title": "Folder",
          "description": "The folder to save the file to."
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "\n        The filename to save the file to.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "basic_fields": [
        "workbook",
        "folder",
        "filename"
      ]
    },
    {
      "title": "Create Table",
      "description": "Create a new SQLite table with specified columns.\n    sqlite, database, table, create, schema\n\n    Use cases:\n    - Initialize database schema for flashcards\n    - Set up tables for persistent storage\n    - Create memory structures for agents",
      "namespace": "lib.sqlite",
      "node_type": "lib.sqlite.CreateTable",
      "properties": [
        {
          "name": "database_name",
          "type": {
            "type": "str"
          },
          "default": "memory.db",
          "title": "Database Name",
          "description": "Name of the SQLite database file"
        },
        {
          "name": "table_name",
          "type": {
            "type": "str"
          },
          "default": "flashcards",
          "title": "Table Name",
          "description": "Name of the table to create"
        },
        {
          "name": "columns",
          "type": {
            "type": "record_type"
          },
          "default": {
            "type": "record_type",
            "columns": []
          },
          "title": "Columns",
          "description": "Column definitions"
        },
        {
          "name": "add_primary_key",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Add Primary Key",
          "description": "Automatically make first integer column PRIMARY KEY AUTOINCREMENT"
        },
        {
          "name": "if_not_exists",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "If Not Exists",
          "description": "Only create table if it doesn't exist"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "database_name"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "table_name"
        },
        {
          "type": {
            "type": "record_type"
          },
          "name": "columns"
        }
      ],
      "basic_fields": [
        "database_name",
        "table_name",
        "columns",
        "add_primary_key",
        "if_not_exists"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Delete",
      "description": "Delete records from a SQLite table.\n    sqlite, database, delete, remove, drop\n\n    Use cases:\n    - Remove flashcards\n    - Delete agent memory\n    - Clean up old data",
      "namespace": "lib.sqlite",
      "node_type": "lib.sqlite.Delete",
      "properties": [
        {
          "name": "database_name",
          "type": {
            "type": "str"
          },
          "default": "memory.db",
          "title": "Database Name",
          "description": "Name of the SQLite database file"
        },
        {
          "name": "table_name",
          "type": {
            "type": "str"
          },
          "default": "flashcards",
          "title": "Table Name",
          "description": "Name of the table to delete from"
        },
        {
          "name": "where",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Where",
          "description": "WHERE clause (without 'WHERE' keyword), e.g., 'id = 1'. REQUIRED for safety."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "database_name",
        "table_name",
        "where"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Execute SQL",
      "description": "Execute arbitrary SQL statements for advanced operations.\n    sqlite, database, sql, execute, custom\n\n    Use cases:\n    - Complex queries with joins\n    - Aggregate functions (COUNT, SUM, AVG)\n    - Custom SQL operations",
      "namespace": "lib.sqlite",
      "node_type": "lib.sqlite.ExecuteSQL",
      "properties": [
        {
          "name": "database_name",
          "type": {
            "type": "str"
          },
          "default": "memory.db",
          "title": "Database Name",
          "description": "Name of the SQLite database file"
        },
        {
          "name": "sql",
          "type": {
            "type": "str"
          },
          "default": "SELECT * FROM flashcards",
          "title": "Sql",
          "description": "SQL statement to execute"
        },
        {
          "name": "parameters",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Parameters",
          "description": "Parameters for parameterized queries (use ? in SQL)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "database_name",
        "sql",
        "parameters"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Get Database Path",
      "description": "Get the full path to a SQLite database file.\n    sqlite, database, path, location\n\n    Use cases:\n    - Reference database location\n    - Verify database exists\n    - Pass path to external tools",
      "namespace": "lib.sqlite",
      "node_type": "lib.sqlite.GetDatabasePath",
      "properties": [
        {
          "name": "database_name",
          "type": {
            "type": "str"
          },
          "default": "memory.db",
          "title": "Database Name",
          "description": "Name of the SQLite database file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "database_name"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Insert",
      "description": "Insert a record into a SQLite table.\n    sqlite, database, insert, add, record\n\n    Use cases:\n    - Add new flashcards to database\n    - Store agent observations\n    - Persist workflow results",
      "namespace": "lib.sqlite",
      "node_type": "lib.sqlite.Insert",
      "properties": [
        {
          "name": "database_name",
          "type": {
            "type": "str"
          },
          "default": "memory.db",
          "title": "Database Name",
          "description": "Name of the SQLite database file"
        },
        {
          "name": "table_name",
          "type": {
            "type": "str"
          },
          "default": "flashcards",
          "title": "Table Name",
          "description": "Name of the table to insert into"
        },
        {
          "name": "data",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {
            "content": "example"
          },
          "title": "Data",
          "description": "Data to insert as dict (column: value)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "database_name",
        "table_name",
        "data"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Query",
      "description": "Query records from a SQLite table.\n    sqlite, database, query, select, search, retrieve\n\n    Use cases:\n    - Retrieve flashcards for review\n    - Search agent memory\n    - Fetch stored data",
      "namespace": "lib.sqlite",
      "node_type": "lib.sqlite.Query",
      "properties": [
        {
          "name": "database_name",
          "type": {
            "type": "str"
          },
          "default": "memory.db",
          "title": "Database Name",
          "description": "Name of the SQLite database file"
        },
        {
          "name": "table_name",
          "type": {
            "type": "str"
          },
          "default": "flashcards",
          "title": "Table Name",
          "description": "Name of the table to query"
        },
        {
          "name": "where",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Where",
          "description": "WHERE clause (without 'WHERE' keyword), e.g., 'id = 1'"
        },
        {
          "name": "columns",
          "type": {
            "type": "record_type"
          },
          "default": {
            "type": "record_type",
            "columns": []
          },
          "title": "Columns",
          "description": "Columns to select"
        },
        {
          "name": "order_by",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Order By",
          "description": "ORDER BY clause (without 'ORDER BY' keyword)"
        },
        {
          "name": "limit",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Limit",
          "description": "Maximum number of rows to return (0 = no limit)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "database_name",
        "table_name",
        "where",
        "columns",
        "order_by",
        "limit"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Update",
      "description": "Update records in a SQLite table.\n    sqlite, database, update, modify, change\n\n    Use cases:\n    - Update flashcard content\n    - Modify stored records\n    - Change agent memory",
      "namespace": "lib.sqlite",
      "node_type": "lib.sqlite.Update",
      "properties": [
        {
          "name": "database_name",
          "type": {
            "type": "str"
          },
          "default": "memory.db",
          "title": "Database Name",
          "description": "Name of the SQLite database file"
        },
        {
          "name": "table_name",
          "type": {
            "type": "str"
          },
          "default": "flashcards",
          "title": "Table Name",
          "description": "Name of the table to update"
        },
        {
          "name": "data",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {
            "content": "updated"
          },
          "title": "Data",
          "description": "Data to update as dict (column: new_value)"
        },
        {
          "name": "where",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Where",
          "description": "WHERE clause (without 'WHERE' keyword), e.g., 'id = 1'"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "database_name",
        "table_name",
        "data",
        "where"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Browser",
      "description": "Fetches content from a web page using a headless browser.\n    browser, web, scraping, content, fetch\n\n    Use cases:\n    - Extract content from JavaScript-heavy websites\n    - Retrieve text content from web pages\n    - Get metadata from web pages\n    - Save extracted content to files",
      "namespace": "lib.browser",
      "node_type": "lib.browser.Browser",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to navigate to"
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 20000,
          "title": "Timeout",
          "description": "Timeout in milliseconds for page navigation"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "success"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "content"
        },
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "metadata"
        }
      ],
      "basic_fields": [
        "url",
        "timeout"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Browser Navigation",
      "description": "Navigates and interacts with web pages in a browser session.\n    browser, navigation, interaction, click, extract\n\n    Use cases:\n    - Perform complex web interactions\n    - Navigate through multi-step web processes\n    - Extract content after interaction",
      "namespace": "lib.browser",
      "node_type": "lib.browser.BrowserNavigation",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to navigate to (required for 'goto' action)"
        },
        {
          "name": "action",
          "type": {
            "type": "enum",
            "values": [
              "click",
              "goto",
              "back",
              "forward",
              "reload",
              "extract"
            ],
            "type_name": "nodetool.nodes.lib.browser.BrowserNavigation.Action"
          },
          "default": "goto",
          "title": "Action",
          "description": "Navigation or extraction action to perform"
        },
        {
          "name": "selector",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Selector",
          "description": "CSS selector for the element to interact with or extract from"
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 30000,
          "title": "Timeout",
          "description": "Timeout in milliseconds for the action"
        },
        {
          "name": "wait_for",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Wait For",
          "description": "Optional selector to wait for after performing the action"
        },
        {
          "name": "extract_type",
          "type": {
            "type": "enum",
            "values": [
              "text",
              "html",
              "value",
              "attribute"
            ],
            "type_name": "nodetool.nodes.lib.browser.BrowserNavigation.ExtractType"
          },
          "default": "text",
          "title": "Extract Type",
          "description": "Type of content to extract (for 'extract' action)"
        },
        {
          "name": "attribute",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Attribute",
          "description": "Attribute name to extract (when extract_type is 'attribute')"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url",
        "action",
        "selector",
        "timeout",
        "wait_for",
        "extract_type",
        "attribute"
      ]
    },
    {
      "title": "Browser Use",
      "description": "Browser agent tool that uses browser_use under the hood.\n\n    This module provides a tool for running browser-based agents using the browser_use library.\n    The agent can perform complex web automation tasks like form filling, navigation, data extraction,\n    and multi-step workflows using natural language instructions.\n\n    Use cases:\n    - Perform complex web automation tasks based on natural language.\n    - Automate form filling and data entry.\n    - Scrape data after complex navigation or interaction sequences.\n    - Automate multi-step web workflows.",
      "namespace": "lib.browser",
      "node_type": "lib.browser.BrowserUse",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gpt-4o",
              "claude-3-5-sonnet"
            ],
            "type_name": "nodetool.nodes.lib.browser.BrowserUseModel"
          },
          "default": "gpt-4o",
          "title": "Model",
          "description": "The model to use for the browser agent."
        },
        {
          "name": "task",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Task",
          "description": "Natural language description of the browser task to perform. Can include complex multi-step instructions like 'Compare prices between websites', 'Fill out forms', or 'Extract specific data'."
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 300,
          "title": "Timeout",
          "description": "Maximum time in seconds to allow for task completion. Complex tasks may require longer timeouts.",
          "min": 1.0,
          "max": 3600.0
        },
        {
          "name": "use_remote_browser",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Use Remote Browser",
          "description": "Use a remote browser instead of a local one"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "success"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "task"
        },
        {
          "type": {
            "type": "any"
          },
          "name": "result"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "error"
        }
      ],
      "basic_fields": [
        "model",
        "task",
        "timeout",
        "use_remote_browser"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Download File",
      "description": "Downloads a file from a URL and saves it to disk.\n    download, file, web, save\n\n    Use cases:\n    - Download documents, images, or other files from the web\n    - Save data for further processing\n    - Retrieve file assets for analysis",
      "namespace": "lib.browser",
      "node_type": "lib.browser.DownloadFile",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL of the file to download"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Screenshot",
      "description": "Takes a screenshot of a web page or specific element.\n    browser, screenshot, capture, image\n\n    Use cases:\n    - Capture visual representation of web pages\n    - Document specific UI elements\n    - Create visual records of web content",
      "namespace": "lib.browser",
      "node_type": "lib.browser.Screenshot",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to navigate to before taking screenshot"
        },
        {
          "name": "selector",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Selector",
          "description": "Optional CSS selector for capturing a specific element"
        },
        {
          "name": "output_file",
          "type": {
            "type": "str"
          },
          "default": "screenshot.png",
          "title": "Output File",
          "description": "Path to save the screenshot (relative to workspace)"
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 30000,
          "title": "Timeout",
          "description": "Timeout in milliseconds for page navigation"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url",
        "selector",
        "output_file",
        "timeout"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Web Fetch",
      "description": "Fetches HTML content from a URL and converts it to text.\n    web, fetch, html, markdown, http\n\n    Use cases:\n    - Extract text content from web pages\n    - Process web content for analysis\n    - Save web content to files",
      "namespace": "lib.browser",
      "node_type": "lib.browser.WebFetch",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to fetch content from"
        },
        {
          "name": "selector",
          "type": {
            "type": "str"
          },
          "default": "body",
          "title": "Selector",
          "description": "CSS selector to extract specific elements"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url",
        "selector"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Paddle OCR",
      "description": "Performs Optical Character Recognition (OCR) on images using PaddleOCR.\n    image, text, ocr, document\n\n    Use cases:\n    - Text extraction from images\n    - Document digitization\n    - Receipt/invoice processing\n    - Handwriting recognition",
      "namespace": "lib.ocr",
      "node_type": "lib.ocr.PaddleOCR",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Input Image",
          "description": "The image to perform OCR on"
        },
        {
          "name": "language",
          "type": {
            "type": "enum",
            "values": [
              "en",
              "fr",
              "de",
              "es",
              "it",
              "pt",
              "nl",
              "pl",
              "ro",
              "hr",
              "cs",
              "hu",
              "sk",
              "sl",
              "tr",
              "vi",
              "id",
              "ms",
              "la",
              "ru",
              "bg",
              "uk",
              "be",
              "mn",
              "ch",
              "ja",
              "ko",
              "ar",
              "fa",
              "ur",
              "hi",
              "mr",
              "ne",
              "sa"
            ],
            "type_name": "nodetool.nodes.lib.ocr.OCRLanguage"
          },
          "default": "en",
          "title": "Language",
          "description": "Language code for OCR"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "ocr_result"
              }
            ]
          },
          "name": "boxes"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        }
      ],
      "basic_fields": [
        "image",
        "language"
      ]
    },
    {
      "title": "Convert To Markdown",
      "description": "Converts various document formats to markdown using MarkItDown.\n    markdown, convert, document\n\n    Use cases:\n    - Convert Word documents to markdown\n    - Convert Excel files to markdown tables\n    - Convert PowerPoint to markdown content",
      "namespace": "lib.markitdown",
      "node_type": "lib.markitdown.ConvertToMarkdown",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Document",
          "description": "The document to convert to markdown"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "document"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Get Secret",
      "description": "Get a secret value from configuration.\n    secrets, credentials, configuration",
      "namespace": "lib.secret",
      "node_type": "lib.secret.GetSecret",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "Secret key name"
        },
        {
          "name": "default",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Default",
          "description": "Default value if not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str",
            "optional": true
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "default"
      ]
    },
    {
      "title": "Base Url",
      "description": "Extract the base URL from a given URL.\n    url parsing, domain extraction, web utilities\n\n    Use cases:\n    - Get domain name from full URLs\n    - Clean up URLs for comparison\n    - Extract root website addresses\n    - Standardize URL formats",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.BaseUrl",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "URL",
          "description": "The URL to extract the base from"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "Extract Audio",
      "description": "Extract audio elements from HTML content.\n    extract, audio, src\n\n    Use cases:\n    - Collect audio sources from web pages\n    - Analyze audio usage on websites\n    - Create audio playlists",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractAudio",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract audio from."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "The base URL of the page, used to resolve relative audio URLs."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        }
      ],
      "basic_fields": [
        "html",
        "base_url"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Extract Images",
      "description": "Extract images from HTML content.\n    extract, images, src\n\n    Use cases:\n    - Collect images from web pages\n    - Analyze image usage on websites\n    - Create image galleries",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractImages",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract images from."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "The base URL of the page, used to resolve relative image URLs."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "image"
        }
      ],
      "basic_fields": [
        "html",
        "base_url"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Extract Links",
      "description": "Extract all links from HTML content with type classification.\n    extract, links, urls, web scraping, html\n\n    Use cases:\n    - Analyze website structure and navigation\n    - Discover related content and resources\n    - Build sitemaps and link graphs\n    - Find internal and external references\n    - Collect URLs for further processing",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractLinks",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract links from."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "The base URL of the page, used to determine internal/external links."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "href"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "type"
        }
      ],
      "basic_fields": [
        "html",
        "base_url"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Extract Metadata",
      "description": "Extract metadata from HTML content.\n    extract, metadata, seo\n\n    Use cases:\n    - Analyze SEO elements\n    - Gather page information\n    - Extract structured data",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractMetadata",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract metadata from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "title"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "description"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "keywords"
        }
      ],
      "basic_fields": [
        "html"
      ]
    },
    {
      "title": "Extract Videos",
      "description": "Extract videos from HTML content.\n    extract, videos, src\n\n    Use cases:\n    - Collect video sources from web pages\n    - Analyze video usage on websites\n    - Create video playlists",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractVideos",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract videos from."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "The base URL of the page, used to resolve relative video URLs."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "video"
        }
      ],
      "basic_fields": [
        "html",
        "base_url"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Convert HTML to Text",
      "description": "Converts HTML to plain text by removing tags and decoding entities using BeautifulSoup.\n    html, text, convert\n\n    Use cases:\n    - Cleaning HTML content for text analysis\n    - Extracting readable content from web pages\n    - Preparing HTML data for natural language processing",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.HTMLToText",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "HTML"
        },
        {
          "name": "preserve_linebreaks",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Preserve Line Breaks",
          "description": "Convert block-level elements to newlines"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "preserve_linebreaks"
      ]
    },
    {
      "title": "Website Content Extractor",
      "description": "Extract main content from a website, removing navigation, ads, and other non-essential elements.\n    scrape, web scraping, content extraction, text analysis\n\n    Use cases:\n    - Clean web content for further analysis\n    - Extract article text from news websites\n    - Prepare web content for summarization",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.WebsiteContentExtractor",
      "properties": [
        {
          "name": "html_content",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html Content",
          "description": "The raw HTML content of the website."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "html_content"
      ]
    },
    {
      "title": "Circle",
      "description": "Generate SVG circle element with customizable position, radius, and styling.\n    svg, shape, vector, circle\n\n    Use cases:\n    - Create circular shapes and icons\n    - Design buttons, badges, and indicators\n    - Build data visualizations like pie charts\n    - Create decorative elements and patterns",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Circle",
      "properties": [
        {
          "name": "cx",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Cx",
          "description": "Center X coordinate"
        },
        {
          "name": "cy",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Cy",
          "description": "Center Y coordinate"
        },
        {
          "name": "radius",
          "type": {
            "type": "int"
          },
          "default": 50,
          "title": "Radius",
          "description": "Radius"
        },
        {
          "name": "fill",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Fill",
          "description": "Fill color"
        },
        {
          "name": "stroke",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "none"
          },
          "title": "Stroke",
          "description": "Stroke color"
        },
        {
          "name": "stroke_width",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Stroke Width",
          "description": "Stroke width"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "cx",
        "cy",
        "radius",
        "fill",
        "stroke",
        "stroke_width"
      ]
    },
    {
      "title": "Clip Path",
      "description": "Create clipping paths for SVG elements.\n    svg, clip, mask\n\n    Use cases:\n    - Mask parts of elements\n    - Create complex shapes through clipping\n    - Apply visual effects using masks",
      "namespace": "lib.svg",
      "node_type": "lib.svg.ClipPath",
      "properties": [
        {
          "name": "clip_content",
          "type": {
            "type": "svg_element"
          },
          "default": {
            "type": "svg_element",
            "name": "",
            "attributes": {},
            "content": null,
            "children": []
          },
          "title": "Clip Content",
          "description": "SVG element to use as clip path"
        },
        {
          "name": "content",
          "type": {
            "type": "svg_element"
          },
          "default": {
            "type": "svg_element",
            "name": "",
            "attributes": {},
            "content": null,
            "children": []
          },
          "title": "Content",
          "description": "SVG element to clip"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "clip_content",
        "content"
      ]
    },
    {
      "title": "SVG Document",
      "description": "Combine SVG elements into a complete SVG document.\n    svg, document, combine\n\n    Use cases:\n    - Combine multiple SVG elements into a single document\n    - Set document-level properties like viewBox and dimensions\n    - Export complete SVG documents",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Document",
      "properties": [
        {
          "name": "content",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "svg_element"
              },
              {
                "type": "list",
                "type_args": [
                  {
                    "type": "svg_element"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Content",
          "description": "SVG content"
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 800,
          "title": "Width",
          "description": "Document width",
          "min": 1.0,
          "max": 4096.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 600,
          "title": "Height",
          "description": "Document height",
          "min": 1.0,
          "max": 4096.0
        },
        {
          "name": "viewBox",
          "type": {
            "type": "str"
          },
          "default": "0 0 800 600",
          "title": "Viewbox",
          "description": "SVG viewBox attribute"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "content",
        "width",
        "height",
        "viewBox"
      ]
    },
    {
      "title": "Drop Shadow",
      "description": "Apply drop shadow filter effect to SVG elements for depth.\n    svg, filter, shadow, effects\n\n    Use cases:\n    - Add depth and elevation to elements\n    - Create realistic shadow effects\n    - Enhance visual hierarchy\n    - Improve element separation and readability",
      "namespace": "lib.svg",
      "node_type": "lib.svg.DropShadow",
      "properties": [
        {
          "name": "std_deviation",
          "type": {
            "type": "float"
          },
          "default": 3.0,
          "title": "Std Deviation",
          "description": "Standard deviation for blur"
        },
        {
          "name": "dx",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Dx",
          "description": "X offset for shadow"
        },
        {
          "name": "dy",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Dy",
          "description": "Y offset for shadow"
        },
        {
          "name": "color",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Color",
          "description": "Color for shadow"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "std_deviation",
        "dx",
        "dy",
        "color"
      ]
    },
    {
      "title": "Ellipse",
      "description": "Generate SVG ellipse element with customizable position, radii, and styling.\n    svg, shape, vector, ellipse\n\n    Use cases:\n    - Create oval shapes and organic forms\n    - Design speech bubbles and callouts\n    - Build data visualization elements\n    - Create decorative patterns and borders",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Ellipse",
      "properties": [
        {
          "name": "cx",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Cx",
          "description": "Center X coordinate"
        },
        {
          "name": "cy",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Cy",
          "description": "Center Y coordinate"
        },
        {
          "name": "rx",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Rx",
          "description": "X radius"
        },
        {
          "name": "ry",
          "type": {
            "type": "int"
          },
          "default": 50,
          "title": "Ry",
          "description": "Y radius"
        },
        {
          "name": "fill",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Fill",
          "description": "Fill color"
        },
        {
          "name": "stroke",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "none"
          },
          "title": "Stroke",
          "description": "Stroke color"
        },
        {
          "name": "stroke_width",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Stroke Width",
          "description": "Stroke width"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "cx",
        "cy",
        "rx",
        "ry",
        "fill",
        "stroke",
        "stroke_width"
      ]
    },
    {
      "title": "Gaussian Blur",
      "description": "Apply Gaussian blur filter effect to SVG elements.\n    svg, filter, blur, effects\n\n    Use cases:\n    - Create soft focus and depth effects\n    - Add subtle shadows and glows\n    - Simulate motion blur\n    - Soften edges in graphics",
      "namespace": "lib.svg",
      "node_type": "lib.svg.GaussianBlur",
      "properties": [
        {
          "name": "std_deviation",
          "type": {
            "type": "float"
          },
          "default": 3.0,
          "title": "Std Deviation",
          "description": "Standard deviation for blur"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "std_deviation"
      ]
    },
    {
      "title": "Gradient",
      "description": "Create linear or radial gradients for SVG elements.\n    svg, gradient, color\n\n    Use cases:\n    - Add smooth color transitions\n    - Create complex color effects\n    - Define reusable gradient definitions",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Gradient",
      "properties": [
        {
          "name": "gradient_type",
          "type": {
            "type": "enum",
            "values": [
              "linearGradient",
              "radialGradient"
            ],
            "type_name": "nodetool.nodes.lib.svg.Gradient.GradientType"
          },
          "default": "linearGradient",
          "title": "Gradient Type",
          "description": "Type of gradient"
        },
        {
          "name": "x1",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "X1",
          "description": "Start X position (linear) or center X (radial)"
        },
        {
          "name": "y1",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Y1",
          "description": "Start Y position (linear) or center Y (radial)"
        },
        {
          "name": "x2",
          "type": {
            "type": "float"
          },
          "default": 100,
          "title": "X2",
          "description": "End X position (linear) or radius X (radial)"
        },
        {
          "name": "y2",
          "type": {
            "type": "float"
          },
          "default": 100,
          "title": "Y2",
          "description": "End Y position (linear) or radius Y (radial)"
        },
        {
          "name": "color1",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Color1",
          "description": "Start color of gradient"
        },
        {
          "name": "color2",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#FFFFFF"
          },
          "title": "Color2",
          "description": "End color of gradient"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "gradient_type",
        "x1",
        "y1",
        "x2",
        "y2",
        "color1",
        "color2"
      ]
    },
    {
      "title": "Line",
      "description": "Generate SVG line element with customizable endpoints and styling.\n    svg, shape, vector, line\n\n    Use cases:\n    - Draw straight lines and connectors\n    - Create dividers and separators\n    - Build diagrams and flowcharts\n    - Design grid patterns and borders",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Line",
      "properties": [
        {
          "name": "x1",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "X1",
          "description": "Start X coordinate"
        },
        {
          "name": "y1",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Y1",
          "description": "Start Y coordinate"
        },
        {
          "name": "x2",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "X2",
          "description": "End X coordinate"
        },
        {
          "name": "y2",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Y2",
          "description": "End Y coordinate"
        },
        {
          "name": "stroke",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Stroke",
          "description": "Stroke color"
        },
        {
          "name": "stroke_width",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Stroke Width",
          "description": "Stroke width"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "x1",
        "y1",
        "x2",
        "y2",
        "stroke",
        "stroke_width"
      ]
    },
    {
      "title": "Path",
      "description": "Generate SVG path element using path data commands.\n    svg, shape, vector, path\n\n    Use cases:\n    - Create complex curved and custom shapes\n    - Build logos and custom icons\n    - Design intricate patterns and illustrations\n    - Import path data from design tools",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Path",
      "properties": [
        {
          "name": "path_data",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path Data",
          "description": "SVG path data (d attribute)"
        },
        {
          "name": "fill",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Fill",
          "description": "Fill color"
        },
        {
          "name": "stroke",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "none"
          },
          "title": "Stroke",
          "description": "Stroke color"
        },
        {
          "name": "stroke_width",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Stroke Width",
          "description": "Stroke width"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "path_data",
        "fill",
        "stroke",
        "stroke_width"
      ]
    },
    {
      "title": "Polygon",
      "description": "Generate SVG polygon element with multiple vertices.\n    svg, shape, vector, polygon\n\n    Use cases:\n    - Create multi-sided shapes like triangles, pentagons, stars\n    - Build custom icons and symbols\n    - Design complex geometric patterns\n    - Create irregular shapes and forms",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Polygon",
      "properties": [
        {
          "name": "points",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Points",
          "description": "Points in format 'x1,y1 x2,y2 x3,y3...'"
        },
        {
          "name": "fill",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Fill",
          "description": "Fill color"
        },
        {
          "name": "stroke",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "none"
          },
          "title": "Stroke",
          "description": "Stroke color"
        },
        {
          "name": "stroke_width",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Stroke Width",
          "description": "Stroke width"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "points",
        "fill",
        "stroke",
        "stroke_width"
      ]
    },
    {
      "title": "Rectangle",
      "description": "Generate SVG rectangle element with customizable position, size, and styling.\n    svg, shape, vector, rectangle\n\n    Use cases:\n    - Create rectangular shapes in SVG documents\n    - Design borders, frames, and backgrounds\n    - Build user interface components\n    - Create geometric patterns and layouts",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Rect",
      "properties": [
        {
          "name": "x",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "X",
          "description": "X coordinate"
        },
        {
          "name": "y",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Y",
          "description": "Y coordinate"
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Width",
          "description": "Width"
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Height",
          "description": "Height"
        },
        {
          "name": "fill",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Fill",
          "description": "Fill color"
        },
        {
          "name": "stroke",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "none"
          },
          "title": "Stroke",
          "description": "Stroke color"
        },
        {
          "name": "stroke_width",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Stroke Width",
          "description": "Stroke width"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "x",
        "y",
        "width",
        "height",
        "fill",
        "stroke",
        "stroke_width"
      ]
    },
    {
      "title": "SVG to Image",
      "description": "Create an SVG document and convert it to a raster image in one step.\n    svg, document, raster, convert\n\n    Use cases:\n    - Create and rasterize SVG documents in a single operation\n    - Generate image files from SVG elements\n    - Convert vector graphics to bitmap format with custom dimensions",
      "namespace": "lib.svg",
      "node_type": "lib.svg.SVGToImage",
      "properties": [
        {
          "name": "content",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "svg_element"
              },
              {
                "type": "list",
                "type_args": [
                  {
                    "type": "svg_element"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Content",
          "description": "SVG content"
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 800,
          "title": "Width",
          "description": "Document width",
          "min": 1.0,
          "max": 4096.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 600,
          "title": "Height",
          "description": "Document height",
          "min": 1.0,
          "max": 4096.0
        },
        {
          "name": "viewBox",
          "type": {
            "type": "str"
          },
          "default": "0 0 800 600",
          "title": "Viewbox",
          "description": "SVG viewBox attribute"
        },
        {
          "name": "scale",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Scale",
          "description": "Scale factor for rasterization",
          "min": 1.0,
          "max": 10.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "content",
        "width",
        "height",
        "viewBox",
        "scale"
      ]
    },
    {
      "title": "Text",
      "description": "Add text elements to SVG.\n    svg, text, typography\n\n    Use cases:\n    - Add labels to vector graphics\n    - Create text-based logos\n    - Generate dynamic text content in SVGs",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Text",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text content"
        },
        {
          "name": "x",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "X",
          "description": "X coordinate"
        },
        {
          "name": "y",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Y",
          "description": "Y coordinate"
        },
        {
          "name": "font_family",
          "type": {
            "type": "str"
          },
          "default": "Arial",
          "title": "Font Family",
          "description": "Font family"
        },
        {
          "name": "font_size",
          "type": {
            "type": "int"
          },
          "default": 16,
          "title": "Font Size",
          "description": "Font size"
        },
        {
          "name": "fill",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Fill",
          "description": "Text color"
        },
        {
          "name": "text_anchor",
          "type": {
            "type": "enum",
            "values": [
              "start",
              "middle",
              "end"
            ],
            "type_name": "nodetool.nodes.lib.svg.SVGTextAnchor"
          },
          "default": "start",
          "title": "Text Anchor",
          "description": "Text anchor position"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "x",
        "y",
        "font_family",
        "font_size",
        "fill",
        "text_anchor"
      ]
    },
    {
      "title": "Transform",
      "description": "Apply transformations to SVG elements.\n    svg, transform, animation\n\n    Use cases:\n    - Rotate, scale, or translate elements\n    - Create complex transformations\n    - Prepare elements for animation",
      "namespace": "lib.svg",
      "node_type": "lib.svg.Transform",
      "properties": [
        {
          "name": "content",
          "type": {
            "type": "svg_element"
          },
          "default": {
            "type": "svg_element",
            "name": "",
            "attributes": {},
            "content": null,
            "children": []
          },
          "title": "Content",
          "description": "SVG element to transform"
        },
        {
          "name": "translate_x",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Translate X",
          "description": "X translation"
        },
        {
          "name": "translate_y",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Translate Y",
          "description": "Y translation"
        },
        {
          "name": "rotate",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Rotate",
          "description": "Rotation angle in degrees"
        },
        {
          "name": "scale_x",
          "type": {
            "type": "float"
          },
          "default": 1,
          "title": "Scale X",
          "description": "X scale factor"
        },
        {
          "name": "scale_y",
          "type": {
            "type": "float"
          },
          "default": 1,
          "title": "Scale Y",
          "description": "Y scale factor"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "svg_element"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "content",
        "translate_x",
        "translate_y",
        "rotate",
        "scale_x",
        "scale_y"
      ]
    },
    {
      "title": "Extract Bullet Lists",
      "description": "Extracts bulleted lists from markdown.\n    markdown, lists, bullets, extraction\n\n    Use cases:\n    - Extract unordered list items\n    - Analyze bullet point structures\n    - Convert bullet lists to structured data",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractBulletLists",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "markdown"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Code Blocks",
      "description": "Extracts code blocks and their languages from markdown.\n    markdown, code, extraction\n\n    Use cases:\n    - Extract code samples for analysis\n    - Collect programming examples\n    - Analyze code snippets in documentation",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractCodeBlocks",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "markdown"
      ]
    },
    {
      "title": "Extract Headers",
      "description": "Extracts headers and creates a document structure/outline.\n    markdown, headers, structure\n\n    Use cases:\n    - Generate table of contents\n    - Analyze document structure\n    - Extract main topics from documents",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractHeaders",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        },
        {
          "name": "max_level",
          "type": {
            "type": "int"
          },
          "default": 6,
          "title": "Max Level",
          "description": "Maximum header level to extract (1-6)",
          "min": 1.0,
          "max": 6.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "markdown",
        "max_level"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Links",
      "description": "Extracts all links from markdown text.\n    markdown, links, extraction\n\n    Use cases:\n    - Extract references and citations from academic documents\n    - Build link graphs from markdown documentation\n    - Analyze external resources referenced in markdown files",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractLinks",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        },
        {
          "name": "include_titles",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Include Titles",
          "description": "Whether to include link titles in output"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "markdown",
        "include_titles"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Numbered Lists",
      "description": "Extracts numbered lists from markdown.\n    markdown, lists, numbered, extraction\n\n    Use cases:\n    - Extract ordered list items\n    - Analyze enumerated structures\n    - Convert numbered lists to structured data",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractNumberedLists",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "markdown"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Tables",
      "description": "Extracts tables from markdown and converts them to structured data.\n    markdown, tables, data\n\n    Use cases:\n    - Extract tabular data from markdown\n    - Convert markdown tables to structured formats\n    - Analyze tabulated information",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractTables",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "markdown"
      ],
      "expose_as_tool": true
    },
    {
      "title": "DELETE Request",
      "description": "Remove a resource from a server using an HTTP DELETE request.\n    http, delete, request, url\n\n    Use cases:\n    - Delete user accounts\n    - Remove API resources\n    - Cancel subscriptions\n    - Clear cache entries",
      "namespace": "lib.http",
      "node_type": "lib.http.DeleteRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Download Dataframe",
      "description": "Download data from a URL and return as a dataframe.\n    http, get, request, url, dataframe, csv, json, data\n\n    Use cases:\n    - Download CSV data and convert to dataframe\n    - Fetch JSON data and convert to dataframe\n    - Retrieve tabular data from APIs\n    - Process data files from URLs",
      "namespace": "lib.http",
      "node_type": "lib.http.DownloadDataframe",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "file_format",
          "type": {
            "type": "enum",
            "values": [
              "csv",
              "json",
              "tsv"
            ],
            "type_name": "nodetool.nodes.lib.http.DownloadDataframe.FileFormat"
          },
          "default": "csv",
          "title": "File Format",
          "description": "The format of the data file (csv, json, tsv)."
        },
        {
          "name": "columns",
          "type": {
            "type": "record_type"
          },
          "default": {
            "type": "record_type",
            "columns": []
          },
          "title": "Columns",
          "description": "The columns of the dataframe."
        },
        {
          "name": "encoding",
          "type": {
            "type": "str"
          },
          "default": "utf-8",
          "title": "Encoding",
          "description": "The encoding of the text file."
        },
        {
          "name": "delimiter",
          "type": {
            "type": "str"
          },
          "default": ",",
          "title": "Delimiter",
          "description": "The delimiter for CSV/TSV files."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url",
        "columns",
        "file_format"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Download Files",
      "description": "Download files from a list of URLs into a local folder.\n    download, files, urls, batch\n\n    Use cases:\n    - Batch download files from multiple URLs\n    - Create local copies of remote resources\n    - Archive web content\n    - Download datasets",
      "namespace": "lib.http",
      "node_type": "lib.http.DownloadFiles",
      "properties": [
        {
          "name": "urls",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Urls",
          "description": "List of URLs to download."
        },
        {
          "name": "output_folder",
          "type": {
            "type": "str"
          },
          "default": "downloads",
          "title": "Output Folder",
          "description": "Local folder path where files will be saved."
        },
        {
          "name": "max_concurrent_downloads",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "Max Concurrent Downloads",
          "description": "Maximum number of concurrent downloads."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "success"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "failed"
        }
      ],
      "basic_fields": [
        "urls",
        "output_folder",
        "max_concurrent_downloads"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Fetch Page",
      "description": "Fetch a web page using Selenium and return its content.\n    selenium, fetch, webpage, http\n\n    Use cases:\n    - Retrieve content from dynamic websites\n    - Capture JavaScript-rendered content\n    - Interact with web applications",
      "namespace": "lib.http",
      "node_type": "lib.http.FetchPage",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to fetch the page from."
        },
        {
          "name": "wait_time",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Wait Time",
          "description": "Maximum time to wait for page load (in seconds)."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "html"
        },
        {
          "type": {
            "type": "bool"
          },
          "name": "success"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "error_message"
        }
      ],
      "basic_fields": [
        "url",
        "wait_time"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Filter Valid URLs",
      "description": "Filter a list of URLs by checking their validity using HEAD requests.\n    url validation, http, head request\n\n    Use cases:\n    - Clean URL lists by removing broken links\n    - Verify resource availability\n    - Validate website URLs before processing",
      "namespace": "lib.http",
      "node_type": "lib.http.FilterValidURLs",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "urls",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Urls",
          "description": "List of URLs to validate."
        },
        {
          "name": "max_concurrent_requests",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Max Concurrent Requests",
          "description": "Maximum number of concurrent HEAD requests."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "GET Request",
      "description": "Perform an HTTP GET request to retrieve data from a specified URL.\n    http, get, request, url\n\n    Use cases:\n    - Fetch web page content\n    - Retrieve API data\n    - Download files\n    - Check website availability",
      "namespace": "lib.http",
      "node_type": "lib.http.GetRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "GET Binary",
      "description": "Perform an HTTP GET request and return raw binary data.\n    http, get, request, url, binary, download\n\n    Use cases:\n    - Download binary files\n    - Fetch images or media\n    - Retrieve PDF documents\n    - Download any non-text content",
      "namespace": "lib.http",
      "node_type": "lib.http.GetRequestBinary",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "GET Document",
      "description": "Perform an HTTP GET request and return a document\n    http, get, request, url, document\n\n    Use cases:\n    - Download PDF documents\n    - Retrieve Word documents\n    - Fetch Excel files\n    - Download any document format",
      "namespace": "lib.http",
      "node_type": "lib.http.GetRequestDocument",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "HEAD Request",
      "description": "Retrieve headers from a resource using an HTTP HEAD request.\n    http, head, request, url\n\n    Use cases:\n    - Check resource existence\n    - Get metadata without downloading content\n    - Verify authentication or permissions",
      "namespace": "lib.http",
      "node_type": "lib.http.HeadRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "Image Downloader",
      "description": "Download images from list of URLs and return a list of ImageRefs.\n    image download, web scraping, data processing\n\n    Use cases:\n    - Prepare image datasets for machine learning tasks\n    - Archive images from web pages\n    - Process and analyze images extracted from websites",
      "namespace": "lib.http",
      "node_type": "lib.http.ImageDownloader",
      "properties": [
        {
          "name": "images",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Images",
          "description": "List of image URLs to download."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "Base URL to prepend to relative image URLs."
        },
        {
          "name": "max_concurrent_downloads",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Max Concurrent Downloads",
          "description": "Maximum number of concurrent image downloads."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "name": "images"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "failed_urls"
        }
      ],
      "basic_fields": [
        "images",
        "base_url",
        "max_concurrent_downloads"
      ],
      "expose_as_tool": true
    },
    {
      "title": "GET JSON",
      "description": "Perform an HTTP GET request and parse the response as JSON.\n    http, get, request, url, json, api\n\n    Use cases:\n    - Fetch data from REST APIs\n    - Retrieve JSON-formatted responses\n    - Interface with JSON web services",
      "namespace": "lib.http",
      "node_type": "lib.http.JSONGetRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "PATCH JSON",
      "description": "Partially update resources with JSON data using an HTTP PATCH request.\n    http, patch, request, url, json, api\n\n    Use cases:\n    - Partial updates to API resources\n    - Modify specific fields without full replacement\n    - Efficient updates for large objects",
      "namespace": "lib.http",
      "node_type": "lib.http.JSONPatchRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Data",
          "description": "The JSON data to send in the PATCH request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "POST JSON",
      "description": "Send JSON data to a server using an HTTP POST request.\n    http, post, request, url, json, api\n\n    Use cases:\n    - Send structured data to REST APIs\n    - Create resources with JSON payloads\n    - Interface with modern web services",
      "namespace": "lib.http",
      "node_type": "lib.http.JSONPostRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Data",
          "description": "The JSON data to send in the POST request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "PUT JSON",
      "description": "Update resources with JSON data using an HTTP PUT request.\n    http, put, request, url, json, api\n\n    Use cases:\n    - Update existing API resources\n    - Replace complete objects in REST APIs\n    - Set configuration with JSON data",
      "namespace": "lib.http",
      "node_type": "lib.http.JSONPutRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Data",
          "description": "The JSON data to send in the PUT request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ]
    },
    {
      "title": "POST Request",
      "description": "Send data to a server using an HTTP POST request.\n    http, post, request, url, data\n\n    Use cases:\n    - Submit form data\n    - Create new resources on an API\n    - Upload files\n    - Authenticate users",
      "namespace": "lib.http",
      "node_type": "lib.http.PostRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Data",
          "description": "The data to send in the POST request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "POST Binary",
      "description": "Send data using an HTTP POST request and return raw binary data.\n    http, post, request, url, data, binary\n\n    Use cases:\n    - Upload and receive binary files\n    - Interact with binary APIs\n    - Process image or media uploads\n    - Handle binary file transformations",
      "namespace": "lib.http",
      "node_type": "lib.http.PostRequestBinary",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "bytes"
              }
            ]
          },
          "default": "",
          "title": "Data",
          "description": "The data to send in the POST request. Can be string or binary."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "PUT Request",
      "description": "Update existing resources on a server using an HTTP PUT request.\n    http, put, request, url, data\n\n    Use cases:\n    - Update user profiles\n    - Modify existing API resources\n    - Replace file contents\n    - Set configuration values",
      "namespace": "lib.http",
      "node_type": "lib.http.PutRequest",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Data",
          "description": "The data to send in the PUT request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "url"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Add",
      "description": "Adds two numbers together.\n    math, add, plus, +, sum\n\n    Use cases:\n    - Perform basic arithmetic operations\n    - Calculate totals and sums\n    - Combine numerical values\n    - Increment counters and scores",
      "namespace": "lib.math",
      "node_type": "lib.math.Add",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Cosine",
      "description": "Computes cosine of the given angle in radians.\n    math, cosine, trig",
      "namespace": "lib.math",
      "node_type": "lib.math.Cosine",
      "layout": "small",
      "properties": [
        {
          "name": "angle_rad",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "Angle (rad)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "angle_rad"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Divide",
      "description": "Divides A by B to calculate the quotient.\n    math, divide, division, quotient, /\n\n    Use cases:\n    - Calculate averages and ratios\n    - Distribute quantities evenly\n    - Determine rates and proportions\n    - Compute per-unit values",
      "namespace": "lib.math",
      "node_type": "lib.math.Divide",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 1.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Math Function",
      "description": "Performs a selected unary math operation on an input.\n    math, negate, absolute, square, cube, square_root, cube_root, sine, cosine, tangent, arcsine, arccosine, arctangent, log,   -, abs, ^2, ^3, sqrt, cbrt, sin, cos, tan, asin, acos, atan, log",
      "namespace": "lib.math",
      "node_type": "lib.math.MathFunction",
      "layout": "small",
      "properties": [
        {
          "name": "input",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "Input"
        },
        {
          "name": "operation",
          "type": {
            "type": "enum",
            "values": [
              "negate",
              "absolute",
              "square",
              "cube",
              "square_root",
              "cube_root",
              "sine",
              "cosine",
              "tangent",
              "arcsin",
              "arccos",
              "arctan",
              "log"
            ],
            "type_name": "nodetool.nodes.lib.math.MathFunction.Operation"
          },
          "default": "negate",
          "title": "Operation",
          "description": "Unary operation to perform"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input",
        "operation"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Modulus",
      "description": "Computes A modulo B to find the remainder after division.\n    math, modulus, modulo, remainder, %\n\n    Use cases:\n    - Determine if numbers are even or odd\n    - Implement cyclic patterns and rotations\n    - Calculate remainders in division\n    - Build repeating sequences",
      "namespace": "lib.math",
      "node_type": "lib.math.Modulus",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 1.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Multiply",
      "description": "Multiplies two numbers together.\n    math, multiply, product, *, times\n\n    Use cases:\n    - Calculate products and totals\n    - Scale values by factors\n    - Compute areas and volumes\n    - Apply multipliers and rates",
      "namespace": "lib.math",
      "node_type": "lib.math.Multiply",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Power",
      "description": "Raises base to the given exponent.\n    math, power, exponent, ^",
      "namespace": "lib.math",
      "node_type": "lib.math.Power",
      "layout": "small",
      "properties": [
        {
          "name": "base",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "Base"
        },
        {
          "name": "exponent",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 1.0,
          "title": "Exponent"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "base",
        "exponent"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Sine",
      "description": "Computes sine of the given angle in radians.\n    math, sine, trig",
      "namespace": "lib.math",
      "node_type": "lib.math.Sine",
      "layout": "small",
      "properties": [
        {
          "name": "angle_rad",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "Angle (rad)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "angle_rad"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Sqrt",
      "description": "Computes square root of x.\n    math, sqrt, square_root",
      "namespace": "lib.math",
      "node_type": "lib.math.Sqrt",
      "layout": "small",
      "properties": [
        {
          "name": "x",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "X"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "x"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Subtract",
      "description": "Subtracts B from A.\n    math, subtract, minus, -, difference\n\n    Use cases:\n    - Calculate differences between values\n    - Determine remaining amounts\n    - Compute offsets and deltas\n    - Track decrements and reductions",
      "namespace": "lib.math",
      "node_type": "lib.math.Subtract",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Add Time Delta",
      "description": "Add or subtract time from a datetime using specified intervals.\n    datetime, add, subtract, delta, offset\n\n    Use cases:\n    - Calculate future/past dates\n    - Generate date ranges\n    - Schedule events at specific intervals\n    - Calculate expiration dates and deadlines",
      "namespace": "lib.date",
      "node_type": "lib.date.AddTimeDelta",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Input Datetime",
          "description": "Starting datetime"
        },
        {
          "name": "days",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Days",
          "description": "Number of days to add (negative to subtract)",
          "min": -3650.0,
          "max": 3650.0
        },
        {
          "name": "hours",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Hours",
          "description": "Number of hours to add (negative to subtract)",
          "min": -24.0,
          "max": 24.0
        },
        {
          "name": "minutes",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Minutes",
          "description": "Number of minutes to add (negative to subtract)",
          "min": -60.0,
          "max": 60.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_datetime",
        "days",
        "hours",
        "minutes"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Boundary Time",
      "description": "Get the start or end boundary of a time period (day, week, month, year).\n    datetime, start, end, boundary, day, week, month, year\n\n    Use cases:\n    - Get period boundaries for reporting and analytics\n    - Normalize dates to period starts/ends\n    - Calculate billing cycles\n    - Group data by time periods",
      "namespace": "lib.date",
      "node_type": "lib.date.BoundaryTime",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Input Datetime",
          "description": "Input datetime"
        },
        {
          "name": "period",
          "type": {
            "type": "enum",
            "values": [
              "day",
              "week",
              "month",
              "year"
            ],
            "type_name": "nodetool.nodes.lib.date.PeriodType"
          },
          "default": "day",
          "title": "Period",
          "description": "Time period type"
        },
        {
          "name": "boundary",
          "type": {
            "type": "enum",
            "values": [
              "start",
              "end"
            ],
            "type_name": "nodetool.nodes.lib.date.BoundaryType"
          },
          "default": "start",
          "title": "Boundary",
          "description": "Start or end of period"
        },
        {
          "name": "start_monday",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Start Monday",
          "description": "For week period: Consider Monday as start of week (False for Sunday)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_datetime",
        "period",
        "boundary",
        "start_monday"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Date Difference",
      "description": "Calculate the time difference between two datetimes.\n    datetime, difference, duration, elapsed\n\n    Use cases:\n    - Calculate time periods between events\n    - Measure durations and elapsed time\n    - Track age or time since events\n    - Compute service level agreement (SLA) metrics",
      "namespace": "lib.date",
      "node_type": "lib.date.DateDifference",
      "properties": [
        {
          "name": "start_date",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Start Date",
          "description": "Start datetime"
        },
        {
          "name": "end_date",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "End Date",
          "description": "End datetime"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "total_seconds"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "days"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "hours"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "minutes"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "seconds"
        }
      ],
      "basic_fields": [
        "start_date",
        "end_date"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Date Range",
      "description": "Generate a list of dates between start and end dates with custom intervals.\n    datetime, range, list, sequence\n\n    Use cases:\n    - Generate date sequences for reporting\n    - Create date-based iterations in workflows\n    - Build calendar views\n    - Schedule recurring events",
      "namespace": "lib.date",
      "node_type": "lib.date.DateRange",
      "properties": [
        {
          "name": "start_date",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Start Date",
          "description": "Start date of the range"
        },
        {
          "name": "end_date",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "End Date",
          "description": "End date of the range"
        },
        {
          "name": "step_days",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Step Days",
          "description": "Number of days between each date"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "datetime"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "start_date",
        "end_date",
        "step_days"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Date To Datetime",
      "description": "Convert a Date object to a Datetime object at midnight.\n    date, datetime, convert, transformation\n\n    Use cases:\n    - Convert dates to datetime for time calculations\n    - Standardize date types in workflows\n    - Prepare dates for timestamp comparisons\n    - Convert legacy date formats",
      "namespace": "lib.date",
      "node_type": "lib.date.DateToDatetime",
      "properties": [
        {
          "name": "input_date",
          "type": {
            "type": "date"
          },
          "default": {
            "type": "date",
            "year": 0,
            "month": 0,
            "day": 0
          },
          "title": "Input Date",
          "description": "Date to convert"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_date"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Datetime To Date",
      "description": "Convert a Datetime object to a Date object, removing time component.\n    date, datetime, convert, transformation\n\n    Use cases:\n    - Extract date portion from timestamps\n    - Remove time information for date-only comparisons\n    - Normalize datetime data to dates\n    - Simplify date-based grouping",
      "namespace": "lib.date",
      "node_type": "lib.date.DatetimeToDate",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Input Datetime",
          "description": "Datetime to convert"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "date"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_datetime"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Format Date Time",
      "description": "Convert a datetime object to a custom formatted string.\n    datetime, format, convert, string\n\n    Use cases:\n    - Standardize date formats across systems\n    - Prepare dates for different locales and regions\n    - Generate human-readable date strings\n    - Format dates for filenames and reports",
      "namespace": "lib.date",
      "node_type": "lib.date.FormatDateTime",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Input Datetime",
          "description": "Datetime object to format"
        },
        {
          "name": "output_format",
          "type": {
            "type": "enum",
            "values": [
              "%Y-%m-%d",
              "%m/%d/%Y",
              "%d/%m/%Y",
              "%B %d, %Y",
              "%Y%m%d",
              "%Y%m%d_%H%M%S",
              "%Y-%m-%dT%H:%M:%S",
              "%Y-%m-%dT%H:%M:%S%z",
              "%Y-%m-%dT%H:%M:%S%z"
            ],
            "type_name": "nodetool.nodes.lib.date.DateFormat"
          },
          "default": "%B %d, %Y",
          "title": "Output Format",
          "description": "Desired output format"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_datetime",
        "output_format"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Get Quarter",
      "description": "Get the quarter number and start/end dates for a given datetime.\n    datetime, quarter, period, fiscal\n\n    Use cases:\n    - Financial reporting periods\n    - Quarterly analytics and metrics\n    - Business cycle calculations\n    - Group data by fiscal quarters",
      "namespace": "lib.date",
      "node_type": "lib.date.GetQuarter",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Input Datetime",
          "description": "Input datetime"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "quarter"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "quarter_start"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "quarter_end"
        }
      ],
      "basic_fields": [
        "input_datetime"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Get Weekday",
      "description": "Get the weekday name or number from a datetime.\n    datetime, weekday, name, day\n\n    Use cases:\n    - Get day names for scheduling and calendar displays\n    - Filter events by weekday\n    - Build day-of-week based logic\n    - Generate weekly reports",
      "namespace": "lib.date",
      "node_type": "lib.date.GetWeekday",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Input Datetime",
          "description": "Input datetime"
        },
        {
          "name": "as_name",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "As Name",
          "description": "Return weekday name instead of number (0-6)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input_datetime",
        "as_name"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Is Date In Range",
      "description": "Check if a date falls within a specified range with optional inclusivity.\n    datetime, range, check, validate\n\n    Use cases:\n    - Validate date ranges in forms and inputs\n    - Filter date-based data\n    - Check if events fall within specific periods\n    - Implement date-based access control",
      "namespace": "lib.date",
      "node_type": "lib.date.IsDateInRange",
      "properties": [
        {
          "name": "check_date",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Check Date",
          "description": "Date to check"
        },
        {
          "name": "start_date",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "Start Date",
          "description": "Start of date range"
        },
        {
          "name": "end_date",
          "type": {
            "type": "datetime"
          },
          "default": {
            "type": "datetime",
            "year": 0,
            "month": 0,
            "day": 0,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "microsecond": 0,
            "tzinfo": "UTC",
            "utc_offset": 0
          },
          "title": "End Date",
          "description": "End of date range"
        },
        {
          "name": "inclusive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Inclusive",
          "description": "Include start and end dates in range"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "check_date",
        "start_date",
        "end_date",
        "inclusive"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Now",
      "description": "Get the current date and time in UTC timezone.\n    datetime, current, now, timestamp\n\n    Use cases:\n    - Generate timestamps for events and logs\n    - Set default datetime values in workflows\n    - Calculate time-based conditions\n    - Track real-time operations",
      "namespace": "lib.date",
      "node_type": "lib.date.Now",
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "expose_as_tool": true
    },
    {
      "title": "Parse Date",
      "description": "Parse a date string into a structured Date object.\n    date, parse, format, convert\n\n    Use cases:\n    - Convert date strings from various sources into standard format\n    - Extract date components from text input\n    - Validate and normalize date formats\n    - Process dates from CSV, JSON, or API responses",
      "namespace": "lib.date",
      "node_type": "lib.date.ParseDate",
      "properties": [
        {
          "name": "date_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Date String",
          "description": "The date string to parse"
        },
        {
          "name": "input_format",
          "type": {
            "type": "enum",
            "values": [
              "%Y-%m-%d",
              "%m/%d/%Y",
              "%d/%m/%Y",
              "%B %d, %Y",
              "%Y%m%d",
              "%Y%m%d_%H%M%S",
              "%Y-%m-%dT%H:%M:%S",
              "%Y-%m-%dT%H:%M:%S%z",
              "%Y-%m-%dT%H:%M:%S%z"
            ],
            "type_name": "nodetool.nodes.lib.date.DateFormat"
          },
          "default": "%Y-%m-%d",
          "title": "Input Format",
          "description": "Format of the input date string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "date"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "date_string",
        "input_format"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Parse Date Time",
      "description": "Parse a date/time string into a structured Datetime object.\n    datetime, parse, format, convert\n\n    Use cases:\n    - Extract datetime components from strings\n    - Convert between datetime formats\n    - Process timestamps from logs and databases\n    - Standardize datetime data from multiple sources",
      "namespace": "lib.date",
      "node_type": "lib.date.ParseDateTime",
      "properties": [
        {
          "name": "datetime_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Datetime String",
          "description": "The datetime string to parse"
        },
        {
          "name": "input_format",
          "type": {
            "type": "enum",
            "values": [
              "%Y-%m-%d",
              "%m/%d/%Y",
              "%d/%m/%Y",
              "%B %d, %Y",
              "%Y%m%d",
              "%Y%m%d_%H%M%S",
              "%Y-%m-%dT%H:%M:%S",
              "%Y-%m-%dT%H:%M:%S%z",
              "%Y-%m-%dT%H:%M:%S%z"
            ],
            "type_name": "nodetool.nodes.lib.date.DateFormat"
          },
          "default": "%Y-%m-%d",
          "title": "Input Format",
          "description": "Format of the input datetime string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "datetime_string",
        "input_format"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Relative Time",
      "description": "Get datetime relative to current time (past or future) with configurable units.\n    datetime, past, future, relative, hours, days, months\n\n    Use cases:\n    - Calculate past or future dates dynamically\n    - Generate relative timestamps for scheduling\n    - Set expiration times\n    - Create time-based filters",
      "namespace": "lib.date",
      "node_type": "lib.date.RelativeTime",
      "properties": [
        {
          "name": "amount",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Amount",
          "description": "Amount of time units",
          "min": 0.0
        },
        {
          "name": "unit",
          "type": {
            "type": "enum",
            "values": [
              "hours",
              "days",
              "months"
            ],
            "type_name": "nodetool.nodes.lib.date.TimeUnitType"
          },
          "default": "days",
          "title": "Unit",
          "description": "Time unit type"
        },
        {
          "name": "direction",
          "type": {
            "type": "enum",
            "values": [
              "past",
              "future"
            ],
            "type_name": "nodetool.nodes.lib.date.TimeDirection"
          },
          "default": "future",
          "title": "Direction",
          "description": "Past or future"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "amount",
        "unit",
        "direction"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Today",
      "description": "Get the current date in Date format.\n    date, today, now, current\n\n    Use cases:\n    - Get today's date for logging and timestamping\n    - Set default dates in forms and workflows\n    - Calculate date-based conditions\n    - Track daily operations and schedules",
      "namespace": "lib.date",
      "node_type": "lib.date.Today",
      "outputs": [
        {
          "type": {
            "type": "date"
          },
          "name": "output"
        }
      ],
      "expose_as_tool": true
    },
    {
      "title": "Filter JSON",
      "description": "Filter JSON array based on a key-value condition.\n    json, filter, array\n\n    Use cases:\n    - Filter arrays of objects\n    - Search JSON data",
      "namespace": "lib.json",
      "node_type": "lib.json.FilterJSON",
      "properties": [
        {
          "name": "array",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Array",
          "description": "Array of JSON objects to filter"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key",
          "description": "Key to filter on"
        },
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "default": {},
          "title": "Value",
          "description": "Value to match"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "array",
        "key",
        "value"
      ]
    },
    {
      "title": "Get JSONPath Bool",
      "description": "Extract a boolean value from a JSON path\n    json, path, extract, boolean",
      "namespace": "lib.json",
      "node_type": "lib.json.GetJSONPathBool",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": {},
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path",
        "default"
      ]
    },
    {
      "title": "Get JSONPath Dict",
      "description": "Extract a dictionary value from a JSON path\n    json, path, extract, object",
      "namespace": "lib.json",
      "node_type": "lib.json.GetJSONPathDict",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": {},
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path",
        "default"
      ]
    },
    {
      "title": "Get JSONPath Float",
      "description": "Extract a float value from a JSON path\n    json, path, extract, number",
      "namespace": "lib.json",
      "node_type": "lib.json.GetJSONPathFloat",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": {},
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path",
        "default"
      ]
    },
    {
      "title": "Get JSONPath Int",
      "description": "Extract an integer value from a JSON path\n    json, path, extract, number",
      "namespace": "lib.json",
      "node_type": "lib.json.GetJSONPathInt",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": {},
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path",
        "default"
      ]
    },
    {
      "title": "Get JSONPath List",
      "description": "Extract a list value from a JSON path\n    json, path, extract, array",
      "namespace": "lib.json",
      "node_type": "lib.json.GetJSONPathList",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": {},
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "list"
          },
          "default": [],
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path",
        "default"
      ]
    },
    {
      "title": "Get JSONPath Str",
      "description": "Extract a string value from a JSON path\n    json, path, extract, string",
      "namespace": "lib.json",
      "node_type": "lib.json.GetJSONPathStr",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": {},
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "path",
        "default"
      ]
    },
    {
      "title": "JSON Template",
      "description": "Template JSON strings with variable substitution.\n    json, template, substitute, variables\n\n    Example:\n    template: '{\"name\": \"$user\", \"age\": $age}'\n    values: {\"user\": \"John\", \"age\": 30}\n    result: '{\"name\": \"John\", \"age\": 30}'\n\n    Use cases:\n    - Create dynamic JSON payloads\n    - Generate JSON with variable data\n    - Build API request templates",
      "namespace": "lib.json",
      "node_type": "lib.json.JSONTemplate",
      "properties": [
        {
          "name": "template",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Template",
          "description": "JSON template string with $variable placeholders"
        },
        {
          "name": "values",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Values",
          "description": "Dictionary of values to substitute into the template"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "template",
        "values"
      ]
    },
    {
      "title": "Load JSON Folder",
      "description": "Load JSON files from an asset folder.\n    load, json, file, import",
      "namespace": "lib.json",
      "node_type": "lib.json.LoadJSONAssets",
      "properties": [
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The asset folder to load the JSON files from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "json"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        }
      ],
      "basic_fields": [
        "folder"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Parse Dict",
      "description": "Parse a JSON string into a Python dictionary.\n    json, parse, decode, dictionary\n\n    Use cases:\n    - Convert JSON API responses to Python dictionaries\n    - Process JSON configuration files\n    - Parse object-like JSON data",
      "namespace": "lib.json",
      "node_type": "lib.json.ParseDict",
      "properties": [
        {
          "name": "json_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Json String",
          "description": "JSON string to parse into a dictionary"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "json_string"
      ]
    },
    {
      "title": "Parse List",
      "description": "Parse a JSON string into a Python list.\n    json, parse, decode, array, list\n\n    Use cases:\n    - Convert JSON array responses to Python lists\n    - Process JSON data collections\n    - Parse array-like JSON data",
      "namespace": "lib.json",
      "node_type": "lib.json.ParseList",
      "properties": [
        {
          "name": "json_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Json String",
          "description": "JSON string to parse into a list"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "json_string"
      ]
    },
    {
      "title": "Stringify JSON",
      "description": "Convert a Python object to a formatted JSON string.\n    json, stringify, encode, serialize\n\n    Use cases:\n    - Prepare data for API requests\n    - Save data in JSON format\n    - Format data for storage or transmission\n    - Create human-readable JSON output",
      "namespace": "lib.json",
      "node_type": "lib.json.StringifyJSON",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": {},
          "title": "Data",
          "description": "Data to convert to JSON"
        },
        {
          "name": "indent",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Indent",
          "description": "Number of spaces for indentation"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "indent"
      ]
    },
    {
      "title": "Validate JSON",
      "description": "Validate JSON data against a schema.\n    json, validate, schema\n\n    Use cases:\n    - Ensure API payloads match specifications\n    - Validate configuration files",
      "namespace": "lib.json",
      "node_type": "lib.json.ValidateJSON",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": {},
          "title": "Data",
          "description": "JSON data to validate"
        },
        {
          "name": "json_schema",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Json Schema",
          "description": "JSON schema for validation"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "data",
        "json_schema"
      ]
    },
    {
      "title": "Extract Markdown",
      "description": "Convert PDF to Markdown format using pymupdf4llm.\n    pdf, markdown, convert\n\n    Use cases:\n    - Convert PDF documents to markdown format\n    - Preserve document structure in markdown\n    - Create editable markdown from PDFs",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractMarkdown",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Pdf",
          "description": "The PDF document to convert to markdown"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Tables",
      "description": "Extract tables from a PDF document using PyMuPDF.\n    pdf, tables, extract, structured\n\n    Use cases:\n    - Extract tabular data from PDFs\n    - Convert PDF tables to structured formats\n    - Analyze table layouts and content",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractTables",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Pdf",
          "description": "The PDF document to extract tables from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Text",
      "description": "Extract plain text from a PDF document using PyMuPDF.\n    pdf, text, extract\n\n    Use cases:\n    - Extract raw text content from PDFs\n    - Convert PDF documents to plain text\n    - Prepare text for further processing",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractText",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Pdf",
          "description": "The PDF document to extract text from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Text Blocks",
      "description": "Extract text blocks with their bounding boxes from a PDF.\n    pdf, text, blocks, layout\n\n    Use cases:\n    - Analyze text layout and structure\n    - Extract text while preserving block-level formatting\n    - Get text position information",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractTextBlocks",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Pdf",
          "description": "The PDF document to extract text blocks from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Extract Text With Style",
      "description": "Extract text with style information (font, size, color) from a PDF.\n    pdf, text, style, formatting\n\n    Use cases:\n    - Preserve text formatting during extraction\n    - Analyze document styling\n    - Extract text with font information",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractTextWithStyle",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {
            "type": "document",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Pdf",
          "description": "The PDF document to extract styled text from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Format UUID",
      "description": "Format a UUID string in different representations.\n    uuid, format, convert, hex, urn, identifier\n\n    Use cases:\n    - Convert UUID to different formats\n    - Generate URN representations\n    - Format UUIDs for specific use cases",
      "namespace": "lib.uuid",
      "node_type": "lib.uuid.FormatUUID",
      "properties": [
        {
          "name": "uuid_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Uuid String",
          "description": "UUID string to format"
        },
        {
          "name": "format",
          "type": {
            "type": "enum",
            "values": [
              "standard",
              "hex",
              "urn",
              "int",
              "bytes_hex"
            ],
            "type_name": "nodetool.nodes.lib.uuid.UUIDFormat"
          },
          "default": "standard",
          "title": "Format",
          "description": "Output format (standard, hex, urn, int, bytes_hex)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "uuid_string",
        "format"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Generate UUID 1",
      "description": "Generate a time-based UUID (version 1).\n    uuid, time, identifier, unique, guid, timestamp\n\n    Use cases:\n    - Create sortable unique identifiers\n    - Generate time-ordered IDs\n    - Track creation timestamps in IDs",
      "namespace": "lib.uuid",
      "node_type": "lib.uuid.GenerateUUID1",
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "expose_as_tool": true
    },
    {
      "title": "Generate UUID 3",
      "description": "Generate a name-based UUID using MD5 (version 3).\n    uuid, name, identifier, unique, guid, md5, deterministic\n\n    Use cases:\n    - Create deterministic IDs from names\n    - Generate consistent identifiers for the same input\n    - Map names to unique identifiers",
      "namespace": "lib.uuid",
      "node_type": "lib.uuid.GenerateUUID3",
      "properties": [
        {
          "name": "namespace",
          "type": {
            "type": "str"
          },
          "default": "dns",
          "title": "Namespace",
          "description": "Namespace (dns, url, oid, x500, or a UUID string)"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "Name to generate UUID from"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "namespace",
        "name"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Generate UUID 4",
      "description": "Generate a random UUID (version 4).\n    uuid, random, identifier, unique, guid\n\n    Use cases:\n    - Create unique identifiers for records\n    - Generate session IDs\n    - Produce random unique keys",
      "namespace": "lib.uuid",
      "node_type": "lib.uuid.GenerateUUID4",
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "expose_as_tool": true
    },
    {
      "title": "Generate UUID 5",
      "description": "Generate a name-based UUID using SHA-1 (version 5).\n    uuid, name, identifier, unique, guid, sha1, deterministic\n\n    Use cases:\n    - Create deterministic IDs from names (preferred over UUID3)\n    - Generate consistent identifiers for the same input\n    - Map names to unique identifiers with better collision resistance",
      "namespace": "lib.uuid",
      "node_type": "lib.uuid.GenerateUUID5",
      "properties": [
        {
          "name": "namespace",
          "type": {
            "type": "str"
          },
          "default": "dns",
          "title": "Namespace",
          "description": "Namespace (dns, url, oid, x500, or a UUID string)"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "Name to generate UUID from"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "namespace",
        "name"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Is Valid UUID",
      "description": "Check if a string is a valid UUID.\n    uuid, validate, check, verify, identifier\n\n    Use cases:\n    - Validate user input\n    - Filter valid UUIDs from a dataset\n    - Conditional workflow based on UUID validity",
      "namespace": "lib.uuid",
      "node_type": "lib.uuid.IsValidUUID",
      "properties": [
        {
          "name": "uuid_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Uuid String",
          "description": "String to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "uuid_string"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Parse UUID",
      "description": "Parse and validate a UUID string.\n    uuid, parse, validate, check, identifier\n\n    Use cases:\n    - Validate UUID format\n    - Normalize UUID strings\n    - Extract UUID version information",
      "namespace": "lib.uuid",
      "node_type": "lib.uuid.ParseUUID",
      "properties": [
        {
          "name": "uuid_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Uuid String",
          "description": "UUID string to parse"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "uuid_string"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Index Array",
      "description": "Select specific indices from an array along a specified axis.\n    array, index, select, subset\n\n    Use cases:\n    - Extract specific samples from a dataset\n    - Select particular features or dimensions\n    - Implement batch sampling operations",
      "namespace": "lib.numpy.manipulation",
      "node_type": "lib.numpy.manipulation.IndexArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The input array to index"
        },
        {
          "name": "indices",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Indices",
          "description": "The comma separated indices to select"
        },
        {
          "name": "axis",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Axis",
          "description": "Axis along which to index"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "indices",
        "axis"
      ]
    },
    {
      "title": "Mat Mul",
      "description": "Perform matrix multiplication on two input arrays.\n    array, matrix, multiplication, linear algebra\n\n    Use cases:\n    - Implement linear transformations\n    - Calculate dot products of vectors\n    - Perform matrix operations in neural networks",
      "namespace": "lib.numpy.manipulation",
      "node_type": "lib.numpy.manipulation.MatMul",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "A",
          "description": "First input array"
        },
        {
          "name": "b",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "B",
          "description": "Second input array"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ]
    },
    {
      "title": "Slice Array",
      "description": "Extract a slice of an array along a specified axis.\n    array, slice, subset, index\n\n    Use cases:\n    - Extract specific time periods from time series data\n    - Select subset of features from datasets\n    - Create sliding windows over sequential data",
      "namespace": "lib.numpy.manipulation",
      "node_type": "lib.numpy.manipulation.SliceArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The input array to slice"
        },
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start",
          "description": "Starting index (inclusive)"
        },
        {
          "name": "stop",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Stop",
          "description": "Ending index (exclusive)"
        },
        {
          "name": "step",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Step",
          "description": "Step size between elements"
        },
        {
          "name": "axis",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Axis",
          "description": "Axis along which to slice"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "start",
        "stop",
        "step",
        "axis"
      ]
    },
    {
      "title": "Split Array",
      "description": "Split an array into multiple sub-arrays along a specified axis.\n    array, split, divide, partition\n\n    Use cases:\n    - Divide datasets into training/validation splits\n    - Create batches from large arrays\n    - Separate multi-channel data",
      "namespace": "lib.numpy.manipulation",
      "node_type": "lib.numpy.manipulation.SplitArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The input array to split"
        },
        {
          "name": "num_splits",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Splits",
          "description": "Number of equal splits to create"
        },
        {
          "name": "axis",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Axis",
          "description": "Axis along which to split"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "num_splits",
        "axis"
      ]
    },
    {
      "title": "Stack",
      "description": "Stack multiple arrays along a specified axis.\n    array, stack, concatenate, join, merge, axis\n\n    Use cases:\n    - Combine multiple 2D arrays into a 3D array\n    - Stack time series data from multiple sources\n    - Merge feature vectors for machine learning models",
      "namespace": "lib.numpy.manipulation",
      "node_type": "lib.numpy.manipulation.Stack",
      "properties": [
        {
          "name": "arrays",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "np_array"
              }
            ]
          },
          "default": [],
          "title": "Arrays",
          "description": "Arrays to stack"
        },
        {
          "name": "axis",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Axis",
          "description": "The axis to stack along.",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "arrays",
        "axis"
      ]
    },
    {
      "title": "Transpose Array",
      "description": "Transpose the dimensions of the input array.\n    array, transpose, reshape, dimensions\n\n    Use cases:\n    - Convert row vectors to column vectors\n    - Rearrange data for compatibility with other operations\n    - Implement certain linear algebra operations",
      "namespace": "lib.numpy.manipulation",
      "node_type": "lib.numpy.manipulation.TransposeArray",
      "layout": "small",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Array to transpose"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Add Array",
      "description": "Performs addition on two arrays.\n    math, plus, add, addition, sum, +",
      "namespace": "lib.numpy.arithmetic",
      "node_type": "lib.numpy.arithmetic.AddArray",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ]
    },
    {
      "title": "Divide Array",
      "description": "Divides the first array by the second.\n    math, division, arithmetic, quotient, /",
      "namespace": "lib.numpy.arithmetic",
      "node_type": "lib.numpy.arithmetic.DivideArray",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ]
    },
    {
      "title": "Modulus Array",
      "description": "Calculates the element-wise remainder of division.\n    math, modulo, remainder, mod, %\n\n    Use cases:\n    - Implementing cyclic behaviors\n    - Checking for even/odd numbers\n    - Limiting values to a specific range",
      "namespace": "lib.numpy.arithmetic",
      "node_type": "lib.numpy.arithmetic.ModulusArray",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ]
    },
    {
      "title": "Multiply Array",
      "description": "Multiplies two arrays.\n    math, product, times, *",
      "namespace": "lib.numpy.arithmetic",
      "node_type": "lib.numpy.arithmetic.MultiplyArray",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ]
    },
    {
      "title": "Subtract Array",
      "description": "Subtracts the second array from the first.\n    math, minus, difference, -",
      "namespace": "lib.numpy.arithmetic",
      "node_type": "lib.numpy.arithmetic.SubtractArray",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ]
    },
    {
      "title": "Reshape 1 D",
      "description": "Reshape an array to a 1D shape without changing its data.\n    array, reshape, vector, flatten\n\n    Use cases:\n    - Flatten multi-dimensional data for certain algorithms\n    - Convert images to vector form for machine learning\n    - Prepare data for 1D operations",
      "namespace": "lib.numpy.reshaping",
      "node_type": "lib.numpy.reshaping.Reshape1D",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The input array to reshape"
        },
        {
          "name": "num_elements",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Elements",
          "description": "The number of elements"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "num_elements"
      ]
    },
    {
      "title": "Reshape 2 D",
      "description": "Reshape an array to a new shape without changing its data.\n    array, reshape, dimensions, structure\n\n    Use cases:\n    - Convert between different dimensional representations\n    - Prepare data for specific model architectures\n    - Flatten or unflatten arrays",
      "namespace": "lib.numpy.reshaping",
      "node_type": "lib.numpy.reshaping.Reshape2D",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The input array to reshape"
        },
        {
          "name": "num_rows",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Rows",
          "description": "The number of rows"
        },
        {
          "name": "num_cols",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Cols",
          "description": "The number of columns"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "num_rows",
        "num_cols"
      ]
    },
    {
      "title": "Reshape 3 D",
      "description": "Reshape an array to a 3D shape without changing its data.\n    array, reshape, dimensions, volume\n\n    Use cases:\n    - Convert data for 3D visualization\n    - Prepare image data with channels\n    - Structure data for 3D convolutions",
      "namespace": "lib.numpy.reshaping",
      "node_type": "lib.numpy.reshaping.Reshape3D",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The input array to reshape"
        },
        {
          "name": "num_rows",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Rows",
          "description": "The number of rows"
        },
        {
          "name": "num_cols",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Cols",
          "description": "The number of columns"
        },
        {
          "name": "num_depths",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Depths",
          "description": "The number of depths"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "num_rows",
        "num_cols",
        "num_depths"
      ]
    },
    {
      "title": "Reshape 4 D",
      "description": "Reshape an array to a 4D shape without changing its data.\n    array, reshape, dimensions, batch\n\n    Use cases:\n    - Prepare batch data for neural networks\n    - Structure spatiotemporal data\n    - Format data for 3D image processing with channels",
      "namespace": "lib.numpy.reshaping",
      "node_type": "lib.numpy.reshaping.Reshape4D",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The input array to reshape"
        },
        {
          "name": "num_rows",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Rows",
          "description": "The number of rows"
        },
        {
          "name": "num_cols",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Cols",
          "description": "The number of columns"
        },
        {
          "name": "num_depths",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Depths",
          "description": "The number of depths"
        },
        {
          "name": "num_channels",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Num Channels",
          "description": "The number of channels"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "num_rows",
        "num_cols",
        "num_depths",
        "num_channels"
      ]
    },
    {
      "title": "Save Array",
      "description": "Save a numpy array to a file in the specified folder.\n    array, save, file, storage\n\n    Use cases:\n    - Store processed arrays for later use\n    - Save analysis results\n    - Create checkpoints in processing pipelines",
      "namespace": "lib.numpy.io",
      "node_type": "lib.numpy.io.SaveArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The array to save."
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {
            "type": "folder",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Folder",
          "description": "The folder to save the array in."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d_%H-%M-%S.npy",
          "title": "Name",
          "description": "\n        The name of the asset to save.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "folder",
        "name"
      ]
    },
    {
      "title": "Array To List",
      "description": "Convert a array to a nested list structure.\n    array, list, conversion, type\n\n    Use cases:\n    - Prepare array data for JSON serialization\n    - Convert array outputs to Python data structures\n    - Interface array data with non-array operations",
      "namespace": "lib.numpy.conversion",
      "node_type": "lib.numpy.conversion.ArrayToList",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Array to convert to list"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Array To Scalar",
      "description": "Convert a single-element array to a scalar value.\n    array, scalar, conversion, type\n\n    Use cases:\n    - Extract final results from array computations\n    - Prepare values for non-array operations\n    - Simplify output for human-readable results",
      "namespace": "lib.numpy.conversion",
      "node_type": "lib.numpy.conversion.ArrayToScalar",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Array to convert to scalar"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Convert To Array",
      "description": "Convert PIL Image to normalized tensor representation.\n    image, tensor, conversion, normalization\n\n    Use cases:\n    - Prepare images for machine learning models\n    - Convert between image formats for processing\n    - Normalize image data for consistent calculations",
      "namespace": "lib.numpy.conversion",
      "node_type": "lib.numpy.conversion.ConvertToArray",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The input image to convert to a tensor. The image should have either 1 (grayscale), 3 (RGB), or 4 (RGBA) channels."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Convert To Audio",
      "description": "Converts a array object back to an audio file.\n    audio, conversion, array\n\n    Use cases:\n    - Save processed audio data as a playable file\n    - Convert generated or modified audio arrays to audio format\n    - Output results of audio processing pipelinesr",
      "namespace": "lib.numpy.conversion",
      "node_type": "lib.numpy.conversion.ConvertToAudio",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The array to convert to an audio file."
        },
        {
          "name": "sample_rate",
          "type": {
            "type": "int"
          },
          "default": 44100,
          "title": "Sample Rate",
          "description": "The sample rate of the audio file.",
          "min": 0.0,
          "max": 44100.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "sample_rate"
      ]
    },
    {
      "title": "Convert To Image",
      "description": "Convert array data to PIL Image format.\n    array, image, conversion, denormalization\n\n    Use cases:\n    - Visualize array data as images\n    - Save processed array results as images\n    - Convert model outputs back to viewable format",
      "namespace": "lib.numpy.conversion",
      "node_type": "lib.numpy.conversion.ConvertToImage",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The input array to convert to an image. Should have either 1, 3, or 4 channels."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "List To Array",
      "description": "Convert a list of values to a array.\n    list, array, conversion, type\n\n    Use cases:\n    - Prepare list data for array operations\n    - Create arrays from Python data structures\n    - Convert sequence data to array format",
      "namespace": "lib.numpy.conversion",
      "node_type": "lib.numpy.conversion.ListToArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values",
          "description": "List of values to convert to array"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Scalar To Array",
      "description": "Convert a scalar value to a single-element array.\n    scalar, array, conversion, type\n\n    Use cases:\n    - Prepare scalar inputs for array operations\n    - Create constant arrays for computations\n    - Initialize array values in workflows",
      "namespace": "lib.numpy.conversion",
      "node_type": "lib.numpy.conversion.ScalarToArray",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "default": 0,
          "title": "Value",
          "description": "Scalar value to convert to array"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "value"
      ]
    },
    {
      "title": "Plot Array",
      "description": "Create a plot visualization of array data.\n    array, plot, visualization, graph\n\n    Use cases:\n    - Visualize trends in array data\n    - Create charts for reports or dashboards\n    - Debug array outputs in workflows",
      "namespace": "lib.numpy.visualization",
      "node_type": "lib.numpy.visualization.PlotArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Array to plot"
        },
        {
          "name": "plot_type",
          "type": {
            "type": "enum",
            "values": [
              "line",
              "bar",
              "scatter"
            ],
            "type_name": "nodetool.nodes.lib.numpy.visualization.PlotArray.PlotType"
          },
          "default": "line",
          "title": "Plot Type",
          "description": "Type of plot to create"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "plot_type"
      ]
    },
    {
      "title": "Binary Operation",
      "description": "",
      "namespace": "lib.numpy.utils",
      "node_type": "lib.numpy.utils.BinaryOperation",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "a",
        "b"
      ]
    },
    {
      "title": "Arg Max Array",
      "description": "Find indices of maximum values along a specified axis of a array.\n    array, argmax, index, maximum\n\n    Use cases:\n    - Determine winning classes in classification tasks\n    - Find peaks in signal processing\n    - Locate best-performing items in datasets",
      "namespace": "lib.numpy.statistics",
      "node_type": "lib.numpy.statistics.ArgMaxArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Input array"
        },
        {
          "name": "axis",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Axis",
          "description": "Axis along which to find maximum indices"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "np_array"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "axis"
      ]
    },
    {
      "title": "Arg Min Array",
      "description": "Find indices of minimum values along a specified axis of a array.\n    array, argmin, index, minimum\n\n    Use cases:\n    - Locate lowest-performing items in datasets\n    - Find troughs in signal processing\n    - Determine least likely classes in classification tasks",
      "namespace": "lib.numpy.statistics",
      "node_type": "lib.numpy.statistics.ArgMinArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Input array"
        },
        {
          "name": "axis",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Axis",
          "description": "Axis along which to find minimum indices"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "np_array"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "axis"
      ]
    },
    {
      "title": "Max Array",
      "description": "Compute the maximum value along a specified axis of a array.\n    array, maximum, reduction, statistics\n\n    Use cases:\n    - Find peak values in time series data\n    - Implement max pooling in neural networks\n    - Determine highest scores across multiple categories",
      "namespace": "lib.numpy.statistics",
      "node_type": "lib.numpy.statistics.MaxArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Input array"
        },
        {
          "name": "axis",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Axis",
          "description": "Axis along which to compute maximum"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "np_array"
              },
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "axis"
      ]
    },
    {
      "title": "Mean Array",
      "description": "Compute the mean value along a specified axis of a array.\n    array, average, reduction, statistics\n\n    Use cases:\n    - Calculate average values in datasets\n    - Implement mean pooling in neural networks\n    - Compute centroids in clustering algorithms",
      "namespace": "lib.numpy.statistics",
      "node_type": "lib.numpy.statistics.MeanArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Input array"
        },
        {
          "name": "axis",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Axis",
          "description": "Axis along which to compute mean"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "np_array"
              },
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "axis"
      ]
    },
    {
      "title": "Min Array",
      "description": "Calculate the minimum value along a specified axis of a array.\n    array, minimum, reduction, statistics\n\n    Use cases:\n    - Find lowest values in datasets\n    - Implement min pooling in neural networks\n    - Determine minimum thresholds across categories",
      "namespace": "lib.numpy.statistics",
      "node_type": "lib.numpy.statistics.MinArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Input array"
        },
        {
          "name": "axis",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Axis",
          "description": "Axis along which to compute minimum"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "np_array"
              },
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "axis"
      ]
    },
    {
      "title": "Sum Array",
      "description": "Calculate the sum of values along a specified axis of a array.\n    array, summation, reduction, statistics\n\n    Use cases:\n    - Compute total values across categories\n    - Implement sum pooling in neural networks\n    - Calculate cumulative metrics in time series data",
      "namespace": "lib.numpy.statistics",
      "node_type": "lib.numpy.statistics.SumArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Input array"
        },
        {
          "name": "axis",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Axis",
          "description": "Axis along which to compute sum"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "np_array"
              },
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values",
        "axis"
      ]
    },
    {
      "title": "Abs Array",
      "description": "Compute the absolute value of each element in a array.\n    array, absolute, magnitude\n\n    Use cases:\n    - Calculate magnitudes of complex numbers\n    - Preprocess data for certain algorithms\n    - Implement activation functions in neural networks",
      "namespace": "lib.numpy.math",
      "node_type": "lib.numpy.math.AbsArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "The input array to compute the absolute values from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Cosine Array",
      "description": "Computes the cosine of input angles in radians.\n    math, trigonometry, cosine, cos\n\n    Use cases:\n    - Calculating horizontal components in physics\n    - Creating circular motions\n    - Phase calculations in signal processing",
      "namespace": "lib.numpy.math",
      "node_type": "lib.numpy.math.CosineArray",
      "layout": "small",
      "properties": [
        {
          "name": "angle_rad",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "Angle (Radians)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "angle_rad"
      ]
    },
    {
      "title": "Exp Array",
      "description": "Calculate the exponential of each element in a array.\n    array, exponential, math, activation\n\n    Use cases:\n    - Implement exponential activation functions\n    - Calculate growth rates in scientific models\n    - Transform data for certain statistical analyses",
      "namespace": "lib.numpy.math",
      "node_type": "lib.numpy.math.ExpArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Input array"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Log Array",
      "description": "Calculate the natural logarithm of each element in a array.\n    array, logarithm, math, transformation\n\n    Use cases:\n    - Implement log transformations on data\n    - Calculate entropy in information theory\n    - Normalize data with large ranges",
      "namespace": "lib.numpy.math",
      "node_type": "lib.numpy.math.LogArray",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Input array"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Power Array",
      "description": "Raises the base array to the power of the exponent element-wise.\n    math, exponentiation, power, pow, **\n\n    Use cases:\n    - Calculating compound interest\n    - Implementing polynomial functions\n    - Applying non-linear transformations to data",
      "namespace": "lib.numpy.math",
      "node_type": "lib.numpy.math.PowerArray",
      "layout": "small",
      "properties": [
        {
          "name": "base",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 1.0,
          "title": "Base"
        },
        {
          "name": "exponent",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 2.0,
          "title": "Exponent"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "base",
        "exponent"
      ]
    },
    {
      "title": "Sine Array",
      "description": "Computes the sine of input angles in radians.\n    math, trigonometry, sine, sin\n\n    Use cases:\n    - Calculating vertical components in physics\n    - Generating smooth periodic functions\n    - Audio signal processing",
      "namespace": "lib.numpy.math",
      "node_type": "lib.numpy.math.SineArray",
      "layout": "small",
      "properties": [
        {
          "name": "angle_rad",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "default": 0.0,
          "title": "Angle (Radians)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "angle_rad"
      ]
    },
    {
      "title": "Sqrt Array",
      "description": "Calculates the square root of the input array element-wise.\n    math, square root, sqrt, \u221a\n\n    Use cases:\n    - Normalizing data\n    - Calculating distances in Euclidean space\n    - Finding intermediate values in binary search",
      "namespace": "lib.numpy.math",
      "node_type": "lib.numpy.math.SqrtArray",
      "layout": "small",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Values",
          "description": "Input array"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              },
              {
                "type": "np_array"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "values"
      ]
    },
    {
      "title": "Adaptive Contrast",
      "description": "Applies localized contrast enhancement using adaptive techniques.\n    image, contrast, enhance\n\n    Use cases:\n    - Improve visibility in images with varying lighting conditions\n    - Prepare images for improved feature detection in computer vision",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.AdaptiveContrast",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust the contrast for."
        },
        {
          "name": "clip_limit",
          "type": {
            "type": "float"
          },
          "default": 2.0,
          "title": "Clip Limit",
          "description": "Clip limit for adaptive contrast.",
          "min": 0.0,
          "max": 100.0
        },
        {
          "name": "grid_size",
          "type": {
            "type": "int"
          },
          "default": 8,
          "title": "Grid Size",
          "description": "Grid size for adaptive contrast.",
          "min": 1.0,
          "max": 64.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "clip_limit",
        "grid_size"
      ]
    },
    {
      "title": "Auto Contrast",
      "description": "Automatically adjusts image contrast for enhanced visual quality.\n    image, contrast, balance\n\n    Use cases:\n    - Enhance image clarity for better visual perception\n    - Pre-process images for computer vision tasks\n    - Improve photo aesthetics in editing workflows",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.AutoContrast",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust the contrast for."
        },
        {
          "name": "cutoff",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Cutoff",
          "description": "Represents the percentage of pixels to ignore at both the darkest and lightest ends of the histogram. A cutoff value of 5 means ignoring the darkest 5% and the lightest 5% of pixels, enhancing overall contrast by stretching the remaining pixel values across the full brightness range.",
          "min": 0.0,
          "max": 255.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "cutoff"
      ]
    },
    {
      "title": "Brightness",
      "description": "Adjusts overall image brightness to lighten or darken.\n    image, brightness, enhance\n\n    Use cases:\n    - Correct underexposed or overexposed photographs\n    - Enhance visibility of dark image regions\n    - Prepare images for consistent display across devices",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.Brightness",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust the brightness for."
        },
        {
          "name": "factor",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "default": 1.0,
          "title": "Factor",
          "description": "Factor to adjust the brightness. 1.0 means no change."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "factor"
      ]
    },
    {
      "title": "Color",
      "description": "Adjusts color intensity of an image.\n    image, color, enhance\n\n    Use cases:\n    - Enhance color vibrancy in photographs\n    - Correct color imbalances in digital images\n    - Prepare images for consistent brand color representation",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.Color",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust the brightness for."
        },
        {
          "name": "factor",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Factor",
          "description": "Factor to adjust the contrast. 1.0 means no change."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "factor"
      ]
    },
    {
      "title": "Contrast",
      "description": "Adjusts image contrast to modify light-dark differences.\n    image, contrast, enhance\n\n    Use cases:\n    - Enhance visibility of details in low-contrast images\n    - Prepare images for visual analysis or recognition tasks\n    - Create dramatic effects in artistic photography",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.Contrast",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust the brightness for."
        },
        {
          "name": "factor",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Factor",
          "description": "Factor to adjust the contrast. 1.0 means no change."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "factor"
      ]
    },
    {
      "title": "Detail",
      "description": "Enhances fine details in images.\n    image, detail, enhance\n\n    Use cases:\n    - Improve clarity of textural elements in photographs\n    - Enhance visibility of small features for analysis\n    - Prepare images for high-resolution display or printing",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.Detail",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to detail."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Edge Enhance",
      "description": "Enhances edge visibility by increasing contrast along boundaries.\n    image, edge, enhance\n\n    Use cases:\n    - Improve object boundary detection for computer vision\n    - Highlight structural elements in technical drawings\n    - Prepare images for feature extraction in image analysis",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.EdgeEnhance",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to edge enhance."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Equalize",
      "description": "Enhances image contrast by equalizing intensity distribution.\n    image, contrast, histogram\n\n    Use cases:\n    - Improve visibility in poorly lit images\n    - Enhance details for image analysis tasks\n    - Normalize image data for machine learning",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.Equalize",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to equalize."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Rank Filter",
      "description": "Applies rank-based filtering to enhance or smooth image features.\n    image, filter, enhance\n\n    Use cases:\n    - Reduce noise while preserving edges in images\n    - Enhance specific image features based on local intensity\n    - Pre-process images for improved segmentation results",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.RankFilter",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to rank filter."
        },
        {
          "name": "size",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "Size",
          "description": "Rank filter size.",
          "min": 1.0,
          "max": 512.0
        },
        {
          "name": "rank",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "Rank",
          "description": "Rank filter rank.",
          "min": 1.0,
          "max": 512.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "size",
        "rank"
      ]
    },
    {
      "title": "Sharpen",
      "description": "Enhances image detail by intensifying local pixel contrast.\n    image, sharpen, clarity\n\n    Use cases:\n    - Improve clarity of photographs for print or display\n    - Refine texture details in product photography\n    - Enhance readability of text in document images",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.Sharpen",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to sharpen."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Sharpness",
      "description": "Adjusts image sharpness to enhance or reduce detail clarity.\n    image, clarity, sharpness\n\n    Use cases:\n    - Enhance photo details for improved visual appeal\n    - Refine images for object detection tasks\n    - Correct slightly blurred images",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.Sharpness",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust the brightness for."
        },
        {
          "name": "factor",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Factor",
          "description": "Factor to adjust the contrast. 1.0 means no change."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "factor"
      ]
    },
    {
      "title": "Unsharp Mask",
      "description": "Sharpens images using the unsharp mask technique.\n    image, sharpen, enhance\n\n    Use cases:\n    - Enhance edge definition in photographs\n    - Improve perceived sharpness of digital artwork\n    - Prepare images for high-quality printing or display",
      "namespace": "lib.pillow.enhance",
      "node_type": "lib.pillow.enhance.UnsharpMask",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to unsharp mask."
        },
        {
          "name": "radius",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Radius",
          "description": "Unsharp mask radius.",
          "min": 0.0,
          "max": 512.0
        },
        {
          "name": "percent",
          "type": {
            "type": "int"
          },
          "default": 150,
          "title": "Percent",
          "description": "Unsharp mask percent.",
          "min": 0.0,
          "max": 1000.0
        },
        {
          "name": "threshold",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "Threshold",
          "description": "Unsharp mask threshold.",
          "min": 0.0,
          "max": 512.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "radius",
        "percent",
        "threshold"
      ]
    },
    {
      "title": "Blend",
      "description": "Blend two images with adjustable alpha mixing.\n    blend, mix, fade, transition\n\n    Use cases:\n    - Create smooth transitions between images\n    - Adjust opacity of overlays\n    - Combine multiple exposures or effects",
      "namespace": "lib.pillow.__init__",
      "node_type": "lib.pillow.__init__.Blend",
      "properties": [
        {
          "name": "image1",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image1",
          "description": "The first image to blend."
        },
        {
          "name": "image2",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image2",
          "description": "The second image to blend."
        },
        {
          "name": "alpha",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Alpha",
          "description": "The mix ratio.",
          "min": 0.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image1",
        "image2",
        "alpha"
      ]
    },
    {
      "title": "Composite",
      "description": "Combine two images using a mask for advanced compositing.\n    composite, mask, blend, layering\n\n    Use cases:\n    - Create complex image compositions\n    - Apply selective blending or effects\n    - Implement advanced photo editing techniques",
      "namespace": "lib.pillow.__init__",
      "node_type": "lib.pillow.__init__.Composite",
      "properties": [
        {
          "name": "image1",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image1",
          "description": "The first image to composite."
        },
        {
          "name": "image2",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image2",
          "description": "The second image to composite."
        },
        {
          "name": "mask",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Mask",
          "description": "The mask to composite with."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image1",
        "image2",
        "mask"
      ]
    },
    {
      "title": "CDL",
      "description": "ASC CDL (Color Decision List) color correction.\n    cdl, slope, offset, power, saturation, asc, color decision list\n\n    Use cases:\n    - Apply industry-standard CDL color correction\n    - Exchange color grades between different software\n    - Apply precise mathematical color transformations\n    - Create consistent looks across multiple shots\n\n    Formula: output = (input * slope + offset) ^ power\n    Followed by saturation adjustment.",
      "namespace": "lib.pillow.color_grading",
      "node_type": "lib.pillow.color_grading.CDL",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to color correct."
        },
        {
          "name": "slope_r",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Slope R",
          "description": "Red slope (multiplier).",
          "min": 0.0,
          "max": 4.0
        },
        {
          "name": "slope_g",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Slope G",
          "description": "Green slope (multiplier).",
          "min": 0.0,
          "max": 4.0
        },
        {
          "name": "slope_b",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Slope B",
          "description": "Blue slope (multiplier).",
          "min": 0.0,
          "max": 4.0
        },
        {
          "name": "offset_r",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Offset R",
          "description": "Red offset (addition).",
          "min": -1.0,
          "max": 1.0
        },
        {
          "name": "offset_g",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Offset G",
          "description": "Green offset (addition).",
          "min": -1.0,
          "max": 1.0
        },
        {
          "name": "offset_b",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Offset B",
          "description": "Blue offset (addition).",
          "min": -1.0,
          "max": 1.0
        },
        {
          "name": "power_r",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Power R",
          "description": "Red power (gamma).",
          "min": 0.1,
          "max": 4.0
        },
        {
          "name": "power_g",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Power G",
          "description": "Green power (gamma).",
          "min": 0.1,
          "max": 4.0
        },
        {
          "name": "power_b",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Power B",
          "description": "Blue power (gamma).",
          "min": 0.1,
          "max": 4.0
        },
        {
          "name": "saturation",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Saturation",
          "description": "Saturation adjustment.",
          "min": 0.0,
          "max": 4.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "slope_r",
        "slope_g",
        "slope_b",
        "offset_r",
        "offset_g",
        "offset_b",
        "power_r",
        "power_g",
        "power_b",
        "saturation"
      ]
    },
    {
      "title": "Color Balance",
      "description": "Adjust color temperature and tint for white balance correction.\n    white balance, temperature, tint, color balance, warm, cool\n\n    Use cases:\n    - Correct white balance in photos and video\n    - Warm up or cool down the overall image\n    - Fix color casts from mixed lighting\n    - Create mood through color temperature shifts",
      "namespace": "lib.pillow.color_grading",
      "node_type": "lib.pillow.color_grading.ColorBalance",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust."
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Temperature",
          "description": "Color temperature. Positive = warmer (orange), negative = cooler (blue).",
          "min": -1.0,
          "max": 1.0
        },
        {
          "name": "tint",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Tint",
          "description": "Color tint. Positive = magenta, negative = green.",
          "min": -1.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "temperature",
        "tint"
      ]
    },
    {
      "title": "Curves",
      "description": "RGB curves adjustment with control points for precise tonal control.\n    curves, rgb, tonal, contrast, levels\n\n    Use cases:\n    - Create custom contrast curves\n    - Adjust specific tonal ranges precisely\n    - Create cross-processed or stylized looks\n    - Match the tonal characteristics of film stocks",
      "namespace": "lib.pillow.color_grading",
      "node_type": "lib.pillow.color_grading.Curves",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust."
        },
        {
          "name": "black_point",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Black Point",
          "description": "Input black point (lifts shadows).",
          "min": 0.0,
          "max": 0.5
        },
        {
          "name": "white_point",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "White Point",
          "description": "Input white point (compresses highlights).",
          "min": 0.5,
          "max": 1.0
        },
        {
          "name": "shadows",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Shadows",
          "description": "Shadow curve adjustment.",
          "min": -0.5,
          "max": 0.5
        },
        {
          "name": "midtones",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Midtones",
          "description": "Midtone curve adjustment (gamma).",
          "min": -0.5,
          "max": 0.5
        },
        {
          "name": "highlights",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Highlights",
          "description": "Highlight curve adjustment.",
          "min": -0.5,
          "max": 0.5
        },
        {
          "name": "red_midtones",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Red Midtones",
          "description": "Red channel midtone adjustment.",
          "min": -0.5,
          "max": 0.5
        },
        {
          "name": "green_midtones",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Green Midtones",
          "description": "Green channel midtone adjustment.",
          "min": -0.5,
          "max": 0.5
        },
        {
          "name": "blue_midtones",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Blue Midtones",
          "description": "Blue channel midtone adjustment.",
          "min": -0.5,
          "max": 0.5
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "black_point",
        "white_point",
        "shadows",
        "midtones",
        "highlights",
        "red_midtones",
        "green_midtones",
        "blue_midtones"
      ]
    },
    {
      "title": "Exposure",
      "description": "Comprehensive tonal exposure controls similar to Lightroom/Camera Raw.\n    exposure, contrast, highlights, shadows, whites, blacks, tonal\n\n    Use cases:\n    - Correct over/underexposed images\n    - Recover highlight and shadow detail\n    - Adjust overall contrast and tonal range\n    - Fine-tune the brightness of specific tonal regions",
      "namespace": "lib.pillow.color_grading",
      "node_type": "lib.pillow.color_grading.Exposure",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust."
        },
        {
          "name": "exposure",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Exposure",
          "description": "Exposure adjustment in stops. Affects entire image.",
          "min": -5.0,
          "max": 5.0
        },
        {
          "name": "contrast",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Contrast",
          "description": "Contrast adjustment. Affects midtone separation.",
          "min": -1.0,
          "max": 1.0
        },
        {
          "name": "highlights",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Highlights",
          "description": "Highlight recovery/boost. Affects brightest areas.",
          "min": -1.0,
          "max": 1.0
        },
        {
          "name": "shadows",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Shadows",
          "description": "Shadow recovery/darken. Affects darkest areas.",
          "min": -1.0,
          "max": 1.0
        },
        {
          "name": "whites",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Whites",
          "description": "White point adjustment. Sets the brightest white.",
          "min": -1.0,
          "max": 1.0
        },
        {
          "name": "blacks",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Blacks",
          "description": "Black point adjustment. Sets the darkest black.",
          "min": -1.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "exposure",
        "contrast",
        "highlights",
        "shadows",
        "whites",
        "blacks"
      ]
    },
    {
      "title": "Film Look",
      "description": "Apply preset cinematic film looks with adjustable intensity.\n    film look, cinematic, preset, movie, lut, color grade\n\n    Use cases:\n    - Quickly apply popular cinematic color grades\n    - Create consistent looks across multiple images\n    - Emulate classic film stock characteristics\n    - Starting point for custom color grading",
      "namespace": "lib.pillow.color_grading",
      "node_type": "lib.pillow.color_grading.FilmLook",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to apply the film look to."
        },
        {
          "name": "preset",
          "type": {
            "type": "enum",
            "values": [
              "teal_orange",
              "blockbuster",
              "noir",
              "vintage",
              "cold_blue",
              "warm_sunset",
              "matrix",
              "bleach_bypass",
              "cross_process",
              "faded_film"
            ],
            "type_name": "nodetool.nodes.lib.pillow.color_grading.FilmLookPreset"
          },
          "default": "teal_orange",
          "title": "Preset",
          "description": "The cinematic look to apply."
        },
        {
          "name": "intensity",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Intensity",
          "description": "Intensity of the effect. 0=none, 1=full, 2=exaggerated.",
          "min": 0.0,
          "max": 2.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "preset",
        "intensity"
      ]
    },
    {
      "title": "HSLAdjust",
      "description": "Adjust hue, saturation, and luminance for specific color ranges.\n    hsl, hue, saturation, luminance, selective color, color range\n\n    Use cases:\n    - Shift specific colors (e.g., make blues more cyan)\n    - Desaturate or boost individual color ranges\n    - Brighten or darken specific colors\n    - Create color-specific looks (teal skies, orange skin)",
      "namespace": "lib.pillow.color_grading",
      "node_type": "lib.pillow.color_grading.HSLAdjust",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust."
        },
        {
          "name": "color_range",
          "type": {
            "type": "enum",
            "values": [
              "reds",
              "oranges",
              "yellows",
              "greens",
              "cyans",
              "blues",
              "purples",
              "magentas"
            ],
            "type_name": "nodetool.nodes.lib.pillow.color_grading.HSLAdjust.ColorRange"
          },
          "default": "reds",
          "title": "Color Range",
          "description": "The color range to adjust."
        },
        {
          "name": "hue_shift",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Hue Shift",
          "description": "Hue shift for the selected color range. -1 to 1 = -180 to +180 degrees.",
          "min": -1.0,
          "max": 1.0
        },
        {
          "name": "saturation",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Saturation",
          "description": "Saturation adjustment for the selected color range.",
          "min": -1.0,
          "max": 1.0
        },
        {
          "name": "luminance",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Luminance",
          "description": "Luminance adjustment for the selected color range.",
          "min": -1.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "color_range",
        "hue_shift",
        "saturation",
        "luminance"
      ]
    },
    {
      "title": "Lift Gamma Gain",
      "description": "Three-way color corrector for shadows, midtones, and highlights.\n    lift, gamma, gain, color wheels, primary correction, shadows, midtones, highlights\n\n    Use cases:\n    - Apply the industry-standard three-way color correction\n    - Balance colors across different tonal ranges\n    - Create color contrast between shadows and highlights\n    - Match footage from different sources\n\n    Lift affects shadows, Gamma affects midtones, Gain affects highlights.\n    Each control adjusts both luminance and color for its tonal range.",
      "namespace": "lib.pillow.color_grading",
      "node_type": "lib.pillow.color_grading.LiftGammaGain",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to color correct."
        },
        {
          "name": "lift_r",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Lift R",
          "description": "Red lift (shadow color shift).",
          "min": -1.0,
          "max": 1.0
        },
        {
          "name": "lift_g",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Lift G",
          "description": "Green lift (shadow color shift).",
          "min": -1.0,
          "max": 1.0
        },
        {
          "name": "lift_b",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Lift B",
          "description": "Blue lift (shadow color shift).",
          "min": -1.0,
          "max": 1.0
        },
        {
          "name": "lift_master",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Lift Master",
          "description": "Master lift (shadow brightness).",
          "min": -1.0,
          "max": 1.0
        },
        {
          "name": "gamma_r",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Gamma R",
          "description": "Red gamma (midtone adjustment).",
          "min": 0.1,
          "max": 4.0
        },
        {
          "name": "gamma_g",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Gamma G",
          "description": "Green gamma (midtone adjustment).",
          "min": 0.1,
          "max": 4.0
        },
        {
          "name": "gamma_b",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Gamma B",
          "description": "Blue gamma (midtone adjustment).",
          "min": 0.1,
          "max": 4.0
        },
        {
          "name": "gamma_master",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Gamma Master",
          "description": "Master gamma (overall midtones).",
          "min": 0.1,
          "max": 4.0
        },
        {
          "name": "gain_r",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Gain R",
          "description": "Red gain (highlight multiplier).",
          "min": 0.0,
          "max": 4.0
        },
        {
          "name": "gain_g",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Gain G",
          "description": "Green gain (highlight multiplier).",
          "min": 0.0,
          "max": 4.0
        },
        {
          "name": "gain_b",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Gain B",
          "description": "Blue gain (highlight multiplier).",
          "min": 0.0,
          "max": 4.0
        },
        {
          "name": "gain_master",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Gain Master",
          "description": "Master gain (overall brightness).",
          "min": 0.0,
          "max": 4.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "lift_r",
        "lift_g",
        "lift_b",
        "lift_master",
        "gamma_r",
        "gamma_g",
        "gamma_b",
        "gamma_master",
        "gain_r",
        "gain_g",
        "gain_b",
        "gain_master"
      ]
    },
    {
      "title": "Saturation Vibrance",
      "description": "Adjust color saturation with vibrance protection for skin tones.\n    saturation, vibrance, color intensity, skin tones\n\n    Use cases:\n    - Boost color intensity without clipping\n    - Protect skin tones while increasing saturation\n    - Create desaturated or oversaturated looks\n    - Fine-tune color intensity independently",
      "namespace": "lib.pillow.color_grading",
      "node_type": "lib.pillow.color_grading.SaturationVibrance",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust."
        },
        {
          "name": "saturation",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Saturation",
          "description": "Global saturation. 0 = no change, -1 = grayscale, 1 = 2x saturation.",
          "min": -1.0,
          "max": 1.0
        },
        {
          "name": "vibrance",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Vibrance",
          "description": "Smart saturation that protects already-saturated colors and skin tones.",
          "min": -1.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "saturation",
        "vibrance"
      ]
    },
    {
      "title": "Split Toning",
      "description": "Apply different color tints to shadows and highlights.\n    split toning, shadows, highlights, tint, duotone\n\n    Use cases:\n    - Create classic teal and orange looks\n    - Add color contrast between shadows and highlights\n    - Emulate film processing techniques\n    - Create stylized color-graded images",
      "namespace": "lib.pillow.color_grading",
      "node_type": "lib.pillow.color_grading.SplitToning",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to apply split toning to."
        },
        {
          "name": "shadow_hue",
          "type": {
            "type": "float"
          },
          "default": 200.0,
          "title": "Shadow Hue",
          "description": "Hue of shadow tint in degrees (0=red, 120=green, 240=blue).",
          "min": 0.0,
          "max": 360.0
        },
        {
          "name": "shadow_saturation",
          "type": {
            "type": "float"
          },
          "default": 0.3,
          "title": "Shadow Saturation",
          "description": "Saturation of shadow tint.",
          "min": 0.0,
          "max": 1.0
        },
        {
          "name": "highlight_hue",
          "type": {
            "type": "float"
          },
          "default": 40.0,
          "title": "Highlight Hue",
          "description": "Hue of highlight tint in degrees.",
          "min": 0.0,
          "max": 360.0
        },
        {
          "name": "highlight_saturation",
          "type": {
            "type": "float"
          },
          "default": 0.3,
          "title": "Highlight Saturation",
          "description": "Saturation of highlight tint.",
          "min": 0.0,
          "max": 1.0
        },
        {
          "name": "balance",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Balance",
          "description": "Balance between shadows (-1) and highlights (+1).",
          "min": -1.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "shadow_hue",
        "shadow_saturation",
        "highlight_hue",
        "highlight_saturation",
        "balance"
      ]
    },
    {
      "title": "Vignette",
      "description": "Apply cinematic vignette effect to darken or lighten image edges.\n    vignette, edge, darken, focus, cinematic\n\n    Use cases:\n    - Draw attention to the center of the image\n    - Create a classic cinematic look\n    - Simulate lens light falloff\n    - Add subtle framing to photos",
      "namespace": "lib.pillow.color_grading",
      "node_type": "lib.pillow.color_grading.Vignette",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to apply vignette to."
        },
        {
          "name": "amount",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Amount",
          "description": "Vignette amount. Positive darkens edges, negative lightens.",
          "min": -1.0,
          "max": 1.0
        },
        {
          "name": "midpoint",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Midpoint",
          "description": "Distance from center where vignette begins (0=center, 1=edges).",
          "min": 0.0,
          "max": 1.0
        },
        {
          "name": "roundness",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Roundness",
          "description": "Shape of vignette. 0=oval matching image aspect, 1=circular, -1=rectangular.",
          "min": -1.0,
          "max": 1.0
        },
        {
          "name": "feather",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Feather",
          "description": "Softness of the vignette edge.",
          "min": 0.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "amount",
        "midpoint",
        "roundness",
        "feather"
      ]
    },
    {
      "title": "Blur",
      "description": "Apply a Gaussian blur effect to an image.\n    image, filter, blur\n\n    - Soften images or reduce noise and detail\n    - Make focal areas stand out by blurring surroundings\n    - Protect privacy by blurring sensitive information",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.Blur",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to blur."
        },
        {
          "name": "radius",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Radius",
          "description": "Blur radius.",
          "min": 0.0,
          "max": 128.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "radius"
      ]
    },
    {
      "title": "Canny",
      "description": "Apply Canny edge detection to an image.\n    image, filter, edges\n\n    - Highlight areas of rapid intensity change\n    - Outline object boundaries and structure\n    - Enhance inputs for object detection and image segmentation",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.Canny",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to canny."
        },
        {
          "name": "low_threshold",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Low Threshold",
          "description": "Low threshold.",
          "min": 0.0,
          "max": 255.0
        },
        {
          "name": "high_threshold",
          "type": {
            "type": "int"
          },
          "default": 200,
          "title": "High Threshold",
          "description": "High threshold.",
          "min": 0.0,
          "max": 255.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "low_threshold",
        "high_threshold"
      ]
    },
    {
      "title": "Contour",
      "description": "Apply a contour filter to highlight image edges.\n    image, filter, contour\n\n    - Extract key features from complex images\n    - Aid pattern recognition and object detection\n    - Create stylized contour sketch art effects",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.Contour",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to contour."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Convert To Grayscale",
      "description": "Convert an image to grayscale.\n    image, grayscale\n\n    - Simplify images for feature and edge detection\n    - Prepare images for shape-based machine learning\n    - Create vintage or monochrome aesthetic effects",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.ConvertToGrayscale",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to convert."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Emboss",
      "description": "Apply an emboss filter for a 3D raised effect.\n    image, filter, emboss\n\n    - Add texture and depth to photos\n    - Create visually interesting graphics\n    - Incorporate unique effects in digital artwork",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.Emboss",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to emboss."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Expand",
      "description": "Add a border around an image to increase its size.\n    image, border, expand\n\n    - Make images stand out by adding a colored border\n    - Create framed photo effects\n    - Separate image content from surroundings",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.Expand",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to expand."
        },
        {
          "name": "border",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Border",
          "description": "Border size.",
          "min": 0.0,
          "max": 512.0
        },
        {
          "name": "fill",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Fill",
          "description": "Fill color.",
          "min": 0.0,
          "max": 255.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "border",
        "fill"
      ]
    },
    {
      "title": "Find Edges",
      "description": "Detect and highlight edges in an image.\n    image, filter, edges\n\n    - Analyze structural patterns in images\n    - Aid object detection in computer vision\n    - Detect important features like corners and ridges",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.FindEdges",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to find edges."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Get Channel",
      "description": "Extract a specific color channel from an image.\n    image, color, channel, isolate, extract\n\n    - Isolate color information for image analysis\n    - Manipulate specific color components in graphic design\n    - Enhance or reduce visibility of certain colors",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.GetChannel",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to get the channel from."
        },
        {
          "name": "channel",
          "type": {
            "type": "enum",
            "values": [
              "R",
              "G",
              "B"
            ],
            "type_name": "nodetool.nodes.lib.pillow.filter.GetChannel.ChannelEnum"
          },
          "default": "R",
          "title": "Channel"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "channel"
      ]
    },
    {
      "title": "Invert",
      "description": "Invert the colors of an image.\n    image, filter, invert\n\n    - Create negative versions of images for visual effects\n    - Analyze image data by bringing out hidden details\n    - Preprocess images for operations that work better on inverted colors",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.Invert",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to adjust the brightness for."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Posterize",
      "description": "Reduce the number of colors in an image for a poster-like effect.\n    image, filter, posterize\n\n    - Create graphic art by simplifying image colors\n    - Apply artistic effects to photographs\n    - Generate visually compelling content for advertising",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.Posterize",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to posterize."
        },
        {
          "name": "bits",
          "type": {
            "type": "int"
          },
          "default": 4,
          "title": "Bits",
          "description": "Number of bits to posterize to.",
          "min": 1.0,
          "max": 8.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "bits"
      ]
    },
    {
      "title": "Smooth",
      "description": "Apply smoothing to reduce image noise and detail.\n    image, filter, smooth\n\n    - Enhance visual aesthetics of images\n    - Improve object detection by reducing irrelevant details\n    - Aid facial recognition by simplifying images",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.Smooth",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to smooth."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image"
      ]
    },
    {
      "title": "Solarize",
      "description": "Apply a solarize effect to partially invert image tones.\n    image, filter, solarize\n\n    - Create surreal artistic photo effects\n    - Enhance visual data by making certain elements more prominent\n    - Add a unique style to images for graphic design",
      "namespace": "lib.pillow.filter",
      "node_type": "lib.pillow.filter.Solarize",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to solarize."
        },
        {
          "name": "threshold",
          "type": {
            "type": "int"
          },
          "default": 128,
          "title": "Threshold",
          "description": "Threshold for solarization.",
          "min": 0.0,
          "max": 255.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "threshold"
      ]
    },
    {
      "title": "Background",
      "description": "The Background Node creates a blank background.\n    image, background, blank, base, layer\n    This node is mainly used for generating a base layer for image processing tasks. It produces a uniform image, having a user-specified width, height and color. The color is given in a hexadecimal format, defaulting to white if not specified.\n\n    #### Applications\n    - As a base layer for creating composite images.\n    - As a starting point for generating patterns or graphics.\n    - When blank backgrounds of specific colors are required for visualization tasks.",
      "namespace": "lib.pillow.draw",
      "node_type": "lib.pillow.draw.Background",
      "properties": [
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Width",
          "min": 1.0,
          "max": 4096.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Height",
          "min": 1.0,
          "max": 4096.0
        },
        {
          "name": "color",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#FFFFFF"
          },
          "title": "Color"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "width",
        "height",
        "color"
      ]
    },
    {
      "title": "Gaussian Noise",
      "description": "This node creates and adds Gaussian noise to an image.\n    image, noise, gaussian, distortion, artifact\n\n    The Gaussian Noise Node is designed to simulate realistic distortions that can occur in a photographic image. It generates a noise-filled image using the Gaussian (normal) distribution. The noise level can be adjusted using the mean and standard deviation parameters.\n\n    #### Applications\n    - Simulating sensor noise in synthetic data.\n    - Testing image-processing algorithms' resilience to noise.\n    - Creating artistic effects in images.",
      "namespace": "lib.pillow.draw",
      "node_type": "lib.pillow.draw.GaussianNoise",
      "properties": [
        {
          "name": "mean",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Mean"
        },
        {
          "name": "stddev",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Stddev"
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Width",
          "min": 1.0,
          "max": 1024.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Height",
          "min": 1.0,
          "max": 1024.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "mean",
        "stddev",
        "width",
        "height"
      ]
    },
    {
      "title": "Render Text",
      "description": "This node allows you to add text to images.\n    text, font, label, title, watermark, caption, image, overlay\n    This node takes text, font updates, coordinates (where to place the text), and an image to work with. A user can use the Render Text Node to add a label or title to an image, watermark an image, or place a caption directly on an image.\n\n    The Render Text Node offers customizable options, including the ability to choose the text's font, size, color, and alignment (left, center, or right). Text placement can also be defined, providing flexibility to place the text wherever you see fit.\n\n    #### Applications\n    - Labeling images in a image gallery or database.\n    - Watermarking images for copyright protection.\n    - Adding custom captions to photographs.\n    - Creating instructional images to guide the reader's view.",
      "namespace": "lib.pillow.draw",
      "node_type": "lib.pillow.draw.RenderText",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to render."
        },
        {
          "name": "font",
          "type": {
            "type": "font"
          },
          "default": {
            "type": "font",
            "name": "DejaVuSans"
          },
          "title": "Font",
          "description": "The font to use."
        },
        {
          "name": "x",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "X",
          "description": "The x coordinate.",
          "min": 0.0
        },
        {
          "name": "y",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Y",
          "description": "The y coordinate.",
          "min": 0.0
        },
        {
          "name": "size",
          "type": {
            "type": "int"
          },
          "default": 12,
          "title": "Size",
          "description": "The font size.",
          "min": 1.0,
          "max": 512.0
        },
        {
          "name": "color",
          "type": {
            "type": "color"
          },
          "default": {
            "type": "color",
            "value": "#000000"
          },
          "title": "Color",
          "description": "The font color."
        },
        {
          "name": "align",
          "type": {
            "type": "enum",
            "values": [
              "left",
              "center",
              "right"
            ],
            "type_name": "nodetool.nodes.lib.pillow.draw.RenderText.TextAlignment"
          },
          "default": "left",
          "title": "Align"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to render on."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "text",
        "font",
        "x",
        "y",
        "size",
        "color",
        "align",
        "image"
      ]
    },
    {
      "title": "Suno",
      "description": "Generate music using Suno AI via Kie.ai.\n\n    kie, suno, music, audio, ai, generation, vocals, instrumental\n\n    Creates full tracks with vocals and instrumentals up to around 8 minutes long.\n    Supports the latest Suno V4.5+ model with improved vocal quality and composition.\n\n    Use cases:\n    - Generate background music for projects\n    - Create AI-composed songs with vocals\n    - Produce instrumentals for content\n    - Generate music in various genres and styles",
      "namespace": "kie.audio",
      "node_type": "kie.audio.Suno",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Description of the music to generate (genre, mood, instruments, etc.)."
        },
        {
          "name": "lyrics",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Lyrics",
          "description": "Optional lyrics for the song. Leave empty for instrumental."
        },
        {
          "name": "style",
          "type": {
            "type": "enum",
            "values": [
              "pop",
              "rock",
              "jazz",
              "classical",
              "electronic",
              "hip-hop",
              "r&b",
              "country",
              "folk",
              "ambient",
              "custom"
            ],
            "type_name": "nodetool.nodes.kie.audio.Suno.Style"
          },
          "default": "custom",
          "title": "Style",
          "description": "Music style/genre. Use 'custom' for prompt-based generation."
        },
        {
          "name": "instrumental",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Instrumental",
          "description": "Generate instrumental-only (no vocals)."
        },
        {
          "name": "duration",
          "type": {
            "type": "int"
          },
          "default": 60,
          "title": "Duration",
          "description": "Approximate duration in seconds.",
          "min": 30.0,
          "max": 480.0
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "v4",
              "v4.5",
              "v4.5+"
            ],
            "type_name": "nodetool.nodes.kie.audio.Suno.Model"
          },
          "default": "v4.5+",
          "title": "Model",
          "description": "Suno model version to use."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "lyrics",
        "style",
        "instrumental",
        "duration",
        "model"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Grok Imagine Image To Video",
      "description": "Generate videos from images using xAI's Grok Imagine model via Kie.ai.\n\n    kie, grok, xai, video generation, ai, image-to-video, multimodal\n\n    Grok Imagine can transform images into videos with coherent motion and\n    synchronized background elements.\n\n    Use cases:\n    - Animate static images\n    - Create videos from photos\n    - Generate motion from images",
      "namespace": "kie.video",
      "node_type": "kie.video.GrokImagineImageToVideo",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The source image to animate."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text to guide the animation."
        },
        {
          "name": "duration",
          "type": {
            "type": "enum",
            "values": [
              "short",
              "medium",
              "long"
            ],
            "type_name": "nodetool.nodes.kie.video.GrokImagineImageToVideo.Duration"
          },
          "default": "medium",
          "title": "Duration",
          "description": "Duration of the generated video."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "prompt",
        "duration"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Grok Imagine Text To Video",
      "description": "Generate videos from text using xAI's Grok Imagine model via Kie.ai.\n\n    kie, grok, xai, video generation, ai, text-to-video, multimodal\n\n    Grok Imagine can generate videos from text prompts with coherent motion\n    and synchronized background elements.\n\n    Use cases:\n    - Generate videos from text descriptions\n    - Create cinematic content from prompts\n    - Text-to-video generation",
      "namespace": "kie.video",
      "node_type": "kie.video.GrokImagineTextToVideo",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the video to generate."
        },
        {
          "name": "duration",
          "type": {
            "type": "enum",
            "values": [
              "short",
              "medium",
              "long"
            ],
            "type_name": "nodetool.nodes.kie.video.GrokImagineTextToVideo.Duration"
          },
          "default": "medium",
          "title": "Duration",
          "description": "Duration of the generated video."
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "720p",
              "1080p"
            ],
            "type_name": "nodetool.nodes.kie.video.GrokImagineTextToVideo.Resolution"
          },
          "default": "1080p",
          "title": "Resolution",
          "description": "Video resolution."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "duration",
        "resolution"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Hailuo Image To Video Pro",
      "description": "Generate videos from images using MiniMax's Hailuo 2.3 Pro model via Kie.ai.\n\n    kie, hailuo, minimax, video generation, ai, image-to-video, pro, high-quality\n\n    Hailuo 2.3 Pro specializes in realistic character motion, expressive facial\n    micro-expressions, and cinematic quality for image-to-video generation.\n\n    Use cases:\n    - Generate high-quality cinematic videos from images\n    - Create content with expressive facial animations\n    - Professional image-to-video production\n    - Complex character movements from static images",
      "namespace": "kie.video",
      "node_type": "kie.video.HailuoImageToVideoPro",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The reference image to animate into a video."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text to guide the video generation."
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "720p",
              "1080p"
            ],
            "type_name": "nodetool.nodes.kie.video.HailuoImageToVideoPro.Resolution"
          },
          "default": "1080p",
          "title": "Resolution",
          "description": "Video resolution."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "prompt",
        "resolution"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Hailuo Image To Video Standard",
      "description": "Generate videos from images using MiniMax's Hailuo 2.3 Standard model via Kie.ai.\n\n    kie, hailuo, minimax, video generation, ai, image-to-video, standard, fast\n\n    Hailuo 2.3 Standard offers efficient image-to-video generation with good quality\n    and faster processing times for practical use cases.\n\n    Use cases:\n    - Generate quality videos from images efficiently\n    - Quick image animation with realistic motion\n    - Fast image-to-video prototyping\n    - Practical video content creation",
      "namespace": "kie.video",
      "node_type": "kie.video.HailuoImageToVideoStandard",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The reference image to animate into a video."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text to guide the video generation."
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "720p",
              "1080p"
            ],
            "type_name": "nodetool.nodes.kie.video.HailuoImageToVideoStandard.Resolution"
          },
          "default": "720p",
          "title": "Resolution",
          "description": "Video resolution."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "prompt",
        "resolution"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Kling AIAvatar",
      "description": "Generate talking avatar videos using Kuaishou's Kling AI via Kie.ai.\n\n    kie, kling, kuaishou, avatar, video generation, ai, talking-head, lip-sync\n\n    Transforms a photo plus audio track into a lip-synced talking avatar video\n    with natural-looking speech animation and consistent identity.\n\n    Use cases:\n    - Create virtual influencer content\n    - Generate educational presenters\n    - Lip-synced avatar videos\n    - Virtual spokesperson creation",
      "namespace": "kie.video",
      "node_type": "kie.video.KlingAIAvatar",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The face/character image to animate."
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio track for lip-syncing."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text to guide emotions and expressions."
        },
        {
          "name": "mode",
          "type": {
            "type": "enum",
            "values": [
              "standard",
              "pro"
            ],
            "type_name": "nodetool.nodes.kie.video.KlingAIAvatar.Mode"
          },
          "default": "standard",
          "title": "Mode",
          "description": "Generation mode: 'standard' or 'pro' for higher quality."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "audio",
        "prompt",
        "mode"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Kling Image To Video",
      "description": "Generate videos from images using Kuaishou's Kling 2.6 model via Kie.ai.\n\n    kie, kling, kuaishou, video generation, ai, image-to-video, realistic\n\n    Kling 2.6 Image-to-Video transforms reference images into high-quality videos\n    with realistic motion, physics consistency, and cinematic quality output.\n\n    Use cases:\n    - Generate high-quality videos from images\n    - Create realistic motion and physics from images\n    - Animate static images with cinematic quality\n    - Professional image-to-video production",
      "namespace": "kie.video",
      "node_type": "kie.video.KlingImageToVideo",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The reference image to animate into a video."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text to guide the video generation."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "16:9",
              "9:16",
              "1:1"
            ],
            "type_name": "nodetool.nodes.kie.video.KlingImageToVideo.AspectRatio"
          },
          "default": "16:9",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated video."
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "720p",
              "1080p"
            ],
            "type_name": "nodetool.nodes.kie.video.KlingImageToVideo.Resolution"
          },
          "default": "720p",
          "title": "Resolution",
          "description": "Video resolution."
        },
        {
          "name": "duration",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "Duration",
          "description": "Video duration in seconds.",
          "min": 1.0,
          "max": 10.0
        },
        {
          "name": "seed",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Seed",
          "description": "Random seed for reproducible results. Use -1 for random seed."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "prompt",
        "aspect_ratio",
        "resolution",
        "duration",
        "seed"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Kling Text To Video",
      "description": "Generate videos from text using Kuaishou's Kling 2.6 model via Kie.ai.\n\n    kie, kling, kuaishou, video generation, ai, text-to-video, realistic\n\n    Kling 2.6 offers high-quality text-to-video generation with realistic motion,\n    physics consistency, and cinematic quality output.\n\n    Use cases:\n    - Generate high-quality videos from text\n    - Create realistic motion and physics\n    - Cinematic content creation\n    - Professional video production",
      "namespace": "kie.video",
      "node_type": "kie.video.KlingTextToVideo",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the video to generate."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "16:9",
              "9:16",
              "1:1"
            ],
            "type_name": "nodetool.nodes.kie.video.KlingTextToVideo.AspectRatio"
          },
          "default": "16:9",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated video."
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "720p",
              "1080p"
            ],
            "type_name": "nodetool.nodes.kie.video.KlingTextToVideo.Resolution"
          },
          "default": "720p",
          "title": "Resolution",
          "description": "Video resolution."
        },
        {
          "name": "duration",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "Duration",
          "description": "Video duration in seconds.",
          "min": 1.0,
          "max": 10.0
        },
        {
          "name": "seed",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Seed",
          "description": "Random seed for reproducible results. Use -1 for random seed."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "aspect_ratio",
        "resolution",
        "duration",
        "seed"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Seedance V 1 Lite Image To Video",
      "description": "Generate videos from images using ByteDance's Seedance V1 Lite model via Kie.ai.\n\n    kie, seedance, bytedance, video generation, ai, image-to-video, lite, fast\n\n    Seedance V1 Lite offers fast image-to-video generation with efficient processing,\n    transforming reference images into dynamic video sequences.\n\n    Use cases:\n    - Fast image animation from reference images\n    - Quick video prototyping\n    - Animate static images efficiently\n    - Rapid iteration on image-to-video concepts",
      "namespace": "kie.video",
      "node_type": "kie.video.SeedanceV1LiteImageToVideo",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The reference image to animate into a video."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text to guide the video generation."
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "720p",
              "1080p"
            ],
            "type_name": "nodetool.nodes.kie.video.SeedanceV1LiteImageToVideo.Resolution"
          },
          "default": "720p",
          "title": "Resolution",
          "description": "Video resolution."
        },
        {
          "name": "duration",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "Duration",
          "description": "Video duration in seconds.",
          "min": 1.0,
          "max": 10.0
        },
        {
          "name": "camera_fixed",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Camera Fixed",
          "description": "Whether to keep the camera fixed or allow camera movement."
        },
        {
          "name": "seed",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Seed",
          "description": "Random seed for reproducible results. Use -1 for random seed."
        },
        {
          "name": "enable_safety_checker",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Enable Safety Checker",
          "description": "Enable safety checker to filter inappropriate content."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "prompt",
        "resolution",
        "duration",
        "camera_fixed",
        "seed",
        "enable_safety_checker"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Seedance V 1 Lite Text To Video",
      "description": "Generate videos from text using ByteDance's Seedance V1 Lite model via Kie.ai.\n\n    kie, seedance, bytedance, video generation, ai, text-to-video, lite, fast\n\n    Seedance V1 Lite offers fast text-to-video generation with efficient processing,\n    supporting multi-shot videos and cinematic scene transitions.\n\n    Use cases:\n    - Fast video prototyping from text\n    - Create multi-shot videos with scene transitions\n    - Quick concept visualization\n    - Rapid iteration on video ideas",
      "namespace": "kie.video",
      "node_type": "kie.video.SeedanceV1LiteTextToVideo",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the video to generate. Supports shot descriptions with [Cut to] notation."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "16:9",
              "9:16",
              "1:1"
            ],
            "type_name": "nodetool.nodes.kie.video.SeedanceV1LiteTextToVideo.AspectRatio"
          },
          "default": "16:9",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated video."
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "720p",
              "1080p"
            ],
            "type_name": "nodetool.nodes.kie.video.SeedanceV1LiteTextToVideo.Resolution"
          },
          "default": "720p",
          "title": "Resolution",
          "description": "Video resolution."
        },
        {
          "name": "duration",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "Duration",
          "description": "Video duration in seconds.",
          "min": 1.0,
          "max": 10.0
        },
        {
          "name": "camera_fixed",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Camera Fixed",
          "description": "Whether to keep the camera fixed or allow camera movement."
        },
        {
          "name": "seed",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Seed",
          "description": "Random seed for reproducible results. Use -1 for random seed."
        },
        {
          "name": "enable_safety_checker",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Enable Safety Checker",
          "description": "Enable safety checker to filter inappropriate content."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "aspect_ratio",
        "resolution",
        "duration",
        "camera_fixed",
        "seed",
        "enable_safety_checker"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Seedance V 1 Pro Fast Image To Video",
      "description": "Generate videos from images using ByteDance's Seedance V1 Pro Fast model via Kie.ai.\n\n    kie, seedance, bytedance, video generation, ai, image-to-video, pro, fast\n\n    Seedance V1 Pro Fast offers balanced image-to-video generation with both\n    quality and speed, transforming reference images into high-quality video sequences\n    with optimized processing time.\n\n    Use cases:\n    - Generate high-quality videos from images efficiently\n    - Fast professional image animations\n    - Balanced quality and speed image-to-video conversion\n    - Production-ready image animation",
      "namespace": "kie.video",
      "node_type": "kie.video.SeedanceV1ProFastImageToVideo",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The reference image to animate into a video."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text to guide the video generation."
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "720p",
              "1080p"
            ],
            "type_name": "nodetool.nodes.kie.video.SeedanceV1ProFastImageToVideo.Resolution"
          },
          "default": "720p",
          "title": "Resolution",
          "description": "Video resolution."
        },
        {
          "name": "duration",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "Duration",
          "description": "Video duration in seconds.",
          "min": 1.0,
          "max": 10.0
        },
        {
          "name": "camera_fixed",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Camera Fixed",
          "description": "Whether to keep the camera fixed or allow camera movement."
        },
        {
          "name": "seed",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Seed",
          "description": "Random seed for reproducible results. Use -1 for random seed."
        },
        {
          "name": "enable_safety_checker",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Enable Safety Checker",
          "description": "Enable safety checker to filter inappropriate content."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "prompt",
        "resolution",
        "duration",
        "camera_fixed",
        "seed",
        "enable_safety_checker"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Seedance V 1 Pro Image To Video",
      "description": "Generate videos from images using ByteDance's Seedance V1 Pro model via Kie.ai.\n\n    kie, seedance, bytedance, video generation, ai, image-to-video, pro, high-quality\n\n    Seedance V1 Pro offers high-quality image-to-video generation with improved\n    fidelity, transforming reference images into professional video sequences.\n\n    Use cases:\n    - Generate high-quality videos from images\n    - Create professional image animations\n    - Cinematic image-to-video conversion\n    - High-fidelity video production from images",
      "namespace": "kie.video",
      "node_type": "kie.video.SeedanceV1ProImageToVideo",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The reference image to animate into a video."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text to guide the video generation."
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "720p",
              "1080p"
            ],
            "type_name": "nodetool.nodes.kie.video.SeedanceV1ProImageToVideo.Resolution"
          },
          "default": "720p",
          "title": "Resolution",
          "description": "Video resolution."
        },
        {
          "name": "duration",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "Duration",
          "description": "Video duration in seconds.",
          "min": 1.0,
          "max": 10.0
        },
        {
          "name": "camera_fixed",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Camera Fixed",
          "description": "Whether to keep the camera fixed or allow camera movement."
        },
        {
          "name": "seed",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Seed",
          "description": "Random seed for reproducible results. Use -1 for random seed."
        },
        {
          "name": "enable_safety_checker",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Enable Safety Checker",
          "description": "Enable safety checker to filter inappropriate content."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "prompt",
        "resolution",
        "duration",
        "camera_fixed",
        "seed",
        "enable_safety_checker"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Seedance V 1 Pro Text To Video",
      "description": "Generate videos from text using ByteDance's Seedance V1 Pro model via Kie.ai.\n\n    kie, seedance, bytedance, video generation, ai, text-to-video, pro, high-quality\n\n    Seedance V1 Pro offers high-quality text-to-video generation with improved\n    fidelity, supporting multi-shot videos and cinematic scene transitions.\n\n    Use cases:\n    - Generate high-quality videos from text\n    - Create professional multi-shot videos\n    - Cinematic content creation\n    - High-fidelity video production",
      "namespace": "kie.video",
      "node_type": "kie.video.SeedanceV1ProTextToVideo",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the video to generate. Supports shot descriptions with [Cut to] notation."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "16:9",
              "9:16",
              "1:1"
            ],
            "type_name": "nodetool.nodes.kie.video.SeedanceV1ProTextToVideo.AspectRatio"
          },
          "default": "16:9",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated video."
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "720p",
              "1080p"
            ],
            "type_name": "nodetool.nodes.kie.video.SeedanceV1ProTextToVideo.Resolution"
          },
          "default": "720p",
          "title": "Resolution",
          "description": "Video resolution."
        },
        {
          "name": "duration",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "Duration",
          "description": "Video duration in seconds.",
          "min": 1.0,
          "max": 10.0
        },
        {
          "name": "camera_fixed",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Camera Fixed",
          "description": "Whether to keep the camera fixed or allow camera movement."
        },
        {
          "name": "seed",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Seed",
          "description": "Random seed for reproducible results. Use -1 for random seed."
        },
        {
          "name": "enable_safety_checker",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Enable Safety Checker",
          "description": "Enable safety checker to filter inappropriate content."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "aspect_ratio",
        "resolution",
        "duration",
        "camera_fixed",
        "seed",
        "enable_safety_checker"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Sora 2 Image To Video",
      "description": "Generate videos from images using OpenAI's Sora 2 model via Kie.ai.\n\n    kie, sora, openai, video generation, ai, image-to-video, realistic\n\n    Sora 2 Image-to-Video transforms reference images into videos emphasizing\n    realistic motion, physics consistency, and native audio. Supports standard\n    and pro modes for different quality/speed tradeoffs.\n\n    Use cases:\n    - Generate realistic videos from images\n    - Create videos with native audio (dialogue/ambient sound)\n    - Animate static images with realistic motion\n    - Cinematic content creation from images",
      "namespace": "kie.video",
      "node_type": "kie.video.Sora2ImageToVideo",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The reference image to animate into a video."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text to guide the video generation."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "landscape",
              "portrait",
              "square"
            ],
            "type_name": "nodetool.nodes.kie.video.Sora2ImageToVideo.AspectRatio"
          },
          "default": "landscape",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated video."
        },
        {
          "name": "n_frames",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "N Frames",
          "description": "Number of frames for the video.",
          "min": 1.0,
          "max": 60.0
        },
        {
          "name": "remove_watermark",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Remove Watermark",
          "description": "Whether to remove the watermark from the generated video."
        },
        {
          "name": "mode",
          "type": {
            "type": "enum",
            "values": [
              "standard",
              "pro"
            ],
            "type_name": "nodetool.nodes.kie.video.Sora2ImageToVideo.Mode"
          },
          "default": "standard",
          "title": "Mode",
          "description": "Generation mode: 'standard' or 'pro' for higher quality."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "prompt",
        "aspect_ratio",
        "n_frames",
        "remove_watermark",
        "mode"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Sora 2 Pro Image To Video",
      "description": "Generate videos from images using OpenAI's Sora 2 Pro model via Kie.ai.\n\n    kie, sora, openai, video generation, ai, image-to-video, pro, 1080p\n\n    Sora 2 Pro Image-to-Video transforms reference images into professional-grade\n    HD videos with improved realism in motion and physics. Supports higher resolution\n    (HD) and longer clips (15s).\n\n    Use cases:\n    - Generate professional-grade HD videos from images\n    - Create longer 15-second video clips\n    - High-fidelity motion and physics from images\n    - Premium image-to-video content creation",
      "namespace": "kie.video",
      "node_type": "kie.video.Sora2ProImageToVideo",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The reference image to animate into a video."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text to guide the video generation."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "landscape",
              "portrait",
              "square"
            ],
            "type_name": "nodetool.nodes.kie.video.Sora2ProImageToVideo.AspectRatio"
          },
          "default": "landscape",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated video."
        },
        {
          "name": "n_frames",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "N Frames",
          "description": "Number of frames for the video.",
          "min": 1.0,
          "max": 60.0
        },
        {
          "name": "remove_watermark",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Remove Watermark",
          "description": "Whether to remove the watermark from the generated video."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "prompt",
        "aspect_ratio",
        "n_frames",
        "remove_watermark"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Sora 2 Pro Storyboard",
      "description": "Generate storyboard videos using OpenAI's Sora 2 Pro model via Kie.ai.\n\n    kie, sora, openai, video generation, ai, storyboard, pro, 1080p\n\n    Sora 2 Pro Storyboard creates professional-grade storyboard videos with\n    scene transitions, cinematic framing, and professional editing techniques.\n\n    Use cases:\n    - Generate cinematic storyboards from text\n    - Create professional video previews\n    - Plan video shoots with visual storyboards\n    - Develop video concepts with scene sequences",
      "namespace": "kie.video",
      "node_type": "kie.video.Sora2ProStoryboard",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the storyboard sequence."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "landscape",
              "portrait",
              "square"
            ],
            "type_name": "nodetool.nodes.kie.video.Sora2ProStoryboard.AspectRatio"
          },
          "default": "landscape",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated video."
        },
        {
          "name": "n_frames",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "N Frames",
          "description": "Number of frames for the video.",
          "min": 1.0,
          "max": 60.0
        },
        {
          "name": "remove_watermark",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Remove Watermark",
          "description": "Whether to remove the watermark from the generated video."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "aspect_ratio",
        "n_frames",
        "remove_watermark"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Sora 2 Pro Text To Video",
      "description": "Generate videos from text using OpenAI's Sora 2 Pro model via Kie.ai.\n\n    kie, sora, openai, video generation, ai, text-to-video, pro, 1080p\n\n    Sora 2 Pro Text-to-Video generates professional-grade HD videos from text prompts\n    with improved realism in motion and physics. Supports higher resolution (HD) and\n    longer clips (15s).\n\n    Use cases:\n    - Generate professional-grade HD videos from text\n    - Create longer 15-second clips\n    - High-fidelity motion and physics\n    - Premium text-to-video content creation",
      "namespace": "kie.video",
      "node_type": "kie.video.Sora2ProTextToVideo",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the video to generate."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "landscape",
              "portrait",
              "square"
            ],
            "type_name": "nodetool.nodes.kie.video.Sora2ProTextToVideo.AspectRatio"
          },
          "default": "landscape",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated video."
        },
        {
          "name": "n_frames",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "N Frames",
          "description": "Number of frames for the video.",
          "min": 1.0,
          "max": 60.0
        },
        {
          "name": "remove_watermark",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Remove Watermark",
          "description": "Whether to remove the watermark from the generated video."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "aspect_ratio",
        "n_frames",
        "remove_watermark"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Sora 2 Text To Video",
      "description": "Generate videos from text using OpenAI's Sora 2 model via Kie.ai.\n\n    kie, sora, openai, video generation, ai, text-to-video, realistic\n\n    Sora 2 Text-to-Video generates short videos (up to 10 seconds) from text prompts,\n    emphasizing realistic motion, physics consistency, and native audio. Supports\n    standard and pro modes for different quality/speed tradeoffs.\n\n    Use cases:\n    - Generate realistic videos from text\n    - Create videos with native audio (dialogue/ambient sound)\n    - Quick text-to-video prototyping\n    - Cinematic content creation",
      "namespace": "kie.video",
      "node_type": "kie.video.Sora2TextToVideo",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the video to generate."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "landscape",
              "portrait",
              "square"
            ],
            "type_name": "nodetool.nodes.kie.video.Sora2TextToVideo.AspectRatio"
          },
          "default": "landscape",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated video."
        },
        {
          "name": "n_frames",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "N Frames",
          "description": "Number of frames for the video.",
          "min": 1.0,
          "max": 60.0
        },
        {
          "name": "remove_watermark",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Remove Watermark",
          "description": "Whether to remove the watermark from the generated video."
        },
        {
          "name": "mode",
          "type": {
            "type": "enum",
            "values": [
              "standard",
              "pro"
            ],
            "type_name": "nodetool.nodes.kie.video.Sora2TextToVideo.Mode"
          },
          "default": "standard",
          "title": "Mode",
          "description": "Generation mode: 'standard' or 'pro' for higher quality."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "aspect_ratio",
        "n_frames",
        "remove_watermark",
        "mode"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Topaz Video Upscale",
      "description": "Upscale and enhance videos using Topaz Labs AI via Kie.ai.\n\n    kie, topaz, upscale, enhance, video, ai, 4k\n\n    Uses Topaz Labs' video enhancement AI to upscale videos to 1080p or 4K,\n    sharpen frames, reduce noise, and interpolate frames for smoother motion.\n\n    Use cases:\n    - Upscale old or low-quality footage to HD/4K\n    - Enhance YouTube content or game recordings\n    - Restore and improve home videos\n    - Prepare videos for high-resolution displays",
      "namespace": "kie.video",
      "node_type": "kie.video.TopazVideoUpscale",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {
            "type": "video",
            "uri": "",
            "asset_id": null,
            "data": null,
            "duration": null,
            "format": null
          },
          "title": "Video",
          "description": "The video to upscale."
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "1080p",
              "4k"
            ],
            "type_name": "nodetool.nodes.kie.video.TopazVideoUpscale.Resolution"
          },
          "default": "1080p",
          "title": "Resolution",
          "description": "Target resolution for upscaling."
        },
        {
          "name": "denoise",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Denoise",
          "description": "Apply denoising to reduce artifacts."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "video",
        "resolution",
        "denoise"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Flux 2 Flex Image To Image",
      "description": "Generate images using Black Forest Labs' Flux 2 Flex Image-to-Image model via Kie.ai.\n\n    kie, flux, flux-2, flux-flex, black-forest-labs, image generation, ai, image-to-image\n\n    Use cases:\n    - Transform existing images with text prompts\n    - Apply artistic styles to photos\n    - Create variations of existing images\n    - Enhance and modify images",
      "namespace": "kie.image",
      "node_type": "kie.image.Flux2FlexImageToImage",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing how to transform the image."
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The source image to transform."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "1:1",
              "16:9",
              "9:16",
              "4:3",
              "3:4"
            ],
            "type_name": "nodetool.nodes.kie.image.Flux2FlexImageToImage.AspectRatio"
          },
          "default": "1:1",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated image."
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "1K",
              "2K"
            ],
            "type_name": "nodetool.nodes.kie.image.Flux2FlexImageToImage.Resolution"
          },
          "default": "1K",
          "title": "Resolution",
          "description": "Output image resolution."
        },
        {
          "name": "steps",
          "type": {
            "type": "int"
          },
          "default": 25,
          "title": "Steps",
          "description": "Number of inference steps. Higher values may produce better quality but take longer.",
          "min": 1.0,
          "max": 50.0
        },
        {
          "name": "guidance_scale",
          "type": {
            "type": "float"
          },
          "default": 7.5,
          "title": "Guidance Scale",
          "description": "Guidance scale for the generation. Higher values adhere more closely to the prompt.",
          "min": 1.0,
          "max": 20.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "image",
        "aspect_ratio",
        "resolution",
        "steps",
        "guidance_scale"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Flux 2 Flex Text To Image",
      "description": "Generate images using Black Forest Labs' Flux 2 Flex Text-to-Image model via Kie.ai.\n\n    kie, flux, flux-2, flux-flex, black-forest-labs, image generation, ai, text-to-image\n\n    Use cases:\n    - Generate high-quality images from text with flexible parameters\n    - Create professional visual content\n    - Generate images with fine detail and artistic style",
      "namespace": "kie.image",
      "node_type": "kie.image.Flux2FlexTextToImage",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the image to generate."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "1:1",
              "16:9",
              "9:16",
              "4:3",
              "3:4"
            ],
            "type_name": "nodetool.nodes.kie.image.Flux2FlexTextToImage.AspectRatio"
          },
          "default": "1:1",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated image."
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "1K",
              "2K"
            ],
            "type_name": "nodetool.nodes.kie.image.Flux2FlexTextToImage.Resolution"
          },
          "default": "1K",
          "title": "Resolution",
          "description": "Output image resolution."
        },
        {
          "name": "steps",
          "type": {
            "type": "int"
          },
          "default": 25,
          "title": "Steps",
          "description": "Number of inference steps. Higher values may produce better quality but take longer.",
          "min": 1.0,
          "max": 50.0
        },
        {
          "name": "guidance_scale",
          "type": {
            "type": "float"
          },
          "default": 7.5,
          "title": "Guidance Scale",
          "description": "Guidance scale for the generation. Higher values adhere more closely to the prompt.",
          "min": 1.0,
          "max": 20.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "aspect_ratio",
        "resolution",
        "steps",
        "guidance_scale"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Flux 2 Pro Image To Image",
      "description": "Generate images using Black Forest Labs' Flux 2 Pro Image-to-Image model via Kie.ai.\n\n    kie, flux, flux-2, flux-pro, black-forest-labs, image generation, ai, image-to-image\n\n    Use cases:\n    - Transform existing images with text prompts\n    - Apply artistic styles to photos\n    - Create variations of existing images\n    - Enhance and modify images",
      "namespace": "kie.image",
      "node_type": "kie.image.Flux2ProImageToImage",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing how to transform the image."
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The source image to transform."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "1:1",
              "16:9",
              "9:16",
              "4:3",
              "3:4"
            ],
            "type_name": "nodetool.nodes.kie.image.Flux2ProImageToImage.AspectRatio"
          },
          "default": "1:1",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated image."
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "1K",
              "2K"
            ],
            "type_name": "nodetool.nodes.kie.image.Flux2ProImageToImage.Resolution"
          },
          "default": "1K",
          "title": "Resolution",
          "description": "Output image resolution."
        },
        {
          "name": "steps",
          "type": {
            "type": "int"
          },
          "default": 25,
          "title": "Steps",
          "description": "Number of inference steps. Higher values may produce better quality but take longer.",
          "min": 1.0,
          "max": 50.0
        },
        {
          "name": "guidance_scale",
          "type": {
            "type": "float"
          },
          "default": 7.5,
          "title": "Guidance Scale",
          "description": "Guidance scale for the generation. Higher values adhere more closely to the prompt.",
          "min": 1.0,
          "max": 20.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "image",
        "aspect_ratio",
        "resolution",
        "steps",
        "guidance_scale"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Flux 2 Pro Text To Image",
      "description": "Generate images using Black Forest Labs' Flux 2 Pro Text-to-Image model via Kie.ai.\n\n    kie, flux, flux-2, flux-pro, black-forest-labs, image generation, ai, text-to-image\n\n    Use cases:\n    - Generate high-quality artistic images from text\n    - Create professional visual content\n    - Generate images with fine detail and artistic style",
      "namespace": "kie.image",
      "node_type": "kie.image.Flux2ProTextToImage",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the image to generate."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "1:1",
              "16:9",
              "9:16",
              "4:3",
              "3:4"
            ],
            "type_name": "nodetool.nodes.kie.image.Flux2ProTextToImage.AspectRatio"
          },
          "default": "1:1",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated image."
        },
        {
          "name": "resolution",
          "type": {
            "type": "enum",
            "values": [
              "1K",
              "2K"
            ],
            "type_name": "nodetool.nodes.kie.image.Flux2ProTextToImage.Resolution"
          },
          "default": "1K",
          "title": "Resolution",
          "description": "Output image resolution."
        },
        {
          "name": "steps",
          "type": {
            "type": "int"
          },
          "default": 25,
          "title": "Steps",
          "description": "Number of inference steps. Higher values may produce better quality but take longer.",
          "min": 1.0,
          "max": 50.0
        },
        {
          "name": "guidance_scale",
          "type": {
            "type": "float"
          },
          "default": 7.5,
          "title": "Guidance Scale",
          "description": "Guidance scale for the generation. Higher values adhere more closely to the prompt.",
          "min": 1.0,
          "max": 20.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "aspect_ratio",
        "resolution",
        "steps",
        "guidance_scale"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Flux Kontext",
      "description": "Generate images using Black Forest Labs' Flux Kontext model via Kie.ai.\n\n    kie, flux, flux-kontext, black-forest-labs, image generation, ai, text-to-image, editing\n\n    Flux Kontext supports Pro (speed-optimized) and Max (quality-focused) variants\n    with features like multiple aspect ratios, safety controls, and async processing.\n\n    Use cases:\n    - Generate high-quality artistic images\n    - Advanced image editing and generation\n    - Create professional visual content\n    - Generate images with fine detail and artistic style",
      "namespace": "kie.image",
      "node_type": "kie.image.FluxKontext",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the image to generate."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "1:1",
              "16:9",
              "9:16",
              "4:3",
              "3:4"
            ],
            "type_name": "nodetool.nodes.kie.image.FluxKontext.AspectRatio"
          },
          "default": "1:1",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated image."
        },
        {
          "name": "mode",
          "type": {
            "type": "enum",
            "values": [
              "pro",
              "max"
            ],
            "type_name": "nodetool.nodes.kie.image.FluxKontext.Mode"
          },
          "default": "pro",
          "title": "Mode",
          "description": "Generation mode: 'pro' for speed, 'max' for quality."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "aspect_ratio",
        "mode"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Grok Imagine Text To Image",
      "description": "Generate images using xAI's Grok Imagine Text-to-Image model via Kie.ai.\n\n    kie, grok, xai, image generation, ai, text-to-image, multimodal\n\n    Grok Imagine is a multimodal generative model that can generate images\n    from text prompts.\n\n    Use cases:\n    - Generate images from text descriptions\n    - Create visual content with AI",
      "namespace": "kie.image",
      "node_type": "kie.image.GrokImagineTextToImage",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the image to generate."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "1:1",
              "16:9",
              "9:16",
              "4:3",
              "3:4"
            ],
            "type_name": "nodetool.nodes.kie.image.GrokImagineTextToImage.AspectRatio"
          },
          "default": "1:1",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated image."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "aspect_ratio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Grok Imagine Upscale",
      "description": "Upscale images using xAI's Grok Imagine Upscale model via Kie.ai.\n\n    kie, grok, xai, upscale, enhance, image, ai, super-resolution\n\n    Grok Imagine Upscale enhances and upscales images to higher resolutions\n    while maintaining quality and detail.\n\n    Use cases:\n    - Upscale low-resolution images\n    - Enhance image quality and detail\n    - Improve resolution for printing or display",
      "namespace": "kie.image",
      "node_type": "kie.image.GrokImagineUpscale",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to upscale."
        },
        {
          "name": "scale_factor",
          "type": {
            "type": "enum",
            "values": [
              "2",
              "4",
              "8"
            ],
            "type_name": "nodetool.nodes.kie.image.GrokImagineUpscale.ScaleFactor"
          },
          "default": "2",
          "title": "Scale Factor",
          "description": "The upscaling factor (2x, 4x, or 8x)."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "scale_factor"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Nano Banana",
      "description": "Generate images using Google's Nano Banana model (Gemini 2.5) via Kie.ai.\n\n    kie, nano-banana, google, gemini, image generation, ai, text-to-image, fast\n\n    Nano Banana is powered by Gemini 2.5 Flash Image and offers fast\n    language-driven image generation/editing, focusing on speed and iteration efficiency.\n\n    Use cases:\n    - Generate images with efficient processing\n    - Create visual content quickly\n    - Generate images for rapid prototyping\n    - Fast iteration on image concepts",
      "namespace": "kie.image",
      "node_type": "kie.image.NanoBanana",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the image to generate."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "1:1",
              "16:9",
              "9:16",
              "4:3",
              "3:4"
            ],
            "type_name": "nodetool.nodes.kie.image.NanoBanana.AspectRatio"
          },
          "default": "1:1",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated image."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "aspect_ratio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Nano Banana Pro",
      "description": "Generate images using Google's Nano Banana Pro model (Gemini 3.0) via Kie.ai.\n\n    kie, nano-banana-pro, google, gemini, image generation, ai, text-to-image, 4k, high-fidelity\n\n    Nano Banana Pro is based on Gemini 3.0 Pro Image and provides higher fidelity\n    with sharper structure, 4K output, and better text rendering for photorealistic results.\n\n    Use cases:\n    - Generate high-fidelity photorealistic images\n    - Create 4K resolution content\n    - Generate images with sharp text rendering\n    - Professional-grade visual content",
      "namespace": "kie.image",
      "node_type": "kie.image.NanoBananaPro",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the image to generate."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "1:1",
              "16:9",
              "9:16",
              "4:3",
              "3:4"
            ],
            "type_name": "nodetool.nodes.kie.image.NanoBananaPro.AspectRatio"
          },
          "default": "1:1",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated image."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "aspect_ratio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Qwen Image To Image",
      "description": "Transform images using Qwen's Image-to-Image model via Kie.ai.\n\n    kie, qwen, alibaba, image transformation, ai, image-to-image\n\n    Qwen's image-to-image model transforms existing images based on text prompts.\n\n    Use cases:\n    - Transform and edit existing images\n    - Apply styles and effects to photos\n    - Create variations of images\n    - Enhance or modify image content",
      "namespace": "kie.image",
      "node_type": "kie.image.QwenImageToImage",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing how to transform the image."
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The source image to transform."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "1:1",
              "16:9",
              "9:16",
              "4:3",
              "3:4"
            ],
            "type_name": "nodetool.nodes.kie.image.QwenImageToImage.AspectRatio"
          },
          "default": "1:1",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the output image."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "image",
        "aspect_ratio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Qwen Text To Image",
      "description": "Generate images using Qwen's Text-to-Image model via Kie.ai.\n\n    kie, qwen, alibaba, image generation, ai, text-to-image\n\n    Qwen's text-to-image model generates high-quality images from text descriptions.\n\n    Use cases:\n    - Generate images from text descriptions\n    - Create artistic and realistic images\n    - Generate illustrations and artwork",
      "namespace": "kie.image",
      "node_type": "kie.image.QwenTextToImage",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the image to generate."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "1:1",
              "16:9",
              "9:16",
              "4:3",
              "3:4"
            ],
            "type_name": "nodetool.nodes.kie.image.QwenTextToImage.AspectRatio"
          },
          "default": "1:1",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated image."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "aspect_ratio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Seedream 45 Edit",
      "description": "Edit images using ByteDance's Seedream 4.5 Edit model via Kie.ai.\n\n    kie, seedream, bytedance, image editing, ai, image-to-image, 4k\n\n    Seedream 4.5 Edit allows you to modify existing images while maintaining\n    high quality and detail fidelity up to 4K resolution.\n\n    Use cases:\n    - Edit and enhance existing images\n    - Apply style changes to photos\n    - Modify specific regions of images\n    - Improve image quality and resolution",
      "namespace": "kie.image",
      "node_type": "kie.image.Seedream45Edit",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing how to edit the image."
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The source image to edit."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "1:1",
              "16:9",
              "9:16",
              "4:3",
              "3:4"
            ],
            "type_name": "nodetool.nodes.kie.image.Seedream45Edit.AspectRatio"
          },
          "default": "1:1",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the output image."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "image",
        "aspect_ratio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Seedream 45 Text To Image",
      "description": "Generate images using ByteDance's Seedream 4.5 Text-to-Image model via Kie.ai.\n\n    kie, seedream, bytedance, image generation, ai, text-to-image, 4k\n\n    Seedream 4.5 generates high-quality visuals up to 4K resolution with\n    improved detail fidelity, multi-image blending, and sharp text/face rendering.\n\n    Use cases:\n    - Generate creative and artistic images from text\n    - Create diverse visual content up to 4K\n    - Generate illustrations with unique styles",
      "namespace": "kie.image",
      "node_type": "kie.image.Seedream45TextToImage",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the image to generate."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "1:1",
              "16:9",
              "9:16",
              "4:3",
              "3:4"
            ],
            "type_name": "nodetool.nodes.kie.image.Seedream45TextToImage.AspectRatio"
          },
          "default": "1:1",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated image."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "aspect_ratio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Topaz Image Upscale",
      "description": "Upscale and enhance images using Topaz Labs AI via Kie.ai.\n\n    kie, topaz, upscale, enhance, image, ai, super-resolution\n\n    Leverages Topaz Labs' image super-resolution models to upscale and enhance images.\n    Can enlarge images by 2x, 4x, etc., while unblurring and sharpening details.\n\n    Use cases:\n    - Upscale low-resolution images to high resolution\n    - Enhance old or degraded photos\n    - Improve AI-generated art quality\n    - Prepare images for large format printing",
      "namespace": "kie.image",
      "node_type": "kie.image.TopazImageUpscale",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to upscale."
        },
        {
          "name": "scale_factor",
          "type": {
            "type": "enum",
            "values": [
              "2",
              "4"
            ],
            "type_name": "nodetool.nodes.kie.image.TopazImageUpscale.ScaleFactor"
          },
          "default": "2",
          "title": "Scale Factor",
          "description": "The upscaling factor (2x or 4x)."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "image",
        "scale_factor"
      ],
      "expose_as_tool": true
    },
    {
      "title": "ZImage",
      "description": "Generate images using Alibaba's Z-Image Turbo model via Kie.ai.\n\n    kie, z-image, zimage, alibaba, image generation, ai, text-to-image, photorealistic\n\n    Z-Image Turbo produces realistic, detail-rich images with very low latency.\n    It supports bilingual text (English/Chinese) in images with sharp text rendering.\n\n    Use cases:\n    - Generate high-quality photorealistic images quickly\n    - Create images with embedded text (English/Chinese)\n    - Generate detailed illustrations with low latency\n    - Product visualizations",
      "namespace": "kie.image",
      "node_type": "kie.image.ZImage",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the image to generate."
        },
        {
          "name": "aspect_ratio",
          "type": {
            "type": "enum",
            "values": [
              "1:1",
              "16:9",
              "9:16",
              "4:3",
              "3:4"
            ],
            "type_name": "nodetool.nodes.kie.image.ZImage.AspectRatio"
          },
          "default": "1:1",
          "title": "Aspect Ratio",
          "description": "The aspect ratio of the generated image."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "aspect_ratio"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Add Vectors",
      "description": "Add vectors to a FAISS index.\n    faiss, add, vectors",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.AddVectors",
      "properties": [
        {
          "name": "index",
          "type": {
            "type": "faiss_index"
          },
          "default": {
            "type": "faiss_index",
            "index": null
          },
          "title": "Index",
          "description": "FAISS index"
        },
        {
          "name": "vectors",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Vectors",
          "description": "Vectors to add (n, d)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "faiss_index"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "index",
        "vectors"
      ]
    },
    {
      "title": "Add With Ids",
      "description": "Add vectors with explicit integer IDs to a FAISS index.\n    faiss, add, ids, vectors",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.AddWithIds",
      "properties": [
        {
          "name": "index",
          "type": {
            "type": "faiss_index"
          },
          "default": {
            "type": "faiss_index",
            "index": null
          },
          "title": "Index",
          "description": "FAISS index"
        },
        {
          "name": "vectors",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Vectors",
          "description": "Vectors to add (n, d)"
        },
        {
          "name": "ids",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Ids",
          "description": "1-D int64 IDs (n,)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "faiss_index"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "index",
        "vectors",
        "ids"
      ]
    },
    {
      "title": "Create Index Flat IP",
      "description": "Create a FAISS IndexFlatIP (inner product / cosine with normalized vectors).\n    faiss, index, ip, create",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.CreateIndexFlatIP",
      "properties": [
        {
          "name": "dim",
          "type": {
            "type": "int"
          },
          "default": 768,
          "title": "Dim",
          "description": "Embedding dimensionality",
          "min": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "faiss_index"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dim"
      ]
    },
    {
      "title": "Create Index Flat L 2",
      "description": "Create a FAISS IndexFlatL2.\n    faiss, index, l2, create",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.CreateIndexFlatL2",
      "properties": [
        {
          "name": "dim",
          "type": {
            "type": "int"
          },
          "default": 768,
          "title": "Dim",
          "description": "Embedding dimensionality",
          "min": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "faiss_index"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dim"
      ]
    },
    {
      "title": "Create Index IVFFlat",
      "description": "Create a FAISS IndexIVFFlat (inverted file index with flat quantizer).\n    faiss, index, ivf, create",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.CreateIndexIVFFlat",
      "properties": [
        {
          "name": "dim",
          "type": {
            "type": "int"
          },
          "default": 768,
          "title": "Dim",
          "description": "Embedding dimensionality",
          "min": 1.0
        },
        {
          "name": "nlist",
          "type": {
            "type": "int"
          },
          "default": 1024,
          "title": "Nlist",
          "description": "Number of Voronoi cells",
          "min": 1.0
        },
        {
          "name": "metric",
          "type": {
            "type": "enum",
            "values": [
              "L2",
              "IP"
            ],
            "type_name": "nodetool.nodes.vector.faiss.Metric"
          },
          "default": "L2",
          "title": "Metric",
          "description": "Distance metric"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "faiss_index"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "dim",
        "nlist",
        "metric"
      ]
    },
    {
      "title": "Search",
      "description": "Search a FAISS index with query vectors, returning distances and indices.\n    faiss, search, query, knn",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.Search",
      "properties": [
        {
          "name": "index",
          "type": {
            "type": "faiss_index"
          },
          "default": {
            "type": "faiss_index",
            "index": null
          },
          "title": "Index",
          "description": "FAISS index"
        },
        {
          "name": "query",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Query",
          "description": "Query vectors (m, d) or (d,)"
        },
        {
          "name": "k",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "K",
          "description": "Number of nearest neighbors",
          "min": 1.0
        },
        {
          "name": "nprobe",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Nprobe",
          "description": "nprobe for IVF indices",
          "min": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "distances"
        },
        {
          "type": {
            "type": "np_array"
          },
          "name": "indices"
        }
      ],
      "basic_fields": [
        "index",
        "query",
        "k",
        "nprobe"
      ]
    },
    {
      "title": "Train Index",
      "description": "Train a FAISS index with training vectors (required for IVF indices).\n    faiss, train, index",
      "namespace": "vector.faiss",
      "node_type": "vector.faiss.TrainIndex",
      "properties": [
        {
          "name": "index",
          "type": {
            "type": "faiss_index"
          },
          "default": {
            "type": "faiss_index",
            "index": null
          },
          "title": "Index",
          "description": "FAISS index"
        },
        {
          "name": "vectors",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Vectors",
          "description": "Training vectors (n, d)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "faiss_index"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "index",
        "vectors"
      ]
    },
    {
      "title": "Collection",
      "description": "Get or create a named vector database collection for storing embeddings.\n    vector, embedding, collection, RAG, get, create, chroma\n\n    Use cases:\n    - Initialize collections for semantic search\n    - Organize embeddings by topic or domain\n    - Set up vector stores for RAG applications\n    - Manage multiple vector databases\n    - Configure embedding models per collection",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.Collection",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The name of the collection to create"
        },
        {
          "name": "embedding_model",
          "type": {
            "type": "llama_model"
          },
          "default": {
            "type": "llama_model",
            "name": "",
            "repo_id": "",
            "modified_at": "",
            "size": 0,
            "digest": "",
            "details": {}
          },
          "title": "Embedding Model",
          "description": "Model to use for embedding, search for nomic-embed-text and download it"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "collection"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "name",
        "embedding_model"
      ]
    },
    {
      "title": "Count",
      "description": "Count the number of documents in a collection.\n    vector, embedding, collection, RAG, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.Count",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to count"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "collection"
      ]
    },
    {
      "title": "Get Documents",
      "description": "Get documents from a chroma collection.\n    vector, embedding, collection, RAG, retrieve, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.GetDocuments",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to get"
        },
        {
          "name": "ids",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Ids",
          "description": "The ids of the documents to get"
        },
        {
          "name": "limit",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Limit",
          "description": "The limit of the documents to get"
        },
        {
          "name": "offset",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Offset",
          "description": "The offset of the documents to get"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "collection",
        "ids",
        "limit",
        "offset"
      ]
    },
    {
      "title": "Hybrid Search",
      "description": "Hybrid search combining semantic and keyword-based search for better retrieval. Uses reciprocal rank fusion to combine results from both methods.\n    vector, RAG, query, semantic, text, similarity, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.HybridSearch",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to query"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to query"
        },
        {
          "name": "n_results",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "N Results",
          "description": "The number of final results to return"
        },
        {
          "name": "k_constant",
          "type": {
            "type": "float"
          },
          "default": 60.0,
          "title": "K Constant",
          "description": "Constant for reciprocal rank fusion (default: 60.0)"
        },
        {
          "name": "min_keyword_length",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "Min Keyword Length",
          "description": "Minimum length for keyword tokens"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "ids"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "metadatas"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "distances"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "scores"
        }
      ],
      "basic_fields": [
        "collection",
        "text",
        "n_results",
        "k_constant",
        "min_keyword_length"
      ]
    },
    {
      "title": "Index Aggregated Text",
      "description": "Index multiple text chunks at once with aggregated embeddings from Ollama.\n    vector, embedding, collection, RAG, index, text, chunk, batch, ollama, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.IndexAggregatedText",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "document",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document",
          "description": "The document to index"
        },
        {
          "name": "document_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document Id",
          "description": "The document ID to associate with the text"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the text"
        },
        {
          "name": "text_chunks",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "union",
                "type_args": [
                  {
                    "type": "text_chunk"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Text Chunks",
          "description": "List of text chunks to index"
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window",
          "description": "The context window size to use for the model",
          "min": 1.0
        },
        {
          "name": "aggregation",
          "type": {
            "type": "enum",
            "values": [
              "mean",
              "max",
              "min",
              "sum"
            ],
            "type_name": "nodetool.nodes.vector.chroma.EmbeddingAggregation"
          },
          "default": "mean",
          "title": "Aggregation",
          "description": "The aggregation method to use for the embeddings."
        }
      ],
      "basic_fields": [
        "collection",
        "document",
        "document_id",
        "metadata",
        "text_chunks",
        "context_window",
        "aggregation"
      ]
    },
    {
      "title": "Index Embedding",
      "description": "Index a single embedding vector into a Chroma collection with optional metadata. Creates a searchable entry that can be queried for similarity matching.\n    vector, index, embedding, chroma, storage, RAG",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.IndexEmbedding",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "embedding",
          "type": {
            "type": "np_array"
          },
          "default": {
            "type": "np_array",
            "value": null,
            "dtype": "<i8",
            "shape": [
              1
            ]
          },
          "title": "Embedding",
          "description": "The embedding to index"
        },
        {
          "name": "index_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Index Id",
          "description": "The ID to associate with the embedding"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the embedding"
        }
      ],
      "basic_fields": [
        "collection",
        "embedding",
        "index_id",
        "metadata"
      ]
    },
    {
      "title": "Index Image",
      "description": "Index a list of image assets or files.\n    vector, embedding, collection, RAG, index, image, batch, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.IndexImage",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": [],
          "title": "Image",
          "description": "List of image assets to index"
        },
        {
          "name": "index_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Index Id",
          "description": "The ID to associate with the image, defaults to the URI of the image"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the image"
        },
        {
          "name": "upsert",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Upsert",
          "description": "Whether to upsert the images"
        }
      ],
      "basic_fields": [
        "collection",
        "image",
        "index_id",
        "metadata",
        "upsert"
      ]
    },
    {
      "title": "Index String",
      "description": "Index a string with a Document ID to a collection.\n    vector, embedding, collection, RAG, index, text, string, chroma\n\n    Use cases:\n    - Index documents for a vector search",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.IndexString",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text content to index"
        },
        {
          "name": "document_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document Id",
          "description": "Document ID to associate with the text content"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the text"
        }
      ],
      "basic_fields": [
        "collection",
        "text",
        "document_id",
        "metadata"
      ]
    },
    {
      "title": "Index Text Chunk",
      "description": "Index a single text chunk.\n    vector, embedding, collection, RAG, index, text, chunk, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.IndexTextChunk",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "document_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document Id",
          "description": "The document ID to associate with the text chunk"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to index"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the text chunk"
        }
      ],
      "basic_fields": [
        "collection",
        "document_id",
        "text",
        "metadata"
      ]
    },
    {
      "title": "Peek",
      "description": "Peek at the documents in a collection.\n    vector, embedding, collection, RAG, preview, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.Peek",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to peek"
        },
        {
          "name": "limit",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Limit",
          "description": "The limit of the documents to peek"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "collection",
        "limit"
      ]
    },
    {
      "title": "Query Image",
      "description": "Query the index for similar images.\n    vector, RAG, query, image, search, similarity, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.QueryImage",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to query"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {
            "type": "image",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Image",
          "description": "The image to query"
        },
        {
          "name": "n_results",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "N Results",
          "description": "The number of results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "ids"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "metadatas"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "distances"
        }
      ],
      "basic_fields": [
        "collection",
        "image",
        "n_results"
      ]
    },
    {
      "title": "Query Text",
      "description": "Query the index for similar text.\n    vector, RAG, query, text, search, similarity, chroma",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.QueryText",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {
            "type": "collection",
            "name": ""
          },
          "title": "Collection",
          "description": "The collection to query"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to query"
        },
        {
          "name": "n_results",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "N Results",
          "description": "The number of results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "ids"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "metadatas"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "distances"
        }
      ],
      "basic_fields": [
        "collection",
        "text",
        "n_results"
      ]
    },
    {
      "title": "Remove Overlap",
      "description": "Removes overlapping words between consecutive strings in a list. Splits text into words and matches word sequences for more accurate overlap detection.\n    vector, RAG, query, text, processing, overlap, deduplication",
      "namespace": "vector.chroma",
      "node_type": "vector.chroma.RemoveOverlap",
      "properties": [
        {
          "name": "documents",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Documents",
          "description": "List of strings to process for overlap removal"
        },
        {
          "name": "min_overlap_words",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Min Overlap Words",
          "description": "Minimum number of words that must overlap to be considered"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        }
      ],
      "basic_fields": [
        "documents",
        "min_overlap_words"
      ]
    },
    {
      "title": "Telegram Bot Trigger",
      "description": "Trigger node that listens for Telegram messages using long polling.\n\n    This trigger connects to Telegram using a bot token and emits events\n    for incoming messages.",
      "namespace": "messaging.telegram",
      "node_type": "messaging.telegram.TelegramBotTrigger",
      "properties": [
        {
          "name": "max_events",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Max Events",
          "description": "Maximum number of events to process (0 = unlimited)",
          "min": 0.0
        },
        {
          "name": "token",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Token",
          "description": "Telegram bot token"
        },
        {
          "name": "chat_id",
          "type": {
            "type": "int",
            "optional": true
          },
          "default": null,
          "title": "Chat Id",
          "description": "Optional chat ID to filter messages"
        },
        {
          "name": "allow_bot_messages",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Allow Bot Messages",
          "description": "Include messages authored by bots"
        },
        {
          "name": "include_edited_messages",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Include Edited Messages",
          "description": "Include edited messages"
        },
        {
          "name": "poll_timeout_seconds",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Poll Timeout Seconds",
          "description": "Long polling timeout in seconds",
          "min": 1.0,
          "max": 60.0
        },
        {
          "name": "poll_interval_seconds",
          "type": {
            "type": "float"
          },
          "default": 0.2,
          "title": "Poll Interval Seconds",
          "description": "Delay between polling requests",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "update_id"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "update_type"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "message_id"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "caption"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "name": "entities"
        },
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "chat"
        },
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "from"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "name": "attachments"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "timestamp"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "source"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "event_type"
        }
      ],
      "basic_fields": [
        "max_events",
        "token",
        "chat_id",
        "allow_bot_messages",
        "include_edited_messages",
        "poll_timeout_seconds",
        "poll_interval_seconds"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Telegram Send Message",
      "description": "Node that sends a message to a Telegram chat using a bot token.",
      "namespace": "messaging.telegram",
      "node_type": "messaging.telegram.TelegramSendMessage",
      "properties": [
        {
          "name": "token",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Token",
          "description": "Telegram bot token"
        },
        {
          "name": "chat_id",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Chat Id",
          "description": "Target chat ID",
          "min": 1.0
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Message text"
        },
        {
          "name": "parse_mode",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Parse Mode",
          "description": "Optional parse mode (MarkdownV2 or HTML)"
        },
        {
          "name": "disable_web_page_preview",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Disable Web Page Preview",
          "description": "Disable link previews"
        },
        {
          "name": "disable_notification",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Disable Notification",
          "description": "Send silently"
        },
        {
          "name": "reply_to_message_id",
          "type": {
            "type": "int",
            "optional": true
          },
          "default": null,
          "title": "Reply To Message Id",
          "description": "Reply to a specific message ID",
          "min": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "token",
        "chat_id",
        "text",
        "parse_mode",
        "disable_web_page_preview",
        "disable_notification",
        "reply_to_message_id"
      ]
    },
    {
      "title": "Discord Bot Trigger",
      "description": "Trigger node that listens for Discord messages from a bot account.\n\n    This trigger connects to Discord using a bot token and emits events\n    for incoming messages.",
      "namespace": "messaging.discord",
      "node_type": "messaging.discord.DiscordBotTrigger",
      "properties": [
        {
          "name": "max_events",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Max Events",
          "description": "Maximum number of events to process (0 = unlimited)",
          "min": 0.0
        },
        {
          "name": "token",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Token",
          "description": "Discord bot token"
        },
        {
          "name": "channel_id",
          "type": {
            "type": "str",
            "optional": true
          },
          "default": null,
          "title": "Channel Id",
          "description": "Optional channel ID to filter messages"
        },
        {
          "name": "allow_bot_messages",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Allow Bot Messages",
          "description": "Include messages authored by bots"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "message_id"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "content"
        },
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "author"
        },
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "channel"
        },
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "guild"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "name": "attachments"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "timestamp"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "source"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "event_type"
        }
      ],
      "basic_fields": [
        "max_events",
        "token",
        "channel_id",
        "allow_bot_messages"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Discord Send Message",
      "description": "Node that sends a message to a Discord channel using a bot token.",
      "namespace": "messaging.discord",
      "node_type": "messaging.discord.DiscordSendMessage",
      "properties": [
        {
          "name": "token",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Token",
          "description": "Discord bot token"
        },
        {
          "name": "channel_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Channel Id",
          "description": "Target channel ID"
        },
        {
          "name": "content",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Content",
          "description": "Message content"
        },
        {
          "name": "tts",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Tts",
          "description": "Send as text-to-speech"
        },
        {
          "name": "embeds",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "default": null,
          "title": "Embeds",
          "description": "Embeds as Discord embed dictionaries",
          "required": true
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "token",
        "channel_id",
        "content",
        "tts",
        "embeds"
      ]
    },
    {
      "title": "Realtime Agent",
      "description": "Stream responses using the official OpenAI Realtime client. Supports optional audio input and streams text chunks.\n    realtime, streaming, openai, audio-input, text-output\n\n    Uses `AsyncOpenAI().beta.realtime.connect(...)` with the events API:\n    - Sends session settings via `session.update`\n    - Adds user input via `conversation.item.create`\n    - Streams back `response.text.delta` events until `response.done`",
      "namespace": "openai.agents",
      "node_type": "openai.agents.RealtimeAgent",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gpt-4o-realtime-preview",
              "gpt-4o-mini-realtime-preview"
            ],
            "type_name": "nodetool.nodes.openai.agents.RealtimeAgent.Model"
          },
          "default": "gpt-4o-mini-realtime-preview",
          "title": "Model"
        },
        {
          "name": "system",
          "type": {
            "type": "str"
          },
          "default": "\nYou are an AI assistant interacting in real-time. Follow these rules unless explicitly overridden by the user:\n\n1. Respond promptly \u2014 minimize delay. If you do not yet have a complete answer, acknowledge the question and indicate what you are doing to find the answer.\n2. Maintain correctness. Always aim for accuracy; if you\u2019re uncertain, say so and optionally offer to verify.\n3. Be concise but clear. Prioritize key information first, then supporting details if helpful.\n4. Ask clarifying questions when needed. If the user\u2019s request is ambiguous, request clarification rather than guessing.\n5. Be consistent in terminology and definitions. Once you adopt a term or abbreviation, use it consistently in this conversation.\n6. Respect politeness and neutrality. Do not use emotive language unless the conversation tone demands it.\n7. Stay within safe and ethical bounds. Avoid disallowed content; follow OpenAI policies.\n8. Adapt to the user\u2019s style and level. If the user seems technical, use technical detail; if non-technical, explain with simpler language.\n---\nYou are now active. Await the user\u2019s request.\n",
          "title": "System",
          "description": "System instructions for the realtime session"
        },
        {
          "name": "chunk",
          "type": {
            "type": "chunk"
          },
          "default": {
            "type": "chunk",
            "node_id": null,
            "content_type": "text",
            "content": "",
            "content_metadata": {},
            "done": false
          },
          "title": "Chunk",
          "description": "The audio chunk to use as input."
        },
        {
          "name": "voice",
          "type": {
            "type": "enum",
            "values": [
              "none",
              "ash",
              "alloy",
              "ballad",
              "coral",
              "echo",
              "fable",
              "onyx",
              "nova",
              "shimmer",
              "sage",
              "verse"
            ],
            "type_name": "nodetool.nodes.openai.agents.RealtimeAgent.Voice"
          },
          "default": "alloy",
          "title": "Voice",
          "description": "The voice for the audio output"
        },
        {
          "name": "speed",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Speed",
          "description": "The speed of the model's spoken response",
          "min": 0.25,
          "max": 1.5
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 0.8,
          "title": "Temperature",
          "description": "The temperature for the response",
          "min": 0.6,
          "max": 1.2
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        },
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        }
      ],
      "basic_fields": [
        "model",
        "prompt",
        "chunk",
        "speed"
      ],
      "is_streaming_output": true,
      "supports_dynamic_outputs": true
    },
    {
      "title": "Realtime Transcription",
      "description": "Stream microphone or audio input to OpenAI Realtime and emit transcription.\n\n    Emits:\n      - `chunk` Chunk(content=..., done=False) for transcript deltas\n      - `chunk` Chunk(content=\"\", done=True) to mark segment end\n      - `text` final aggregated transcript when input ends",
      "namespace": "openai.agents",
      "node_type": "openai.agents.RealtimeTranscription",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {
            "type": "language_model",
            "provider": "empty",
            "id": "",
            "name": "",
            "path": null,
            "supported_tasks": []
          },
          "title": "Model",
          "description": "Model to use"
        },
        {
          "name": "system",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "System",
          "description": "System instructions (optional)"
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 0.8,
          "title": "Temperature",
          "description": "Decoding temperature"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "chunk"
          },
          "name": "chunk"
        }
      ],
      "basic_fields": [
        "model",
        "system",
        "temperature"
      ],
      "is_streaming_output": true
    },
    {
      "title": "Embedding",
      "description": "Generate vector representations of text for semantic analysis.\n    embeddings, similarity, search, clustering, classification\n\n    Uses OpenAI's embedding models to create dense vector representations of text.\n    These vectors capture semantic meaning, enabling:\n    - Semantic search\n    - Text clustering\n    - Document classification\n    - Recommendation systems\n    - Anomaly detection\n    - Measuring text similarity and diversity",
      "namespace": "openai.text",
      "node_type": "openai.text.Embedding",
      "properties": [
        {
          "name": "input",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Input"
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "text-embedding-3-large",
              "text-embedding-3-small"
            ],
            "type_name": "nodetool.nodes.openai.text.Embedding.EmbeddingModel"
          },
          "default": "text-embedding-3-small",
          "title": "Model"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Chunk Size"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input",
        "model",
        "chunk_size"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Web Search",
      "description": "\ud83d\udd0d OpenAI Web Search - Searches the web using OpenAI's web search capabilities.\n\n    This node uses an OpenAI model equipped with web search functionality\n    (like gpt-4o with search preview) to answer queries based on current web information.\n    Requires an OpenAI API key.",
      "namespace": "openai.text",
      "node_type": "openai.text.WebSearch",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "The search query to execute."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "query"
      ]
    },
    {
      "title": "Text To Speech",
      "description": "Converts text to speech using OpenAI TTS models.\n    audio, tts, text-to-speech, voice, synthesis\n\n    Use cases:\n    - Generate spoken content for videos or podcasts\n    - Create voice-overs for presentations\n    - Assist visually impaired users with text reading\n    - Produce audio versions of written content",
      "namespace": "openai.audio",
      "node_type": "openai.audio.TextToSpeech",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "tts-1",
              "tts-1-hd",
              "gpt-4o-mini-tts"
            ],
            "type_name": "nodetool.nodes.openai.audio.TextToSpeech.TtsModel"
          },
          "default": "tts-1",
          "title": "Model"
        },
        {
          "name": "voice",
          "type": {
            "type": "enum",
            "values": [
              "alloy",
              "ash",
              "ballad",
              "coral",
              "echo",
              "fable",
              "onyx",
              "nova",
              "sage",
              "shimmer",
              "verse"
            ],
            "type_name": "nodetool.nodes.openai.audio.TextToSpeech.Voice"
          },
          "default": "alloy",
          "title": "Voice"
        },
        {
          "name": "input",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Input"
        },
        {
          "name": "speed",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Speed",
          "min": 0.25,
          "max": 4.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "input",
        "model",
        "voice"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Transcribe",
      "description": "Converts speech to text using OpenAI's speech-to-text API.\n    audio, transcription, speech-to-text, stt, whisper\n\n    Use cases:\n    - Generate accurate transcriptions of audio content\n    - Create searchable text from audio recordings\n    - Support multiple languages for transcription\n    - Enable automated subtitling and captioning",
      "namespace": "openai.audio",
      "node_type": "openai.audio.Transcribe",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "whisper-1",
              "gpt-4o-transcribe",
              "gpt-4o-mini-transcribe"
            ],
            "type_name": "nodetool.nodes.openai.audio.Transcribe.TranscriptionModel"
          },
          "default": "whisper-1",
          "title": "Model",
          "description": "The model to use for transcription."
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to transcribe (max 25 MB)."
        },
        {
          "name": "language",
          "type": {
            "type": "enum",
            "values": [
              "auto_detect",
              "spanish",
              "italian",
              "korean",
              "portuguese",
              "english",
              "japanese",
              "german",
              "russian",
              "dutch",
              "polish",
              "catalan",
              "french",
              "indonesian",
              "ukrainian",
              "turkish",
              "malay",
              "swedish",
              "mandarin",
              "finnish",
              "norwegian",
              "romanian",
              "thai",
              "vietnamese",
              "slovak",
              "arabic",
              "czech",
              "croatian",
              "greek",
              "serbian",
              "danish",
              "bulgarian",
              "hungarian",
              "filipino",
              "bosnian",
              "galician",
              "macedonian",
              "hindi",
              "estonian",
              "slovenian",
              "tamil",
              "latvian",
              "azerbaijani",
              "urdu",
              "lithuanian",
              "hebrew",
              "welsh",
              "persian",
              "icelandic",
              "kazakh",
              "afrikaans",
              "kannada",
              "marathi",
              "swahili",
              "telugu",
              "maori",
              "nepali",
              "armenian",
              "belarusian",
              "gujarati",
              "punjabi",
              "bengali"
            ],
            "type_name": "nodetool.nodes.openai.audio.Transcribe.Language"
          },
          "default": "auto_detect",
          "title": "Language",
          "description": "The language of the input audio"
        },
        {
          "name": "timestamps",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Timestamps",
          "description": "Whether to return timestamps for the generated text."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text to guide the model's style or continue a previous audio segment."
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Temperature",
          "description": "The sampling temperature between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.",
          "min": 0.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "audio_chunk"
              }
            ]
          },
          "name": "words"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "audio_chunk"
              }
            ]
          },
          "name": "segments"
        }
      ],
      "basic_fields": [
        "audio",
        "language",
        "timestamps"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Translate",
      "description": "Translates speech in audio to English text.\n    audio, translation, speech-to-text, localization\n\n    Use cases:\n    - Translate foreign language audio content to English\n    - Create English transcripts of multilingual recordings\n    - Assist non-English speakers in understanding audio content\n    - Enable cross-language communication in audio formats",
      "namespace": "openai.audio",
      "node_type": "openai.audio.Translate",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {
            "type": "audio",
            "uri": "",
            "asset_id": null,
            "data": null
          },
          "title": "Audio",
          "description": "The audio file to translate."
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Temperature",
          "description": "The temperature to use for the translation."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "audio",
        "temperature"
      ],
      "expose_as_tool": true
    },
    {
      "title": "Create Image",
      "description": "Generates images from textual descriptions.\n    image, t2i, tti, text-to-image, create, generate, picture, photo, art, drawing, illustration\n\n    Use cases:\n    1. Create custom illustrations for articles or presentations\n    2. Generate concept art for creative projects\n    3. Produce visual aids for educational content\n    4. Design unique marketing visuals or product mockups\n    5. Explore artistic ideas and styles programmatically",
      "namespace": "openai.image",
      "node_type": "openai.image.CreateImage",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The prompt to use."
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gpt-image-1"
            ],
            "type_name": "nodetool.nodes.openai.image.CreateImage.Model"
          },
          "default": "gpt-image-1",
          "title": "Model",
          "description": "The model to use for image generation."
        },
        {
          "name": "size",
          "type": {
            "type": "enum",
            "values": [
              "1024x1024",
              "1536x1024",
              "1024x1536"
            ],
            "type_name": "nodetool.nodes.openai.image.CreateImage.Size"
          },
          "default": "1024x1024",
          "title": "Size",
          "description": "The size of the image to generate."
        },
        {
          "name": "background",
          "type": {
            "type": "enum",
            "values": [
              "transparent",
              "opaque",
              "auto"
            ],
            "type_name": "nodetool.nodes.openai.image.CreateImage.Background"
          },
          "default": "auto",
          "title": "Background",
          "description": "The background of the image to generate."
        },
        {
          "name": "quality",
          "type": {
            "type": "enum",
            "values": [
              "high",
              "medium",
              "low"
            ],
            "type_name": "nodetool.nodes.openai.image.CreateImage.Quality"
          },
          "default": "high",
          "title": "Quality",
          "description": "The quality of the image to generate."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "basic_fields": [
        "prompt",
        "model",
        "size",
        "background",
        "quality"
      ],
      "expose_as_tool": true
    }
  ],
  "assets": [
    {
      "package_name": "nodetool-base",
      "name": "AI Product Launch Video Generator.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Autonomous Research Agent.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Categorize Mails.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Chat with Docs.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "ChromaDB Research Agent.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Index PDFs.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Product Description Generator.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Image Enhance.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Story to Video Generator.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Data Validation Pipeline.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Instagram Scraper.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Fetch Papers.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Meeting Transcript Summarizer.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Summarize RSS.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Flashcard Generator.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Daily Digest.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Summarize Paper.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Transcribe Audio.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Agent Google Search.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Creative Story Ideas.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Color Boost Video.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Movie Posters.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Image to Video Animation.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Summarize Newsletters.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "AI Workflows on Reddit.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Competitive Analysis.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Image To Audio Story.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Data Generator.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Data Visualization Pipeline.jpg",
      "path": ""
    },
    {
      "package_name": "nodetool-base",
      "name": "Realtime Agent.jpg",
      "path": ""
    }
  ],
  "examples": [
    {
      "id": "4f0806c6-3102-4f9a-8573-6ffda4dfb4eb",
      "name": "Wikipedia Agent",
      "description": "Demonstrates an Agent triggering multiple tools in parallel while explaining its plan.",
      "tags": [
        "wikipedia",
        "research",
        "agent",
        "parallel"
      ]
    },
    {
      "id": "39664b20a78311f0bfc6000069947dd1",
      "name": "Summarize Newsletters",
      "description": "",
      "tags": [
        "email",
        "start"
      ]
    },
    {
      "id": "",
      "name": "Product Description Generator",
      "description": "Automatically generate marketing copy and product descriptions from product data.",
      "tags": [
        "business",
        "data",
        "research",
        "example"
      ]
    },
    {
      "id": "research_paper_summarizer",
      "name": "Research Paper Summarizer",
      "description": "Extract and summarize key findings from research papers and technical documents.",
      "tags": [
        "research"
      ]
    },
    {
      "id": "af5a2636a78211f09af400006952c72c",
      "name": "Chat with Docs",
      "description": "An intelligent document retrieval and question-answering system that leverages vector search and local LLMs to provide accurate, context-aware responses based on your document collection.",
      "tags": [
        "chat",
        "rag"
      ]
    },
    {
      "id": "",
      "name": "AI Product Launch Video Generator",
      "description": "Create a realistic 16:9 marketing video for a new product launch using the TextToVideo node.",
      "tags": [
        "business",
        "data",
        "video",
        "example"
      ]
    },
    {
      "id": "social_media_sentiment_analysis",
      "name": "Social Media Sentiment Analysis",
      "description": "Analyze sentiment and emotions in social media posts or user-provided text.",
      "tags": [
        "data",
        "nlp"
      ]
    },
    {
      "id": "b10f9d4c-fd63-4b29-8f89-c0a79088ee83",
      "name": "Learning Path Generator",
      "description": "Create a comprehensive learning path for a topic.",
      "tags": [
        "education",
        "planning"
      ]
    },
    {
      "id": "competitive_analysis",
      "name": "Competitive Analysis",
      "description": "Analyze competitor offerings and market positioning for strategic planning. Fetches competitor information from Google search results.",
      "tags": [
        "business",
        "data"
      ]
    },
    {
      "id": "",
      "name": "ChromaDB Research Agent",
      "description": "Query a Chroma collection of papers.",
      "tags": [
        "chromadb",
        "rag",
        "research",
        "example"
      ]
    },
    {
      "id": "7c89894e8ce411f083b10000284d49a0",
      "name": "Image Enhance",
      "description": "Improve image quality with basic enhancement tools like sharpening, contrast and color adjustment",
      "tags": [
        "image",
        "start"
      ]
    },
    {
      "id": "830163fea2fc11f0b02700001a475e0e",
      "name": "Image To Audio Story",
      "description": "Generate and narrate creative stories from images using AI",
      "tags": [
        "start",
        "multimodal"
      ]
    },
    {
      "id": "video_frame_extract_and_text_overlay",
      "name": "Video Frame Extract and Text Overlay",
      "description": "Extract frames from a video file and render customizable text captions/overlays on top of the extracted frames using font rendering.",
      "tags": [
        "image",
        "video"
      ]
    },
    {
      "id": "06d8221c907e11f0a4240000006ab9b5",
      "name": "Realtime Agent",
      "description": "",
      "tags": [
        "openai",
        "agent"
      ]
    },
    {
      "id": "19c0d61c-97c3-43ea-9ec1-e287e10db833",
      "name": "Hacker News Agent",
      "description": "Demonstrates an Agent triggering a browser tool while explaining its actions.",
      "tags": [
        "hackernews",
        "news",
        "agent",
        "browser"
      ]
    },
    {
      "id": "d22725a09fc211f0b7bb00007bf02e69",
      "name": "Summarize Paper",
      "description": "",
      "tags": [
        "audio",
        "start"
      ]
    },
    {
      "id": "autonomous_research_agent",
      "name": "Autonomous Research Agent",
      "description": "Use the ResearchAgent node to perform a lightweight market analysis with structured outputs defined through dynamic slots.",
      "tags": [
        "agent",
        "business",
        "research"
      ]
    },
    {
      "id": "",
      "name": "Game Encounter Planner Agent",
      "description": "Coordinate a squad of AI agents to design, critique, and brief a Frostfang Tundra combat encounter using StructuredOutputGenerator for robust schema enforcement.",
      "tags": [
        "agent",
        "data",
        "rag",
        "example"
      ]
    },
    {
      "id": "bcbefdbea78311f09c5e000014a97b82",
      "name": "Summarize RSS",
      "description": "",
      "tags": []
    },
    {
      "id": "flashcard_generator",
      "name": "Flashcard Generator",
      "description": "Generate study flashcards using AI and store them persistently in a database. Enter any topic and get instant flashcards that are saved for future review.",
      "tags": [
        "education",
        "database",
        "ai",
        "flashcards",
        "learning"
      ]
    },
    {
      "id": "1302ffe8a2f911f0b74c000014916b9c",
      "name": "Categorize Mails",
      "description": "Automatically categorize and organize emails using AI, showing the reasoning.",
      "tags": [
        "email",
        "start",
        "agent"
      ]
    },
    {
      "id": "1ee8a233-c2e4-4e64-adf0-b19058cf8e2e",
      "name": "Reddit Scraper",
      "description": "Analyze a subreddit for specific issues.",
      "tags": [
        "reddit",
        "research",
        "analysis"
      ]
    },
    {
      "id": "beginner_template_story_ideas",
      "name": "Creative Story Ideas",
      "description": "A beginner-friendly template demonstrating core NodeTool concepts: inputs, templates, LLM agents, streaming, and outputs. Generate creative story ideas based on your preferences.",
      "tags": [
        "start",
        "beginner",
        "tutorial",
        "template"
      ]
    },
    {
      "id": "3527dcf2a7a811f09339000078c92dc5",
      "name": "Meeting Transcript Summarizer",
      "description": "Automatically transcribe a meeting recording and generate concise notes.",
      "tags": [
        "audio",
        "llm"
      ]
    },
    {
      "id": "conditional_logic_engine",
      "name": "Conditional Logic Engine",
      "description": "Workflow that demonstrates multi-branch decision logic with value routing.",
      "tags": [
        "workflow"
      ]
    },
    {
      "id": "09eedfbaa30511f0a0840000727222e1",
      "name": "Movie Posters",
      "description": "Create cinematic movie posters using AI image generation",
      "tags": [
        "start",
        "image"
      ]
    },
    {
      "id": "aa95586e-a2cd-4075-a51e-a2e6fc464ada",
      "name": "AI Workflows on Reddit",
      "description": "Find examples of AI workflows on Reddit and compile a markdown report.",
      "tags": [
        "reddit",
        "research",
        "ai"
      ]
    },
    {
      "id": "310d885a341811f0942e0000191c0ba5",
      "name": "Color Boost Video",
      "description": "",
      "tags": [
        "video",
        "start"
      ]
    },
    {
      "id": "3047c2fa760811f0b24700002df0a13c",
      "name": "Index PDFs",
      "description": "Workflow to index PDFs in a folder into a Chroma collection",
      "tags": [
        "rag",
        "start"
      ]
    },
    {
      "id": "4fd373a0a7a711f08ffb0000744cb0d1",
      "name": "Transcribe Audio",
      "description": "Convert speech to text using Whisper model with word-level timestamps",
      "tags": [
        "start",
        "audio",
        "huggingface"
      ]
    },
    {
      "id": "agent-google-search-example",
      "name": "Agent Google Search",
      "description": "Demonstrates an Agent using dynamic outputs to perform Google searches and display results.",
      "tags": [
        "agent",
        "google",
        "search",
        "dynamic-outputs"
      ]
    },
    {
      "id": "fdae9dea-a299-40ef-8db0-856019531c59",
      "name": "Product Hunt AI Extractor",
      "description": "Identify AI products from Product Hunt leaderboards.",
      "tags": [
        "product-hunt",
        "ai",
        "extraction"
      ]
    },
    {
      "id": "",
      "name": "Image to Video Animation",
      "description": "Generate a high-quality still from text, then animate it into a short cinematic clip.",
      "tags": [
        "image",
        "video",
        "example"
      ]
    },
    {
      "id": "8c588b4cf3c711efb8fd000014c2afa2",
      "name": "Fetch Papers",
      "description": "This workflow automatically fetches and downloads research papers from the Awesome Transformers GitHub repository. It extracts paper links from the README.md file, filters for actual papers, and downloads them to a specified folder. Ideal for researchers and AI enthusiasts who want to stay updated with the latest transformer model papers.",
      "tags": [
        "automation"
      ]
    },
    {
      "id": "",
      "name": "Instagram Scraper",
      "description": "Analyze Instagram trends for a specific topic.",
      "tags": [
        "instagram",
        "social-media",
        "trends",
        "example"
      ]
    },
    {
      "id": "list_processing_engine",
      "name": "List Processing Engine",
      "description": "Batch-transform customer records with map/filter/reduce style operations to produce regional summaries and marketing insights.",
      "tags": [
        "business",
        "data"
      ]
    },
    {
      "id": "data_visualization_pipeline",
      "name": "Data Visualization Pipeline",
      "description": "Transform natural language descriptions into data visualizations with AI-powered data and chart generation. This workflow demonstrates how to create customized charts from text prompts without manual data preparation.",
      "tags": [
        "agents"
      ]
    },
    {
      "id": "story_to_video_generator",
      "name": "Story to Video Generator",
      "description": "Transform story ideas into cinematic AI-generated videos. An agent crafts detailed visual prompts optimized for video generation, then creates the video using Gemini Veo.",
      "tags": [
        "video",
        "generation",
        "ai",
        "storytelling",
        "creative"
      ]
    },
    {
      "id": "job_application_analyzer",
      "name": "Job Application Analyzer",
      "description": "Analyze job descriptions and provide personalized application advice.",
      "tags": [
        "workflow"
      ]
    },
    {
      "id": "",
      "name": "Data Validation Pipeline",
      "description": "Validate and clean data for quality assurance before processing.",
      "tags": [
        "data",
        "example"
      ]
    },
    {
      "id": "data_generator",
      "name": "Data Generator",
      "description": "Generate structured data using AI agents",
      "tags": [
        "agents"
      ]
    }
  ]
}