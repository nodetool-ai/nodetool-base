{
  "name": "nodetool-base",
  "description": "Nodetool Base nodes",
  "version": "0.6.0",
  "authors": [
    "Matthias Georgi <matti.georgi@gmail.com>"
  ],
  "repo_id": "nodetool-ai/nodetool-base",
  "nodes": [
    {
      "title": "Chroma",
      "description": "",
      "namespace": "chroma.chroma_node",
      "node_type": "chroma.chroma_node.Chroma",
      "layout": "default",
      "properties": [],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [],
      "is_dynamic": false
    },
    {
      "title": "Hybrid Search",
      "description": "Hybrid search combining semantic and keyword-based search for better retrieval.\n    Uses reciprocal rank fusion to combine results from both methods.",
      "namespace": "chroma.query",
      "node_type": "chroma.query.HybridSearch",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to query"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to query"
        },
        {
          "name": "n_results",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "N Results",
          "description": "The number of final results to return"
        },
        {
          "name": "k_constant",
          "type": {
            "type": "float"
          },
          "default": 60.0,
          "title": "K Constant",
          "description": "Constant for reciprocal rank fusion (default: 60.0)"
        },
        {
          "name": "min_keyword_length",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "Min Keyword Length",
          "description": "Minimum length for keyword tokens"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "ids"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "metadatas"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "distances"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "scores"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "text",
        "n_results",
        "k_constant",
        "min_keyword_length"
      ],
      "is_dynamic": false
    },
    {
      "title": "Query Image",
      "description": "Query the index for similar images.",
      "namespace": "chroma.query",
      "node_type": "chroma.query.QueryImage",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to query"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to query"
        },
        {
          "name": "n_results",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "N Results",
          "description": "The number of results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "ids"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "metadatas"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "distances"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "image",
        "n_results"
      ],
      "is_dynamic": false
    },
    {
      "title": "Query Text",
      "description": "Query the index for similar text.",
      "namespace": "chroma.query",
      "node_type": "chroma.query.QueryText",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to query"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to query"
        },
        {
          "name": "n_results",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "N Results",
          "description": "The number of results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "ids"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "metadatas"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "distances"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "text",
        "n_results"
      ],
      "is_dynamic": false
    },
    {
      "title": "Remove Overlap",
      "description": "Removes overlapping words between consecutive strings in a list.\n    Splits text into words and matches word sequences for more accurate overlap detection.",
      "namespace": "chroma.query",
      "node_type": "chroma.query.RemoveOverlap",
      "layout": "default",
      "properties": [
        {
          "name": "documents",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Documents",
          "description": "List of strings to process for overlap removal"
        },
        {
          "name": "min_overlap_words",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Min Overlap Words",
          "description": "Minimum number of words that must overlap to be considered"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "documents",
        "min_overlap_words"
      ],
      "is_dynamic": false
    },
    {
      "title": "Index Aggregated Text",
      "description": "Index multiple text chunks at once with aggregated embeddings from Ollama.\n    chroma, embedding, collection, RAG, index, text, chunk, batch, ollama",
      "namespace": "chroma.index",
      "node_type": "chroma.index.IndexAggregatedText",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "document",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document",
          "description": "The document to index"
        },
        {
          "name": "document_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document Id",
          "description": "The document ID to associate with the text"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the text"
        },
        {
          "name": "text_chunks",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "union",
                "type_args": [
                  {
                    "type": "text_chunk"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Text Chunks",
          "description": "List of text chunks to index"
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window",
          "description": "The context window size to use for the model",
          "min": 1.0
        },
        {
          "name": "aggregation",
          "type": {
            "type": "enum",
            "values": [
              "mean",
              "max",
              "min",
              "sum"
            ],
            "type_name": "nodetool.nodes.chroma.index.EmbeddingAggregation"
          },
          "default": "mean",
          "title": "Aggregation",
          "description": "The aggregation method to use for the embeddings."
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "document",
        "document_id",
        "metadata",
        "text_chunks",
        "context_window",
        "aggregation"
      ],
      "is_dynamic": false
    },
    {
      "title": "Index Embedding",
      "description": "Index a list of embeddings.",
      "namespace": "chroma.index",
      "node_type": "chroma.index.IndexEmbedding",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "embedding",
          "type": {
            "type": "np_array"
          },
          "default": {},
          "title": "Embedding",
          "description": "The embedding to index"
        },
        {
          "name": "id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Id",
          "description": "The ID to associate with the embedding"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the embedding"
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "embedding",
        "id",
        "metadata"
      ],
      "is_dynamic": false
    },
    {
      "title": "Index Image",
      "description": "Index a single image asset.\n    chroma, embedding, collection, RAG, index, image",
      "namespace": "chroma.index",
      "node_type": "chroma.index.IndexImage",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "Image asset to index"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the image"
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "image",
        "metadata"
      ],
      "is_dynamic": false
    },
    {
      "title": "Index Images",
      "description": "Index a list of image assets or files.\n    chroma, embedding, collection, RAG, index, image, batch",
      "namespace": "chroma.index",
      "node_type": "chroma.index.IndexImages",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "images",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "default": [],
          "title": "Images",
          "description": "List of image assets to index"
        },
        {
          "name": "upsert",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Upsert",
          "description": "Whether to upsert the images"
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "images",
        "upsert"
      ],
      "is_dynamic": false
    },
    {
      "title": "Index String",
      "description": "Index a string with a Document ID to a collection.\n    chroma, embedding, collection, RAG, index, text, string\n\n    Use cases:\n    - Index documents for a vector search",
      "namespace": "chroma.index",
      "node_type": "chroma.index.IndexString",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text content to index"
        },
        {
          "name": "document_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document Id",
          "description": "Document ID to associate with the text content"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the text"
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "text",
        "document_id",
        "metadata"
      ],
      "is_dynamic": false
    },
    {
      "title": "Index Text Chunk",
      "description": "Index a single text chunk.\n    chroma, embedding, collection, RAG, index, text, chunk",
      "namespace": "chroma.index",
      "node_type": "chroma.index.IndexTextChunk",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "text_chunk",
          "type": {
            "type": "text_chunk"
          },
          "default": {},
          "title": "Text Chunk",
          "description": "Text chunk to index"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the text chunk"
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "text_chunk",
        "metadata"
      ],
      "is_dynamic": false
    },
    {
      "title": "Index Text Chunks",
      "description": "Index multiple text chunks at once.\n    chroma, embedding, collection, RAG, index, text, chunk, batch",
      "namespace": "chroma.index",
      "node_type": "chroma.index.IndexTextChunks",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "text_chunks",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "text_chunk"
              }
            ]
          },
          "default": [],
          "title": "Text Chunks",
          "description": "List of text chunks to index"
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "text_chunks"
      ],
      "is_dynamic": false
    },
    {
      "title": "Count",
      "description": "Count the number of documents in a collection.\n    chroma, embedding, collection, RAG",
      "namespace": "chroma.collections",
      "node_type": "chroma.collections.Count",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to count"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get Documents",
      "description": "Get documents from a chroma collection.\n    chroma, embedding, collection, RAG, retrieve",
      "namespace": "chroma.collections",
      "node_type": "chroma.collections.GetDocuments",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to get"
        },
        {
          "name": "ids",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Ids",
          "description": "The ids of the documents to get"
        },
        {
          "name": "limit",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Limit",
          "description": "The limit of the documents to get"
        },
        {
          "name": "offset",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Offset",
          "description": "The offset of the documents to get"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "ids",
        "limit",
        "offset"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get Or Create Collection",
      "description": "Get or create a collection.\n    chroma, embedding, collection, RAG, get, create",
      "namespace": "chroma.collections",
      "node_type": "chroma.collections.GetOrCreateCollection",
      "layout": "default",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The name of the collection to create"
        },
        {
          "name": "embedding_model",
          "type": {
            "type": "llama_model"
          },
          "default": {},
          "title": "Embedding Model",
          "description": "The embedding model to use"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "collection"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "name",
        "embedding_model"
      ],
      "is_dynamic": false
    },
    {
      "title": "Peek",
      "description": "Peek at the documents in a collection.\n    chroma, embedding, collection, RAG, preview",
      "namespace": "chroma.collections",
      "node_type": "chroma.collections.Peek",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to peek"
        },
        {
          "name": "limit",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Limit",
          "description": "The limit of the documents to peek"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "limit"
      ],
      "is_dynamic": false
    },
    {
      "title": "Add Label",
      "description": "Adds a label to a Gmail message.\n    email, gmail, label",
      "namespace": "nodetool.mail",
      "node_type": "nodetool.mail.AddLabel",
      "layout": "default",
      "properties": [
        {
          "name": "email",
          "type": {
            "type": "email"
          },
          "default": {},
          "title": "Email",
          "description": "Email message to label"
        },
        {
          "name": "label",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Label",
          "description": "Label to add to the message"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "email"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "email",
        "label"
      ],
      "is_dynamic": false
    },
    {
      "title": "Gmail Search",
      "description": "Searches Gmail using Gmail-specific search operators.\n    email, gmail, search\n\n    Use cases:\n    - Search for emails based on specific criteria\n    - Retrieve emails from a specific sender\n    - Filter emails by subject, sender, or date",
      "namespace": "nodetool.mail",
      "node_type": "nodetool.mail.GmailSearch",
      "layout": "default",
      "properties": [
        {
          "name": "from_address",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "From Address",
          "description": "Sender's email address to search for"
        },
        {
          "name": "to_address",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "To Address",
          "description": "Recipient's email address to search for"
        },
        {
          "name": "subject",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Subject",
          "description": "Text to search for in email subject"
        },
        {
          "name": "body",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Body",
          "description": "Text to search for in email body"
        },
        {
          "name": "date_filter",
          "type": {
            "type": "enum",
            "values": [
              "SINCE_ONE_HOUR",
              "SINCE_ONE_DAY",
              "SINCE_ONE_WEEK",
              "SINCE_ONE_MONTH",
              "SINCE_ONE_YEAR"
            ],
            "type_name": "nodetool.nodes.nodetool.mail.DateFilter"
          },
          "default": "SINCE_ONE_DAY",
          "title": "Date Filter",
          "description": "Date filter to search for"
        },
        {
          "name": "keywords",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Keywords",
          "description": "Custom keywords or labels to search for"
        },
        {
          "name": "folder",
          "type": {
            "type": "enum",
            "values": [
              "INBOX",
              "[Gmail]/Sent Mail",
              "[Gmail]/Drafts",
              "[Gmail]/Spam",
              "[Gmail]/Trash"
            ],
            "type_name": "nodetool.nodes.nodetool.mail.GmailFolder"
          },
          "default": "INBOX",
          "title": "Folder",
          "description": "Email folder to search in"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "General text to search for anywhere in the email"
        },
        {
          "name": "max_results",
          "type": {
            "type": "int"
          },
          "default": 50,
          "title": "Max Results",
          "description": "Maximum number of emails to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "email"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "subject",
        "body",
        "date_filter",
        "max_results"
      ],
      "is_dynamic": false
    },
    {
      "title": "Move To Archive",
      "description": "Moves specified emails to Gmail archive.\n    email, gmail, archive",
      "namespace": "nodetool.mail",
      "node_type": "nodetool.mail.MoveToArchive",
      "layout": "default",
      "properties": [
        {
          "name": "message_ids",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Message Ids",
          "description": "List of message IDs to archive"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "message_ids"
      ],
      "is_dynamic": false
    },
    {
      "title": "Append",
      "description": "Adds a value to the end of a list.\n    list, add, insert, extend\n\n    Use cases:\n    - Grow a list dynamically\n    - Add new elements to an existing list\n    - Implement a stack-like structure",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Append",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Average",
      "description": "Calculates the arithmetic mean of a list of numbers.\n    list, average, mean, aggregate, math\n\n    Use cases:\n    - Find average value\n    - Calculate mean of numeric data",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Average",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values"
      ],
      "is_dynamic": false
    },
    {
      "title": "Chunk",
      "description": "Splits a list into smaller chunks of specified size.\n    list, chunk, split, group\n\n    Use cases:\n    - Batch processing\n    - Pagination\n    - Creating sublists of fixed size",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Chunk",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Chunk Size"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "list",
                "type_args": [
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "chunk_size"
      ],
      "is_dynamic": false
    },
    {
      "title": "Dedupe",
      "description": "Removes duplicate elements from a list, ensuring uniqueness.\n    list, unique, distinct, deduplicate\n\n    Use cases:\n    - Remove redundant entries\n    - Create a set-like structure\n    - Ensure list elements are unique",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Dedupe",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values"
      ],
      "is_dynamic": false
    },
    {
      "title": "Difference",
      "description": "Finds elements that exist in first list but not in second list.\n    list, set, difference, subtract\n\n    Use cases:\n    - Find unique elements in one list\n    - Remove items present in another list\n    - Identify distinct elements",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Difference",
      "layout": "default",
      "properties": [
        {
          "name": "list1",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List1"
        },
        {
          "name": "list2",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List2"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "list1",
        "list2"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extend",
      "description": "Merges one list into another, extending the original list.\n    list, merge, concatenate, combine\n\n    Use cases:\n    - Combine multiple lists\n    - Add all elements from one list to another",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Extend",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "other_values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Other Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "other_values"
      ],
      "is_dynamic": false
    },
    {
      "title": "Filter Dicts",
      "description": "Filter a list of dictionaries based on a condition.\n    list, filter, query, condition\n\n    Basic Operators:\n    - Comparison: >, <, >=, <=, ==, !=\n    - Logical: and, or, not\n    - Membership: in, not in\n\n    Example Conditions:\n    # Basic comparisons\n    age > 30\n    price <= 100\n    status == 'active'\n\n    # Multiple conditions\n    age > 30 and salary < 50000\n    (price >= 100) and (price <= 200)\n    department in ['Sales', 'Marketing']\n\n    # String operations\n    name.str.startswith('J')\n    email.str.contains('@company.com')\n\n    # Datetime conditions\n    date > '2024-01-01'\n    date.dt.year == 2024\n    date.dt.month >= 6\n    date.dt.day_name() == 'Monday'\n\n    # Date ranges\n    date.between('2024-01-01', '2024-12-31')\n    date >= '2024-01-01' and date < '2025-01-01'\n\n    # Complex datetime\n    date.dt.hour < 12\n    date.dt.dayofweek <= 4  # Weekdays only\n\n    # Numeric operations\n    price.between(100, 200)\n    quantity % 2 == 0  # Even numbers\n\n    # Special values\n    value.isna()  # Check for NULL/NaN\n    value.notna()  # Check for non-NULL/non-NaN\n\n    Note: Dates should be in ISO format (YYYY-MM-DD) or include time (YYYY-MM-DD HH:MM:SS)\n\n    Use cases:\n    - Filter list of dictionary objects based on criteria\n    - Extract subset of data meeting specific conditions\n    - Clean data by removing unwanted entries",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterDicts",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "condition",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Condition",
          "description": "\n        The filtering condition using pandas query syntax.\n\n        Basic Operators:\n        - Comparison: >, <, >=, <=, ==, !=\n        - Logical: and, or, not\n        - Membership: in, not in\n        \n        Example Conditions:\n        # Basic comparisons\n        age > 30\n        price <= 100\n        status == 'active'\n        \n        See node documentation for more examples.\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "condition"
      ],
      "is_dynamic": false
    },
    {
      "title": "Filter Dicts By Number",
      "description": "Filters a list of dictionaries based on numeric values for a specified key.\n    list, filter, dictionary, numbers, numeric\n\n    Use cases:\n    - Filter dictionaries by numeric comparisons (greater than, less than, equal to)\n    - Filter records with even/odd numeric values\n    - Filter entries with positive/negative numbers",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterDictsByNumber",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key"
        },
        {
          "name": "filter_type",
          "type": {
            "type": "enum",
            "values": [
              "greater_than",
              "less_than",
              "equal_to",
              "even",
              "odd",
              "positive",
              "negative"
            ],
            "type_name": "nodetool.nodes.nodetool.list.FilterDictNumberType"
          },
          "default": "greater_than",
          "title": "Filter Type"
        },
        {
          "name": "value",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "key",
        "filter_type",
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Filter Dicts By Range",
      "description": "Filters a list of dictionaries based on a numeric range for a specified key.\n    list, filter, dictionary, range, between\n\n    Use cases:\n    - Filter records based on numeric ranges (e.g., price range, age range)\n    - Find entries with values within specified bounds\n    - Filter data sets based on numeric criteria",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterDictsByRange",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key",
          "description": "The dictionary key to check for the range"
        },
        {
          "name": "min_value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Min Value",
          "description": "The minimum value (inclusive) of the range"
        },
        {
          "name": "max_value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Max Value",
          "description": "The maximum value (inclusive) of the range"
        },
        {
          "name": "inclusive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Inclusive",
          "description": "If True, includes the min and max values in the results"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "key",
        "min_value",
        "max_value",
        "inclusive"
      ],
      "is_dynamic": false
    },
    {
      "title": "Filter Dicts By Value",
      "description": "Filters a list of dictionaries based on their values using various criteria.\n    list, filter, dictionary, values\n\n    Use cases:\n    - Filter dictionaries by value content\n    - Filter dictionaries by value type\n    - Filter dictionaries by value patterns",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterDictsByValue",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key",
          "description": "The dictionary key to check"
        },
        {
          "name": "filter_type",
          "type": {
            "type": "enum",
            "values": [
              "contains",
              "starts_with",
              "ends_with",
              "equals",
              "type_is",
              "length_greater",
              "length_less",
              "exact_length"
            ],
            "type_name": "nodetool.nodes.nodetool.list.FilterType"
          },
          "default": "contains",
          "title": "Filter Type",
          "description": "The type of filter to apply"
        },
        {
          "name": "criteria",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Criteria",
          "description": "The filtering criteria (text to match, type name, or length as string)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "key",
        "filter_type",
        "criteria"
      ],
      "is_dynamic": false
    },
    {
      "title": "Filter Dicts Regex",
      "description": "Filters a list of dictionaries using regular expressions on specified keys.\n    list, filter, regex, dictionary, pattern\n\n    Use cases:\n    - Filter dictionaries with values matching complex patterns\n    - Search for dictionaries containing emails, dates, or specific formats\n    - Advanced text pattern matching across dictionary values",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterDictsRegex",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern"
        },
        {
          "name": "full_match",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Full Match"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "key",
        "pattern",
        "full_match"
      ],
      "is_dynamic": false
    },
    {
      "title": "Filter None",
      "description": "Filters out None values from a list.\n    list, filter, none, null\n\n    Use cases:\n    - Clean data by removing null values\n    - Get only valid entries\n    - Remove placeholder values",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterNone",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values"
      ],
      "is_dynamic": false
    },
    {
      "title": "Filter Number Range",
      "description": "Filters a list of numbers to find values within a specified range.\n    list, filter, numbers, range, between\n\n    Use cases:\n    - Find numbers within a specific range\n    - Filter data points within bounds\n    - Implement range-based filtering",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterNumberRange",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "min_value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Min Value"
        },
        {
          "name": "max_value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Max Value"
        },
        {
          "name": "inclusive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Inclusive"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "min_value",
        "max_value",
        "inclusive"
      ],
      "is_dynamic": false
    },
    {
      "title": "Filter Numbers",
      "description": "Filters a list of numbers based on various numerical conditions.\n    list, filter, numbers, numeric\n\n    Use cases:\n    - Filter numbers by comparison (greater than, less than, equal to)\n    - Filter even/odd numbers\n    - Filter positive/negative numbers",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterNumbers",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "filter_type",
          "type": {
            "type": "enum",
            "values": [
              "greater_than",
              "less_than",
              "equal_to",
              "even",
              "odd",
              "positive",
              "negative"
            ],
            "type_name": "nodetool.nodes.nodetool.list.FilterNumberType"
          },
          "default": "greater_than",
          "title": "Filter Type",
          "description": "The type of filter to apply"
        },
        {
          "name": "value",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Value",
          "description": "The comparison value (for greater_than, less_than, equal_to)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "filter_type",
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Filter Regex",
      "description": "Filters a list of strings using regular expressions.\n    list, filter, regex, pattern, text\n\n    Use cases:\n    - Filter strings using complex patterns\n    - Extract strings matching specific formats (emails, dates, etc.)\n    - Advanced text pattern matching",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterRegex",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "The regular expression pattern to match against."
        },
        {
          "name": "full_match",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Full Match",
          "description": "Whether to match the entire string or find pattern anywhere in string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "pattern",
        "full_match"
      ],
      "is_dynamic": false
    },
    {
      "title": "Filter Strings",
      "description": "Filters a list of strings based on various criteria.\n    list, filter, strings, text\n\n    Use cases:\n    - Filter strings by length\n    - Filter strings containing specific text\n    - Filter strings by prefix/suffix\n    - Filter strings using regex patterns",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.FilterStrings",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "filter_type",
          "type": {
            "type": "enum",
            "values": [
              "contains",
              "starts_with",
              "ends_with",
              "length_greater",
              "length_less",
              "exact_length"
            ],
            "type_name": "nodetool.nodes.nodetool.list.FilterType"
          },
          "default": "contains",
          "title": "Filter Type",
          "description": "The type of filter to apply"
        },
        {
          "name": "criteria",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Criteria",
          "description": "The filtering criteria (text to match or length as string)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "filter_type",
        "criteria"
      ],
      "is_dynamic": false
    },
    {
      "title": "Flatten",
      "description": "Flattens a nested list structure into a single flat list.\n    list, flatten, nested, structure\n\n    Use cases:\n    - Convert nested lists into a single flat list\n    - Simplify complex list structures\n    - Process hierarchical data as a sequence\n\n    Examples:\n    [[1, 2], [3, 4]] -> [1, 2, 3, 4]\n    [[1, [2, 3]], [4, [5, 6]]] -> [1, 2, 3, 4, 5, 6]",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Flatten",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "max_depth",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Max Depth",
          "min": -1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "max_depth"
      ],
      "is_dynamic": false
    },
    {
      "title": "Generate Sequence",
      "description": "Generates a list of integers within a specified range.\n    list, range, sequence, numbers\n\n    Use cases:\n    - Create numbered lists\n    - Generate index sequences\n    - Produce arithmetic progressions",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.GenerateSequence",
      "layout": "default",
      "properties": [
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start"
        },
        {
          "name": "stop",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Stop"
        },
        {
          "name": "step",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Step"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "start",
        "stop",
        "step"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get Element",
      "description": "Retrieves a single value from a list at a specific index.\n    list, get, extract, value\n\n    Use cases:\n    - Access a specific element by position\n    - Implement array-like indexing\n    - Extract the first or last element",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.GetElement",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "index",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Index"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "index"
      ],
      "is_dynamic": false
    },
    {
      "title": "Intersection",
      "description": "Finds common elements between two lists.\n    list, set, intersection, common\n\n    Use cases:\n    - Find elements present in both lists\n    - Identify shared items between collections\n    - Filter for matching elements",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Intersection",
      "layout": "default",
      "properties": [
        {
          "name": "list1",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List1"
        },
        {
          "name": "list2",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List2"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "list1",
        "list2"
      ],
      "is_dynamic": false
    },
    {
      "title": "Length",
      "description": "Calculates the length of a list.\n    list, count, size\n\n    Use cases:\n    - Determine the number of elements in a list\n    - Check if a list is empty\n    - Validate list size constraints",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Length",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values"
      ],
      "is_dynamic": false
    },
    {
      "title": "Map Field",
      "description": "Extracts a specific field from a list of dictionaries or objects.\n    list, map, field, extract, pluck\n\n    Use cases:\n    - Extract specific fields from a list of objects\n    - Transform complex data structures into simple lists\n    - Collect values for a particular key across multiple dictionaries",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.MapField",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "union",
                "type_args": [
                  {
                    "type": "dict"
                  },
                  {
                    "type": "object"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "field",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Field"
        },
        {
          "name": "default",
          "type": {
            "type": "any"
          },
          "title": "Default"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "field",
        "default"
      ],
      "is_dynamic": false
    },
    {
      "title": "Map Template",
      "description": "Maps a template string over a list of dictionaries or objects using Jinja2 templating.\n    list, template, map, formatting\n\n    Use cases:\n    - Formatting multiple records into strings\n    - Generating text from structured data\n    - Creating text representations of data collections\n\n    Examples:\n    - template: \"Name: {{ name }}, Age: {{ age }}\"\n      values: [{\"name\": \"Alice\", \"age\": 30}, {\"name\": \"Bob\", \"age\": 25}]\n      -> [\"Name: Alice, Age: 30\", \"Name: Bob, Age: 25\"]\n\n    Available filters:\n    - truncate(length): Truncates text to given length\n    - upper: Converts text to uppercase\n    - lower: Converts text to lowercase\n    - title: Converts text to title case\n    - trim: Removes whitespace from start/end\n    - replace(old, new): Replaces substring\n    - default(value): Sets default if value is undefined\n    - first: Gets first character/item\n    - last: Gets last character/item\n    - length: Gets length of string/list\n    - sort: Sorts list\n    - join(delimiter): Joins list with delimiter",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.MapTemplate",
      "layout": "default",
      "properties": [
        {
          "name": "template",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Template",
          "description": "\n        Template string with Jinja2 placeholders for formatting\n        Examples:\n        - \"Name: {{ name }}, Age: {{ age }}\"\n        - \"{{ title|truncate(20) }}\"\n        - \"{{ name|upper }}\"\n        "
        },
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "union",
                "type_args": [
                  {
                    "type": "dict",
                    "type_args": [
                      {
                        "type": "str"
                      },
                      {
                        "type": "any"
                      }
                    ]
                  },
                  {
                    "type": "object"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "template",
        "values"
      ],
      "is_dynamic": false
    },
    {
      "title": "Maximum",
      "description": "Finds the largest value in a list of numbers.\n    list, max, maximum, aggregate, math\n\n    Use cases:\n    - Find highest value\n    - Get largest number in dataset",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Maximum",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values"
      ],
      "is_dynamic": false
    },
    {
      "title": "Minimum",
      "description": "Finds the smallest value in a list of numbers.\n    list, min, minimum, aggregate, math\n\n    Use cases:\n    - Find lowest value\n    - Get smallest number in dataset",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Minimum",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values"
      ],
      "is_dynamic": false
    },
    {
      "title": "Product",
      "description": "Calculates the product of all numbers in a list.\n    list, product, multiply, aggregate, math\n\n    Use cases:\n    - Multiply all numbers together\n    - Calculate compound values",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Product",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values"
      ],
      "is_dynamic": false
    },
    {
      "title": "Randomize",
      "description": "Randomly shuffles the elements of a list.\n    list, shuffle, random, order\n\n    Use cases:\n    - Randomize the order of items in a playlist\n    - Implement random sampling without replacement\n    - Create randomized data sets for testing",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Randomize",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values"
      ],
      "is_dynamic": false
    },
    {
      "title": "Reverse",
      "description": "Inverts the order of elements in a list.\n    list, reverse, invert, flip\n\n    Use cases:\n    - Reverse the order of a sequence",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Reverse",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values"
      ],
      "is_dynamic": false
    },
    {
      "title": "Save List",
      "description": "Saves a list to a text file, placing each element on a new line.\n    list, save, file, serialize\n\n    Use cases:\n    - Export list data to a file\n    - Create a simple text-based database\n    - Generate line-separated output",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.SaveList",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "text.txt",
          "title": "Name",
          "description": "\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "text"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "name"
      ],
      "is_dynamic": false
    },
    {
      "title": "Select Elements",
      "description": "Selects specific values from a list using index positions.\n    list, select, index, extract\n\n    Use cases:\n    - Pick specific elements by their positions\n    - Rearrange list elements\n    - Create a new list from selected indices",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.SelectElements",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "indices",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "int"
              }
            ]
          },
          "default": [],
          "title": "Indices"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "indices"
      ],
      "is_dynamic": false
    },
    {
      "title": "Slice",
      "description": "Extracts a subset from a list using start, stop, and step indices.\n    list, slice, subset, extract\n\n    Use cases:\n    - Get a portion of a list\n    - Implement pagination\n    - Extract every nth element",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Slice",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start"
        },
        {
          "name": "stop",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Stop"
        },
        {
          "name": "step",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Step"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "start",
        "stop",
        "step"
      ],
      "is_dynamic": false
    },
    {
      "title": "Sort",
      "description": "Sorts the elements of a list in ascending or descending order.\n    list, sort, order, arrange\n\n    Use cases:\n    - Organize data in a specific order\n    - Prepare data for binary search or other algorithms\n    - Rank items based on their values",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Sort",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "order",
          "type": {
            "type": "enum",
            "values": [
              "ascending",
              "descending"
            ],
            "type_name": "nodetool.nodes.nodetool.list.SortOrder"
          },
          "default": "ascending",
          "title": "Order"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "order"
      ],
      "is_dynamic": false
    },
    {
      "title": "Sum",
      "description": "Calculates the sum of a list of numbers.\n    list, sum, aggregate, math\n\n    Use cases:\n    - Calculate total of numeric values\n    - Add up all elements in a list",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Sum",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values"
      ],
      "is_dynamic": false
    },
    {
      "title": "Transform",
      "description": "Applies a transformation to each element in a list.\n    list, transform, map, convert\n\n    Use cases:\n    - Convert types (str to int, etc.)\n    - Apply formatting\n    - Mathematical operations",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Transform",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        },
        {
          "name": "transform_type",
          "type": {
            "type": "enum",
            "values": [
              "to_int",
              "to_float",
              "to_string",
              "uppercase",
              "lowercase",
              "strip"
            ],
            "type_name": "nodetool.nodes.nodetool.list.TransformType"
          },
          "default": "to_string",
          "title": "Transform Type"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values",
        "transform_type"
      ],
      "is_dynamic": false
    },
    {
      "title": "Union",
      "description": "Combines unique elements from two lists.\n    list, set, union, combine\n\n    Use cases:\n    - Merge lists while removing duplicates\n    - Combine collections uniquely\n    - Create comprehensive set of items",
      "namespace": "nodetool.list",
      "node_type": "nodetool.list.Union",
      "layout": "default",
      "properties": [
        {
          "name": "list1",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List1"
        },
        {
          "name": "list2",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "List2"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "list1",
        "list2"
      ],
      "is_dynamic": false
    },
    {
      "title": "If",
      "description": "Conditionally executes one of two branches based on a condition.\n    control, flow, condition, logic, else, true, false, switch, toggle, flow-control\n\n    Use cases:\n    - Branch workflow based on conditions\n    - Handle different cases in data processing\n    - Implement decision logic",
      "namespace": "nodetool.control",
      "node_type": "nodetool.control.If",
      "layout": "default",
      "properties": [
        {
          "name": "condition",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Condition",
          "description": "The condition to evaluate"
        },
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "title": "Value",
          "description": "The value to pass to the next node"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "if_true"
        },
        {
          "type": {
            "type": "any"
          },
          "name": "if_false"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "condition",
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Evaluate Expression",
      "description": "Evaluates a Python expression with safety restrictions.\n    python, expression, evaluate\n\n    Use cases:\n    - Calculate values dynamically\n    - Transform data with simple expressions\n    - Quick data validation\n\n    IMPORTANT: Only enabled in non-production environments",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.EvaluateExpression",
      "layout": "default",
      "properties": [
        {
          "name": "expression",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Expression",
          "description": "Python expression to evaluate. Variables are available as locals."
        },
        {
          "name": "variables",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Variables",
          "description": "Variables available to the expression"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "expression",
        "variables"
      ],
      "is_dynamic": false
    },
    {
      "title": "Execute Python",
      "description": "Executes Python code with safety restrictions.\n    python, code, execute\n\n    Use cases:\n    - Run custom data transformations\n    - Prototype node functionality\n    - Debug and testing workflows\n\n    IMPORTANT: Only enabled in non-production environments",
      "namespace": "nodetool.code",
      "node_type": "nodetool.code.ExecutePython",
      "layout": "default",
      "properties": [
        {
          "name": "code",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Code",
          "description": "Python code to execute. Input variables are available as locals. Assign the desired output to the 'result' variable."
        },
        {
          "name": "inputs",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Inputs",
          "description": "Input variables available to the code as locals."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "code",
        "inputs"
      ],
      "is_dynamic": false
    },
    {
      "title": "Absolute Path",
      "description": "Return the absolute path of a file or directory.\n    files, path, absolute\n\n    Use cases:\n    - Convert relative paths to absolute\n    - Get full system path\n    - Resolve path references",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.AbsolutePath",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to convert to absolute"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "file_path"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Accessed Time",
      "description": "Get file last accessed timestamp.\n    files, metadata, accessed, time",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.AccessedTime",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Basename",
      "description": "Get the base name component of a file path.\n    files, path, basename\n\n    Use cases:\n    - Extract filename from full path\n    - Get file name without directory\n    - Process file names independently",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.Basename",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "File path to get basename from"
        },
        {
          "name": "remove_extension",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Remove Extension",
          "description": "Remove file extension from basename"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path",
        "remove_extension"
      ],
      "is_dynamic": false
    },
    {
      "title": "Copy File",
      "description": "Copy a file from source to destination path.\n    files, copy, manage\n\n    Use cases:\n    - Create file backups\n    - Duplicate files for processing\n    - Copy files to new locations",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.CopyFile",
      "layout": "default",
      "properties": [
        {
          "name": "source_path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Source Path",
          "description": "Source file path"
        },
        {
          "name": "destination_path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Destination Path",
          "description": "Destination file path"
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "source_path",
        "destination_path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Create Directory",
      "description": "Create a new directory at specified path.\n    files, directory, create\n\n    Use cases:\n    - Set up directory structure for file organization\n    - Create output directories for processed files",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.CreateDirectory",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Directory path to create"
        },
        {
          "name": "exist_ok",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Exist Ok",
          "description": "Don't error if directory already exists"
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path",
        "exist_ok"
      ],
      "is_dynamic": false
    },
    {
      "title": "Created Time",
      "description": "Get file creation timestamp.\n    files, metadata, created, time",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.CreatedTime",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Dirname",
      "description": "Get the directory name component of a file path.\n    files, path, dirname\n\n    Use cases:\n    - Extract directory path from full path\n    - Get parent directory\n    - Process directory paths",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.Dirname",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "File path to get dirname from"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "File Exists",
      "description": "Check if a file or directory exists at the specified path.\n    files, check, exists\n\n    Use cases:\n    - Validate file presence before processing\n    - Implement conditional logic based on file existence",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.FileExists",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to check for existence"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "File Extension",
      "description": "Get file extension.\n    files, metadata, extension",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.FileExtension",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "File Name",
      "description": "Get file name without path.\n    files, metadata, name",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.FileName",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "File Name Match",
      "description": "Match a filename against a pattern using Unix shell-style wildcards.\n    files, pattern, match, filter\n\n    Use cases:\n    - Filter files by name pattern\n    - Validate file naming conventions\n    - Match file extensions",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.FileNameMatch",
      "layout": "default",
      "properties": [
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Filename to check"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "*",
          "title": "Pattern",
          "description": "Pattern to match against (e.g. *.txt, data_*.csv)"
        },
        {
          "name": "case_sensitive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Case Sensitive",
          "description": "Whether the pattern matching should be case-sensitive"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "filename",
        "pattern",
        "case_sensitive"
      ],
      "is_dynamic": false
    },
    {
      "title": "Filter File Names",
      "description": "Filter a list of filenames using Unix shell-style wildcards.\n    files, pattern, filter, list\n\n    Use cases:\n    - Filter multiple files by pattern\n    - Batch process files matching criteria\n    - Select files by extension",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.FilterFileNames",
      "layout": "default",
      "properties": [
        {
          "name": "filenames",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Filenames",
          "description": "list of filenames to filter"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "*",
          "title": "Pattern",
          "description": "Pattern to filter by (e.g. *.txt, data_*.csv)"
        },
        {
          "name": "case_sensitive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Case Sensitive",
          "description": "Whether the pattern matching should be case-sensitive"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "filenames",
        "pattern",
        "case_sensitive"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get Directory",
      "description": "Get directory containing the file.\n    files, metadata, directory",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.GetDirectory",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get Environment Variable",
      "description": "Gets an environment variable value.\n    environment, variable, system\n\n    Use cases:\n    - Access configuration\n    - Get system settings",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.GetEnvironmentVariable",
      "layout": "default",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "Environment variable name"
        },
        {
          "name": "default",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Default",
          "description": "Default value if not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "none"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "name",
        "default"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get File Size",
      "description": "Get file size in bytes.\n    files, metadata, size",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.GetFileSize",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get Path Info",
      "description": "Gets information about a path.\n    path, info, metadata\n\n    Use cases:\n    - Extract path components\n    - Parse file paths",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.GetPathInfo",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get System Info",
      "description": "Gets system information.\n    system, info, platform\n\n    Use cases:\n    - Check system compatibility\n    - Platform-specific logic",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.GetSystemInfo",
      "layout": "default",
      "properties": [],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [],
      "is_dynamic": false
    },
    {
      "title": "Is Directory",
      "description": "Check if path is a directory.\n    files, metadata, type",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.IsDirectory",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Is File",
      "description": "Check if path is a file.\n    files, metadata, type",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.IsFile",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Join Paths",
      "description": "Joins path components.\n    path, join, combine\n\n    Use cases:\n    - Build file paths\n    - Create cross-platform paths",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.JoinPaths",
      "layout": "default",
      "properties": [
        {
          "name": "paths",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Paths",
          "description": "Path components to join"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "file_path"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "paths"
      ],
      "is_dynamic": false
    },
    {
      "title": "List Files",
      "description": "list files in a directory matching a pattern.\n    files, list, directory\n\n    Use cases:\n    - Get files for batch processing\n    - Filter files by extension or pattern",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.ListFiles",
      "layout": "default",
      "properties": [
        {
          "name": "directory",
          "type": {
            "type": "file_path"
          },
          "default": {
            "path": "~"
          },
          "title": "Directory",
          "description": "Directory to scan"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "*",
          "title": "Pattern",
          "description": "File pattern to match (e.g. *.txt)"
        },
        {
          "name": "recursive",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Recursive",
          "description": "Search subdirectories"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "file_path"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "directory",
        "pattern",
        "recursive"
      ],
      "is_dynamic": false
    },
    {
      "title": "Load Audio File",
      "description": "Read an audio file from disk.\n    audio, input, load, file\n\n    Use cases:\n    - Load audio for processing\n    - Import sound files for editing\n    - Read audio assets for a workflow",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.LoadAudioFile",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to the audio file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Load Bytes File",
      "description": "Read raw bytes from a file on disk.\n    files, bytes, read, input, load, file\n\n    Use cases:\n    - Load binary data for processing\n    - Read binary files for a workflow",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.LoadBytesFile",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to the file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Load CSVFile",
      "description": "Read a CSV file from disk.\n    files, csv, read, input, load, file",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.LoadCSVFile",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to the CSV file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Load Document File",
      "description": "Read a document from disk.\n    files, document, read, input, load, file",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.LoadDocumentFile",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to the document to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Load Image File",
      "description": "Read an image file from disk.\n    image, input, load, file\n\n    Use cases:\n    - Load images for processing\n    - Import photos for editing\n    - Read image assets for a workflow",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.LoadImageFile",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to the image file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Load Video File",
      "description": "Read a video file from disk.\n    video, input, load, file\n\n    Use cases:\n    - Load videos for processing\n    - Import video files for editing\n    - Read video assets for a workflow",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.LoadVideoFile",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the video file to read"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Modified Time",
      "description": "Get file last modified timestamp.\n    files, metadata, modified, time",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.ModifiedTime",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Path",
          "description": "Path to file"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Move File",
      "description": "Move a file from source to destination path.\n    files, move, manage\n\n    Use cases:\n    - Organize files into directories\n    - Process and archive files\n    - Relocate completed files",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.MoveFile",
      "layout": "default",
      "properties": [
        {
          "name": "source_path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Source Path",
          "description": "Source file path"
        },
        {
          "name": "destination_path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Destination Path",
          "description": "Destination file path"
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "source_path",
        "destination_path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Normalize Path",
      "description": "Normalizes a path.\n    path, normalize, clean\n\n    Use cases:\n    - Standardize paths\n    - Remove redundant separators",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.NormalizePath",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to normalize"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "file_path"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Path To String",
      "description": "Convert a FilePath object to a string.\n    files, path, string, convert\n\n    Use cases:\n    - Get raw string path from FilePath object\n    - Convert FilePath for string operations\n    - Extract path string for external use",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.PathToString",
      "layout": "default",
      "properties": [
        {
          "name": "file_path",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "File Path",
          "description": "FilePath object to convert to string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "file_path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Relative Path",
      "description": "Return a relative path to a target from a start directory.\n    files, path, relative\n\n    Use cases:\n    - Create relative path references\n    - Generate portable paths\n    - Compare file locations",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.RelativePath",
      "layout": "default",
      "properties": [
        {
          "name": "target_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Target Path",
          "description": "Target path to convert to relative"
        },
        {
          "name": "start_path",
          "type": {
            "type": "str"
          },
          "default": ".",
          "title": "Start Path",
          "description": "Start path for relative conversion"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "file_path"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "target_path",
        "start_path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Save Audio File",
      "description": "Write an audio file to disk.\n    audio, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.SaveAudioFile",
      "layout": "default",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {},
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "\n        Name of the file to save.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "audio",
        "folder",
        "filename"
      ],
      "is_dynamic": false
    },
    {
      "title": "Save Bytes File",
      "description": "Write raw bytes to a file on disk.\n    files, bytes, save, output\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.SaveBytesFile",
      "layout": "default",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "bytes"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Data",
          "description": "The bytes to write to file"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {},
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Name of the file to save. Supports strftime format codes."
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "data",
        "folder",
        "filename"
      ],
      "is_dynamic": false
    },
    {
      "title": "Save CSVDataframe File",
      "description": "Write a pandas DataFrame to a CSV file.\n    files, csv, write, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.SaveCSVDataframeFile",
      "layout": "default",
      "properties": [
        {
          "name": "dataframe",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Dataframe",
          "description": "DataFrame to write to CSV"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {},
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Name of the CSV file to save. Supports strftime format codes."
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "dataframe",
        "folder",
        "filename"
      ],
      "is_dynamic": false
    },
    {
      "title": "Save CSVFile",
      "description": "Write a list of dictionaries to a CSV file.\n    files, csv, write, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.SaveCSVFile",
      "layout": "default",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Data",
          "description": "list of dictionaries to write to CSV"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {},
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Name of the CSV file to save. Supports strftime format codes."
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "data",
        "folder",
        "filename"
      ],
      "is_dynamic": false
    },
    {
      "title": "Save Document File",
      "description": "Write a document to disk.\n    files, document, write, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.SaveDocumentFile",
      "layout": "default",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Document",
          "description": "The document to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {},
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "Name of the file to save. Supports strftime format codes."
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "document",
        "folder",
        "filename"
      ],
      "is_dynamic": false
    },
    {
      "title": "Save Image File",
      "description": "Write an image to disk.\n    image, output, save, file\n\n    Use cases:\n    - Save processed images\n    - Export edited photos\n    - Archive image results",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.SaveImageFile",
      "layout": "default",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {},
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "\n        The name of the image file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "image",
        "folder",
        "filename"
      ],
      "is_dynamic": false
    },
    {
      "title": "Save Video File",
      "description": "Write a video file to disk.\n    video, output, save, file\n\n    The filename can include time and date variables:\n    %Y - Year, %m - Month, %d - Day\n    %H - Hour, %M - Minute, %S - Second",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.SaveVideoFile",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The video to save"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder_path"
          },
          "default": {},
          "title": "Folder",
          "description": "Folder where the file will be saved"
        },
        {
          "name": "filename",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Filename",
          "description": "\n        Name of the file to save.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video",
        "folder",
        "filename"
      ],
      "is_dynamic": false
    },
    {
      "title": "Set Environment Variable",
      "description": "Sets an environment variable.\n    environment, variable, system\n\n    Use cases:\n    - Configure runtime settings\n    - Set up process environment",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.SetEnvironmentVariable",
      "layout": "default",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "Environment variable name"
        },
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value",
          "description": "Environment variable value"
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "name",
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Show Notification",
      "description": "Shows a system notification.\n    notification, system, alert\n\n    Use cases:\n    - Alert user of completed tasks\n    - Show process status\n    - Display important messages",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.ShowNotification",
      "layout": "default",
      "properties": [
        {
          "name": "title",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Title",
          "description": "Title of the notification"
        },
        {
          "name": "message",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Message",
          "description": "Content of the notification"
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Timeout",
          "description": "How long the notification should stay visible (in seconds)"
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "title",
        "message",
        "timeout"
      ],
      "is_dynamic": false
    },
    {
      "title": "Split Extension",
      "description": "Split a path into root and extension components.\n    files, path, extension, split\n\n    Use cases:\n    - Extract file extension\n    - Process filename without extension\n    - Handle file types",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.SplitExtension",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to split"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Split Path",
      "description": "Split a path into directory and file components.\n    files, path, split\n\n    Use cases:\n    - Separate directory from filename\n    - Process path components separately\n    - Extract path parts",
      "namespace": "nodetool.os",
      "node_type": "nodetool.os.SplitPath",
      "layout": "default",
      "properties": [
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to split"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "All",
      "description": "Checks if all boolean values in a list are True.\n    boolean, all, check, logic, condition, flow-control, branch\n\n\n    Use cases:\n    - Ensure all conditions in a set are met\n    - Implement comprehensive checks\n    - Validate multiple criteria simultaneously",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.All",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "bool"
              }
            ]
          },
          "default": [],
          "title": "Values",
          "description": "List of boolean values to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values"
      ],
      "is_dynamic": false
    },
    {
      "title": "Compare",
      "description": "Compares two values using a specified comparison operator.\n    compare, condition, logic\n\n    Use cases:\n    - Implement decision points in workflows\n    - Filter data based on specific criteria\n    - Create dynamic thresholds or limits",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.Compare",
      "layout": "default",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "any"
          },
          "title": "A",
          "description": "First value to compare"
        },
        {
          "name": "b",
          "type": {
            "type": "any"
          },
          "title": "B",
          "description": "Second value to compare"
        },
        {
          "name": "comparison",
          "type": {
            "type": "enum",
            "values": [
              "==",
              "!=",
              ">",
              "<",
              ">=",
              "<="
            ],
            "type_name": "nodetool.nodes.nodetool.boolean.Comparison"
          },
          "default": "==",
          "title": "Comparison",
          "description": "Comparison operator to use"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "a",
        "b",
        "comparison"
      ],
      "is_dynamic": false
    },
    {
      "title": "Conditional Switch",
      "description": "Performs a conditional check on a boolean input and returns a value based on the result.\n    if, condition, flow-control, branch, true, false, switch, toggle\n\n    Use cases:\n    - Implement conditional logic in workflows\n    - Create dynamic branches in workflows\n    - Implement decision points in workflows",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.ConditionalSwitch",
      "layout": "default",
      "properties": [
        {
          "name": "condition",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Condition",
          "description": "The condition to check"
        },
        {
          "name": "if_true",
          "type": {
            "type": "any"
          },
          "title": "If True",
          "description": "The value to return if the condition is true"
        },
        {
          "name": "if_false",
          "type": {
            "type": "any"
          },
          "title": "If False",
          "description": "The value to return if the condition is false"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "condition",
        "if_true",
        "if_false"
      ],
      "is_dynamic": false
    },
    {
      "title": "Is In",
      "description": "Checks if a value is present in a list of options.\n    membership, contains, check\n\n    Use cases:\n    - Validate input against a set of allowed values\n    - Implement category or group checks\n    - Filter data based on inclusion criteria",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.IsIn",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "title": "Value",
          "description": "The value to check for membership"
        },
        {
          "name": "options",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Options",
          "description": "The list of options to check against"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value",
        "options"
      ],
      "is_dynamic": false
    },
    {
      "title": "Is None",
      "description": "Checks if a value is None.\n    null, none, check\n\n    Use cases:\n    - Validate input presence\n    - Handle optional parameters\n    - Implement null checks in data processing",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.IsNone",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "title": "Value",
          "description": "The value to check for None"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Logical Operator",
      "description": "Performs logical operations on two boolean inputs.\n    boolean, logic, operator, condition, flow-control, branch, else, true, false, switch, toggle\n\n    Use cases:\n    - Combine multiple conditions in decision-making\n    - Implement complex logical rules in workflows\n    - Create advanced filters or triggers",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.LogicalOperator",
      "layout": "default",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "A",
          "description": "First boolean input"
        },
        {
          "name": "b",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "B",
          "description": "Second boolean input"
        },
        {
          "name": "operation",
          "type": {
            "type": "enum",
            "values": [
              "and",
              "or",
              "xor",
              "nand",
              "nor"
            ],
            "type_name": "nodetool.nodes.nodetool.boolean.BooleanOperation"
          },
          "default": "and",
          "title": "Operation",
          "description": "Logical operation to perform"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "a",
        "b",
        "operation"
      ],
      "is_dynamic": false
    },
    {
      "title": "Not",
      "description": "Performs logical NOT operation on a boolean input.\n    boolean, logic, not, invert, !, negation, condition, else, true, false, switch, toggle, flow-control, branch\n\n    Use cases:\n    - Invert a condition's result\n    - Implement toggle functionality\n    - Create opposite logic branches",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.Not",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Value",
          "description": "Boolean input to negate"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Some",
      "description": "Checks if any boolean value in a list is True.\n    boolean, any, check, logic, condition, flow-control, branch\n\n    Use cases:\n    - Check if at least one condition in a set is met\n    - Implement optional criteria checks\n    - Create flexible validation rules",
      "namespace": "nodetool.boolean",
      "node_type": "nodetool.boolean.Some",
      "layout": "default",
      "properties": [
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "bool"
              }
            ]
          },
          "default": [],
          "title": "Values",
          "description": "List of boolean values to check"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "values"
      ],
      "is_dynamic": false
    },
    {
      "title": "Agent",
      "description": "Executes tasks using a multi-step agent that can call tools\n    agent, execution, tasks\n\n    Use cases:\n    - Automate complex workflows with reasoning\n    - Process tasks with tool calling capabilities\n    - Solve problems step-by-step with LLM reasoning",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.Agent",
      "layout": "default",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "Agent",
          "title": "Name",
          "description": "The name of the agent executor"
        },
        {
          "name": "objective",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Objective",
          "description": "The objective or problem to create a plan for"
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "Model to use for execution"
        },
        {
          "name": "reasoning_model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Reasoning Model",
          "description": "Model to use for reasoning tasks"
        },
        {
          "name": "task",
          "type": {
            "type": "task"
          },
          "default": {},
          "title": "Task",
          "description": "Pre-defined task to execute, skipping planning"
        },
        {
          "name": "tools",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tool_name"
              }
            ]
          },
          "default": [],
          "title": "Tools",
          "description": "List of tools to use for execution"
        },
        {
          "name": "input_files",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "file_path"
              }
            ]
          },
          "default": [],
          "title": "Input Files",
          "description": "List of input files to use for the agent"
        },
        {
          "name": "max_steps",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Max Steps",
          "description": "Maximum execution steps to prevent infinite loops"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "objective",
        "model",
        "task",
        "tools"
      ],
      "is_dynamic": false
    },
    {
      "title": "Dataframe Agent",
      "description": "Executes tasks using a multi-step agent that can call tools and return a dataframe\n    agent, execution, tasks\n\n    Use cases:\n    - Automate complex workflows with reasoning\n    - Process tasks with tool calling capabilities\n    - Solve problems step-by-step with LLM reasoning",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.DataframeAgent",
      "layout": "default",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "Agent",
          "title": "Name",
          "description": "The name of the agent executor"
        },
        {
          "name": "objective",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Objective",
          "description": "The objective or problem to create a plan for"
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "Model to use for execution"
        },
        {
          "name": "reasoning_model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Reasoning Model",
          "description": "Model to use for reasoning tasks"
        },
        {
          "name": "task",
          "type": {
            "type": "task"
          },
          "default": {},
          "title": "Task",
          "description": "Pre-defined task to execute, skipping planning"
        },
        {
          "name": "tools",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tool_name"
              }
            ]
          },
          "default": [],
          "title": "Tools",
          "description": "List of tools to use for execution"
        },
        {
          "name": "input_files",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "file_path"
              }
            ]
          },
          "default": [],
          "title": "Input Files",
          "description": "List of input files to use for the agent"
        },
        {
          "name": "max_steps",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Max Steps",
          "description": "Maximum execution steps to prevent infinite loops"
        },
        {
          "name": "columns",
          "type": {
            "type": "record_type"
          },
          "default": {},
          "title": "Columns",
          "description": "The columns to use in the dataframe."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "objective",
        "model",
        "task",
        "tools",
        "columns"
      ],
      "is_dynamic": false
    },
    {
      "title": "Dict Agent",
      "description": "Executes tasks using a multi-step agent that can call tools and return a dictionary\n    agent, execution, tasks",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.DictAgent",
      "layout": "default",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "Agent",
          "title": "Name",
          "description": "The name of the agent executor"
        },
        {
          "name": "objective",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Objective",
          "description": "The objective or problem to create a plan for"
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "Model to use for execution"
        },
        {
          "name": "reasoning_model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Reasoning Model",
          "description": "Model to use for reasoning tasks"
        },
        {
          "name": "task",
          "type": {
            "type": "task"
          },
          "default": {},
          "title": "Task",
          "description": "Pre-defined task to execute, skipping planning"
        },
        {
          "name": "tools",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tool_name"
              }
            ]
          },
          "default": [],
          "title": "Tools",
          "description": "List of tools to use for execution"
        },
        {
          "name": "input_files",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "file_path"
              }
            ]
          },
          "default": [],
          "title": "Input Files",
          "description": "List of input files to use for the agent"
        },
        {
          "name": "max_steps",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Max Steps",
          "description": "Maximum execution steps to prevent infinite loops"
        },
        {
          "name": "fields",
          "type": {
            "type": "record_type"
          },
          "default": {},
          "title": "Fields",
          "description": "The fields to use in the dictionary."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "objective",
        "model",
        "task",
        "tools",
        "fields"
      ],
      "is_dynamic": false
    },
    {
      "title": "Image Agent",
      "description": "Executes tasks using a multi-step agent that can call tools and return an image path.\n    agent, execution, tasks, image\n\n    Use cases:\n    - Generate images based on prompts\n    - Find relevant images using search tools",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.ImageAgent",
      "layout": "default",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "Agent",
          "title": "Name",
          "description": "The name of the agent executor"
        },
        {
          "name": "objective",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Objective",
          "description": "The objective or problem to create a plan for"
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "Model to use for execution"
        },
        {
          "name": "reasoning_model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Reasoning Model",
          "description": "Model to use for reasoning tasks"
        },
        {
          "name": "task",
          "type": {
            "type": "task"
          },
          "default": {},
          "title": "Task",
          "description": "Pre-defined task to execute, skipping planning"
        },
        {
          "name": "tools",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tool_name"
              }
            ]
          },
          "default": [],
          "title": "Tools",
          "description": "List of tools to use for execution"
        },
        {
          "name": "input_files",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "file_path"
              }
            ]
          },
          "default": [],
          "title": "Input Files",
          "description": "List of input files to use for the agent"
        },
        {
          "name": "max_steps",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Max Steps",
          "description": "Maximum execution steps to prevent infinite loops"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "objective",
        "model",
        "task",
        "tools"
      ],
      "is_dynamic": false
    },
    {
      "title": "List Agent",
      "description": "Executes tasks using a multi-step agent that can call tools and return a list\n    agent, execution, tasks, list\n\n    Use cases:\n    - Generate lists of items\n    - Create sequences of steps\n    - Collect multiple results",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.ListAgent",
      "layout": "default",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "Agent",
          "title": "Name",
          "description": "The name of the agent executor"
        },
        {
          "name": "objective",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Objective",
          "description": "The objective or problem to create a plan for"
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "Model to use for execution"
        },
        {
          "name": "reasoning_model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Reasoning Model",
          "description": "Model to use for reasoning tasks"
        },
        {
          "name": "task",
          "type": {
            "type": "task"
          },
          "default": {},
          "title": "Task",
          "description": "Pre-defined task to execute, skipping planning"
        },
        {
          "name": "tools",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tool_name"
              }
            ]
          },
          "default": [],
          "title": "Tools",
          "description": "List of tools to use for execution"
        },
        {
          "name": "input_files",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "file_path"
              }
            ]
          },
          "default": [],
          "title": "Input Files",
          "description": "List of input files to use for the agent"
        },
        {
          "name": "max_steps",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Max Steps",
          "description": "Maximum execution steps to prevent infinite loops"
        },
        {
          "name": "item_type",
          "type": {
            "type": "str"
          },
          "default": "string",
          "title": "Item Type",
          "description": "The type of items in the list (string, number, object)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "objective",
        "model",
        "task",
        "tools",
        "item_type"
      ],
      "is_dynamic": false
    },
    {
      "title": "Task Planner",
      "description": "Generates a Task execution plan based on an objective, model, and tools.\n    Outputs a Task object that can be used by an Agent executor.\n    planning, task generation, workflow design",
      "namespace": "nodetool.agents",
      "node_type": "nodetool.agents.TaskPlanner",
      "layout": "default",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "Task Planner",
          "title": "Name",
          "description": "The name of the task planner node"
        },
        {
          "name": "objective",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Objective",
          "description": "The objective or problem to create a plan for"
        },
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "Model to use for planning"
        },
        {
          "name": "reasoning_model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Reasoning Model",
          "description": "Model to use for reasoning"
        },
        {
          "name": "tools",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tool_name"
              }
            ]
          },
          "default": [],
          "title": "Tools",
          "description": "List of EXECUTION tools available for the planned subtasks"
        },
        {
          "name": "input_files",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "file_path"
              }
            ]
          },
          "default": [],
          "title": "Input Files",
          "description": "List of input files to use for planning"
        },
        {
          "name": "output_schema",
          "type": {
            "type": "dict",
            "optional": true
          },
          "title": "Output Schema",
          "description": "Optional JSON schema for the final task output"
        },
        {
          "name": "output_type",
          "type": {
            "type": "str",
            "optional": true
          },
          "title": "Output Type",
          "description": "Optional type hint for the final task output (e.g., 'json', 'markdown')"
        },
        {
          "name": "enable_analysis_phase",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Enable Analysis Phase",
          "description": "Whether to use analysis in the planning phase"
        },
        {
          "name": "enable_data_contracts_phase",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Enable Data Contracts Phase",
          "description": "Whether to use data contracts in the planning phase"
        },
        {
          "name": "use_structured_output",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Use Structured Output",
          "description": "Attempt to use structured output for plan generation"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "task"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "objective",
        "model",
        "tools",
        "input_files",
        "output_schema",
        "output_type",
        "enable_analysis_phase",
        "enable_data_contracts_phase",
        "use_structured_output"
      ],
      "is_dynamic": false
    },
    {
      "title": "Browser",
      "description": "Fetches content from a web page using a headless browser.\n    browser, web, scraping, content, fetch\n\n    Use cases:\n    - Extract content from JavaScript-heavy websites\n    - Retrieve text content from web pages\n    - Get metadata from web pages\n    - Save extracted content to files",
      "namespace": "nodetool.browser",
      "node_type": "nodetool.browser.Browser",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to navigate to"
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 20000,
          "title": "Timeout",
          "description": "Timeout in milliseconds for page navigation"
        },
        {
          "name": "use_readability",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Use Readability",
          "description": "Use Python's Readability for better content extraction"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "success"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "content"
        },
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "metadata"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url",
        "timeout",
        "use_readability"
      ],
      "is_dynamic": false
    },
    {
      "title": "Browser Navigation",
      "description": "Navigates and interacts with web pages in a browser session.\n    browser, navigation, interaction, click, extract\n\n    Use cases:\n    - Perform complex web interactions\n    - Navigate through multi-step web processes\n    - Extract content after interaction",
      "namespace": "nodetool.browser",
      "node_type": "nodetool.browser.BrowserNavigation",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to navigate to (required for 'goto' action)"
        },
        {
          "name": "action",
          "type": {
            "type": "enum",
            "values": [
              "click",
              "goto",
              "back",
              "forward",
              "reload",
              "extract"
            ],
            "type_name": "nodetool.nodes.nodetool.browser.Action"
          },
          "default": "goto",
          "title": "Action",
          "description": "Navigation or extraction action to perform"
        },
        {
          "name": "selector",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Selector",
          "description": "CSS selector for the element to interact with or extract from"
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 30000,
          "title": "Timeout",
          "description": "Timeout in milliseconds for the action"
        },
        {
          "name": "wait_for",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Wait For",
          "description": "Optional selector to wait for after performing the action"
        },
        {
          "name": "extract_type",
          "type": {
            "type": "enum",
            "values": [
              "text",
              "html",
              "value",
              "attribute"
            ],
            "type_name": "nodetool.nodes.nodetool.browser.ExtractType"
          },
          "default": "text",
          "title": "Extract Type",
          "description": "Type of content to extract (for 'extract' action)"
        },
        {
          "name": "attribute",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Attribute",
          "description": "Attribute name to extract (when extract_type is 'attribute')"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url",
        "action",
        "selector",
        "timeout",
        "wait_for",
        "extract_type",
        "attribute"
      ],
      "is_dynamic": false
    },
    {
      "title": "Browser Use",
      "description": "Browser agent tool that uses browser_use under the hood.\n\n    This module provides a tool for running browser-based agents using the browser_use library.\n    The agent can perform complex web automation tasks like form filling, navigation, data extraction,\n    and multi-step workflows using natural language instructions.\n\n    Use cases:\n    - Perform complex web automation tasks based on natural language.\n    - Automate form filling and data entry.\n    - Scrape data after complex navigation or interaction sequences.\n    - Automate multi-step web workflows.",
      "namespace": "nodetool.browser",
      "node_type": "nodetool.browser.BrowserUse",
      "layout": "default",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gpt-4o",
              "claude-3-5-sonnet"
            ],
            "type_name": "nodetool.nodes.nodetool.browser.BrowserUseModel"
          },
          "default": "gpt-4o",
          "title": "Model",
          "description": "The model to use for the browser agent."
        },
        {
          "name": "task",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Task",
          "description": "Natural language description of the browser task to perform. Can include complex multi-step instructions like 'Compare prices between websites', 'Fill out forms', or 'Extract specific data'."
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 300,
          "title": "Timeout",
          "description": "Maximum time in seconds to allow for task completion. Complex tasks may require longer timeouts.",
          "min": 1.0,
          "max": 3600.0
        },
        {
          "name": "use_remote_browser",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Use Remote Browser",
          "description": "Use a remote browser instead of a local one"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "success"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "task"
        },
        {
          "type": {
            "type": "any"
          },
          "name": "result"
        },
        {
          "type": {
            "type": "str",
            "optional": true
          },
          "name": "error"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "model",
        "task",
        "timeout",
        "use_remote_browser"
      ],
      "is_dynamic": false
    },
    {
      "title": "Download File",
      "description": "Downloads a file from a URL and saves it to disk.\n    download, file, web, save\n\n    Use cases:\n    - Download documents, images, or other files from the web\n    - Save data for further processing\n    - Retrieve file assets for analysis",
      "namespace": "nodetool.browser",
      "node_type": "nodetool.browser.DownloadFile",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL of the file to download"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url"
      ],
      "is_dynamic": false
    },
    {
      "title": "Screenshot",
      "description": "Takes a screenshot of a web page or specific element.\n    browser, screenshot, capture, image\n\n    Use cases:\n    - Capture visual representation of web pages\n    - Document specific UI elements\n    - Create visual records of web content",
      "namespace": "nodetool.browser",
      "node_type": "nodetool.browser.Screenshot",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to navigate to before taking screenshot"
        },
        {
          "name": "selector",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Selector",
          "description": "Optional CSS selector for capturing a specific element"
        },
        {
          "name": "output_file",
          "type": {
            "type": "file_path"
          },
          "default": {
            "path": "screenshot.png"
          },
          "title": "Output File",
          "description": "Path to save the screenshot (relative to workspace)"
        },
        {
          "name": "timeout",
          "type": {
            "type": "int"
          },
          "default": 30000,
          "title": "Timeout",
          "description": "Timeout in milliseconds for page navigation"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url",
        "selector",
        "output_file",
        "timeout"
      ],
      "is_dynamic": false
    },
    {
      "title": "Web Fetch",
      "description": "Fetches HTML content from a URL and converts it to text.\n    web, fetch, html, markdown, http\n\n    Use cases:\n    - Extract text content from web pages\n    - Process web content for analysis\n    - Save web content to files",
      "namespace": "nodetool.browser",
      "node_type": "nodetool.browser.WebFetch",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to fetch content from"
        },
        {
          "name": "selector",
          "type": {
            "type": "str"
          },
          "default": "body",
          "title": "Selector",
          "description": "CSS selector to extract specific elements"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url",
        "selector"
      ],
      "is_dynamic": false
    },
    {
      "title": "Chart Generator",
      "description": "LLM Agent to create Plotly Express charts based on natural language descriptions.\n    llm, data visualization, charts\n\n    Use cases:\n    - Generating interactive charts from natural language descriptions\n    - Creating data visualizations with minimal configuration\n    - Converting data analysis requirements into visual representations",
      "namespace": "nodetool.generators",
      "node_type": "nodetool.generators.ChartGenerator",
      "layout": "default",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "The GPT model to use for chart generation."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Natural language description of the desired chart"
        },
        {
          "name": "data",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Data",
          "description": "The data to visualize"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 100000.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "plotly_config"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "prompt",
        "data",
        "model"
      ],
      "is_dynamic": false
    },
    {
      "title": "Data Generator",
      "description": "LLM Agent to create a dataframe based on a user prompt.\n    llm, dataframe creation, data structuring\n\n    Use cases:\n    - Generating structured data from natural language descriptions\n    - Creating sample datasets for testing or demonstration\n    - Converting unstructured text into tabular format",
      "namespace": "nodetool.generators",
      "node_type": "nodetool.generators.DataGenerator",
      "layout": "default",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "The GPT model to use for data generation."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The user prompt"
        },
        {
          "name": "input_text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Input Text",
          "description": "The input text to be analyzed by the agent."
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 100000.0
        },
        {
          "name": "columns",
          "type": {
            "type": "record_type"
          },
          "default": {},
          "title": "Columns",
          "description": "The columns to use in the dataframe."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "prompt",
        "model",
        "columns"
      ],
      "is_dynamic": false
    },
    {
      "title": "SVGGenerator",
      "description": "LLM Agent to create SVG elements based on user prompts.\n    svg, generator, vector, graphics\n\n    Use cases:\n    - Creating vector graphics from text descriptions\n    - Generating scalable illustrations\n    - Creating custom icons and diagrams",
      "namespace": "nodetool.generators",
      "node_type": "nodetool.generators.SVGGenerator",
      "layout": "default",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "The language model to use for SVG generation."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The user prompt for SVG generation"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "Image to use for generation"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "Audio to use for generation"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 8192,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 100000.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "svg_element"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "prompt",
        "image",
        "audio",
        "model"
      ],
      "is_dynamic": false
    },
    {
      "title": "Audio Input",
      "description": "Audio asset input for workflows.\n    input, parameter, audio\n\n    Use cases:\n    - Load audio files for processing\n    - Analyze sound or speech content\n    - Provide audio input to models",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.AudioInput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Value",
          "description": "The audio to use as input."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Boolean Input",
      "description": "Boolean parameter input for workflows.\n    input, parameter, boolean, bool\n\n    Use cases:\n    - Toggle features on/off\n    - Set binary flags\n    - Control conditional logic",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.BooleanInput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Chat Input",
      "description": "Chat message input for workflows.\n    input, parameter, chat, message\n\n    Use cases:\n    - Accept user prompts or queries\n    - Capture conversational input\n    - Provide instructions to language models",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.ChatInput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "message"
              }
            ]
          },
          "default": [],
          "title": "Value",
          "description": "The chat message to use as input."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "message"
              }
            ]
          },
          "name": "history"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "image"
          },
          "name": "image"
        },
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        },
        {
          "type": {
            "type": "video"
          },
          "name": "video"
        },
        {
          "type": {
            "type": "document"
          },
          "name": "document"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Collection Input",
      "description": "Collection input for workflows.\n    input, parameter, collection, chroma\n\n    Use cases:\n    - Select a vector database collection\n    - Specify target collection for indexing\n    - Choose collection for similarity search",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.CollectionInput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Value",
          "description": "The collection to use as input."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "collection"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Document File Input",
      "description": "Document file input for workflows.\n    input, parameter, document, text\n\n    Use cases:\n    - Load text documents for processing\n    - Analyze document content\n    - Extract text for NLP tasks\n    - Index documents for search",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.DocumentFileInput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Value",
          "description": "The path to the document file."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "document"
        },
        {
          "type": {
            "type": "file_path"
          },
          "name": "path"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Document Input",
      "description": "Document asset input for workflows.\n    input, parameter, document\n\n    Use cases:\n    - Load documents for processing\n    - Analyze document content\n    - Provide document input to models",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.DocumentInput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Value",
          "description": "The document to use as input."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Enum Input",
      "description": "Enumeration parameter input for workflows.\n    input, parameter, enum, options, select\n\n    Use cases:\n    - Select from predefined options\n    - Enforce choice from valid values\n    - Configure categorical parameters",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.EnumInput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "options",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Options",
          "description": "Comma-separated list of valid options"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Float Input",
      "description": "Float parameter input for workflows.\n    input, parameter, float, number\n\n    Use cases:\n    - Specify a numeric value within a defined range\n    - Set thresholds or scaling factors\n    - Configure continuous parameters like opacity or volume",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.FloatInput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "min",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Min"
        },
        {
          "name": "max",
          "type": {
            "type": "float"
          },
          "default": 100,
          "title": "Max"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Group Input",
      "description": "Generic group input for loops.\n    input, group, collection, loop\n\n    Use cases:\n    - provides input for a loop\n    - iterates over a group of items",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.GroupInput",
      "layout": "default",
      "properties": [],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [],
      "is_dynamic": false
    },
    {
      "title": "Image Input",
      "description": "Image asset input for workflows.\n    input, parameter, image\n\n    Use cases:\n    - Load images for processing or analysis\n    - Provide visual input to models\n    - Select images for manipulation",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.ImageInput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Value",
          "description": "The image to use as input."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Integer Input",
      "description": "Integer parameter input for workflows.\n    input, parameter, integer, number\n\n    Use cases:\n    - Specify counts or quantities\n    - Set index values\n    - Configure discrete numeric parameters",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.IntegerInput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        },
        {
          "name": "min",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Min"
        },
        {
          "name": "max",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Max"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Path Input",
      "description": "Local path input for workflows.\n    input, parameter, path\n\n    Use cases:\n    - Provide a local path to a file or directory\n    - Specify a file or directory for processing\n    - Load local data for analysis",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.PathInput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "Value",
          "description": "The path to use as input."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "file_path"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "String Input",
      "description": "String parameter input for workflows.\n    input, parameter, string, text\n\n    Use cases:\n    - Provide text labels or names\n    - Enter search queries\n    - Specify file paths or URLs",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.StringInput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Text Input",
      "description": "Text content input for workflows.\n    input, parameter, text\n\n    Use cases:\n    - Load text documents or articles\n    - Process multi-line text content\n    - Analyze large text bodies",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.TextInput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "text"
          },
          "default": {},
          "title": "Value",
          "description": "The text to use as input."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "text"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Video Input",
      "description": "Video asset input for workflows.\n    input, parameter, video\n\n    Use cases:\n    - Load video files for processing\n    - Analyze video content\n    - Extract frames or audio from videos",
      "namespace": "nodetool.input",
      "node_type": "nodetool.input.VideoInput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Value",
          "description": "The video to use as input."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Split Text into Chunks",
      "description": "Splits text into chunks of specified word length.\n    text, chunk, split\n\n    Use cases:\n    - Preparing text for processing by models with input length limits\n    - Creating manageable text segments for parallel processing\n    - Generating summaries of text sections",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Chunk",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "length",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Length",
          "min": 1.0,
          "max": 1000.0
        },
        {
          "name": "overlap",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Overlap"
        },
        {
          "name": "separator",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Separator"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "length",
        "overlap",
        "separator"
      ],
      "is_dynamic": false
    },
    {
      "title": "Concatenate Text",
      "description": "Concatenates two text inputs into a single output.\n    text, concatenation, combine, +\n\n    Use cases:\n    - Joining outputs from multiple text processing nodes\n    - Combining parts of sentences or paragraphs\n    - Merging text data from different sources",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Concat",
      "layout": "default",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "a",
        "b"
      ],
      "is_dynamic": false
    },
    {
      "title": "Contains Text",
      "description": "Checks if text contains a specified substring.\n    text, check, contains, compare, validate, substring, string\n\n    Use cases:\n    - Searching for keywords in text\n    - Filtering content based on presence of terms\n    - Validating text content",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Contains",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "substring",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Substring"
        },
        {
          "name": "case_sensitive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Case Sensitive"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "substring",
        "case_sensitive"
      ],
      "is_dynamic": false
    },
    {
      "title": "Count Tokens",
      "description": "Counts the number of tokens in text using tiktoken.\n    text, tokens, count, encoding\n\n    Use cases:\n    - Checking text length for LLM input limits\n    - Estimating API costs\n    - Managing token budgets in text processing",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.CountTokens",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "encoding",
          "type": {
            "type": "enum",
            "values": [
              "cl100k_base",
              "p50k_base",
              "r50k_base"
            ],
            "type_name": "nodetool.nodes.nodetool.text.TiktokenEncoding"
          },
          "default": "cl100k_base",
          "title": "Encoding",
          "description": "The tiktoken encoding to use for token counting"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "encoding"
      ],
      "is_dynamic": false
    },
    {
      "title": "Ends With",
      "description": "Checks if text ends with a specified suffix.\n    text, check, suffix, compare, validate, substring, string\n\n    Use cases:\n    - Validating file extensions\n    - Checking string endings\n    - Filtering text based on ending content",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.EndsWith",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "suffix",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Suffix"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "suffix"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Text",
      "description": "Extracts a substring from input text.\n    text, extract, substring\n\n    Use cases:\n    - Extracting specific portions of text for analysis\n    - Trimming unwanted parts from text data\n    - Focusing on relevant sections of longer documents",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Extract",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start"
        },
        {
          "name": "end",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "End"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "start",
        "end"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract JSON",
      "description": "Extracts data from JSON using JSONPath expressions.\n    json, extract, jsonpath\n\n    Use cases:\n    - Retrieving specific fields from complex JSON structures\n    - Filtering and transforming JSON data for analysis\n    - Extracting nested data from API responses or configurations",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.ExtractJSON",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "JSON Text"
        },
        {
          "name": "json_path",
          "type": {
            "type": "str"
          },
          "default": "$.*",
          "title": "JSONPath Expression"
        },
        {
          "name": "find_all",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Find All"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "json_path",
        "find_all"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Regex Groups",
      "description": "Extracts substrings matching regex groups from text.\n    text, regex, extract\n\n    Use cases:\n    - Extracting structured data (e.g., dates, emails) from unstructured text\n    - Parsing specific patterns in log files or documents\n    - Isolating relevant information from complex text formats",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.ExtractRegex",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "regex",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Regex"
        },
        {
          "name": "dotall",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Dotall"
        },
        {
          "name": "ignorecase",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Ignorecase"
        },
        {
          "name": "multiline",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Multiline"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "regex",
        "dotall",
        "ignorecase",
        "multiline"
      ],
      "is_dynamic": false
    },
    {
      "title": "Find All Regex Matches",
      "description": "Finds all regex matches in text as separate substrings.\n    text, regex, find\n\n    Use cases:\n    - Identifying all occurrences of a pattern in text\n    - Extracting multiple instances of structured data\n    - Analyzing frequency and distribution of specific text patterns",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.FindAllRegex",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "regex",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Regex"
        },
        {
          "name": "dotall",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Dotall"
        },
        {
          "name": "ignorecase",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Ignorecase"
        },
        {
          "name": "multiline",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Multiline"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "regex",
        "dotall",
        "ignorecase",
        "multiline"
      ],
      "is_dynamic": false
    },
    {
      "title": "Format Text",
      "description": "Replaces placeholders in a string with dynamic inputs using Jinja2 templating.\n    text, template, formatting\n\n    Use cases:\n    - Generating personalized messages with dynamic content\n    - Creating parameterized queries or commands\n    - Formatting and filtering text output based on variable inputs\n\n    Examples:\n    - text: \"Hello, {{ name }}!\"\n    - text: \"Title: {{ title|truncate(20) }}\"\n    - text: \"Name: {{ name|upper }}\"\n\n    Available filters:\n    - truncate(length): Truncates text to given length\n    - upper: Converts text to uppercase\n    - lower: Converts text to lowercase\n    - title: Converts text to title case\n    - trim: Removes whitespace from start/end\n    - replace(old, new): Replaces substring\n    - default(value): Sets default if value is undefined\n    - first: Gets first character/item\n    - last: Gets last character/item\n    - length: Gets length of string/list\n    - sort: Sorts list\n    - join(delimiter): Joins list with delimiter",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.FormatText",
      "layout": "default",
      "properties": [
        {
          "name": "template",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Template",
          "description": "\n    Examples:\n    - text: \"Hello, {{ name }}!\"\n    - text: \"Title: {{ title|truncate(20) }}\"\n    - text: \"Name: {{ name|upper }}\" \n\n    Available filters:\n    - truncate(length): Truncates text to given length\n    - upper: Converts text to uppercase\n    - lower: Converts text to lowercase\n    - title: Converts text to title case\n    - trim: Removes whitespace from start/end\n    - replace(old, new): Replaces substring\n    - default(value): Sets default if value is undefined\n    - first: Gets first character/item\n    - last: Gets last character/item\n    - length: Gets length of string/list\n    - sort: Sorts list\n    - join(delimiter): Joins list with delimiter\n"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "template"
      ],
      "is_dynamic": true
    },
    {
      "title": "Check Length",
      "description": "Checks if text length meets specified conditions.\n    text, check, length, compare, validate, whitespace, string\n\n    Use cases:\n    - Validating input length requirements\n    - Filtering text by length\n    - Checking content size constraints",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.HasLength",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "min_length",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Minimum Length"
        },
        {
          "name": "max_length",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Maximum Length"
        },
        {
          "name": "exact_length",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Exact Length"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "min_length",
        "max_length",
        "exact_length"
      ],
      "is_dynamic": false
    },
    {
      "title": "Is Empty",
      "description": "Checks if text is empty or contains only whitespace.\n    text, check, empty, compare, validate, whitespace, string\n\n    Use cases:\n    - Validating required text fields\n    - Filtering out empty content\n    - Checking for meaningful input",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.IsEmpty",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "trim_whitespace",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Trim Whitespace"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "trim_whitespace"
      ],
      "is_dynamic": false
    },
    {
      "title": "Join Text",
      "description": "Joins a list of strings into a single string using a specified separator.\n    text, join, combine, +, add, concatenate\n\n    Use cases:\n    - Combining multiple text elements with a consistent delimiter\n    - Creating comma-separated lists from individual items\n    - Assembling formatted text from array elements",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Join",
      "layout": "default",
      "properties": [
        {
          "name": "strings",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Strings"
        },
        {
          "name": "separator",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Separator"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "strings",
        "separator"
      ],
      "is_dynamic": false
    },
    {
      "title": "Parse JSON String",
      "description": "Parses a JSON string into a Python object.\n    json, parse, convert\n\n    Use cases:\n    - Converting JSON API responses for further processing\n    - Preparing structured data for analysis or storage\n    - Extracting configuration or settings from JSON files",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.ParseJSON",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "JSON string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text"
      ],
      "is_dynamic": false
    },
    {
      "title": "Find Regex Matches",
      "description": "Find all matches of a regex pattern in text.\n    regex, search, pattern, match\n\n    Use cases:\n    - Extract specific patterns from text\n    - Validate text against patterns\n    - Find all occurrences of a pattern",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.RegexMatch",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to search in"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "Regular expression pattern"
        },
        {
          "name": "group",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Group",
          "description": "Capture group to extract (0 for full match)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "pattern",
        "group"
      ],
      "is_dynamic": false
    },
    {
      "title": "Replace with Regex",
      "description": "Replace text matching a regex pattern.\n    regex, replace, substitute\n\n    Use cases:\n    - Clean or standardize text\n    - Remove unwanted patterns\n    - Transform text formats",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.RegexReplace",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to perform replacements on"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "Regular expression pattern"
        },
        {
          "name": "replacement",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Replacement",
          "description": "Replacement text"
        },
        {
          "name": "count",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Count",
          "description": "Maximum replacements (0 for unlimited)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "pattern",
        "replacement",
        "count"
      ],
      "is_dynamic": false
    },
    {
      "title": "Split with Regex",
      "description": "Split text using a regex pattern as delimiter.\n    regex, split, tokenize\n\n    Use cases:\n    - Parse structured text\n    - Extract fields from formatted strings\n    - Tokenize text",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.RegexSplit",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to split"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "Regular expression pattern to split on"
        },
        {
          "name": "maxsplit",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Maxsplit",
          "description": "Maximum number of splits (0 for unlimited)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "pattern",
        "maxsplit"
      ],
      "is_dynamic": false
    },
    {
      "title": "Validate with Regex",
      "description": "Check if text matches a regex pattern.\n    regex, validate, check\n\n    Use cases:\n    - Validate input formats (email, phone, etc)\n    - Check text structure\n    - Filter text based on patterns",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.RegexValidate",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to validate"
        },
        {
          "name": "pattern",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Pattern",
          "description": "Regular expression pattern"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "pattern"
      ],
      "is_dynamic": false
    },
    {
      "title": "Replace Text",
      "description": "Replaces a substring in a text with another substring.\n    text, replace, substitute\n\n    Use cases:\n    - Correcting or updating specific text patterns\n    - Sanitizing or normalizing text data\n    - Implementing simple text transformations",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Replace",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "old",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Old"
        },
        {
          "name": "new",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "New"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "old",
        "new"
      ],
      "is_dynamic": false
    },
    {
      "title": "Save Text",
      "description": "Saves input text to a file in the assets folder.\n    text, save, file\n\n    Use cases:\n    - Persisting processed text results\n    - Creating text files for downstream nodes or external use\n    - Archiving text data within the workflow",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.SaveText",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {},
          "title": "Folder",
          "description": "Name of the output folder."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d-%H-%M-%S.txt",
          "title": "Name",
          "description": "\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "text"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "folder",
        "name"
      ],
      "is_dynamic": false
    },
    {
      "title": "Slice Text",
      "description": "Slices text using Python's slice notation (start:stop:step).\n    text, slice, substring\n\n    Use cases:\n    - Extracting specific portions of text with flexible indexing\n    - Reversing text using negative step\n    - Taking every nth character with step parameter\n\n    Examples:\n    - start=0, stop=5: first 5 characters\n    - start=-5: last 5 characters\n    - step=2: every second character\n    - step=-1: reverse the text",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Slice",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "start",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Start Index"
        },
        {
          "name": "stop",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Stop Index"
        },
        {
          "name": "step",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Step"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "start",
        "stop",
        "step"
      ],
      "is_dynamic": false
    },
    {
      "title": "Split Text",
      "description": "Separates text into a list of strings based on a specified delimiter.\n    text, split, tokenize\n\n    Use cases:\n    - Parsing CSV or similar delimited data\n    - Breaking down sentences into words or phrases\n    - Extracting specific elements from structured text",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Split",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "delimiter",
          "type": {
            "type": "str"
          },
          "default": ",",
          "title": "Delimiter"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "delimiter"
      ],
      "is_dynamic": false
    },
    {
      "title": "Starts With",
      "description": "Checks if text starts with a specified prefix.\n    text, check, prefix, compare, validate, substring, string\n\n    Use cases:\n    - Validating string prefixes\n    - Filtering text based on starting content\n    - Checking file name patterns",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.StartsWith",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "prefix",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prefix"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "prefix"
      ],
      "is_dynamic": false
    },
    {
      "title": "Template",
      "description": "Uses Jinja2 templating to format strings with variables and filters.\n    text, template, formatting, format, combine, concatenate, +, add, variable, replace, filter\n\n    Use cases:\n    - Generating personalized messages with dynamic content\n    - Creating parameterized queries or commands\n    - Formatting and filtering text output based on variable inputs\n\n    Examples:\n    - text: \"Hello, {{ name }}!\"\n    - text: \"Title: {{ title|truncate(20) }}\"\n    - text: \"Name: {{ name|upper }}\"\n\n    Available filters:\n    - truncate(length): Truncates text to given length\n    - upper: Converts text to uppercase\n    - lower: Converts text to lowercase\n    - title: Converts text to title case\n    - trim: Removes whitespace from start/end\n    - replace(old, new): Replaces substring\n    - default(value): Sets default if value is undefined\n    - first: Gets first character/item\n    - last: Gets last character/item\n    - length: Gets length of string/list\n    - sort: Sorts list\n    - join(delimiter): Joins list with delimiter",
      "namespace": "nodetool.text",
      "node_type": "nodetool.text.Template",
      "layout": "default",
      "properties": [
        {
          "name": "string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "String",
          "description": "\n    Examples:\n    - text: \"Hello, {{ name }}!\"\n    - text: \"Title: {{ title|truncate(20) }}\"\n    - text: \"Name: {{ name|upper }}\"\n\n    Available filters:\n    - truncate(length): Truncates text to given length\n    - upper: Converts text to uppercase\n    - lower: Converts text to lowercase\n    - title: Converts text to title case\n    - trim: Removes whitespace from start/end\n    - replace(old, new): Replaces substring\n    - default(value): Sets default if value is undefined\n    - first: Gets first character/item\n    - last: Gets last character/item\n    - length: Gets length of string/list\n    - sort: Sorts list\n    - join(delimiter): Joins list with delimiter\n"
        },
        {
          "name": "values",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "list"
              },
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              },
              {
                "type": "object"
              }
            ]
          },
          "default": {},
          "title": "Values",
          "description": "\n        The values to replace in the string.\n        - If a string, it will be used as the format string.\n        - If a list, it will be used as the format arguments.\n        - If a dictionary, it will be used as the template variables.\n        - If an object, it will be converted to a dictionary using the object's __dict__ method.\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "string",
        "values"
      ],
      "is_dynamic": false
    },
    {
      "title": "Loop",
      "description": "Loops over a list of items and processes the remaining nodes for each item.\n    loop, itereate, repeat, for, each, batch\n\n    Use cases:\n    - Loop over a list of items and process the nodes inside the group",
      "namespace": "nodetool.group",
      "node_type": "nodetool.group.Loop",
      "layout": "default",
      "properties": [
        {
          "name": "input",
          "type": {
            "type": "any"
          },
          "default": [],
          "title": "Input",
          "description": "The input data to loop over."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "input"
      ],
      "is_dynamic": false
    },
    {
      "title": "Data Extractor",
      "description": "Extract structured data from text content using LLM providers.\n    data-extraction, structured-data, nlp, parsing\n\n    Specialized for extracting structured information:\n    - Converting unstructured text into structured data\n    - Identifying and extracting specific fields from documents\n    - Parsing text according to predefined schemas\n    - Creating structured records from natural language content",
      "namespace": "nodetool.llms",
      "node_type": "nodetool.llms.Extractor",
      "layout": "default",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "Model to use for data extraction"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to extract data from"
        },
        {
          "name": "extraction_prompt",
          "type": {
            "type": "str"
          },
          "default": "Extract the following information from the text:",
          "title": "Extraction Prompt",
          "description": "Additional instructions for the extraction process"
        },
        {
          "name": "columns",
          "type": {
            "type": "record_type"
          },
          "default": {},
          "title": "Columns",
          "description": "The fields to extract from the text"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "description": "The maximum number of tokens to generate.",
          "min": 1.0,
          "max": 100000.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "extraction_prompt",
        "columns",
        "model"
      ],
      "is_dynamic": false
    },
    {
      "title": "LLM",
      "description": "Generate natural language responses using LLM providers.\n    llm, text-generation, chatbot, question-answering\n\n    Leverages LLM providers to:\n    - Generate human-like text responses\n    - Answer questions\n    - Complete prompts\n    - Engage in conversational interactions\n    - Assist with writing and editing tasks\n    - Perform text analysis and summarization",
      "namespace": "nodetool.llms",
      "node_type": "nodetool.llms.LLM",
      "layout": "default",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "Model to use for execution"
        },
        {
          "name": "system",
          "type": {
            "type": "str"
          },
          "default": "You are a friendly assistant.",
          "title": "System",
          "description": "The system prompt for the LLM"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The prompt for the LLM"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to analyze"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio to analyze"
        },
        {
          "name": "voice",
          "type": {
            "type": "enum",
            "values": [
              "none",
              "alloy",
              "echo",
              "fable",
              "onyx",
              "nova",
              "shimmer"
            ],
            "type_name": "nodetool.nodes.nodetool.llms.Voice"
          },
          "default": "none",
          "title": "Voice",
          "description": "The voice for the audio output (only for OpenAI)"
        },
        {
          "name": "tools",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tool_name"
              }
            ]
          },
          "default": [],
          "title": "Tools",
          "description": "List of tools to use for execution"
        },
        {
          "name": "messages",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "message"
              }
            ]
          },
          "default": [],
          "title": "Messages",
          "description": "The messages for the LLM"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "min": 1.0,
          "max": 100000.0
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window (Ollama)",
          "min": 1.0,
          "max": 65536.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        },
        {
          "type": {
            "type": "image"
          },
          "name": "image"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "prompt",
        "model",
        "messages",
        "image",
        "audio",
        "tools"
      ],
      "is_dynamic": false
    },
    {
      "title": "LLM (Streaming)",
      "description": "Generate natural language responses using LLM providers and streams output.\n    llm, text-generation, chatbot, question-answering, streaming",
      "namespace": "nodetool.llms",
      "node_type": "nodetool.llms.LLMStreaming",
      "layout": "default",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "Model to use for execution"
        },
        {
          "name": "system",
          "type": {
            "type": "str"
          },
          "default": "You are a friendly assistant.",
          "title": "System",
          "description": "The system prompt for the LLM"
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The prompt for the LLM"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to analyze"
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio to analyze"
        },
        {
          "name": "tools",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tool_name"
              }
            ]
          },
          "default": [],
          "title": "Tools",
          "description": "List of tools to use for execution"
        },
        {
          "name": "messages",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "message"
              }
            ]
          },
          "default": [],
          "title": "Messages",
          "description": "The messages for the LLM"
        },
        {
          "name": "max_tokens",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Max Tokens",
          "min": 1.0,
          "max": 100000.0
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window (Ollama)",
          "min": 1.0,
          "max": 65536.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "image"
          },
          "name": "image"
        },
        {
          "type": {
            "type": "audio"
          },
          "name": "audio"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "prompt",
        "model",
        "messages",
        "image",
        "audio",
        "tools"
      ],
      "is_dynamic": false
    },
    {
      "title": "Text Summarizer",
      "description": "Generate concise summaries of text content using LLM providers.\n    text, summarization, nlp, content\n\n    Specialized for creating high-quality summaries:\n    - Condensing long documents into key points\n    - Creating executive summaries\n    - Extracting main ideas from text\n    - Maintaining factual accuracy while reducing length",
      "namespace": "nodetool.llms",
      "node_type": "nodetool.llms.Summarizer",
      "layout": "default",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "Model to use for summarization"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to summarize"
        },
        {
          "name": "max_words",
          "type": {
            "type": "int"
          },
          "default": 150,
          "title": "Max Words",
          "description": "Target maximum number of words for the summary",
          "min": 50.0,
          "max": 500.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "max_words",
        "model"
      ],
      "is_dynamic": false
    },
    {
      "title": "Text Classifier",
      "description": "Classify text into predefined or dynamic categories using LLM.\n    classification, nlp, categorization\n\n    Use cases:\n    - Sentiment analysis\n    - Topic classification\n    - Intent detection\n    - Content categorization",
      "namespace": "nodetool.llms",
      "node_type": "nodetool.llms.TextClassifier",
      "layout": "default",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "language_model"
          },
          "default": {},
          "title": "Model",
          "description": "Model to use for classification"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to classify"
        },
        {
          "name": "categories",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Categories",
          "description": "List of possible categories. If empty, LLM will determine categories."
        },
        {
          "name": "multi_label",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Multi Label",
          "description": "Allow multiple category assignments"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "categories",
        "multi_label",
        "model"
      ],
      "is_dynamic": false
    },
    {
      "title": "Save Audio",
      "description": "Save an audio file to a specified folder.\n    audio, folder, name\n\n    Use cases:\n    - Save generated audio files with timestamps\n    - Organize outputs into specific folders\n    - Create backups of generated audio",
      "namespace": "nodetool.audio",
      "node_type": "nodetool.audio.SaveAudio",
      "layout": "default",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio"
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {},
          "title": "Folder",
          "description": "The folder to save the audio file to. "
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d-%H-%M-%S.opus",
          "title": "Name",
          "description": "\n        The name of the audio file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "audio",
        "folder",
        "name"
      ],
      "is_dynamic": false
    },
    {
      "title": "Add",
      "description": "Performs addition on two inputs.\n    math, plus, add, addition, sum, +",
      "namespace": "nodetool.math",
      "node_type": "nodetool.math.Add",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "a",
        "b"
      ],
      "is_dynamic": false
    },
    {
      "title": "Binary Operation",
      "description": "",
      "namespace": "nodetool.math",
      "node_type": "nodetool.math.BinaryOperation",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "a",
        "b"
      ],
      "is_dynamic": false
    },
    {
      "title": "Cosine",
      "description": "Computes the cosine of input angles in radians.\n    math, trigonometry, cosine, cos\n\n    Use cases:\n    - Calculating horizontal components in physics\n    - Creating circular motions\n    - Phase calculations in signal processing",
      "namespace": "nodetool.math",
      "node_type": "nodetool.math.Cosine",
      "layout": "small",
      "properties": [
        {
          "name": "angle_rad",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "default": 0.0,
          "title": "Angle (Radians)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "angle_rad"
      ],
      "is_dynamic": false
    },
    {
      "title": "Divide",
      "description": "Divides the first input by the second.\n    math, division, arithmetic, quotient, /",
      "namespace": "nodetool.math",
      "node_type": "nodetool.math.Divide",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "a",
        "b"
      ],
      "is_dynamic": false
    },
    {
      "title": "Modulus",
      "description": "Calculates the element-wise remainder of division.\n    math, modulo, remainder, mod, %\n\n    Use cases:\n    - Implementing cyclic behaviors\n    - Checking for even/odd numbers\n    - Limiting values to a specific range",
      "namespace": "nodetool.math",
      "node_type": "nodetool.math.Modulus",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "a",
        "b"
      ],
      "is_dynamic": false
    },
    {
      "title": "Multiply",
      "description": "Multiplies two inputs.\n    math, product, times, *",
      "namespace": "nodetool.math",
      "node_type": "nodetool.math.Multiply",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "a",
        "b"
      ],
      "is_dynamic": false
    },
    {
      "title": "Power",
      "description": "Raises the base to the power of the exponent element-wise.\n    math, exponentiation, power, pow, **\n\n    Use cases:\n    - Calculating compound interest\n    - Implementing polynomial functions\n    - Applying non-linear transformations to data",
      "namespace": "nodetool.math",
      "node_type": "nodetool.math.Power",
      "layout": "small",
      "properties": [
        {
          "name": "base",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "default": 1.0,
          "title": "Base"
        },
        {
          "name": "exponent",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "default": 2.0,
          "title": "Exponent"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "base",
        "exponent"
      ],
      "is_dynamic": false
    },
    {
      "title": "Sine",
      "description": "Computes the sine of input angles in radians.\n    math, trigonometry, sine, sin\n\n    Use cases:\n    - Calculating vertical components in physics\n    - Generating smooth periodic functions\n    - Audio signal processing",
      "namespace": "nodetool.math",
      "node_type": "nodetool.math.Sine",
      "layout": "small",
      "properties": [
        {
          "name": "angle_rad",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "default": 0.0,
          "title": "Angle (Radians)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "angle_rad"
      ],
      "is_dynamic": false
    },
    {
      "title": "Sqrt",
      "description": "Calculates the square root of the input element-wise.\n    math, square root, sqrt, \u221a\n\n    Use cases:\n    - Normalizing data\n    - Calculating distances in Euclidean space\n    - Finding intermediate values in binary search",
      "namespace": "nodetool.math",
      "node_type": "nodetool.math.Sqrt",
      "layout": "small",
      "properties": [
        {
          "name": "x",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 1.0,
          "title": "Input"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "float"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "x"
      ],
      "is_dynamic": false
    },
    {
      "title": "Subtract",
      "description": "Subtracts the second input from the first.\n    math, minus, difference, -",
      "namespace": "nodetool.math",
      "node_type": "nodetool.math.Subtract",
      "layout": "small",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "A"
        },
        {
          "name": "b",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": 0.0,
          "title": "B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "float"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "a",
        "b"
      ],
      "is_dynamic": false
    },
    {
      "title": "Audio",
      "description": "Represents an audio file constant in the workflow.\n    audio, file, mp3, wav\n\n    Use cases:\n    - Provide a fixed audio input for audio processing nodes\n    - Reference a specific audio file in the workflow\n    - Set default audio for testing or demonstration purposes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Audio",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Bool",
      "description": "Represents a boolean constant in the workflow.\n    boolean, logic, flag\n\n    Use cases:\n    - Control flow decisions in conditional nodes\n    - Toggle features or behaviors in the workflow\n    - Set default boolean values for configuration",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Bool",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Constant",
      "description": "",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Constant",
      "layout": "default",
      "properties": [],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [],
      "is_dynamic": false
    },
    {
      "title": "Data Frame",
      "description": "Represents a fixed DataFrame constant in the workflow.\n    table, data, dataframe, pandas\n\n    Use cases:\n    - Provide static data for analysis or processing\n    - Define lookup tables or reference data\n    - Set sample data for testing or demonstration",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.DataFrame",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "DataFrame"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Date",
      "description": "Make a date object from year, month, day.\n    date, make, create",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Date",
      "layout": "default",
      "properties": [
        {
          "name": "year",
          "type": {
            "type": "int"
          },
          "default": 1900,
          "title": "Year",
          "description": "Year of the date"
        },
        {
          "name": "month",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Month",
          "description": "Month of the date"
        },
        {
          "name": "day",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Day",
          "description": "Day of the date"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "date"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "year",
        "month",
        "day"
      ],
      "is_dynamic": false
    },
    {
      "title": "Date Time",
      "description": "Make a datetime object from year, month, day, hour, minute, second.\n    datetime, make, create",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.DateTime",
      "layout": "default",
      "properties": [
        {
          "name": "year",
          "type": {
            "type": "int"
          },
          "default": 1900,
          "title": "Year",
          "description": "Year of the datetime"
        },
        {
          "name": "month",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Month",
          "description": "Month of the datetime"
        },
        {
          "name": "day",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Day",
          "description": "Day of the datetime"
        },
        {
          "name": "hour",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Hour",
          "description": "Hour of the datetime"
        },
        {
          "name": "minute",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Minute",
          "description": "Minute of the datetime"
        },
        {
          "name": "second",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Second",
          "description": "Second of the datetime"
        },
        {
          "name": "microsecond",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Microsecond",
          "description": "Microsecond of the datetime"
        },
        {
          "name": "tzinfo",
          "type": {
            "type": "str"
          },
          "default": "UTC",
          "title": "Tzinfo",
          "description": "Timezone of the datetime"
        },
        {
          "name": "utc_offset",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Utc Offset",
          "description": "UTC offset of the datetime"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "year",
        "month",
        "day",
        "hour",
        "minute",
        "second",
        "microsecond",
        "tzinfo",
        "utc_offset"
      ],
      "is_dynamic": false
    },
    {
      "title": "Dict",
      "description": "Represents a dictionary constant in the workflow.\n    dictionary, key-value, mapping\n\n    Use cases:\n    - Store configuration settings\n    - Provide structured data inputs\n    - Define parameter sets for other nodes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Dict",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Document",
      "description": "Represents a document constant in the workflow.\n    document, pdf, word, docx",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Document",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Document"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Float",
      "description": "Represents a floating-point number constant in the workflow.\n    number, decimal, float\n\n    Use cases:\n    - Set numerical parameters for calculations\n    - Define thresholds or limits\n    - Provide fixed numerical inputs for processing",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Float",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Image",
      "description": "Represents an image file constant in the workflow.\n    picture, photo, image\n\n    Use cases:\n    - Provide a fixed image input for image processing nodes\n    - Reference a specific image file in the workflow\n    - Set default image for testing or demonstration purposes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Image",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Integer",
      "description": "Represents an integer constant in the workflow.\n    number, integer, whole\n\n    Use cases:\n    - Set numerical parameters for calculations\n    - Define counts, indices, or sizes\n    - Provide fixed numerical inputs for processing",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Integer",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "JSON",
      "description": "Represents a JSON constant in the workflow.\n    json, object, dictionary",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.JSON",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "json"
          },
          "default": {},
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "json"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "List",
      "description": "Represents a list constant in the workflow.\n    array, sequence, collection\n\n    Use cases:\n    - Store multiple values of the same type\n    - Provide ordered data inputs\n    - Define sequences for iteration in other nodes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.List",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "String",
      "description": "Represents a string constant in the workflow.\n    text, string, characters\n\n    Use cases:\n    - Provide fixed text inputs for processing\n    - Define labels, identifiers, or names\n    - Set default text values for configuration",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.String",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Video",
      "description": "Represents a video file constant in the workflow.\n    video, movie, mp4, file\n\n    Use cases:\n    - Provide a fixed video input for video processing nodes\n    - Reference a specific video file in the workflow\n    - Set default video for testing or demonstration purposes",
      "namespace": "nodetool.constant",
      "node_type": "nodetool.constant.Video",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Value"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Arg Max",
      "description": "Returns the label associated with the highest value in a dictionary.\n    dictionary, maximum, label, argmax\n\n    Use cases:\n    - Get the most likely class from classification probabilities\n    - Find the category with highest score\n    - Identify the winner in a voting/ranking system",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.ArgMax",
      "layout": "small",
      "properties": [
        {
          "name": "scores",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "float"
              }
            ]
          },
          "default": {},
          "title": "Scores",
          "description": "Dictionary mapping labels to their corresponding scores/values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "scores"
      ],
      "is_dynamic": false
    },
    {
      "title": "Combine",
      "description": "Merges two dictionaries, with second dictionary values taking precedence.\n    dictionary, merge, update, +, add, concatenate\n\n    Use cases:\n    - Combine default and custom configurations\n    - Merge partial updates with existing data\n    - Create aggregate data structures",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Combine",
      "layout": "small",
      "properties": [
        {
          "name": "dict_a",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dict A"
        },
        {
          "name": "dict_b",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dict B"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "dict_a",
        "dict_b"
      ],
      "is_dynamic": false
    },
    {
      "title": "Filter",
      "description": "Creates a new dictionary with only specified keys from the input.\n    dictionary, filter, select\n\n    Use cases:\n    - Extract relevant fields from a larger data structure\n    - Implement data access controls\n    - Prepare specific data subsets for processing",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Filter",
      "layout": "default",
      "properties": [
        {
          "name": "dictionary",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dictionary"
        },
        {
          "name": "keys",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Keys"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "dictionary",
        "keys"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get Value",
      "description": "Retrieves a value from a dictionary using a specified key.\n    dictionary, get, value, key\n\n    Use cases:\n    - Access a specific item in a configuration dictionary\n    - Retrieve a value from a parsed JSON object\n    - Extract a particular field from a data structure",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.GetValue",
      "layout": "small",
      "properties": [
        {
          "name": "dictionary",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dictionary"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key"
        },
        {
          "name": "default",
          "type": {
            "type": "any"
          },
          "title": "Default"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "dictionary",
        "key",
        "default"
      ],
      "is_dynamic": false
    },
    {
      "title": "Make Dictionary",
      "description": "Creates a simple dictionary with up to three key-value pairs.\n    dictionary, create, simple\n\n    Use cases:\n    - Create configuration entries\n    - Initialize simple data structures\n    - Build basic key-value mappings",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.MakeDictionary",
      "layout": "small",
      "properties": [],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [],
      "is_dynamic": true
    },
    {
      "title": "Parse JSON",
      "description": "Parses a JSON string into a Python dictionary.\n    json, parse, dictionary\n\n    Use cases:\n    - Process API responses\n    - Load configuration files\n    - Deserialize stored data",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.ParseJSON",
      "layout": "small",
      "properties": [
        {
          "name": "json_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Json String"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "json_string"
      ],
      "is_dynamic": false
    },
    {
      "title": "Reduce Dictionaries",
      "description": "Reduces a list of dictionaries into one dictionary based on a specified key field.\n    dictionary, reduce, aggregate\n\n    Use cases:\n    - Aggregate data by a specific field\n    - Create summary dictionaries from list of records\n    - Combine multiple data points into a single structure",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.ReduceDictionaries",
      "layout": "default",
      "properties": [
        {
          "name": "dictionaries",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Dictionaries",
          "description": "List of dictionaries to be reduced"
        },
        {
          "name": "key_field",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key Field",
          "description": "The field to use as the key in the resulting dictionary"
        },
        {
          "name": "value_field",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Value Field",
          "description": "Optional field to use as the value. If not specified, the entire dictionary (minus the key field) will be used as the value."
        },
        {
          "name": "conflict_resolution",
          "type": {
            "type": "enum",
            "values": [
              "first",
              "last",
              "error"
            ],
            "type_name": "nodetool.nodes.nodetool.dictionary.ConflictResolution"
          },
          "default": "first",
          "title": "Conflict Resolution",
          "description": "How to handle conflicts when the same key appears multiple times"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "any"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "dictionaries",
        "key_field",
        "value_field",
        "conflict_resolution"
      ],
      "is_dynamic": false
    },
    {
      "title": "Remove",
      "description": "Removes a key-value pair from a dictionary.\n    dictionary, remove, delete\n\n    Use cases:\n    - Delete a specific configuration option\n    - Remove sensitive information before processing\n    - Clean up temporary entries in a data structure",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Remove",
      "layout": "small",
      "properties": [
        {
          "name": "dictionary",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dictionary"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "dictionary",
        "key"
      ],
      "is_dynamic": false
    },
    {
      "title": "Update",
      "description": "Updates a dictionary with new key-value pairs.\n    dictionary, add, update\n\n    Use cases:\n    - Extend a configuration with additional settings\n    - Add new entries to a cache or lookup table\n    - Merge user input with existing data",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Update",
      "layout": "small",
      "properties": [
        {
          "name": "dictionary",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Dictionary"
        },
        {
          "name": "new_pairs",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "New Pairs"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "dictionary",
        "new_pairs"
      ],
      "is_dynamic": false
    },
    {
      "title": "Zip",
      "description": "Creates a dictionary from parallel lists of keys and values.\n    dictionary, create, zip\n\n    Use cases:\n    - Convert separate data columns into key-value pairs\n    - Create lookups from parallel data structures\n    - Transform list data into associative arrays",
      "namespace": "nodetool.dictionary",
      "node_type": "nodetool.dictionary.Zip",
      "layout": "small",
      "properties": [
        {
          "name": "keys",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Keys"
        },
        {
          "name": "values",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Values"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "any"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "keys",
        "values"
      ],
      "is_dynamic": false
    },
    {
      "title": "Add Time Delta",
      "description": "Add or subtract time from a datetime.\n    datetime, add, subtract\n\n    Use cases:\n    - Calculate future/past dates\n    - Generate date ranges",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.AddTimeDelta",
      "layout": "default",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Starting datetime"
        },
        {
          "name": "days",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Days",
          "description": "Number of days to add (negative to subtract)",
          "min": -3650.0,
          "max": 3650.0
        },
        {
          "name": "hours",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Hours",
          "description": "Number of hours to add (negative to subtract)",
          "min": -24.0,
          "max": 24.0
        },
        {
          "name": "minutes",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Minutes",
          "description": "Number of minutes to add (negative to subtract)",
          "min": -60.0,
          "max": 60.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "input_datetime",
        "days",
        "hours",
        "minutes"
      ],
      "is_dynamic": false
    },
    {
      "title": "Date Difference",
      "description": "Calculate the difference between two dates.\n    datetime, difference, duration\n\n    Use cases:\n    - Calculate time periods\n    - Measure durations",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.DateDifference",
      "layout": "default",
      "properties": [
        {
          "name": "start_date",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Start Date",
          "description": "Start datetime"
        },
        {
          "name": "end_date",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "End Date",
          "description": "End datetime"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "total_seconds"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "days"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "hours"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "minutes"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "seconds"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "start_date",
        "end_date"
      ],
      "is_dynamic": false
    },
    {
      "title": "Date Range",
      "description": "Generate a list of dates between start and end dates.\n    datetime, range, list\n\n    Use cases:\n    - Generate date sequences\n    - Create date-based iterations",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.DateRange",
      "layout": "default",
      "properties": [
        {
          "name": "start_date",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Start Date",
          "description": "Start date of the range"
        },
        {
          "name": "end_date",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "End Date",
          "description": "End date of the range"
        },
        {
          "name": "step_days",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Step Days",
          "description": "Number of days between each date"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "datetime"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "start_date",
        "end_date",
        "step_days"
      ],
      "is_dynamic": false
    },
    {
      "title": "Date To Datetime",
      "description": "Convert a Date object to a Datetime object.\n    date, datetime, convert",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.DateToDatetime",
      "layout": "default",
      "properties": [
        {
          "name": "input_date",
          "type": {
            "type": "date"
          },
          "default": {},
          "title": "Input Date",
          "description": "Date to convert"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "input_date"
      ],
      "is_dynamic": false
    },
    {
      "title": "Datetime To Date",
      "description": "Convert a Datetime object to a Date object.\n    date, datetime, convert",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.DatetimeToDate",
      "layout": "default",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Datetime to convert"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "date"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "input_datetime"
      ],
      "is_dynamic": false
    },
    {
      "title": "Days Ago",
      "description": "Get datetime from specified days ago.\n    datetime, past, days",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.DaysAgo",
      "layout": "default",
      "properties": [
        {
          "name": "days",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Days",
          "description": "Number of days ago",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "days"
      ],
      "is_dynamic": false
    },
    {
      "title": "Days From Now",
      "description": "Get datetime specified days in the future.\n    datetime, future, days",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.DaysFromNow",
      "layout": "default",
      "properties": [
        {
          "name": "days",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Days",
          "description": "Number of days in the future",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "days"
      ],
      "is_dynamic": false
    },
    {
      "title": "End Of Day",
      "description": "Get the datetime set to the end of the day (23:59:59).\n    datetime, day, end",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.EndOfDay",
      "layout": "default",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Input datetime"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "input_datetime"
      ],
      "is_dynamic": false
    },
    {
      "title": "End Of Month",
      "description": "Get the datetime set to the last day of the month.\n    datetime, month, end",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.EndOfMonth",
      "layout": "default",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Input datetime"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "input_datetime"
      ],
      "is_dynamic": false
    },
    {
      "title": "End Of Week",
      "description": "Get the datetime set to the last day of the week (Sunday by default).\n    datetime, week, end",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.EndOfWeek",
      "layout": "default",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Input datetime"
        },
        {
          "name": "start_monday",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Start Monday",
          "description": "Consider Monday as start of week (False for Sunday)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "input_datetime",
        "start_monday"
      ],
      "is_dynamic": false
    },
    {
      "title": "End Of Year",
      "description": "Get the datetime set to the last day of the year.\n    datetime, year, end",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.EndOfYear",
      "layout": "default",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Input datetime"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "input_datetime"
      ],
      "is_dynamic": false
    },
    {
      "title": "Format Date Time",
      "description": "Convert a datetime object to a formatted string.\n    datetime, format, convert\n\n    Use cases:\n    - Standardize date formats\n    - Prepare dates for different systems",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.FormatDateTime",
      "layout": "default",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Datetime object to format"
        },
        {
          "name": "output_format",
          "type": {
            "type": "enum",
            "values": [
              "%Y-%m-%d",
              "%m/%d/%Y",
              "%d/%m/%Y",
              "%B %d, %Y",
              "%Y%m%d",
              "%Y%m%d_%H%M%S",
              "%Y-%m-%dT%H:%M:%S",
              "%Y-%m-%dT%H:%M:%S%z",
              "%Y-%m-%dT%H:%M:%S%z"
            ],
            "type_name": "nodetool.nodes.nodetool.date.DateFormat"
          },
          "default": "%B %d, %Y",
          "title": "Output Format",
          "description": "Desired output format"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "input_datetime",
        "output_format"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get Quarter",
      "description": "Get the quarter number and start/end dates for a given datetime.\n    datetime, quarter, period\n\n    Use cases:\n    - Financial reporting periods\n    - Quarterly analytics",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.GetQuarter",
      "layout": "default",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Input datetime"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "quarter"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "quarter_start"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "quarter_end"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "input_datetime"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get Weekday",
      "description": "Get the weekday name or number from a datetime.\n    datetime, weekday, name\n\n    Use cases:\n    - Get day names for scheduling\n    - Filter events by weekday",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.GetWeekday",
      "layout": "default",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Input datetime"
        },
        {
          "name": "as_name",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "As Name",
          "description": "Return weekday name instead of number (0-6)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "int"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "input_datetime",
        "as_name"
      ],
      "is_dynamic": false
    },
    {
      "title": "Hours Ago",
      "description": "Get datetime from specified hours ago.\n    datetime, past, hours",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.HoursAgo",
      "layout": "default",
      "properties": [
        {
          "name": "hours",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Hours",
          "description": "Number of hours ago",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "hours"
      ],
      "is_dynamic": false
    },
    {
      "title": "Hours From Now",
      "description": "Get datetime specified hours in the future.\n    datetime, future, hours",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.HoursFromNow",
      "layout": "default",
      "properties": [
        {
          "name": "hours",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Hours",
          "description": "Number of hours in the future",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "hours"
      ],
      "is_dynamic": false
    },
    {
      "title": "Is Date In Range",
      "description": "Check if a date falls within a specified range.\n    datetime, range, check\n\n    Use cases:\n    - Validate date ranges\n    - Filter date-based data",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.IsDateInRange",
      "layout": "default",
      "properties": [
        {
          "name": "check_date",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Check Date",
          "description": "Date to check"
        },
        {
          "name": "start_date",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Start Date",
          "description": "Start of date range"
        },
        {
          "name": "end_date",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "End Date",
          "description": "End of date range"
        },
        {
          "name": "inclusive",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Inclusive",
          "description": "Include start and end dates in range"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "check_date",
        "start_date",
        "end_date",
        "inclusive"
      ],
      "is_dynamic": false
    },
    {
      "title": "Months Ago",
      "description": "Get datetime from specified months ago.\n    datetime, past, months",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.MonthsAgo",
      "layout": "default",
      "properties": [
        {
          "name": "months",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Months",
          "description": "Number of months ago",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "months"
      ],
      "is_dynamic": false
    },
    {
      "title": "Months From Now",
      "description": "Get datetime specified months in the future.\n    datetime, future, months",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.MonthsFromNow",
      "layout": "default",
      "properties": [
        {
          "name": "months",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Months",
          "description": "Number of months in the future",
          "min": 0.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "months"
      ],
      "is_dynamic": false
    },
    {
      "title": "Now",
      "description": "Get the current date and time.\n    datetime, current, now",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.Now",
      "layout": "default",
      "properties": [],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [],
      "is_dynamic": false
    },
    {
      "title": "Parse Date",
      "description": "Parse a date string into components.\n    date, parse, format",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.ParseDate",
      "layout": "default",
      "properties": [
        {
          "name": "date_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Date String",
          "description": "The date string to parse"
        },
        {
          "name": "input_format",
          "type": {
            "type": "enum",
            "values": [
              "%Y-%m-%d",
              "%m/%d/%Y",
              "%d/%m/%Y",
              "%B %d, %Y",
              "%Y%m%d",
              "%Y%m%d_%H%M%S",
              "%Y-%m-%dT%H:%M:%S",
              "%Y-%m-%dT%H:%M:%S%z",
              "%Y-%m-%dT%H:%M:%S%z"
            ],
            "type_name": "nodetool.nodes.nodetool.date.DateFormat"
          },
          "default": "%Y-%m-%d",
          "title": "Input Format",
          "description": "Format of the input date string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "date"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "date_string",
        "input_format"
      ],
      "is_dynamic": false
    },
    {
      "title": "Parse Date Time",
      "description": "Parse a date/time string into components.\n    datetime, parse, format\n\n    Use cases:\n    - Extract date components from strings\n    - Convert between date formats",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.ParseDateTime",
      "layout": "default",
      "properties": [
        {
          "name": "datetime_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Datetime String",
          "description": "The datetime string to parse"
        },
        {
          "name": "input_format",
          "type": {
            "type": "enum",
            "values": [
              "%Y-%m-%d",
              "%m/%d/%Y",
              "%d/%m/%Y",
              "%B %d, %Y",
              "%Y%m%d",
              "%Y%m%d_%H%M%S",
              "%Y-%m-%dT%H:%M:%S",
              "%Y-%m-%dT%H:%M:%S%z",
              "%Y-%m-%dT%H:%M:%S%z"
            ],
            "type_name": "nodetool.nodes.nodetool.date.DateFormat"
          },
          "default": "%Y-%m-%d",
          "title": "Input Format",
          "description": "Format of the input datetime string"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "datetime_string",
        "input_format"
      ],
      "is_dynamic": false
    },
    {
      "title": "Start Of Day",
      "description": "Get the datetime set to the start of the day (00:00:00).\n    datetime, day, start",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.StartOfDay",
      "layout": "default",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Input datetime"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "input_datetime"
      ],
      "is_dynamic": false
    },
    {
      "title": "Start Of Month",
      "description": "Get the datetime set to the first day of the month.\n    datetime, month, start",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.StartOfMonth",
      "layout": "default",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Input datetime"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "input_datetime"
      ],
      "is_dynamic": false
    },
    {
      "title": "Start Of Week",
      "description": "Get the datetime set to the first day of the week (Monday by default).\n    datetime, week, start",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.StartOfWeek",
      "layout": "default",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Input datetime"
        },
        {
          "name": "start_monday",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Start Monday",
          "description": "Consider Monday as start of week (False for Sunday)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "input_datetime",
        "start_monday"
      ],
      "is_dynamic": false
    },
    {
      "title": "Start Of Year",
      "description": "Get the datetime set to the first day of the year.\n    datetime, year, start",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.StartOfYear",
      "layout": "default",
      "properties": [
        {
          "name": "input_datetime",
          "type": {
            "type": "datetime"
          },
          "default": {},
          "title": "Input Datetime",
          "description": "Input datetime"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "datetime"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "input_datetime"
      ],
      "is_dynamic": false
    },
    {
      "title": "Today",
      "description": "Get the current date.\n    date, today, now",
      "namespace": "nodetool.date",
      "node_type": "nodetool.date.Today",
      "layout": "default",
      "properties": [],
      "outputs": [
        {
          "type": {
            "type": "date"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [],
      "is_dynamic": false
    },
    {
      "title": "Base Get JSONPath",
      "description": "Base class for extracting typed data from a JSON object using a path expression.\n    json, path, extract\n\n    Examples for an object {\"a\": {\"b\": {\"c\": 1}}}\n    \"a.b.c\" -> 1\n    \"a.b\" -> {\"c\": 1}\n    \"a\" -> {\"b\": {\"c\": 1}}\n\n    Use cases:\n    - Navigate complex JSON structures\n    - Extract specific values from nested JSON with type safety",
      "namespace": "nodetool.json",
      "node_type": "nodetool.json.BaseGetJSONPath",
      "layout": "default",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "data",
        "path"
      ],
      "is_dynamic": false
    },
    {
      "title": "Filter JSON",
      "description": "Filter JSON array based on a key-value condition.\n    json, filter, array\n\n    Use cases:\n    - Filter arrays of objects\n    - Search JSON data",
      "namespace": "nodetool.json",
      "node_type": "nodetool.json.FilterJSON",
      "layout": "default",
      "properties": [
        {
          "name": "array",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "default": [],
          "title": "Array",
          "description": "Array of JSON objects to filter"
        },
        {
          "name": "key",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Key",
          "description": "Key to filter on"
        },
        {
          "name": "value",
          "type": {
            "type": "any"
          },
          "title": "Value",
          "description": "Value to match"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "array",
        "key",
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get JSONPath Bool",
      "description": "Extract a boolean value from a JSON path\n    json, path, extract, boolean",
      "namespace": "nodetool.json",
      "node_type": "nodetool.json.GetJSONPathBool",
      "layout": "default",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "data",
        "path",
        "default"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get JSONPath Dict",
      "description": "Extract a dictionary value from a JSON path\n    json, path, extract, object",
      "namespace": "nodetool.json",
      "node_type": "nodetool.json.GetJSONPathDict",
      "layout": "default",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "data",
        "path",
        "default"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get JSONPath Float",
      "description": "Extract a float value from a JSON path\n    json, path, extract, number",
      "namespace": "nodetool.json",
      "node_type": "nodetool.json.GetJSONPathFloat",
      "layout": "default",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "data",
        "path",
        "default"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get JSONPath Int",
      "description": "Extract an integer value from a JSON path\n    json, path, extract, number",
      "namespace": "nodetool.json",
      "node_type": "nodetool.json.GetJSONPathInt",
      "layout": "default",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "data",
        "path",
        "default"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get JSONPath List",
      "description": "Extract a list value from a JSON path\n    json, path, extract, array",
      "namespace": "nodetool.json",
      "node_type": "nodetool.json.GetJSONPathList",
      "layout": "default",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "list"
          },
          "default": [],
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "data",
        "path",
        "default"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get JSONPath Str",
      "description": "Extract a string value from a JSON path\n    json, path, extract, string",
      "namespace": "nodetool.json",
      "node_type": "nodetool.json.GetJSONPathStr",
      "layout": "default",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "title": "Data",
          "description": "JSON object to extract from"
        },
        {
          "name": "path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Path",
          "description": "Path to the desired value (dot notation)"
        },
        {
          "name": "default",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Default",
          "description": "Default value to return if path is not found"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "data",
        "path",
        "default"
      ],
      "is_dynamic": false
    },
    {
      "title": "JSON Template",
      "description": "Template JSON strings with variable substitution.\n    json, template, substitute, variables\n\n    Example:\n    template: '{\"name\": \"$user\", \"age\": $age}'\n    values: {\"user\": \"John\", \"age\": 30}\n    result: '{\"name\": \"John\", \"age\": 30}'\n\n    Use cases:\n    - Create dynamic JSON payloads\n    - Generate JSON with variable data\n    - Build API request templates",
      "namespace": "nodetool.json",
      "node_type": "nodetool.json.JSONTemplate",
      "layout": "default",
      "properties": [
        {
          "name": "template",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Template",
          "description": "JSON template string with $variable placeholders"
        },
        {
          "name": "values",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Values",
          "description": "Dictionary of values to substitute into the template"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "template",
        "values"
      ],
      "is_dynamic": false
    },
    {
      "title": "Parse Dict",
      "description": "Parse a JSON string into a Python dictionary.\n    json, parse, decode, dictionary\n\n    Use cases:\n    - Convert JSON API responses to Python dictionaries\n    - Process JSON configuration files\n    - Parse object-like JSON data",
      "namespace": "nodetool.json",
      "node_type": "nodetool.json.ParseDict",
      "layout": "default",
      "properties": [
        {
          "name": "json_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Json String",
          "description": "JSON string to parse into a dictionary"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "json_string"
      ],
      "is_dynamic": false
    },
    {
      "title": "Parse List",
      "description": "Parse a JSON string into a Python list.\n    json, parse, decode, array, list\n\n    Use cases:\n    - Convert JSON array responses to Python lists\n    - Process JSON data collections\n    - Parse array-like JSON data",
      "namespace": "nodetool.json",
      "node_type": "nodetool.json.ParseList",
      "layout": "default",
      "properties": [
        {
          "name": "json_string",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Json String",
          "description": "JSON string to parse into a list"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "json_string"
      ],
      "is_dynamic": false
    },
    {
      "title": "Stringify JSON",
      "description": "Convert a Python object to a JSON string.\n    json, stringify, encode\n\n    Use cases:\n    - Prepare data for API requests\n    - Save data in JSON format",
      "namespace": "nodetool.json",
      "node_type": "nodetool.json.StringifyJSON",
      "layout": "default",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "default": {},
          "title": "Data",
          "description": "Data to convert to JSON"
        },
        {
          "name": "indent",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Indent",
          "description": "Number of spaces for indentation"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "data",
        "indent"
      ],
      "is_dynamic": false
    },
    {
      "title": "Validate JSON",
      "description": "Validate JSON data against a schema.\n    json, validate, schema\n\n    Use cases:\n    - Ensure API payloads match specifications\n    - Validate configuration files",
      "namespace": "nodetool.json",
      "node_type": "nodetool.json.ValidateJSON",
      "layout": "default",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "any"
          },
          "title": "Data",
          "description": "JSON data to validate"
        },
        {
          "name": "schema",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Schema",
          "description": "JSON schema for validation"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "data",
        "schema"
      ],
      "is_dynamic": false
    },
    {
      "title": "Add Audio",
      "description": "Add an audio track to a video, replacing or mixing with existing audio.\n    video, audio, soundtrack, merge\n\n    Use cases:\n    1. Add background music or narration to a silent video\n    2. Replace original audio with a new soundtrack\n    3. Mix new audio with existing video sound",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.AddAudio",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to add audio to."
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio file to add to the video."
        },
        {
          "name": "volume",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Volume",
          "description": "Volume adjustment for the added audio. 1.0 is original volume.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "mix",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Mix",
          "description": "If True, mix new audio with existing. If False, replace existing audio."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video",
        "audio",
        "volume",
        "mix"
      ],
      "is_dynamic": false
    },
    {
      "title": "Add Subtitles",
      "description": "Add subtitles to a video.\n    video, subtitles, text, caption\n\n    Use cases:\n    1. Add translations or closed captions to videos\n    2. Include explanatory text or commentary in educational videos\n    3. Create lyric videos for music content",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.AddSubtitles",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to add subtitles to."
        },
        {
          "name": "chunks",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "audio_chunk"
              }
            ]
          },
          "default": [],
          "title": "Chunks",
          "description": "Audio chunks to add as subtitles."
        },
        {
          "name": "font",
          "type": {
            "type": "enum",
            "values": [
              "DejaVuSans-Bold.ttf",
              "DejaVuSans.ttf",
              "FreeSans.ttf"
            ],
            "type_name": "nodetool.nodes.nodetool.video.SubtitleTextFont"
          },
          "default": "DejaVuSans.ttf",
          "title": "Font",
          "description": "The font to use."
        },
        {
          "name": "align",
          "type": {
            "type": "enum",
            "values": [
              "top",
              "center",
              "bottom"
            ],
            "type_name": "nodetool.nodes.nodetool.video.SubtitleTextAlignment"
          },
          "default": "bottom",
          "title": "Align",
          "description": "Vertical alignment of subtitles."
        },
        {
          "name": "font_size",
          "type": {
            "type": "int"
          },
          "default": 24,
          "title": "Font Size",
          "description": "The font size.",
          "min": 1.0,
          "max": 72.0
        },
        {
          "name": "font_color",
          "type": {
            "type": "color"
          },
          "default": {
            "value": "#FFFFFF"
          },
          "title": "Font Color",
          "description": "The font color."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video",
        "chunks",
        "font",
        "align",
        "font_size",
        "font_color"
      ],
      "is_dynamic": false
    },
    {
      "title": "Blur",
      "description": "Apply a blur effect to a video.\n    video, blur, smooth, soften\n\n    Use cases:\n    1. Create a dreamy or soft focus effect\n    2. Obscure or censor specific areas of the video\n    3. Reduce noise or grain in low-quality footage",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Blur",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to apply blur effect."
        },
        {
          "name": "strength",
          "type": {
            "type": "float"
          },
          "default": 5.0,
          "title": "Strength",
          "description": "The strength of the blur effect. Higher values create a stronger blur.",
          "min": 0.0,
          "max": 20.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video",
        "strength"
      ],
      "is_dynamic": false
    },
    {
      "title": "Chroma Key",
      "description": "Apply chroma key (green screen) effect to a video.\n    video, chroma key, green screen, compositing\n\n    Use cases:\n    1. Remove green or blue background from video footage\n    2. Create special effects by compositing video onto new backgrounds\n    3. Produce professional-looking videos for presentations or marketing",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.ChromaKey",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to apply chroma key effect."
        },
        {
          "name": "key_color",
          "type": {
            "type": "color"
          },
          "default": {
            "value": "#00FF00"
          },
          "title": "Key Color",
          "description": "The color to key out (e.g., '#00FF00' for green)."
        },
        {
          "name": "similarity",
          "type": {
            "type": "float"
          },
          "default": 0.3,
          "title": "Similarity",
          "description": "Similarity threshold for the key color.",
          "min": 0.0,
          "max": 1.0
        },
        {
          "name": "blend",
          "type": {
            "type": "float"
          },
          "default": 0.1,
          "title": "Blend",
          "description": "Blending of the keyed area edges.",
          "min": 0.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video",
        "key_color",
        "similarity",
        "blend"
      ],
      "is_dynamic": false
    },
    {
      "title": "Color Balance",
      "description": "Adjust the color balance of a video.\n    video, color, balance, adjustment\n\n    Use cases:\n    1. Correct color casts in video footage\n    2. Enhance specific color tones for artistic effect\n    3. Normalize color balance across multiple video clips",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.ColorBalance",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to adjust color balance."
        },
        {
          "name": "red_adjust",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Red Adjust",
          "description": "Red channel adjustment factor.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "green_adjust",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Green Adjust",
          "description": "Green channel adjustment factor.",
          "min": 0.0,
          "max": 2.0
        },
        {
          "name": "blue_adjust",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Blue Adjust",
          "description": "Blue channel adjustment factor.",
          "min": 0.0,
          "max": 2.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video",
        "red_adjust",
        "green_adjust",
        "blue_adjust"
      ],
      "is_dynamic": false
    },
    {
      "title": "Concat",
      "description": "Concatenate multiple video files into a single video, including audio when available.\n    video, concat, merge, combine, audio, +",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Concat",
      "layout": "default",
      "properties": [
        {
          "name": "video_a",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video A",
          "description": "The first video to concatenate."
        },
        {
          "name": "video_b",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video B",
          "description": "The second video to concatenate."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video_a",
        "video_b"
      ],
      "is_dynamic": false
    },
    {
      "title": "Create Video",
      "description": "Combine a sequence of frames into a single video file.\n    video, frames, combine, sequence\n\n    Use cases:\n    1. Create time-lapse videos from image sequences\n    2. Compile processed frames back into a video\n    3. Generate animations from individual images",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.CreateVideo",
      "layout": "default",
      "properties": [
        {
          "name": "frames",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "default": [],
          "title": "Frames",
          "description": "The frames to combine into a video."
        },
        {
          "name": "fps",
          "type": {
            "type": "float"
          },
          "default": 30,
          "title": "Fps",
          "description": "The FPS of the output video."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "frames",
        "fps"
      ],
      "is_dynamic": false
    },
    {
      "title": "Denoise",
      "description": "Apply noise reduction to a video.\n    video, denoise, clean, enhance\n\n    Use cases:\n    1. Improve video quality by reducing unwanted noise\n    2. Enhance low-light footage\n    3. Prepare video for further processing or compression",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Denoise",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to denoise."
        },
        {
          "name": "strength",
          "type": {
            "type": "float"
          },
          "default": 5.0,
          "title": "Strength",
          "description": "Strength of the denoising effect. Higher values mean more denoising.",
          "min": 0.0,
          "max": 20.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video",
        "strength"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Audio",
      "description": "Separate audio from a video file.\n    video, audio, extract, separate",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.ExtractAudio",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to separate."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Frames",
      "description": "Extract frames from a video file using OpenCV.\n    video, frames, extract, sequence\n\n    Use cases:\n    1. Generate image sequences for further processing\n    2. Extract specific frame ranges from a video\n    3. Create thumbnails or previews from video content",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.ExtractFrames",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to extract frames from."
        },
        {
          "name": "start",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start",
          "description": "The frame to start extracting from."
        },
        {
          "name": "end",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End",
          "description": "The frame to stop extracting from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video",
        "start",
        "end"
      ],
      "is_dynamic": false
    },
    {
      "title": "Fps",
      "description": "Get the frames per second (FPS) of a video file.\n    video, analysis, frames, fps\n\n    Use cases:\n    1. Analyze video properties for quality assessment\n    2. Determine appropriate playback speed for video editing\n    3. Ensure compatibility with target display systems",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Fps",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to analyze for FPS."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video"
      ],
      "is_dynamic": false
    },
    {
      "title": "Overlay",
      "description": "Overlay one video on top of another, including audio overlay when available.\n    video, overlay, composite, picture-in-picture, audio",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Overlay",
      "layout": "default",
      "properties": [
        {
          "name": "main_video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Main Video",
          "description": "The main (background) video."
        },
        {
          "name": "overlay_video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Overlay Video",
          "description": "The video to overlay on top."
        },
        {
          "name": "x",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "X",
          "description": "X-coordinate for overlay placement."
        },
        {
          "name": "y",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Y",
          "description": "Y-coordinate for overlay placement."
        },
        {
          "name": "scale",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Scale",
          "description": "Scale factor for the overlay video."
        },
        {
          "name": "overlay_audio_volume",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Overlay Audio Volume",
          "description": "Volume of the overlay audio relative to the main audio.",
          "min": 0.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "main_video",
        "overlay_video",
        "x",
        "y",
        "scale",
        "overlay_audio_volume"
      ],
      "is_dynamic": false
    },
    {
      "title": "Resize",
      "description": "Resize a video to a specific width and height.\n    video, resize, scale, dimensions\n\n    Use cases:\n    1. Adjust video resolution for different display requirements\n    2. Reduce file size by downscaling video\n    3. Prepare videos for specific platforms with size constraints",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Resize",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to resize."
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Width",
          "description": "The target width. Use -1 to maintain aspect ratio."
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "Height",
          "description": "The target height. Use -1 to maintain aspect ratio."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video",
        "width",
        "height"
      ],
      "is_dynamic": false
    },
    {
      "title": "Reverse",
      "description": "Reverse the playback of a video.\n    video, reverse, backwards, effect\n\n    Use cases:\n    1. Create artistic effects by playing video in reverse\n    2. Analyze motion or events in reverse order\n    3. Generate unique transitions or intros for video projects",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Reverse",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to reverse."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video"
      ],
      "is_dynamic": false
    },
    {
      "title": "Rotate",
      "description": "Rotate a video by a specified angle.\n    video, rotate, orientation, transform\n\n    Use cases:\n    1. Correct orientation of videos taken with a rotated camera\n    2. Create artistic effects by rotating video content\n    3. Adjust video for different display orientations",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Rotate",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to rotate."
        },
        {
          "name": "angle",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Angle",
          "description": "The angle of rotation in degrees.",
          "min": -360.0,
          "max": 360.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video",
        "angle"
      ],
      "is_dynamic": false
    },
    {
      "title": "Saturation",
      "description": "Adjust the color saturation of a video.\n    video, saturation, color, enhance\n\n    Use cases:\n    1. Enhance color vibrancy in dull or flat-looking footage\n    2. Create stylistic effects by over-saturating or desaturating video\n    3. Correct oversaturated footage from certain cameras",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Saturation",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to adjust saturation."
        },
        {
          "name": "saturation",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Saturation",
          "description": "Saturation level. 1.0 is original, <1 decreases saturation, >1 increases saturation.",
          "min": 0.0,
          "max": 3.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video",
        "saturation"
      ],
      "is_dynamic": false
    },
    {
      "title": "Save Video",
      "description": "Save a video to a file.\n    video, save, file, output\n\n    Use cases:\n    1. Export processed video to a specific folder\n    2. Save video with a custom name\n    3. Create a copy of a video in a different location",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.SaveVideo",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The video to save."
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {},
          "title": "Folder",
          "description": "Name of the output folder."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d-%H-%M-%S.mp4",
          "title": "Name",
          "description": "\n        Name of the output video.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video",
        "folder",
        "name"
      ],
      "is_dynamic": false
    },
    {
      "title": "Set Speed",
      "description": "Adjust the playback speed of a video.\n    video, speed, tempo, time\n\n    Use cases:\n    1. Create slow-motion effects by decreasing video speed\n    2. Generate time-lapse videos by increasing playback speed\n    3. Synchronize video duration with audio or other timing requirements",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.SetSpeed",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to adjust speed."
        },
        {
          "name": "speed_factor",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Speed Factor",
          "description": "The speed adjustment factor. Values > 1 speed up, < 1 slow down."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video",
        "speed_factor"
      ],
      "is_dynamic": false
    },
    {
      "title": "Sharpness",
      "description": "Adjust the sharpness of a video.\n    video, sharpen, enhance, detail\n\n    Use cases:\n    1. Enhance detail in slightly out-of-focus footage\n    2. Correct softness introduced by video compression\n    3. Create stylistic effects by over-sharpening",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Sharpness",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to sharpen."
        },
        {
          "name": "luma_amount",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Luma Amount",
          "description": "Amount of sharpening to apply to luma (brightness) channel.",
          "min": 0.0,
          "max": 3.0
        },
        {
          "name": "chroma_amount",
          "type": {
            "type": "float"
          },
          "default": 0.5,
          "title": "Chroma Amount",
          "description": "Amount of sharpening to apply to chroma (color) channels.",
          "min": 0.0,
          "max": 3.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video",
        "luma_amount",
        "chroma_amount"
      ],
      "is_dynamic": false
    },
    {
      "title": "Stabilize",
      "description": "Apply video stabilization to reduce camera shake and jitter.\n    video, stabilize, smooth, shake-reduction\n\n    Use cases:\n    1. Improve quality of handheld or action camera footage\n    2. Smooth out panning and tracking shots\n    3. Enhance viewer experience by reducing motion sickness",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Stabilize",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to stabilize."
        },
        {
          "name": "smoothing",
          "type": {
            "type": "float"
          },
          "default": 10.0,
          "title": "Smoothing",
          "description": "Smoothing strength. Higher values result in smoother but potentially more cropped video.",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "crop_black",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Crop Black",
          "description": "Whether to crop black borders that may appear after stabilization."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video",
        "smoothing",
        "crop_black"
      ],
      "is_dynamic": false
    },
    {
      "title": "Transition",
      "description": "Create a transition effect between two videos, including audio transition when available.\n    video, transition, effect, merge, audio\n\n    Use cases:\n    1. Create smooth transitions between video clips in a montage\n    2. Add professional-looking effects to video projects\n    3. Blend scenes together for creative storytelling\n    4. Smoothly transition between audio tracks of different video clips",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Transition",
      "layout": "default",
      "properties": [
        {
          "name": "video_a",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video A",
          "description": "The first video in the transition."
        },
        {
          "name": "video_b",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video B",
          "description": "The second video in the transition."
        },
        {
          "name": "transition_type",
          "type": {
            "type": "enum",
            "values": [
              "fade",
              "wipeleft",
              "wiperight",
              "wipeup",
              "wipedown",
              "slideleft",
              "slideright",
              "slideup",
              "slidedown",
              "circlecrop",
              "rectcrop",
              "distance",
              "fadeblack",
              "fadewhite",
              "radial",
              "smoothleft",
              "smoothright",
              "smoothup",
              "smoothdown",
              "circleopen",
              "circleclose",
              "vertopen",
              "vertclose",
              "horzopen",
              "horzclose",
              "dissolve",
              "pixelize",
              "diagtl",
              "diagtr",
              "diagbl",
              "diagbr",
              "hlslice",
              "hrslice",
              "vuslice",
              "vdslice",
              "hblur",
              "fadegrays",
              "wipetl",
              "wipetr",
              "wipebl",
              "wipebr",
              "squeezeh",
              "squeezev",
              "zoomin",
              "fadefast",
              "fadeslow",
              "hlwind",
              "hrwind",
              "vuwind",
              "vdwind",
              "coverleft",
              "coverright",
              "coverup",
              "coverdown",
              "revealleft",
              "revealright",
              "revealup",
              "revealdown"
            ],
            "type_name": "nodetool.nodes.nodetool.video.TransitionType"
          },
          "default": "fade",
          "title": "Transition Type",
          "description": "Type of transition effect"
        },
        {
          "name": "duration",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Duration",
          "description": "Duration of the transition effect in seconds.",
          "min": 0.1,
          "max": 5.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video_a",
        "video_b",
        "transition_type",
        "duration"
      ],
      "is_dynamic": false
    },
    {
      "title": "Trim",
      "description": "Trim a video to a specific start and end time.\n    video, trim, cut, segment\n\n    Use cases:\n    1. Extract specific segments from a longer video\n    2. Remove unwanted parts from the beginning or end of a video\n    3. Create shorter clips from a full-length video",
      "namespace": "nodetool.video",
      "node_type": "nodetool.video.Trim",
      "layout": "default",
      "properties": [
        {
          "name": "video",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Video",
          "description": "The input video to trim."
        },
        {
          "name": "start_time",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Start Time",
          "description": "The start time in seconds for the trimmed video."
        },
        {
          "name": "end_time",
          "type": {
            "type": "float"
          },
          "default": -1.0,
          "title": "End Time",
          "description": "The end time in seconds for the trimmed video. Use -1 for the end of the video."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "video",
        "start_time",
        "end_time"
      ],
      "is_dynamic": false
    },
    {
      "title": "Batch To List",
      "description": "Convert an image batch to a list of image references.\n    batch, list, images, processing\n\n    Use cases:\n    - Convert comfy batch outputs to list format",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.BatchToList",
      "layout": "default",
      "properties": [
        {
          "name": "batch",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Batch",
          "description": "The batch of images to convert."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "batch"
      ],
      "is_dynamic": false
    },
    {
      "title": "Crop",
      "description": "Crop an image to specified coordinates.\n    image, crop\n\n    - Remove unwanted borders from images\n    - Focus on particular subjects within an image\n    - Simplify images by removing distractions",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Crop",
      "layout": "default",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to crop."
        },
        {
          "name": "left",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Left",
          "description": "The left coordinate.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "top",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Top",
          "description": "The top coordinate.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "right",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Right",
          "description": "The right coordinate.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "bottom",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Bottom",
          "description": "The bottom coordinate.",
          "min": 0.0,
          "max": 4096.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "image",
        "left",
        "top",
        "right",
        "bottom"
      ],
      "is_dynamic": false
    },
    {
      "title": "Fit",
      "description": "Resize an image to fit within specified dimensions while preserving aspect ratio.\n    image, resize, fit\n\n    - Resize images for online publishing requirements\n    - Preprocess images to uniform sizes for machine learning\n    - Control image display sizes for web development",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Fit",
      "layout": "default",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to fit."
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Width",
          "description": "Width to fit to.",
          "min": 1.0,
          "max": 4096.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Height",
          "description": "Height to fit to.",
          "min": 1.0,
          "max": 4096.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "image",
        "width",
        "height"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get Metadata",
      "description": "Get metadata about the input image.\n    metadata, properties, analysis, information\n\n    Use cases:\n    - Use width and height for layout calculations\n    - Analyze image properties for processing decisions\n    - Gather information for image cataloging or organization",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.GetMetadata",
      "layout": "default",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The input image."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "format"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "mode"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "width"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "height"
        },
        {
          "type": {
            "type": "int"
          },
          "name": "channels"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "image"
      ],
      "is_dynamic": false
    },
    {
      "title": "Paste",
      "description": "Paste one image onto another at specified coordinates.\n    paste, composite, positioning, overlay\n\n    Use cases:\n    - Add watermarks or logos to images\n    - Combine multiple image elements\n    - Create collages or montages",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Paste",
      "layout": "default",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to paste into."
        },
        {
          "name": "paste",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Paste",
          "description": "The image to paste."
        },
        {
          "name": "left",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Left",
          "description": "The left coordinate.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "top",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Top",
          "description": "The top coordinate.",
          "min": 0.0,
          "max": 4096.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "image",
        "paste",
        "left",
        "top"
      ],
      "is_dynamic": false
    },
    {
      "title": "Resize",
      "description": "Change image dimensions to specified width and height.\n    image, resize\n\n    - Preprocess images for machine learning model inputs\n    - Optimize images for faster web page loading\n    - Create uniform image sizes for layouts",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Resize",
      "layout": "default",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to resize."
        },
        {
          "name": "width",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Width",
          "description": "The target width.",
          "min": 0.0,
          "max": 4096.0
        },
        {
          "name": "height",
          "type": {
            "type": "int"
          },
          "default": 512,
          "title": "Height",
          "description": "The target height.",
          "min": 0.0,
          "max": 4096.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "image",
        "width",
        "height"
      ],
      "is_dynamic": false
    },
    {
      "title": "Save Image",
      "description": "Save an image to specified folder with customizable name format.\n    save, image, folder, naming\n\n    Use cases:\n    - Save generated images with timestamps\n    - Organize outputs into specific folders\n    - Create backups of processed images",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.SaveImage",
      "layout": "default",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to save."
        },
        {
          "name": "folder",
          "type": {
            "type": "folder"
          },
          "default": {},
          "title": "Folder",
          "description": "The folder to save the image in."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "%Y-%m-%d_%H-%M-%S.png",
          "title": "Name",
          "description": "\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        "
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "image",
        "folder",
        "name"
      ],
      "is_dynamic": false
    },
    {
      "title": "Scale",
      "description": "Enlarge or shrink an image by a scale factor.\n    image, resize, scale\n\n    - Adjust image dimensions for display galleries\n    - Standardize image sizes for machine learning datasets\n    - Create thumbnail versions of images",
      "namespace": "nodetool.image",
      "node_type": "nodetool.image.Scale",
      "layout": "default",
      "properties": [
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to scale."
        },
        {
          "name": "scale",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Scale",
          "description": "The scale factor.",
          "min": 0.0,
          "max": 10.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "image",
        "scale"
      ],
      "is_dynamic": false
    },
    {
      "title": "Array Output",
      "description": "Output node for generic array data.\n    array, numerical\n\n    Use cases:\n    - Outputting results from machine learning models\n    - Representing complex numerical data structures",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.ArrayOutput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "np_array"
          },
          "default": {},
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Audio Output",
      "description": "Output node for audio content references.\n    audio, sound, media\n\n    Use cases:\n    - Displaying processed or generated audio\n    - Passing audio data between workflow nodes\n    - Returning results of audio analysis",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.AudioOutput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Boolean Output",
      "description": "Output node for a single boolean value.\n    boolean, true, false, flag, condition, flow-control, branch, else, true, false, switch, toggle\n\n    Use cases:\n    - Returning binary results (yes/no, true/false)\n    - Controlling conditional logic in workflows\n    - Indicating success/failure of operations",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.BooleanOutput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bool"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Dataframe Output",
      "description": "Output node for structured data references.\n    dataframe, table, structured\n\n    Use cases:\n    - Outputting tabular data results\n    - Passing structured data between analysis steps\n    - Displaying data in table format",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.DataframeOutput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "dataframe"
          },
          "default": {},
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Dictionary Output",
      "description": "Output node for key-value pair data.\n    dictionary, key-value, mapping\n\n    Use cases:\n    - Returning multiple named values\n    - Passing complex data structures between nodes\n    - Organizing heterogeneous output data",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.DictionaryOutput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "default": {},
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Document Output",
      "description": "Output node for document content references.\n    document, pdf, file\n\n    Use cases:\n    - Displaying processed or generated documents\n    - Passing document data between workflow nodes\n    - Returning results of document analysis",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.DocumentOutput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Float Output",
      "description": "Output node for a single float value.\n    float, decimal, number\n\n    Use cases:\n    - Returning decimal results (e.g. percentages, ratios)\n    - Passing floating-point parameters between nodes\n    - Displaying numeric metrics with decimal precision",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.FloatOutput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Group Output",
      "description": "Generic output node for grouped data from any node.\n    group, composite, multi-output\n\n    Use cases:\n    - Aggregating multiple outputs from a single node\n    - Passing varied data types as a single unit\n    - Organizing related outputs in workflows",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.GroupOutput",
      "layout": "default",
      "properties": [
        {
          "name": "input",
          "type": {
            "type": "any"
          },
          "title": "Input"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "input"
      ],
      "is_dynamic": false
    },
    {
      "title": "Image List Output",
      "description": "Output node for a list of image references.\n    images, list, gallery\n\n    Use cases:\n    - Displaying multiple images in a grid\n    - Returning image search results",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.ImageListOutput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "default": [],
          "title": "Value",
          "description": "The images to display."
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Image Output",
      "description": "Output node for a single image reference.\n    image, picture, visual\n\n    Use cases:\n    - Displaying a single processed or generated image\n    - Passing image data between workflow nodes\n    - Returning image analysis results",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.ImageOutput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Integer Output",
      "description": "Output node for a single integer value.\n    integer, number, count\n\n    Use cases:\n    - Returning numeric results (e.g. counts, indices)\n    - Passing integer parameters between nodes\n    - Displaying numeric metrics",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.IntegerOutput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "List Output",
      "description": "Output node for a list of arbitrary values.\n    list, output, any\n\n    Use cases:\n    - Returning multiple results from a workflow\n    - Aggregating outputs from multiple nodes",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.ListOutput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "default": [],
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "any"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Model Output",
      "description": "Output node for machine learning model references.\n    model, ml, ai\n\n    Use cases:\n    - Passing trained models between workflow steps\n    - Outputting newly created or fine-tuned models\n    - Referencing models for later use in the workflow",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.ModelOutput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "model_ref"
          },
          "default": {},
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "model_ref"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "String Output",
      "description": "Output node for a single string value.\n    string, text, output\n\n    Use cases:\n    - Returning text results or messages\n    - Passing string parameters between nodes\n    - Displaying short text outputs",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.StringOutput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Text Output",
      "description": "Output node for structured text content.\n    text, content, document\n\n    Use cases:\n    - Returning longer text content or documents\n    - Passing formatted text between processing steps\n    - Displaying rich text output",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.TextOutput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "text"
          },
          "default": {},
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "text"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Video Output",
      "description": "Output node for video content references.\n    video, media, clip\n\n    Use cases:\n    - Displaying processed or generated video content\n    - Passing video data between workflow steps\n    - Returning results of video analysis",
      "namespace": "nodetool.output",
      "node_type": "nodetool.output.VideoOutput",
      "layout": "default",
      "properties": [
        {
          "name": "value",
          "type": {
            "type": "video"
          },
          "default": {},
          "title": "Value"
        },
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The parameter name for the workflow."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "video"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "value"
      ],
      "is_dynamic": false
    },
    {
      "title": "Image Generation",
      "description": "Generate an image using Google's Imagen model via the Gemini API.\n    google, image generation, ai, imagen\n\n    Use cases:\n    - Create images from text descriptions\n    - Generate assets for creative projects\n    - Explore AI-powered image synthesis",
      "namespace": "google.image_generation",
      "node_type": "google.image_generation.ImageGeneration",
      "layout": "default",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the image to generate."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "prompt"
      ],
      "is_dynamic": false
    },
    {
      "title": "Embedding",
      "description": "Generate vector representations of text for semantic analysis.\n    embeddings, similarity, search, clustering, classification\n\n    Uses OpenAI's embedding models to create dense vector representations of text.\n    These vectors capture semantic meaning, enabling:\n    - Semantic search\n    - Text clustering\n    - Document classification\n    - Recommendation systems\n    - Anomaly detection\n    - Measuring text similarity and diversity",
      "namespace": "openai.text",
      "node_type": "openai.text.Embedding",
      "layout": "default",
      "properties": [
        {
          "name": "input",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Input"
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "text-embedding-3-large",
              "text-embedding-3-small"
            ],
            "type_name": "nodetool.nodes.openai.text.EmbeddingModel"
          },
          "default": "text-embedding-3-small",
          "title": "Model"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Chunk Size"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "np_array"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "input",
        "model",
        "chunk_size"
      ],
      "is_dynamic": false
    },
    {
      "title": "Web Search",
      "description": "\ud83d\udd0d OpenAI Web Search - Searches the web using OpenAI's web search capabilities.\n\n    This node uses an OpenAI model equipped with web search functionality\n    (like gpt-4o with search preview) to answer queries based on current web information.\n    Requires an OpenAI API key.",
      "namespace": "openai.text",
      "node_type": "openai.text.WebSearch",
      "layout": "default",
      "properties": [
        {
          "name": "query",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Query",
          "description": "The search query to execute."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "query"
      ],
      "is_dynamic": false
    },
    {
      "title": "Text To Speech",
      "description": "Converts text to speech using OpenAI TTS models.\n    audio, tts, text-to-speech, voice, synthesis\n\n    Use cases:\n    - Generate spoken content for videos or podcasts\n    - Create voice-overs for presentations\n    - Assist visually impaired users with text reading\n    - Produce audio versions of written content",
      "namespace": "openai.audio",
      "node_type": "openai.audio.TextToSpeech",
      "layout": "default",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "tts-1",
              "tts-1-hd",
              "gpt-4o-mini-tts"
            ],
            "type_name": "nodetool.nodes.openai.audio.TtsModel"
          },
          "default": "tts-1",
          "title": "Model"
        },
        {
          "name": "voice",
          "type": {
            "type": "enum",
            "values": [
              "alloy",
              "ash",
              "ballad",
              "coral",
              "echo",
              "fable",
              "onyx",
              "nova",
              "sage",
              "shimmer",
              "verse"
            ],
            "type_name": "nodetool.nodes.openai.audio.Voice"
          },
          "default": "alloy",
          "title": "Voice"
        },
        {
          "name": "input",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Input"
        },
        {
          "name": "speed",
          "type": {
            "type": "float"
          },
          "default": 1.0,
          "title": "Speed",
          "min": 0.25,
          "max": 4.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "audio"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "input",
        "model",
        "voice"
      ],
      "is_dynamic": false
    },
    {
      "title": "Transcribe",
      "description": "Converts speech to text using OpenAI's speech-to-text API.\n    audio, transcription, speech-to-text, stt, whisper\n\n    Use cases:\n    - Generate accurate transcriptions of audio content\n    - Create searchable text from audio recordings\n    - Support multiple languages for transcription\n    - Enable automated subtitling and captioning",
      "namespace": "openai.audio",
      "node_type": "openai.audio.Transcribe",
      "layout": "default",
      "properties": [
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "whisper-1",
              "gpt-4o-transcribe",
              "gpt-4o-mini-transcribe"
            ],
            "type_name": "nodetool.nodes.openai.audio.TranscriptionModel"
          },
          "default": "whisper-1",
          "title": "Model",
          "description": "The model to use for transcription."
        },
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio file to transcribe (max 25 MB)."
        },
        {
          "name": "language",
          "type": {
            "type": "enum",
            "values": [
              "auto_detect",
              "spanish",
              "italian",
              "korean",
              "portuguese",
              "english",
              "japanese",
              "german",
              "russian",
              "dutch",
              "polish",
              "catalan",
              "french",
              "indonesian",
              "ukrainian",
              "turkish",
              "malay",
              "swedish",
              "mandarin",
              "finnish",
              "norwegian",
              "romanian",
              "thai",
              "vietnamese",
              "slovak",
              "arabic",
              "czech",
              "croatian",
              "greek",
              "serbian",
              "danish",
              "bulgarian",
              "hungarian",
              "filipino",
              "bosnian",
              "galician",
              "macedonian",
              "hindi",
              "estonian",
              "slovenian",
              "tamil",
              "latvian",
              "azerbaijani",
              "urdu",
              "lithuanian",
              "hebrew",
              "welsh",
              "persian",
              "icelandic",
              "kazakh",
              "afrikaans",
              "kannada",
              "marathi",
              "swahili",
              "telugu",
              "maori",
              "nepali",
              "armenian",
              "belarusian",
              "gujarati",
              "punjabi",
              "bengali"
            ],
            "type_name": "nodetool.nodes.openai.audio.Language"
          },
          "default": "auto_detect",
          "title": "Language",
          "description": "The language of the input audio"
        },
        {
          "name": "timestamps",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Timestamps",
          "description": "Whether to return timestamps for the generated text."
        },
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "Optional text to guide the model's style or continue a previous audio segment."
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 0,
          "title": "Temperature",
          "description": "The sampling temperature between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.",
          "min": 0.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "text"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "audio_chunk"
              }
            ]
          },
          "name": "words"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "audio_chunk"
              }
            ]
          },
          "name": "segments"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "audio",
        "language",
        "timestamps"
      ],
      "is_dynamic": false
    },
    {
      "title": "Translate",
      "description": "Translates speech in audio to English text.\n    audio, translation, speech-to-text, localization\n\n    Use cases:\n    - Translate foreign language audio content to English\n    - Create English transcripts of multilingual recordings\n    - Assist non-English speakers in understanding audio content\n    - Enable cross-language communication in audio formats",
      "namespace": "openai.audio",
      "node_type": "openai.audio.Translate",
      "layout": "default",
      "properties": [
        {
          "name": "audio",
          "type": {
            "type": "audio"
          },
          "default": {},
          "title": "Audio",
          "description": "The audio file to translate."
        },
        {
          "name": "temperature",
          "type": {
            "type": "float"
          },
          "default": 0.0,
          "title": "Temperature",
          "description": "The temperature to use for the translation."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "audio",
        "temperature"
      ],
      "is_dynamic": false
    },
    {
      "title": "Create Image",
      "description": "Generates images from textual descriptions.\n    image, t2i, tti, text-to-image, create, generate, picture, photo, art, drawing, illustration\n\n    Use cases:\n    1. Create custom illustrations for articles or presentations\n    2. Generate concept art for creative projects\n    3. Produce visual aids for educational content\n    4. Design unique marketing visuals or product mockups\n    5. Explore artistic ideas and styles programmatically",
      "namespace": "openai.image",
      "node_type": "openai.image.CreateImage",
      "layout": "default",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The prompt to use."
        },
        {
          "name": "model",
          "type": {
            "type": "enum",
            "values": [
              "gpt-image-1"
            ],
            "type_name": "nodetool.nodes.openai.image.Model"
          },
          "default": "gpt-image-1",
          "title": "Model",
          "description": "The model to use for image generation."
        },
        {
          "name": "size",
          "type": {
            "type": "enum",
            "values": [
              "1024x1024",
              "1536x1024",
              "1024x1536"
            ],
            "type_name": "nodetool.nodes.openai.image.Size"
          },
          "default": "1024x1024",
          "title": "Size",
          "description": "The size of the image to generate."
        },
        {
          "name": "background",
          "type": {
            "type": "enum",
            "values": [
              "transparent",
              "opaque",
              "auto"
            ],
            "type_name": "nodetool.nodes.openai.image.Background"
          },
          "default": "auto",
          "title": "Background",
          "description": "The background of the image to generate."
        },
        {
          "name": "quality",
          "type": {
            "type": "enum",
            "values": [
              "high",
              "medium",
              "low"
            ],
            "type_name": "nodetool.nodes.openai.image.Quality"
          },
          "default": "high",
          "title": "Quality",
          "description": "The quality of the image to generate."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "prompt",
        "model",
        "size",
        "background",
        "quality"
      ],
      "is_dynamic": false
    }
  ]
}