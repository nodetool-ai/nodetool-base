{
  "name": "nodetool-base",
  "description": "Nodetool Base nodes",
  "version": "0.6.0",
  "authors": [
    "Matthias Georgi <matti.georgi@gmail.com>"
  ],
  "repo_id": "nodetool-ai/nodetool-base",
  "nodes": [
    {
      "title": "List Scheduled Events",
      "description": "Fetch scheduled events for a Calendly user.",
      "namespace": "calendly.events",
      "node_type": "calendly.events.ListScheduledEvents",
      "layout": "default",
      "properties": [
        {
          "name": "user",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "User",
          "description": "User URI to fetch events for"
        },
        {
          "name": "count",
          "type": {
            "type": "int"
          },
          "default": 20,
          "title": "Count",
          "description": "Number of events to return",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "status",
          "type": {
            "type": "str"
          },
          "default": "active",
          "title": "Status",
          "description": "Event status filter"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "calendly_event"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "user",
        "count",
        "status"
      ],
      "is_dynamic": false
    },
    {
      "title": "Scheduled Event Fields",
      "description": "Extract fields from a CalendlyEvent.",
      "namespace": "calendly.events",
      "node_type": "calendly.events.ScheduledEventFields",
      "layout": "default",
      "properties": [
        {
          "name": "event",
          "type": {
            "type": "calendly_event"
          },
          "default": {},
          "title": "Event",
          "description": "The Calendly event to extract"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "uri"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "name"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "start_time"
        },
        {
          "type": {
            "type": "datetime"
          },
          "name": "end_time"
        },
        {
          "type": {
            "type": "str"
          },
          "name": "location"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "event"
      ],
      "is_dynamic": false
    },
    {
      "title": "Chroma",
      "description": "Base class for Chroma vector database nodes.\n\n    chroma, base, database\n\n    Use cases:\n    - Provide shared helpers for Chroma indexing and queries\n    - Disable caching for subclasses\n    - Convert result IDs into asset references",
      "namespace": "chroma.chroma_node",
      "node_type": "chroma.chroma_node.Chroma",
      "layout": "default",
      "properties": [],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [],
      "is_dynamic": false
    },
    {
      "title": "Collection",
      "description": "Get or create a collection.\n    chroma, embedding, collection, RAG, get, create",
      "namespace": "chroma.collections",
      "node_type": "chroma.collections.Collection",
      "layout": "default",
      "properties": [
        {
          "name": "name",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Name",
          "description": "The name of the collection to create"
        },
        {
          "name": "embedding_model",
          "type": {
            "type": "llama_model"
          },
          "default": {},
          "title": "Embedding Model",
          "description": "The embedding model to use"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "collection"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "name",
        "embedding_model"
      ],
      "is_dynamic": false
    },
    {
      "title": "Count",
      "description": "Count the number of documents in a collection.\n    chroma, embedding, collection, RAG",
      "namespace": "chroma.collections",
      "node_type": "chroma.collections.Count",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to count"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "int"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get Documents",
      "description": "Get documents from a chroma collection.\n    chroma, embedding, collection, RAG, retrieve",
      "namespace": "chroma.collections",
      "node_type": "chroma.collections.GetDocuments",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to get"
        },
        {
          "name": "ids",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Ids",
          "description": "The ids of the documents to get"
        },
        {
          "name": "limit",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Limit",
          "description": "The limit of the documents to get"
        },
        {
          "name": "offset",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Offset",
          "description": "The offset of the documents to get"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "ids",
        "limit",
        "offset"
      ],
      "is_dynamic": false
    },
    {
      "title": "Peek",
      "description": "Peek at the documents in a collection.\n    chroma, embedding, collection, RAG, preview",
      "namespace": "chroma.collections",
      "node_type": "chroma.collections.Peek",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to peek"
        },
        {
          "name": "limit",
          "type": {
            "type": "int"
          },
          "default": 100,
          "title": "Limit",
          "description": "The limit of the documents to peek"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "limit"
      ],
      "is_dynamic": false
    },
    {
      "title": "Index Aggregated Text",
      "description": "Index multiple text chunks at once with aggregated embeddings from Ollama.\n    chroma, embedding, collection, RAG, index, text, chunk, batch, ollama",
      "namespace": "chroma.index",
      "node_type": "chroma.index.IndexAggregatedText",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "document",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document",
          "description": "The document to index"
        },
        {
          "name": "document_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document Id",
          "description": "The document ID to associate with the text"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the text"
        },
        {
          "name": "text_chunks",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "union",
                "type_args": [
                  {
                    "type": "text_chunk"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "default": [],
          "title": "Text Chunks",
          "description": "List of text chunks to index"
        },
        {
          "name": "context_window",
          "type": {
            "type": "int"
          },
          "default": 4096,
          "title": "Context Window",
          "description": "The context window size to use for the model",
          "min": 1.0
        },
        {
          "name": "aggregation",
          "type": {
            "type": "enum",
            "values": [
              "mean",
              "max",
              "min",
              "sum"
            ],
            "type_name": "nodetool.nodes.chroma.index.EmbeddingAggregation"
          },
          "default": "mean",
          "title": "Aggregation",
          "description": "The aggregation method to use for the embeddings."
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "document",
        "document_id",
        "metadata",
        "text_chunks",
        "context_window",
        "aggregation"
      ],
      "is_dynamic": false
    },
    {
      "title": "Index Embedding",
      "description": "Index a list of embeddings.",
      "namespace": "chroma.index",
      "node_type": "chroma.index.IndexEmbedding",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "embedding",
          "type": {
            "type": "np_array"
          },
          "default": {},
          "title": "Embedding",
          "description": "The embedding to index"
        },
        {
          "name": "id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Id",
          "description": "The ID to associate with the embedding"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the embedding"
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "embedding",
        "id",
        "metadata"
      ],
      "is_dynamic": false
    },
    {
      "title": "Index Image",
      "description": "Index a single image asset.\n    chroma, embedding, collection, RAG, index, image",
      "namespace": "chroma.index",
      "node_type": "chroma.index.IndexImage",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "Image asset to index"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the image"
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "image",
        "metadata"
      ],
      "is_dynamic": false
    },
    {
      "title": "Index Images",
      "description": "Index a list of image assets or files.\n    chroma, embedding, collection, RAG, index, image, batch",
      "namespace": "chroma.index",
      "node_type": "chroma.index.IndexImages",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "images",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "default": [],
          "title": "Images",
          "description": "List of image assets to index"
        },
        {
          "name": "upsert",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Upsert",
          "description": "Whether to upsert the images"
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "images",
        "upsert"
      ],
      "is_dynamic": false
    },
    {
      "title": "Index String",
      "description": "Index a string with a Document ID to a collection.\n    chroma, embedding, collection, RAG, index, text, string\n\n    Use cases:\n    - Index documents for a vector search",
      "namespace": "chroma.index",
      "node_type": "chroma.index.IndexString",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text content to index"
        },
        {
          "name": "document_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document Id",
          "description": "Document ID to associate with the text content"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the text"
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "text",
        "document_id",
        "metadata"
      ],
      "is_dynamic": false
    },
    {
      "title": "Index Text Chunk",
      "description": "Index a single text chunk.\n    chroma, embedding, collection, RAG, index, text, chunk",
      "namespace": "chroma.index",
      "node_type": "chroma.index.IndexTextChunk",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "text_chunk",
          "type": {
            "type": "text_chunk"
          },
          "default": {},
          "title": "Text Chunk",
          "description": "Text chunk to index"
        },
        {
          "name": "metadata",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Metadata",
          "description": "The metadata to associate with the text chunk"
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "text_chunk",
        "metadata"
      ],
      "is_dynamic": false
    },
    {
      "title": "Index Text Chunks",
      "description": "Index multiple text chunks at once.\n    chroma, embedding, collection, RAG, index, text, chunk, batch",
      "namespace": "chroma.index",
      "node_type": "chroma.index.IndexTextChunks",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to index"
        },
        {
          "name": "text_chunks",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "text_chunk"
              }
            ]
          },
          "default": [],
          "title": "Text Chunks",
          "description": "List of text chunks to index"
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "text_chunks"
      ],
      "is_dynamic": false
    },
    {
      "title": "Hybrid Search",
      "description": "Hybrid search combining semantic and keyword-based search for better retrieval.\n    Uses reciprocal rank fusion to combine results from both methods.",
      "namespace": "chroma.query",
      "node_type": "chroma.query.HybridSearch",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to query"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to query"
        },
        {
          "name": "n_results",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "N Results",
          "description": "The number of final results to return"
        },
        {
          "name": "k_constant",
          "type": {
            "type": "float"
          },
          "default": 60.0,
          "title": "K Constant",
          "description": "Constant for reciprocal rank fusion (default: 60.0)"
        },
        {
          "name": "min_keyword_length",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "Min Keyword Length",
          "description": "Minimum length for keyword tokens"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "ids"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "metadatas"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "distances"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "scores"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "text",
        "n_results",
        "k_constant",
        "min_keyword_length"
      ],
      "is_dynamic": false
    },
    {
      "title": "Query Image",
      "description": "Query the index for similar images.",
      "namespace": "chroma.query",
      "node_type": "chroma.query.QueryImage",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to query"
        },
        {
          "name": "image",
          "type": {
            "type": "image"
          },
          "default": {},
          "title": "Image",
          "description": "The image to query"
        },
        {
          "name": "n_results",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "N Results",
          "description": "The number of results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "ids"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "metadatas"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "distances"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "image",
        "n_results"
      ],
      "is_dynamic": false
    },
    {
      "title": "Query Text",
      "description": "Query the index for similar text.",
      "namespace": "chroma.query",
      "node_type": "chroma.query.QueryText",
      "layout": "default",
      "properties": [
        {
          "name": "collection",
          "type": {
            "type": "collection"
          },
          "default": {},
          "title": "Collection",
          "description": "The collection to query"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to query"
        },
        {
          "name": "n_results",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "N Results",
          "description": "The number of results to return"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "ids"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "metadatas"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "float"
              }
            ]
          },
          "name": "distances"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "collection",
        "text",
        "n_results"
      ],
      "is_dynamic": false
    },
    {
      "title": "Remove Overlap",
      "description": "Removes overlapping words between consecutive strings in a list.\n    Splits text into words and matches word sequences for more accurate overlap detection.",
      "namespace": "chroma.query",
      "node_type": "chroma.query.RemoveOverlap",
      "layout": "default",
      "properties": [
        {
          "name": "documents",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Documents",
          "description": "List of strings to process for overlap removal"
        },
        {
          "name": "min_overlap_words",
          "type": {
            "type": "int"
          },
          "default": 2,
          "title": "Min Overlap Words",
          "description": "Minimum number of words that must overlap to be considered"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "documents"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "documents",
        "min_overlap_words"
      ],
      "is_dynamic": false
    },
    {
      "title": "Image Generation",
      "description": "Generate an image using Google's Imagen model via the Gemini API.\n    google, image generation, ai, imagen\n\n    Use cases:\n    - Create images from text descriptions\n    - Generate assets for creative projects\n    - Explore AI-powered image synthesis",
      "namespace": "google.image_generation",
      "node_type": "google.image_generation.ImageGeneration",
      "layout": "default",
      "properties": [
        {
          "name": "prompt",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Prompt",
          "description": "The text prompt describing the image to generate."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "image"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "prompt"
      ],
      "is_dynamic": false
    },
    {
      "title": "Base Url",
      "description": "Extract the base URL from a given URL.\n    url parsing, domain extraction, web utilities\n\n    Use cases:\n    - Get domain name from full URLs\n    - Clean up URLs for comparison\n    - Extract root website addresses\n    - Standardize URL formats",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.BaseUrl",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "URL",
          "description": "The URL to extract the base from"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Audio",
      "description": "Extract audio elements from HTML content.\n    extract, audio, src\n\n    Use cases:\n    - Collect audio sources from web pages\n    - Analyze audio usage on websites\n    - Create audio playlists",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractAudio",
      "layout": "default",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract audio from."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "The base URL of the page, used to resolve relative audio URLs."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "audio"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "html",
        "base_url"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Images",
      "description": "Extract images from HTML content.\n    extract, images, src\n\n    Use cases:\n    - Collect images from web pages\n    - Analyze image usage on websites\n    - Create image galleries",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractImages",
      "layout": "default",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract images from."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "The base URL of the page, used to resolve relative image URLs."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "html",
        "base_url"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Links",
      "description": "Extract links from HTML content.\n    extract, links, urls\n\n    Use cases:\n    - Analyze website structure\n    - Discover related content\n    - Build sitemaps",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractLinks",
      "layout": "default",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract links from."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "The base URL of the page, used to determine internal/external links."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "html",
        "base_url"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Metadata",
      "description": "Extract metadata from HTML content.\n    extract, metadata, seo\n\n    Use cases:\n    - Analyze SEO elements\n    - Gather page information\n    - Extract structured data",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractMetadata",
      "layout": "default",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract metadata from."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "metadata"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "html"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Videos",
      "description": "Extract videos from HTML content.\n    extract, videos, src\n\n    Use cases:\n    - Collect video sources from web pages\n    - Analyze video usage on websites\n    - Create video playlists",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.ExtractVideos",
      "layout": "default",
      "properties": [
        {
          "name": "html",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html",
          "description": "The HTML content to extract videos from."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "The base URL of the page, used to resolve relative video URLs."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "video"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "html",
        "base_url"
      ],
      "is_dynamic": false
    },
    {
      "title": "Convert HTML to Text",
      "description": "Converts HTML to plain text by removing tags and decoding entities using BeautifulSoup.\n    html, text, convert\n\n    Use cases:\n    - Cleaning HTML content for text analysis\n    - Extracting readable content from web pages\n    - Preparing HTML data for natural language processing",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.HTMLToText",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "HTML"
        },
        {
          "name": "preserve_linebreaks",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Preserve Line Breaks",
          "description": "Convert block-level elements to newlines"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "preserve_linebreaks"
      ],
      "is_dynamic": false
    },
    {
      "title": "Website Content Extractor",
      "description": "Extract main content from a website, removing navigation, ads, and other non-essential elements.\n    scrape, web scraping, content extraction, text analysis\n\n    Use cases:\n    - Clean web content for further analysis\n    - Extract article text from news websites\n    - Prepare web content for summarization",
      "namespace": "lib.beautifulsoup",
      "node_type": "lib.beautifulsoup.WebsiteContentExtractor",
      "layout": "default",
      "properties": [
        {
          "name": "html_content",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Html Content",
          "description": "The raw HTML content of the website."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "html_content"
      ],
      "is_dynamic": false
    },
    {
      "title": "Get Close Matches",
      "description": "Finds close matches for a word within a list of possibilities.\n    difflib, fuzzy, match\n\n    Use cases:\n    - Suggest alternatives for misspelled words\n    - Map user input to valid options\n    - Provide recommendations based on partial text",
      "namespace": "lib.difflib",
      "node_type": "lib.difflib.GetCloseMatches",
      "layout": "default",
      "properties": [
        {
          "name": "word",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Word",
          "description": "Word to match"
        },
        {
          "name": "possibilities",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Possibilities",
          "description": "List of possible words"
        },
        {
          "name": "n",
          "type": {
            "type": "int"
          },
          "default": 3,
          "title": "N",
          "description": "Maximum number of matches to return",
          "min": 1.0
        },
        {
          "name": "cutoff",
          "type": {
            "type": "float"
          },
          "default": 0.6,
          "title": "Cutoff",
          "description": "Minimum similarity ratio",
          "min": 0.0,
          "max": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "word",
        "possibilities",
        "n",
        "cutoff"
      ],
      "is_dynamic": false
    },
    {
      "title": "Sequence Similarity Ratio",
      "description": "Calculates the similarity ratio between two strings.\n    difflib, similarity, ratio, compare\n\n    Use cases:\n    - Fuzzy string matching\n    - Compare document versions\n    - Evaluate similarity of user input",
      "namespace": "lib.difflib",
      "node_type": "lib.difflib.SimilarityRatio",
      "layout": "default",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "A",
          "description": "First string to compare"
        },
        {
          "name": "b",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "B",
          "description": "Second string to compare"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "float"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "a",
        "b"
      ],
      "is_dynamic": false
    },
    {
      "title": "Unified Diff",
      "description": "Generates a unified diff between two texts.\n    difflib, diff, compare\n\n    Use cases:\n    - Display differences between versions of text files\n    - Highlight changes in user submitted documents\n    - Compare code snippets",
      "namespace": "lib.difflib",
      "node_type": "lib.difflib.UnifiedDiff",
      "layout": "default",
      "properties": [
        {
          "name": "a",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "A",
          "description": "Original text"
        },
        {
          "name": "b",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "B",
          "description": "Modified text"
        },
        {
          "name": "fromfile",
          "type": {
            "type": "str"
          },
          "default": "a",
          "title": "Fromfile",
          "description": "Name of the original file"
        },
        {
          "name": "tofile",
          "type": {
            "type": "str"
          },
          "default": "b",
          "title": "Tofile",
          "description": "Name of the modified file"
        },
        {
          "name": "lineterm",
          "type": {
            "type": "str"
          },
          "default": "\n",
          "title": "Lineterm",
          "description": "Line terminator"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "a",
        "b",
        "fromfile",
        "tofile",
        "lineterm"
      ],
      "is_dynamic": false
    },
    {
      "title": "FTPBase",
      "description": "Base node for FTP operations.\n    ftp, network, transfer\n\n    Use cases:\n    - Provide shared connection parameters\n    - Reuse login logic across FTP nodes\n    - Hide base class from UI",
      "namespace": "lib.ftplib",
      "node_type": "lib.ftplib.FTPBase",
      "layout": "default",
      "properties": [
        {
          "name": "host",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Host",
          "description": "FTP server host"
        },
        {
          "name": "username",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Username",
          "description": "Username for authentication"
        },
        {
          "name": "password",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Password",
          "description": "Password for authentication"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "host",
        "username",
        "password"
      ],
      "is_dynamic": false
    },
    {
      "title": "Download File",
      "description": "Download a file from an FTP server.\n    ftp, download, file\n\n    Use cases:\n    - Retrieve remote files for processing\n    - Backup data from an FTP server\n    - Integrate legacy FTP systems",
      "namespace": "lib.ftplib",
      "node_type": "lib.ftplib.FTPDownloadFile",
      "layout": "default",
      "properties": [
        {
          "name": "host",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Host",
          "description": "FTP server host"
        },
        {
          "name": "username",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Username",
          "description": "Username for authentication"
        },
        {
          "name": "password",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Password",
          "description": "Password for authentication"
        },
        {
          "name": "remote_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Remote Path",
          "description": "Remote file path to download"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "host",
        "username",
        "password",
        "remote_path"
      ],
      "is_dynamic": false
    },
    {
      "title": "List Directory",
      "description": "List files in a directory on an FTP server.\n    ftp, list, directory\n\n    Use cases:\n    - Browse remote directories\n    - Check available files before download\n    - Monitor FTP server contents",
      "namespace": "lib.ftplib",
      "node_type": "lib.ftplib.FTPListDirectory",
      "layout": "default",
      "properties": [
        {
          "name": "host",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Host",
          "description": "FTP server host"
        },
        {
          "name": "username",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Username",
          "description": "Username for authentication"
        },
        {
          "name": "password",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Password",
          "description": "Password for authentication"
        },
        {
          "name": "directory",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Directory",
          "description": "Remote directory to list"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "host",
        "username",
        "password",
        "directory"
      ],
      "is_dynamic": false
    },
    {
      "title": "Upload File",
      "description": "Upload a file to an FTP server.\n    ftp, upload, file\n\n    Use cases:\n    - Transfer files to an FTP server\n    - Automate backups to a remote system\n    - Integrate with legacy FTP workflows",
      "namespace": "lib.ftplib",
      "node_type": "lib.ftplib.FTPUploadFile",
      "layout": "default",
      "properties": [
        {
          "name": "host",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Host",
          "description": "FTP server host"
        },
        {
          "name": "username",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Username",
          "description": "Username for authentication"
        },
        {
          "name": "password",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Password",
          "description": "Password for authentication"
        },
        {
          "name": "remote_path",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Remote Path",
          "description": "Remote file path to upload to"
        },
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Document",
          "description": "Document to upload"
        }
      ],
      "outputs": [],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "host",
        "username",
        "password",
        "remote_path",
        "document"
      ],
      "is_dynamic": false
    },
    {
      "title": "Hash File",
      "description": "Compute the cryptographic hash of a file.\n    hash, hashlib, digest, file\n\n    Use cases:\n    - Verify downloaded files\n    - Detect file changes\n    - Identify duplicates",
      "namespace": "lib.hashlib",
      "node_type": "lib.hashlib.HashFile",
      "layout": "default",
      "properties": [
        {
          "name": "file",
          "type": {
            "type": "file_path"
          },
          "default": {},
          "title": "File",
          "description": "The file to hash"
        },
        {
          "name": "algorithm",
          "type": {
            "type": "str"
          },
          "default": "md5",
          "title": "Algorithm",
          "description": "Hash algorithm name (e.g. md5, sha1, sha256)"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 8192,
          "title": "Chunk Size",
          "description": "Read size for hashing in bytes",
          "min": 1.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "file",
        "algorithm",
        "chunk_size"
      ],
      "is_dynamic": false
    },
    {
      "title": "Hash String",
      "description": "Compute the cryptographic hash of a string using hashlib.\n    hash, hashlib, digest, string\n\n    Use cases:\n    - Generate deterministic identifiers\n    - Verify data integrity\n    - Create fingerprints for caching",
      "namespace": "lib.hashlib",
      "node_type": "lib.hashlib.HashString",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to hash"
        },
        {
          "name": "algorithm",
          "type": {
            "type": "str"
          },
          "default": "md5",
          "title": "Algorithm",
          "description": "Hash algorithm name (e.g. md5, sha1, sha256)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "algorithm"
      ],
      "is_dynamic": false
    },
    {
      "title": "Escape",
      "description": "Escape special characters in text into HTML-safe sequences.\n    html, escape, entities, convert\n\n    Use cases:\n    - Prepare text for inclusion in HTML\n    - Prevent cross-site scripting in user content\n    - Encode strings for web output",
      "namespace": "lib.html",
      "node_type": "lib.html.Escape",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The text to escape"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text"
      ],
      "is_dynamic": false
    },
    {
      "title": "Unescape",
      "description": "Convert HTML entities back to normal text.\n    html, unescape, entities, decode\n\n    Use cases:\n    - Decode HTML-encoded data\n    - Process text scraped from the web\n    - Convert form submissions to plain text",
      "namespace": "lib.html",
      "node_type": "lib.html.Unescape",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "The HTML text to unescape"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text"
      ],
      "is_dynamic": false
    },
    {
      "title": "DELETE Request",
      "description": "Remove a resource from a server using an HTTP DELETE request.\n    http, delete, request, url\n\n    Use cases:\n    - Delete user accounts\n    - Remove API resources\n    - Cancel subscriptions\n    - Clear cache entries",
      "namespace": "lib.http",
      "node_type": "lib.http.DeleteRequest",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url"
      ],
      "is_dynamic": false
    },
    {
      "title": "Download Dataframe",
      "description": "Download data from a URL and return as a dataframe.\n    http, get, request, url, dataframe, csv, json, data\n\n    Use cases:\n    - Download CSV data and convert to dataframe\n    - Fetch JSON data and convert to dataframe\n    - Retrieve tabular data from APIs\n    - Process data files from URLs",
      "namespace": "lib.http",
      "node_type": "lib.http.DownloadDataframe",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "file_format",
          "type": {
            "type": "enum",
            "values": [
              "csv",
              "json",
              "tsv"
            ],
            "type_name": "nodetool.nodes.lib.http.FileFormat"
          },
          "default": "csv",
          "title": "File Format",
          "description": "The format of the data file (csv, json, tsv)."
        },
        {
          "name": "columns",
          "type": {
            "type": "record_type"
          },
          "default": {},
          "title": "Columns",
          "description": "The columns of the dataframe."
        },
        {
          "name": "encoding",
          "type": {
            "type": "str"
          },
          "default": "utf-8",
          "title": "Encoding",
          "description": "The encoding of the text file."
        },
        {
          "name": "delimiter",
          "type": {
            "type": "str"
          },
          "default": ",",
          "title": "Delimiter",
          "description": "The delimiter for CSV/TSV files."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url",
        "columns",
        "file_format"
      ],
      "is_dynamic": false
    },
    {
      "title": "Download Files",
      "description": "Download files from a list of URLs into a local folder.\n    download, files, urls, batch\n\n    Use cases:\n    - Batch download files from multiple URLs\n    - Create local copies of remote resources\n    - Archive web content\n    - Download datasets",
      "namespace": "lib.http",
      "node_type": "lib.http.DownloadFiles",
      "layout": "default",
      "properties": [
        {
          "name": "urls",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Urls",
          "description": "List of URLs to download."
        },
        {
          "name": "output_folder",
          "type": {
            "type": "file_path"
          },
          "default": {
            "path": "downloads"
          },
          "title": "Output Folder",
          "description": "Local folder path where files will be saved."
        },
        {
          "name": "max_concurrent_downloads",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "Max Concurrent Downloads",
          "description": "Maximum number of concurrent downloads."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "success"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "failed"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "urls",
        "output_folder",
        "max_concurrent_downloads"
      ],
      "is_dynamic": false
    },
    {
      "title": "Fetch Page",
      "description": "Fetch a web page using Selenium and return its content.\n    selenium, fetch, webpage, http\n\n    Use cases:\n    - Retrieve content from dynamic websites\n    - Capture JavaScript-rendered content\n    - Interact with web applications",
      "namespace": "lib.http",
      "node_type": "lib.http.FetchPage",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to fetch the page from."
        },
        {
          "name": "wait_time",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Wait Time",
          "description": "Maximum time to wait for page load (in seconds)."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "html"
        },
        {
          "type": {
            "type": "bool"
          },
          "name": "success"
        },
        {
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "none"
              }
            ]
          },
          "name": "error_message"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url",
        "wait_time"
      ],
      "is_dynamic": false
    },
    {
      "title": "Filter Valid URLs",
      "description": "Filter a list of URLs by checking their validity using HEAD requests.\n    url validation, http, head request\n\n    Use cases:\n    - Clean URL lists by removing broken links\n    - Verify resource availability\n    - Validate website URLs before processing",
      "namespace": "lib.http",
      "node_type": "lib.http.FilterValidURLs",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "urls",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Urls",
          "description": "List of URLs to validate."
        },
        {
          "name": "max_concurrent_requests",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Max Concurrent Requests",
          "description": "Maximum number of concurrent HEAD requests."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url"
      ],
      "is_dynamic": false
    },
    {
      "title": "GET Request",
      "description": "Perform an HTTP GET request to retrieve data from a specified URL.\n    http, get, request, url\n\n    Use cases:\n    - Fetch web page content\n    - Retrieve API data\n    - Download files\n    - Check website availability",
      "namespace": "lib.http",
      "node_type": "lib.http.GetRequest",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url"
      ],
      "is_dynamic": false
    },
    {
      "title": "GET Binary",
      "description": "Perform an HTTP GET request and return raw binary data.\n    http, get, request, url, binary, download\n\n    Use cases:\n    - Download binary files\n    - Fetch images or media\n    - Retrieve PDF documents\n    - Download any non-text content",
      "namespace": "lib.http",
      "node_type": "lib.http.GetRequestBinary",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url"
      ],
      "is_dynamic": false
    },
    {
      "title": "GET Document",
      "description": "Perform an HTTP GET request and return a document\n    http, get, request, url, document\n\n    Use cases:\n    - Download PDF documents\n    - Retrieve Word documents\n    - Fetch Excel files\n    - Download any document format",
      "namespace": "lib.http",
      "node_type": "lib.http.GetRequestDocument",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "document"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url"
      ],
      "is_dynamic": false
    },
    {
      "title": "HTTPBase",
      "description": "Base node for HTTP requests.\n\n    http, network, request\n\n    Use cases:\n    - Share common fields for HTTP nodes\n    - Add custom request parameters in subclasses\n    - Control visibility of specific request types",
      "namespace": "lib.http",
      "node_type": "lib.http.HTTPBase",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "any"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url"
      ],
      "is_dynamic": false
    },
    {
      "title": "HEAD Request",
      "description": "Retrieve headers from a resource using an HTTP HEAD request.\n    http, head, request, url\n\n    Use cases:\n    - Check resource existence\n    - Get metadata without downloading content\n    - Verify authentication or permissions",
      "namespace": "lib.http",
      "node_type": "lib.http.HeadRequest",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url"
      ],
      "is_dynamic": false
    },
    {
      "title": "Image Downloader",
      "description": "Download images from list of URLs and return a list of ImageRefs.\n    image download, web scraping, data processing\n\n    Use cases:\n    - Prepare image datasets for machine learning tasks\n    - Archive images from web pages\n    - Process and analyze images extracted from websites",
      "namespace": "lib.http",
      "node_type": "lib.http.ImageDownloader",
      "layout": "default",
      "properties": [
        {
          "name": "images",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [],
          "title": "Images",
          "description": "List of image URLs to download."
        },
        {
          "name": "base_url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base Url",
          "description": "Base URL to prepend to relative image URLs."
        },
        {
          "name": "max_concurrent_downloads",
          "type": {
            "type": "int"
          },
          "default": 10,
          "title": "Max Concurrent Downloads",
          "description": "Maximum number of concurrent image downloads."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "image"
              }
            ]
          },
          "name": "images"
        },
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "failed_urls"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "images",
        "base_url",
        "max_concurrent_downloads"
      ],
      "is_dynamic": false
    },
    {
      "title": "GET JSON",
      "description": "Perform an HTTP GET request and parse the response as JSON.\n    http, get, request, url, json, api\n\n    Use cases:\n    - Fetch data from REST APIs\n    - Retrieve JSON-formatted responses\n    - Interface with JSON web services",
      "namespace": "lib.http",
      "node_type": "lib.http.JSONGetRequest",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url"
      ],
      "is_dynamic": false
    },
    {
      "title": "PATCH JSON",
      "description": "Partially update resources with JSON data using an HTTP PATCH request.\n    http, patch, request, url, json, api\n\n    Use cases:\n    - Partial updates to API resources\n    - Modify specific fields without full replacement\n    - Efficient updates for large objects",
      "namespace": "lib.http",
      "node_type": "lib.http.JSONPatchRequest",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Data",
          "description": "The JSON data to send in the PATCH request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url"
      ],
      "is_dynamic": false
    },
    {
      "title": "POST JSON",
      "description": "Send JSON data to a server using an HTTP POST request.\n    http, post, request, url, json, api\n\n    Use cases:\n    - Send structured data to REST APIs\n    - Create resources with JSON payloads\n    - Interface with modern web services",
      "namespace": "lib.http",
      "node_type": "lib.http.JSONPostRequest",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Data",
          "description": "The JSON data to send in the POST request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url"
      ],
      "is_dynamic": false
    },
    {
      "title": "PUT JSON",
      "description": "Update resources with JSON data using an HTTP PUT request.\n    http, put, request, url, json, api\n\n    Use cases:\n    - Update existing API resources\n    - Replace complete objects in REST APIs\n    - Set configuration with JSON data",
      "namespace": "lib.http",
      "node_type": "lib.http.JSONPutRequest",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "dict"
          },
          "default": {},
          "title": "Data",
          "description": "The JSON data to send in the PUT request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url"
      ],
      "is_dynamic": false
    },
    {
      "title": "POST Request",
      "description": "Send data to a server using an HTTP POST request.\n    http, post, request, url, data\n\n    Use cases:\n    - Submit form data\n    - Create new resources on an API\n    - Upload files\n    - Authenticate users",
      "namespace": "lib.http",
      "node_type": "lib.http.PostRequest",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Data",
          "description": "The data to send in the POST request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url"
      ],
      "is_dynamic": false
    },
    {
      "title": "POST Binary",
      "description": "Send data using an HTTP POST request and return raw binary data.\n    http, post, request, url, data, binary\n\n    Use cases:\n    - Upload and receive binary files\n    - Interact with binary APIs\n    - Process image or media uploads\n    - Handle binary file transformations",
      "namespace": "lib.http",
      "node_type": "lib.http.PostRequestBinary",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "bytes"
              }
            ]
          },
          "default": "",
          "title": "Data",
          "description": "The data to send in the POST request. Can be string or binary."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "bytes"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url"
      ],
      "is_dynamic": false
    },
    {
      "title": "PUT Request",
      "description": "Update existing resources on a server using an HTTP PUT request.\n    http, put, request, url, data\n\n    Use cases:\n    - Update user profiles\n    - Modify existing API resources\n    - Replace file contents\n    - Set configuration values",
      "namespace": "lib.http",
      "node_type": "lib.http.PutRequest",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "The URL to make the request to."
        },
        {
          "name": "data",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Data",
          "description": "The data to send in the PUT request."
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url"
      ],
      "is_dynamic": false
    },
    {
      "title": "Split Markdown",
      "description": "Splits markdown text by headers while preserving header hierarchy in metadata.\n    markdown, split, headers\n\n    Use cases:\n    - Splitting markdown documentation while preserving structure\n    - Processing markdown files for semantic search\n    - Creating context-aware chunks from markdown content",
      "namespace": "lib.langchain",
      "node_type": "lib.langchain.MarkdownSplitter",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown Text"
        },
        {
          "name": "document_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document Id",
          "description": "Document ID to associate with the text"
        },
        {
          "name": "headers_to_split_on",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "tuple",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "default": [
            [
              "#",
              "Header 1"
            ],
            [
              "##",
              "Header 2"
            ],
            [
              "###",
              "Header 3"
            ]
          ],
          "title": "Headers To Split On",
          "description": "List of tuples containing (header_symbol, header_name)"
        },
        {
          "name": "strip_headers",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Strip Headers",
          "description": "Whether to remove headers from the output content"
        },
        {
          "name": "return_each_line",
          "type": {
            "type": "bool"
          },
          "default": false,
          "title": "Return Each Line",
          "description": "Whether to split into individual lines instead of header sections"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "union",
            "type_args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ]
          },
          "title": "Chunk Size",
          "description": "Optional maximum chunk size for further splitting"
        },
        {
          "name": "chunk_overlap",
          "type": {
            "type": "int"
          },
          "default": 30,
          "title": "Chunk Overlap",
          "description": "Overlap size when using chunk_size"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "text_chunk"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "document_id",
        "headers_to_split_on",
        "strip_headers",
        "return_each_line",
        "chunk_size",
        "chunk_overlap"
      ],
      "is_dynamic": false
    },
    {
      "title": "Split Recursively",
      "description": "Splits text recursively using LangChain's RecursiveCharacterTextSplitter.\n    text, split, chunks\n\n    Use cases:\n    - Splitting documents while preserving semantic relationships\n    - Creating chunks for language model processing\n    - Handling text in languages with/without word boundaries",
      "namespace": "lib.langchain",
      "node_type": "lib.langchain.RecursiveTextSplitter",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "document_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document Id",
          "description": "Document ID to associate with the text"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 1000,
          "title": "Chunk Size",
          "description": "Maximum size of each chunk in characters"
        },
        {
          "name": "chunk_overlap",
          "type": {
            "type": "int"
          },
          "default": 200,
          "title": "Chunk Overlap",
          "description": "Number of characters to overlap between chunks"
        },
        {
          "name": "separators",
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "default": [
            "\n\n",
            "\n",
            "."
          ],
          "title": "Separators",
          "description": "List of separators to use for splitting, in order of preference"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "text_chunk"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "document_id",
        "chunk_size",
        "chunk_overlap",
        "separators"
      ],
      "is_dynamic": false
    },
    {
      "title": "Split into Sentences",
      "description": "Splits text into sentences using LangChain's SentenceTransformersTokenTextSplitter.\n    sentences, split, nlp\n\n    Use cases:\n    - Natural sentence-based text splitting\n    - Creating semantically meaningful chunks\n    - Processing text for sentence-level analysis",
      "namespace": "lib.langchain",
      "node_type": "lib.langchain.SentenceSplitter",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text"
        },
        {
          "name": "document_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document Id",
          "description": "Document ID to associate with the text"
        },
        {
          "name": "chunk_size",
          "type": {
            "type": "int"
          },
          "default": 40,
          "title": "Chunk Size",
          "description": "Maximum number of tokens per chunk"
        },
        {
          "name": "chunk_overlap",
          "type": {
            "type": "int"
          },
          "default": 5,
          "title": "Chunk Overlap",
          "description": "Number of tokens to overlap between chunks"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "text_chunk"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text",
        "document_id",
        "chunk_size",
        "chunk_overlap"
      ],
      "is_dynamic": false
    },
    {
      "title": "HTMLSplitter",
      "description": "Split HTML content into semantic chunks based on HTML tags.\n    html, text, semantic, tags, parsing",
      "namespace": "lib.llama_index",
      "node_type": "lib.llama_index.HTMLSplitter",
      "layout": "default",
      "properties": [
        {
          "name": "document_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document Id",
          "description": "Document ID to associate with the HTML content"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "HTML content to split"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "text_chunk"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "document_id",
        "text"
      ],
      "is_dynamic": false
    },
    {
      "title": "JSONSplitter",
      "description": "Split JSON content into semantic chunks.\n    json, parsing, semantic, structured",
      "namespace": "lib.llama_index",
      "node_type": "lib.llama_index.JSONSplitter",
      "layout": "default",
      "properties": [
        {
          "name": "document_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document Id",
          "description": "Document ID to associate with the JSON content"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "JSON content to split"
        },
        {
          "name": "include_metadata",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Include Metadata",
          "description": "Whether to include metadata in nodes"
        },
        {
          "name": "include_prev_next_rel",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Include Prev Next Rel",
          "description": "Whether to include prev/next relationships"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "text_chunk"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "document_id",
        "text",
        "include_metadata",
        "include_prev_next_rel"
      ],
      "is_dynamic": false
    },
    {
      "title": "Semantic Splitter",
      "description": "Split text semantically.\n    chroma, embedding, collection, RAG, index, text, markdown, semantic",
      "namespace": "lib.llama_index",
      "node_type": "lib.llama_index.SemanticSplitter",
      "layout": "default",
      "properties": [
        {
          "name": "embed_model",
          "type": {
            "type": "llama_model"
          },
          "default": {},
          "title": "Embed Model",
          "description": "Embedding model to use"
        },
        {
          "name": "document_id",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Document Id",
          "description": "Document ID to associate with the text content"
        },
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text content to split"
        },
        {
          "name": "buffer_size",
          "type": {
            "type": "int"
          },
          "default": 1,
          "title": "Buffer Size",
          "description": "Buffer size for semantic splitting",
          "min": 1.0,
          "max": 100.0
        },
        {
          "name": "threshold",
          "type": {
            "type": "int"
          },
          "default": 95,
          "title": "Threshold",
          "description": "Breakpoint percentile threshold for semantic splitting",
          "min": 0.0,
          "max": 100.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "text_chunk"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "embed_model",
        "document_id",
        "text",
        "buffer_size",
        "threshold"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Bullet Lists",
      "description": "Extracts bulleted lists from markdown.\n    markdown, lists, bullets, extraction\n\n    Use cases:\n    - Extract unordered list items\n    - Analyze bullet point structures\n    - Convert bullet lists to structured data",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractBulletLists",
      "layout": "default",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "markdown"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Code Blocks",
      "description": "Extracts code blocks and their languages from markdown.\n    markdown, code, extraction\n\n    Use cases:\n    - Extract code samples for analysis\n    - Collect programming examples\n    - Analyze code snippets in documentation",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractCodeBlocks",
      "layout": "default",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "markdown"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Headers",
      "description": "Extracts headers and creates a document structure/outline.\n    markdown, headers, structure\n\n    Use cases:\n    - Generate table of contents\n    - Analyze document structure\n    - Extract main topics from documents",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractHeaders",
      "layout": "default",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        },
        {
          "name": "max_level",
          "type": {
            "type": "int"
          },
          "default": 6,
          "title": "Max Level",
          "description": "Maximum header level to extract (1-6)",
          "min": 1.0,
          "max": 6.0
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "any"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "markdown",
        "max_level"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Links",
      "description": "Extracts all links from markdown text.\n    markdown, links, extraction\n\n    Use cases:\n    - Extract references and citations from academic documents\n    - Build link graphs from markdown documentation\n    - Analyze external resources referenced in markdown files",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractLinks",
      "layout": "default",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        },
        {
          "name": "include_titles",
          "type": {
            "type": "bool"
          },
          "default": true,
          "title": "Include Titles",
          "description": "Whether to include link titles in output"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict",
                "type_args": [
                  {
                    "type": "str"
                  },
                  {
                    "type": "str"
                  }
                ]
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "markdown",
        "include_titles"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Numbered Lists",
      "description": "Extracts numbered lists from markdown.\n    markdown, lists, numbered, extraction\n\n    Use cases:\n    - Extract ordered list items\n    - Analyze enumerated structures\n    - Convert numbered lists to structured data",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractNumberedLists",
      "layout": "default",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "str"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "markdown"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Tables",
      "description": "Extracts tables from markdown and converts them to structured data.\n    markdown, tables, data\n\n    Use cases:\n    - Extract tabular data from markdown\n    - Convert markdown tables to structured formats\n    - Analyze tabulated information",
      "namespace": "lib.markdown",
      "node_type": "lib.markdown.ExtractTables",
      "layout": "default",
      "properties": [
        {
          "name": "markdown",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Markdown",
          "description": "The markdown text to analyze"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dataframe"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "markdown"
      ],
      "is_dynamic": false
    },
    {
      "title": "Convert To Markdown",
      "description": "Converts various document formats to markdown using MarkItDown.\n    markdown, convert, document\n\n    Use cases:\n    - Convert Word documents to markdown\n    - Convert Excel files to markdown tables\n    - Convert PowerPoint to markdown content",
      "namespace": "lib.markitdown",
      "node_type": "lib.markitdown.ConvertToMarkdown",
      "layout": "default",
      "properties": [
        {
          "name": "document",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Document",
          "description": "The document to convert to markdown"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "document"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Markdown",
      "description": "Convert PDF to Markdown format using pymupdf4llm.\n    pdf, markdown, convert\n\n    Use cases:\n    - Convert PDF documents to markdown format\n    - Preserve document structure in markdown\n    - Create editable markdown from PDFs",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractMarkdown",
      "layout": "default",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Pdf",
          "description": "The PDF document to convert to markdown"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Tables",
      "description": "Extract tables from a PDF document using PyMuPDF.\n    pdf, tables, extract, structured\n\n    Use cases:\n    - Extract tabular data from PDFs\n    - Convert PDF tables to structured formats\n    - Analyze table layouts and content",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractTables",
      "layout": "default",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Pdf",
          "description": "The PDF document to extract tables from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Text",
      "description": "Extract plain text from a PDF document using PyMuPDF.\n    pdf, text, extract\n\n    Use cases:\n    - Extract raw text content from PDFs\n    - Convert PDF documents to plain text\n    - Prepare text for further processing",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractText",
      "layout": "default",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Pdf",
          "description": "The PDF document to extract text from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Text Blocks",
      "description": "Extract text blocks with their bounding boxes from a PDF.\n    pdf, text, blocks, layout\n\n    Use cases:\n    - Analyze text layout and structure\n    - Extract text while preserving block-level formatting\n    - Get text position information",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractTextBlocks",
      "layout": "default",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Pdf",
          "description": "The PDF document to extract text blocks from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "is_dynamic": false
    },
    {
      "title": "Extract Text With Style",
      "description": "Extract text with style information (font, size, color) from a PDF.\n    pdf, text, style, formatting\n\n    Use cases:\n    - Preserve text formatting during extraction\n    - Analyze document styling\n    - Extract text with font information",
      "namespace": "lib.pymupdf",
      "node_type": "lib.pymupdf.ExtractTextWithStyle",
      "layout": "default",
      "properties": [
        {
          "name": "pdf",
          "type": {
            "type": "document"
          },
          "default": {},
          "title": "Pdf",
          "description": "The PDF document to extract styled text from"
        },
        {
          "name": "start_page",
          "type": {
            "type": "int"
          },
          "default": 0,
          "title": "Start Page",
          "description": "First page to extract (0-based index)"
        },
        {
          "name": "end_page",
          "type": {
            "type": "int"
          },
          "default": -1,
          "title": "End Page",
          "description": "Last page to extract (-1 for last page)"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "list",
            "type_args": [
              {
                "type": "dict"
              }
            ]
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "pdf",
        "start_page",
        "end_page"
      ],
      "is_dynamic": false
    },
    {
      "title": "Encode Query Params",
      "description": "Encode a dictionary of parameters into a query string using\n    ``urllib.parse.urlencode``.\n    urllib, query, encode, params\n\n    Use cases:\n    - Build GET request URLs\n    - Serialize data for APIs\n    - Convert parameters to query strings",
      "namespace": "lib.urllib",
      "node_type": "lib.urllib.EncodeQueryParams",
      "layout": "default",
      "properties": [
        {
          "name": "params",
          "type": {
            "type": "dict",
            "type_args": [
              {
                "type": "str"
              },
              {
                "type": "str"
              }
            ]
          },
          "title": "Params",
          "description": "Parameters to encode"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "params"
      ],
      "is_dynamic": false
    },
    {
      "title": "Join URL",
      "description": "Join a base URL with a relative URL using ``urllib.parse.urljoin``.\n    urllib, join, url\n\n    Use cases:\n    - Build absolute links from relative paths\n    - Combine API base with endpoints\n    - Resolve resources from a base URL",
      "namespace": "lib.urllib",
      "node_type": "lib.urllib.JoinURL",
      "layout": "default",
      "properties": [
        {
          "name": "base",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Base",
          "description": "Base URL"
        },
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "Relative or absolute URL"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "base",
        "url"
      ],
      "is_dynamic": false
    },
    {
      "title": "Parse URL",
      "description": "Parse a URL into its components using ``urllib.parse.urlparse``.\n    urllib, parse, url\n\n    Use cases:\n    - Inspect links for validation\n    - Extract host or path information\n    - Analyze query parameters",
      "namespace": "lib.urllib",
      "node_type": "lib.urllib.ParseURL",
      "layout": "default",
      "properties": [
        {
          "name": "url",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Url",
          "description": "URL to parse"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "dict"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "url"
      ],
      "is_dynamic": false
    },
    {
      "title": "Quote URL",
      "description": "Percent-encode a string for safe use in URLs using ``urllib.parse.quote``.\n    urllib, quote, encode\n\n    Use cases:\n    - Escape spaces or special characters\n    - Prepare text for query parameters\n    - Encode file names in URLs",
      "namespace": "lib.urllib",
      "node_type": "lib.urllib.QuoteURL",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Text to quote"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text"
      ],
      "is_dynamic": false
    },
    {
      "title": "Unquote URL",
      "description": "Decode a percent-encoded URL string using ``urllib.parse.unquote``.\n    urllib, unquote, decode\n\n    Use cases:\n    - Convert encoded URLs to readable form\n    - Parse user input from URLs\n    - Display unescaped paths",
      "namespace": "lib.urllib",
      "node_type": "lib.urllib.UnquoteURL",
      "layout": "default",
      "properties": [
        {
          "name": "text",
          "type": {
            "type": "str"
          },
          "default": "",
          "title": "Text",
          "description": "Encoded text"
        }
      ],
      "outputs": [
        {
          "type": {
            "type": "str"
          },
          "name": "output"
        }
      ],
      "the_model_info": {},
      "recommended_models": [],
      "basic_fields": [
        "text"
      ],
      "is_dynamic": false
    },
    {
      "title": "Compress",
      "description": "Compress binary data using the zlib algorithm.\n    zlib, compress, deflate, binary\n\n    Use cases:\n    - Reduce size of binary data\n    - Prepare payloads for transmission\n    - Store data in compressed form",
      "namespace": "lib.zlib",
      "node_type": "lib.zlib.Compress",
      "layout": "default",
      "properties": [
        {
          "name": "data",
          "type": {
            "type": "bytes"
          },
          "default": 