# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.statistics
from nodetool.workflows.base_node import BaseNode


class ArgMaxArray(
    SingleOutputGraphNode[nodetool.metadata.types.NPArray | int],
    GraphNode[nodetool.metadata.types.NPArray | int],
):
    """

    Find indices of maximum values along a specified axis of a array.
    array, argmax, index, maximum

    Use cases:
    - Determine winning classes in classification tasks
    - Find peaks in signal processing
    - Locate best-performing items in datasets
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="Input array",
    )
    axis: int | OutputHandle[int] | None = connect_field(
        default=None, description="Axis along which to find maximum indices"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.numpy.statistics.ArgMaxArray

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.statistics
from nodetool.workflows.base_node import BaseNode


class ArgMinArray(
    SingleOutputGraphNode[nodetool.metadata.types.NPArray | int],
    GraphNode[nodetool.metadata.types.NPArray | int],
):
    """

    Find indices of minimum values along a specified axis of a array.
    array, argmin, index, minimum

    Use cases:
    - Locate lowest-performing items in datasets
    - Find troughs in signal processing
    - Determine least likely classes in classification tasks
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="Input array",
    )
    axis: int | OutputHandle[int] | None = connect_field(
        default=None, description="Axis along which to find minimum indices"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.numpy.statistics.ArgMinArray

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.statistics
from nodetool.workflows.base_node import BaseNode


class MaxArray(
    SingleOutputGraphNode[nodetool.metadata.types.NPArray | float | int],
    GraphNode[nodetool.metadata.types.NPArray | float | int],
):
    """

    Compute the maximum value along a specified axis of a array.
    array, maximum, reduction, statistics

    Use cases:
    - Find peak values in time series data
    - Implement max pooling in neural networks
    - Determine highest scores across multiple categories
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="Input array",
    )
    axis: int | OutputHandle[int] | None = connect_field(
        default=None, description="Axis along which to compute maximum"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.numpy.statistics.MaxArray

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.statistics
from nodetool.workflows.base_node import BaseNode


class MeanArray(
    SingleOutputGraphNode[nodetool.metadata.types.NPArray | float | int],
    GraphNode[nodetool.metadata.types.NPArray | float | int],
):
    """

    Compute the mean value along a specified axis of a array.
    array, average, reduction, statistics

    Use cases:
    - Calculate average values in datasets
    - Implement mean pooling in neural networks
    - Compute centroids in clustering algorithms
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="Input array",
    )
    axis: int | OutputHandle[int] | None = connect_field(
        default=None, description="Axis along which to compute mean"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.numpy.statistics.MeanArray

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.statistics
from nodetool.workflows.base_node import BaseNode


class MinArray(
    SingleOutputGraphNode[nodetool.metadata.types.NPArray | float | int],
    GraphNode[nodetool.metadata.types.NPArray | float | int],
):
    """

    Calculate the minimum value along a specified axis of a array.
    array, minimum, reduction, statistics

    Use cases:
    - Find lowest values in datasets
    - Implement min pooling in neural networks
    - Determine minimum thresholds across categories
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="Input array",
    )
    axis: int | OutputHandle[int] | None = connect_field(
        default=None, description="Axis along which to compute minimum"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.numpy.statistics.MinArray

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.statistics
from nodetool.workflows.base_node import BaseNode


class SumArray(
    SingleOutputGraphNode[nodetool.metadata.types.NPArray | float | int],
    GraphNode[nodetool.metadata.types.NPArray | float | int],
):
    """

    Calculate the sum of values along a specified axis of a array.
    array, summation, reduction, statistics

    Use cases:
    - Compute total values across categories
    - Implement sum pooling in neural networks
    - Calculate cumulative metrics in time series data
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="Input array",
    )
    axis: int | OutputHandle[int] | None = connect_field(
        default=None, description="Axis along which to compute sum"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.numpy.statistics.SumArray

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
