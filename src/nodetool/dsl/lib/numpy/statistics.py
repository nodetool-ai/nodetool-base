# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.statistics


class ArgMaxArray(GraphNode[nodetool.metadata.types.NPArray | int]):
    """
    Find indices of maximum values along a specified axis of a array.
    array, argmax, index, maximum

    Use cases:
    - Determine winning classes in classification tasks
    - Find peaks in signal processing
    - Locate best-performing items in datasets
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="Input array",
    )
    axis: int | OutputHandle[int] | None = connect_field(
        default=None, description="Axis along which to find maximum indices"
    )

    @property
    def output(self) -> OutputHandle[nodetool.metadata.types.NPArray | int]:
        return typing.cast(
            OutputHandle[nodetool.metadata.types.NPArray | int],
            self._single_output_handle(),
        )

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.statistics.ArgMaxArray"


ArgMaxArray.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.statistics


class ArgMinArray(GraphNode[nodetool.metadata.types.NPArray | int]):
    """
    Find indices of minimum values along a specified axis of a array.
    array, argmin, index, minimum

    Use cases:
    - Locate lowest-performing items in datasets
    - Find troughs in signal processing
    - Determine least likely classes in classification tasks
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="Input array",
    )
    axis: int | OutputHandle[int] | None = connect_field(
        default=None, description="Axis along which to find minimum indices"
    )

    @property
    def output(self) -> OutputHandle[nodetool.metadata.types.NPArray | int]:
        return typing.cast(
            OutputHandle[nodetool.metadata.types.NPArray | int],
            self._single_output_handle(),
        )

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.statistics.ArgMinArray"


ArgMinArray.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.statistics


class MaxArray(GraphNode[nodetool.metadata.types.NPArray | float | int]):
    """
    Compute the maximum value along a specified axis of a array.
    array, maximum, reduction, statistics

    Use cases:
    - Find peak values in time series data
    - Implement max pooling in neural networks
    - Determine highest scores across multiple categories
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="Input array",
    )
    axis: int | OutputHandle[int] | None = connect_field(
        default=None, description="Axis along which to compute maximum"
    )

    @property
    def output(self) -> OutputHandle[nodetool.metadata.types.NPArray | float | int]:
        return typing.cast(
            OutputHandle[nodetool.metadata.types.NPArray | float | int],
            self._single_output_handle(),
        )

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.statistics.MaxArray"


MaxArray.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.statistics


class MeanArray(GraphNode[nodetool.metadata.types.NPArray | float | int]):
    """
    Compute the mean value along a specified axis of a array.
    array, average, reduction, statistics

    Use cases:
    - Calculate average values in datasets
    - Implement mean pooling in neural networks
    - Compute centroids in clustering algorithms
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="Input array",
    )
    axis: int | OutputHandle[int] | None = connect_field(
        default=None, description="Axis along which to compute mean"
    )

    @property
    def output(self) -> OutputHandle[nodetool.metadata.types.NPArray | float | int]:
        return typing.cast(
            OutputHandle[nodetool.metadata.types.NPArray | float | int],
            self._single_output_handle(),
        )

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.statistics.MeanArray"


MeanArray.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.statistics


class MinArray(GraphNode[nodetool.metadata.types.NPArray | float | int]):
    """
    Calculate the minimum value along a specified axis of a array.
    array, minimum, reduction, statistics

    Use cases:
    - Find lowest values in datasets
    - Implement min pooling in neural networks
    - Determine minimum thresholds across categories
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="Input array",
    )
    axis: int | OutputHandle[int] | None = connect_field(
        default=None, description="Axis along which to compute minimum"
    )

    @property
    def output(self) -> OutputHandle[nodetool.metadata.types.NPArray | float | int]:
        return typing.cast(
            OutputHandle[nodetool.metadata.types.NPArray | float | int],
            self._single_output_handle(),
        )

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.statistics.MinArray"


MinArray.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.statistics


class SumArray(GraphNode[nodetool.metadata.types.NPArray | float | int]):
    """
    Calculate the sum of values along a specified axis of a array.
    array, summation, reduction, statistics

    Use cases:
    - Compute total values across categories
    - Implement sum pooling in neural networks
    - Calculate cumulative metrics in time series data
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="Input array",
    )
    axis: int | OutputHandle[int] | None = connect_field(
        default=None, description="Axis along which to compute sum"
    )

    @property
    def output(self) -> OutputHandle[nodetool.metadata.types.NPArray | float | int]:
        return typing.cast(
            OutputHandle[nodetool.metadata.types.NPArray | float | int],
            self._single_output_handle(),
        )

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.statistics.SumArray"


SumArray.model_rebuild(force=True)
