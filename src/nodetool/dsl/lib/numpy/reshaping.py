# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.reshaping
from nodetool.workflows.base_node import BaseNode


class Reshape1D(SingleOutputGraphNode[types.NPArray], GraphNode[types.NPArray]):
    """
    Reshape an array to a 1D shape without changing its data.
    array, reshape, vector, flatten

    Use cases:
    - Flatten multi-dimensional data for certain algorithms
    - Convert images to vector form for machine learning
    - Prepare data for 1D operations
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="The input array to reshape",
    )
    num_elements: int | OutputHandle[int] = connect_field(
        default=0, description="The number of elements"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.numpy.reshaping.Reshape1D

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.reshaping
from nodetool.workflows.base_node import BaseNode


class Reshape2D(SingleOutputGraphNode[types.NPArray], GraphNode[types.NPArray]):
    """
    Reshape an array to a new shape without changing its data.
    array, reshape, dimensions, structure

    Use cases:
    - Convert between different dimensional representations
    - Prepare data for specific model architectures
    - Flatten or unflatten arrays
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="The input array to reshape",
    )
    num_rows: int | OutputHandle[int] = connect_field(
        default=0, description="The number of rows"
    )
    num_cols: int | OutputHandle[int] = connect_field(
        default=0, description="The number of columns"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.numpy.reshaping.Reshape2D

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.reshaping
from nodetool.workflows.base_node import BaseNode


class Reshape3D(SingleOutputGraphNode[types.NPArray], GraphNode[types.NPArray]):
    """
    Reshape an array to a 3D shape without changing its data.
    array, reshape, dimensions, volume

    Use cases:
    - Convert data for 3D visualization
    - Prepare image data with channels
    - Structure data for 3D convolutions
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="The input array to reshape",
    )
    num_rows: int | OutputHandle[int] = connect_field(
        default=0, description="The number of rows"
    )
    num_cols: int | OutputHandle[int] = connect_field(
        default=0, description="The number of columns"
    )
    num_depths: int | OutputHandle[int] = connect_field(
        default=0, description="The number of depths"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.numpy.reshaping.Reshape3D

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.reshaping
from nodetool.workflows.base_node import BaseNode


class Reshape4D(SingleOutputGraphNode[types.NPArray], GraphNode[types.NPArray]):
    """
    Reshape an array to a 4D shape without changing its data.
    array, reshape, dimensions, batch

    Use cases:
    - Prepare batch data for neural networks
    - Structure spatiotemporal data
    - Format data for 3D image processing with channels
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="The input array to reshape",
    )
    num_rows: int | OutputHandle[int] = connect_field(
        default=0, description="The number of rows"
    )
    num_cols: int | OutputHandle[int] = connect_field(
        default=0, description="The number of columns"
    )
    num_depths: int | OutputHandle[int] = connect_field(
        default=0, description="The number of depths"
    )
    num_channels: int | OutputHandle[int] = connect_field(
        default=0, description="The number of channels"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.numpy.reshaping.Reshape4D

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
