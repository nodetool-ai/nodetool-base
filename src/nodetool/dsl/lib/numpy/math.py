# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.math


class AbsArray(GraphNode[types.NPArray]):
    """
    Compute the absolute value of each element in a array.
    array, absolute, magnitude

    Use cases:
    - Calculate magnitudes of complex numbers
    - Preprocess data for certain algorithms
    - Implement activation functions in neural networks
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="The input array to compute the absolute values from.",
    )

    @property
    def output(self) -> OutputHandle[types.NPArray]:
        return typing.cast(OutputHandle[types.NPArray], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.math.AbsArray"


AbsArray.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.math


class CosineArray(GraphNode[float | nodetool.metadata.types.NPArray]):
    """
    Computes the cosine of input angles in radians.
    math, trigonometry, cosine, cos

    Use cases:
    - Calculating horizontal components in physics
    - Creating circular motions
    - Phase calculations in signal processing
    """

    angle_rad: (
        float
        | int
        | nodetool.metadata.types.NPArray
        | OutputHandle[float | int | nodetool.metadata.types.NPArray]
    ) = connect_field(default=0.0, description=None)

    @property
    def output(self) -> OutputHandle[float | nodetool.metadata.types.NPArray]:
        return typing.cast(
            OutputHandle[float | nodetool.metadata.types.NPArray],
            self._single_output_handle(),
        )

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.math.CosineArray"


CosineArray.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.math


class ExpArray(GraphNode[float | int | nodetool.metadata.types.NPArray]):
    """
    Calculate the exponential of each element in a array.
    array, exponential, math, activation

    Use cases:
    - Implement exponential activation functions
    - Calculate growth rates in scientific models
    - Transform data for certain statistical analyses
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="Input array",
    )

    @property
    def output(self) -> OutputHandle[float | int | nodetool.metadata.types.NPArray]:
        return typing.cast(
            OutputHandle[float | int | nodetool.metadata.types.NPArray],
            self._single_output_handle(),
        )

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.math.ExpArray"


ExpArray.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.math


class LogArray(GraphNode[float | int | nodetool.metadata.types.NPArray]):
    """
    Calculate the natural logarithm of each element in a array.
    array, logarithm, math, transformation

    Use cases:
    - Implement log transformations on data
    - Calculate entropy in information theory
    - Normalize data with large ranges
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="Input array",
    )

    @property
    def output(self) -> OutputHandle[float | int | nodetool.metadata.types.NPArray]:
        return typing.cast(
            OutputHandle[float | int | nodetool.metadata.types.NPArray],
            self._single_output_handle(),
        )

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.math.LogArray"


LogArray.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.math


class PowerArray(GraphNode[float | int | nodetool.metadata.types.NPArray]):
    """
    Raises the base array to the power of the exponent element-wise.
    math, exponentiation, power, pow, **

    Use cases:
    - Calculating compound interest
    - Implementing polynomial functions
    - Applying non-linear transformations to data
    """

    base: (
        float
        | int
        | nodetool.metadata.types.NPArray
        | OutputHandle[float | int | nodetool.metadata.types.NPArray]
    ) = connect_field(default=1.0, description=None)
    exponent: (
        float
        | int
        | nodetool.metadata.types.NPArray
        | OutputHandle[float | int | nodetool.metadata.types.NPArray]
    ) = connect_field(default=2.0, description=None)

    @property
    def output(self) -> OutputHandle[float | int | nodetool.metadata.types.NPArray]:
        return typing.cast(
            OutputHandle[float | int | nodetool.metadata.types.NPArray],
            self._single_output_handle(),
        )

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.math.PowerArray"


PowerArray.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.math


class SineArray(GraphNode[float | nodetool.metadata.types.NPArray]):
    """
    Computes the sine of input angles in radians.
    math, trigonometry, sine, sin

    Use cases:
    - Calculating vertical components in physics
    - Generating smooth periodic functions
    - Audio signal processing
    """

    angle_rad: (
        float
        | int
        | nodetool.metadata.types.NPArray
        | OutputHandle[float | int | nodetool.metadata.types.NPArray]
    ) = connect_field(default=0.0, description=None)

    @property
    def output(self) -> OutputHandle[float | nodetool.metadata.types.NPArray]:
        return typing.cast(
            OutputHandle[float | nodetool.metadata.types.NPArray],
            self._single_output_handle(),
        )

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.math.SineArray"


SineArray.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.math


class SqrtArray(GraphNode[float | int | nodetool.metadata.types.NPArray]):
    """
    Calculates the square root of the input array element-wise.
    math, square root, sqrt, âˆš

    Use cases:
    - Normalizing data
    - Calculating distances in Euclidean space
    - Finding intermediate values in binary search
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="Input array",
    )

    @property
    def output(self) -> OutputHandle[float | int | nodetool.metadata.types.NPArray]:
        return typing.cast(
            OutputHandle[float | int | nodetool.metadata.types.NPArray],
            self._single_output_handle(),
        )

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.math.SqrtArray"


SqrtArray.model_rebuild(force=True)
