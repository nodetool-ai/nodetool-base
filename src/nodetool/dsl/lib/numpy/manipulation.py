# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.manipulation


class IndexArray(GraphNode[types.NPArray]):
    """
    Select specific indices from an array along a specified axis.
    array, index, select, subset

    Use cases:
    - Extract specific samples from a dataset
    - Select particular features or dimensions
    - Implement batch sampling operations
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="The input array to index",
    )
    indices: str | OutputHandle[str] = connect_field(
        default="", description="The comma separated indices to select"
    )
    axis: int | OutputHandle[int] = connect_field(
        default=0, description="Axis along which to index"
    )

    @property
    def output(self) -> OutputHandle[types.NPArray]:
        return typing.cast(OutputHandle[types.NPArray], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.manipulation.IndexArray"


IndexArray.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.manipulation


class MatMul(GraphNode[types.NPArray]):
    """
    Perform matrix multiplication on two input arrays.
    array, matrix, multiplication, linear algebra

    Use cases:
    - Implement linear transformations
    - Calculate dot products of vectors
    - Perform matrix operations in neural networks
    """

    a: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="First input array",
    )
    b: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="Second input array",
    )

    @property
    def output(self) -> OutputHandle[types.NPArray]:
        return typing.cast(OutputHandle[types.NPArray], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.manipulation.MatMul"


MatMul.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.manipulation


class SliceArray(GraphNode[types.NPArray]):
    """
    Extract a slice of an array along a specified axis.
    array, slice, subset, index

    Use cases:
    - Extract specific time periods from time series data
    - Select subset of features from datasets
    - Create sliding windows over sequential data
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="The input array to slice",
    )
    start: int | OutputHandle[int] = connect_field(
        default=0, description="Starting index (inclusive)"
    )
    stop: int | OutputHandle[int] = connect_field(
        default=0, description="Ending index (exclusive)"
    )
    step: int | OutputHandle[int] = connect_field(
        default=1, description="Step size between elements"
    )
    axis: int | OutputHandle[int] = connect_field(
        default=0, description="Axis along which to slice"
    )

    @property
    def output(self) -> OutputHandle[types.NPArray]:
        return typing.cast(OutputHandle[types.NPArray], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.manipulation.SliceArray"


SliceArray.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.manipulation


class SplitArray(GraphNode[list[types.NPArray]]):
    """
    Split an array into multiple sub-arrays along a specified axis.
    array, split, divide, partition

    Use cases:
    - Divide datasets into training/validation splits
    - Create batches from large arrays
    - Separate multi-channel data
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="The input array to split",
    )
    num_splits: int | OutputHandle[int] = connect_field(
        default=0, description="Number of equal splits to create"
    )
    axis: int | OutputHandle[int] = connect_field(
        default=0, description="Axis along which to split"
    )

    @property
    def output(self) -> OutputHandle[list[types.NPArray]]:
        return typing.cast(
            OutputHandle[list[types.NPArray]], self._single_output_handle()
        )

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.manipulation.SplitArray"


SplitArray.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.manipulation


class Stack(GraphNode[types.NPArray]):
    """
    Stack multiple arrays along a specified axis.
    array, stack, concatenate, join, merge, axis

    Use cases:
    - Combine multiple 2D arrays into a 3D array
    - Stack time series data from multiple sources
    - Merge feature vectors for machine learning models
    """

    arrays: list[types.NPArray] | OutputHandle[list[types.NPArray]] = connect_field(
        default=[], description="Arrays to stack"
    )
    axis: int | OutputHandle[int] = connect_field(
        default=0, description="The axis to stack along."
    )

    @property
    def output(self) -> OutputHandle[types.NPArray]:
        return typing.cast(OutputHandle[types.NPArray], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.manipulation.Stack"


Stack.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.numpy.manipulation


class TransposeArray(GraphNode[types.NPArray]):
    """
    Transpose the dimensions of the input array.
    array, transpose, reshape, dimensions

    Use cases:
    - Convert row vectors to column vectors
    - Rearrange data for compatibility with other operations
    - Implement certain linear algebra operations
    """

    values: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description="Array to transpose",
    )

    @property
    def output(self) -> OutputHandle[types.NPArray]:
        return typing.cast(OutputHandle[types.NPArray], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.numpy.manipulation.TransposeArray"


TransposeArray.model_rebuild(force=True)
