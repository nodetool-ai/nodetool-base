# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.date
from nodetool.workflows.base_node import BaseNode


class AddTimeDelta(SingleOutputGraphNode[types.Datetime], GraphNode[types.Datetime]):
    """
    Add or subtract time from a datetime.
    datetime, add, subtract

    Use cases:
    - Calculate future/past dates
    - Generate date ranges
    """

    input_datetime: types.Datetime | OutputHandle[types.Datetime] = connect_field(
        default=types.Datetime(
            type="datetime",
            year=0,
            month=0,
            day=0,
            hour=0,
            minute=0,
            second=0,
            microsecond=0,
            tzinfo="UTC",
            utc_offset=0,
        ),
        description="Starting datetime",
    )
    days: int | OutputHandle[int] = connect_field(
        default=0, description="Number of days to add (negative to subtract)"
    )
    hours: int | OutputHandle[int] = connect_field(
        default=0, description="Number of hours to add (negative to subtract)"
    )
    minutes: int | OutputHandle[int] = connect_field(
        default=0, description="Number of minutes to add (negative to subtract)"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.date.AddTimeDelta

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.date
from nodetool.workflows.base_node import BaseNode
import nodetool.nodes.lib.date
import nodetool.nodes.lib.date


class BoundaryTime(SingleOutputGraphNode[types.Datetime], GraphNode[types.Datetime]):
    """
    Get the start or end of a time period (day, week, month, year).
    datetime, start, end, boundary, day, week, month, year

    Use cases:
    - Get period boundaries for reporting
    - Normalize dates to period starts/ends
    """

    PeriodType: typing.ClassVar[type] = nodetool.nodes.lib.date.PeriodType
    BoundaryType: typing.ClassVar[type] = nodetool.nodes.lib.date.BoundaryType
    input_datetime: types.Datetime | OutputHandle[types.Datetime] = connect_field(
        default=types.Datetime(
            type="datetime",
            year=0,
            month=0,
            day=0,
            hour=0,
            minute=0,
            second=0,
            microsecond=0,
            tzinfo="UTC",
            utc_offset=0,
        ),
        description="Input datetime",
    )
    period: nodetool.nodes.lib.date.PeriodType = Field(
        default=nodetool.nodes.lib.date.PeriodType.DAY, description="Time period type"
    )
    boundary: nodetool.nodes.lib.date.BoundaryType = Field(
        default=nodetool.nodes.lib.date.BoundaryType.START,
        description="Start or end of period",
    )
    start_monday: bool | OutputHandle[bool] = connect_field(
        default=True,
        description="For week period: Consider Monday as start of week (False for Sunday)",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.date.BoundaryTime

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.date
from nodetool.workflows.base_node import BaseNode


class DateDifference(GraphNode[nodetool.nodes.lib.date.DateDifference.OutputType]):
    """
    Calculate the difference between two dates.
    datetime, difference, duration

    Use cases:
    - Calculate time periods
    - Measure durations
    """

    start_date: types.Datetime | OutputHandle[types.Datetime] = connect_field(
        default=types.Datetime(
            type="datetime",
            year=0,
            month=0,
            day=0,
            hour=0,
            minute=0,
            second=0,
            microsecond=0,
            tzinfo="UTC",
            utc_offset=0,
        ),
        description="Start datetime",
    )
    end_date: types.Datetime | OutputHandle[types.Datetime] = connect_field(
        default=types.Datetime(
            type="datetime",
            year=0,
            month=0,
            day=0,
            hour=0,
            minute=0,
            second=0,
            microsecond=0,
            tzinfo="UTC",
            utc_offset=0,
        ),
        description="End datetime",
    )

    @property
    def out(self) -> "DateDifferenceOutputs":
        return DateDifferenceOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.date.DateDifference

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class DateDifferenceOutputs(OutputsProxy):
    @property
    def total_seconds(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self["total_seconds"])

    @property
    def days(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self["days"])

    @property
    def hours(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self["hours"])

    @property
    def minutes(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self["minutes"])

    @property
    def seconds(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self["seconds"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.date
from nodetool.workflows.base_node import BaseNode


class DateRange(
    SingleOutputGraphNode[list[types.Datetime]], GraphNode[list[types.Datetime]]
):
    """
    Generate a list of dates between start and end dates.
    datetime, range, list

    Use cases:
    - Generate date sequences
    - Create date-based iterations
    """

    start_date: types.Datetime | OutputHandle[types.Datetime] = connect_field(
        default=types.Datetime(
            type="datetime",
            year=0,
            month=0,
            day=0,
            hour=0,
            minute=0,
            second=0,
            microsecond=0,
            tzinfo="UTC",
            utc_offset=0,
        ),
        description="Start date of the range",
    )
    end_date: types.Datetime | OutputHandle[types.Datetime] = connect_field(
        default=types.Datetime(
            type="datetime",
            year=0,
            month=0,
            day=0,
            hour=0,
            minute=0,
            second=0,
            microsecond=0,
            tzinfo="UTC",
            utc_offset=0,
        ),
        description="End date of the range",
    )
    step_days: int | OutputHandle[int] = connect_field(
        default=1, description="Number of days between each date"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.date.DateRange

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.date
from nodetool.workflows.base_node import BaseNode


class DateToDatetime(SingleOutputGraphNode[types.Datetime], GraphNode[types.Datetime]):
    """
    Convert a Date object to a Datetime object.
    date, datetime, convert
    """

    input_date: types.Date | OutputHandle[types.Date] = connect_field(
        default=types.Date(type="date", year=0, month=0, day=0),
        description="Date to convert",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.date.DateToDatetime

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.date
from nodetool.workflows.base_node import BaseNode


class DatetimeToDate(SingleOutputGraphNode[types.Date], GraphNode[types.Date]):
    """
    Convert a Datetime object to a Date object.
    date, datetime, convert
    """

    input_datetime: types.Datetime | OutputHandle[types.Datetime] = connect_field(
        default=types.Datetime(
            type="datetime",
            year=0,
            month=0,
            day=0,
            hour=0,
            minute=0,
            second=0,
            microsecond=0,
            tzinfo="UTC",
            utc_offset=0,
        ),
        description="Datetime to convert",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.date.DatetimeToDate

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.date
from nodetool.workflows.base_node import BaseNode
import nodetool.nodes.lib.date


class FormatDateTime(SingleOutputGraphNode[str], GraphNode[str]):
    """
    Convert a datetime object to a formatted string.
    datetime, format, convert

    Use cases:
    - Standardize date formats
    - Prepare dates for different systems
    """

    DateFormat: typing.ClassVar[type] = nodetool.nodes.lib.date.DateFormat
    input_datetime: types.Datetime | OutputHandle[types.Datetime] = connect_field(
        default=types.Datetime(
            type="datetime",
            year=0,
            month=0,
            day=0,
            hour=0,
            minute=0,
            second=0,
            microsecond=0,
            tzinfo="UTC",
            utc_offset=0,
        ),
        description="Datetime object to format",
    )
    output_format: nodetool.nodes.lib.date.DateFormat = Field(
        default=nodetool.nodes.lib.date.DateFormat.HUMAN_READABLE,
        description="Desired output format",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.date.FormatDateTime

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.date
from nodetool.workflows.base_node import BaseNode


class GetQuarter(GraphNode[nodetool.nodes.lib.date.GetQuarter.OutputType]):
    """
    Get the quarter number and start/end dates for a given datetime.
    datetime, quarter, period

    Use cases:
    - Financial reporting periods
    - Quarterly analytics
    """

    input_datetime: types.Datetime | OutputHandle[types.Datetime] = connect_field(
        default=types.Datetime(
            type="datetime",
            year=0,
            month=0,
            day=0,
            hour=0,
            minute=0,
            second=0,
            microsecond=0,
            tzinfo="UTC",
            utc_offset=0,
        ),
        description="Input datetime",
    )

    @property
    def out(self) -> "GetQuarterOutputs":
        return GetQuarterOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.date.GetQuarter

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class GetQuarterOutputs(OutputsProxy):
    @property
    def quarter(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self["quarter"])

    @property
    def quarter_start(self) -> OutputHandle[types.Datetime]:
        return typing.cast(OutputHandle[types.Datetime], self["quarter_start"])

    @property
    def quarter_end(self) -> OutputHandle[types.Datetime]:
        return typing.cast(OutputHandle[types.Datetime], self["quarter_end"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.date
from nodetool.workflows.base_node import BaseNode


class GetWeekday(SingleOutputGraphNode[str | int], GraphNode[str | int]):
    """
    Get the weekday name or number from a datetime.
    datetime, weekday, name

    Use cases:
    - Get day names for scheduling
    - Filter events by weekday
    """

    input_datetime: types.Datetime | OutputHandle[types.Datetime] = connect_field(
        default=types.Datetime(
            type="datetime",
            year=0,
            month=0,
            day=0,
            hour=0,
            minute=0,
            second=0,
            microsecond=0,
            tzinfo="UTC",
            utc_offset=0,
        ),
        description="Input datetime",
    )
    as_name: bool | OutputHandle[bool] = connect_field(
        default=True, description="Return weekday name instead of number (0-6)"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.date.GetWeekday

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.date
from nodetool.workflows.base_node import BaseNode


class IsDateInRange(SingleOutputGraphNode[bool], GraphNode[bool]):
    """
    Check if a date falls within a specified range.
    datetime, range, check

    Use cases:
    - Validate date ranges
    - Filter date-based data
    """

    check_date: types.Datetime | OutputHandle[types.Datetime] = connect_field(
        default=types.Datetime(
            type="datetime",
            year=0,
            month=0,
            day=0,
            hour=0,
            minute=0,
            second=0,
            microsecond=0,
            tzinfo="UTC",
            utc_offset=0,
        ),
        description="Date to check",
    )
    start_date: types.Datetime | OutputHandle[types.Datetime] = connect_field(
        default=types.Datetime(
            type="datetime",
            year=0,
            month=0,
            day=0,
            hour=0,
            minute=0,
            second=0,
            microsecond=0,
            tzinfo="UTC",
            utc_offset=0,
        ),
        description="Start of date range",
    )
    end_date: types.Datetime | OutputHandle[types.Datetime] = connect_field(
        default=types.Datetime(
            type="datetime",
            year=0,
            month=0,
            day=0,
            hour=0,
            minute=0,
            second=0,
            microsecond=0,
            tzinfo="UTC",
            utc_offset=0,
        ),
        description="End of date range",
    )
    inclusive: bool | OutputHandle[bool] = connect_field(
        default=True, description="Include start and end dates in range"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.date.IsDateInRange

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.date
from nodetool.workflows.base_node import BaseNode


class Now(SingleOutputGraphNode[types.Datetime], GraphNode[types.Datetime]):
    """
    Get the current date and time.
    datetime, current, now
    """

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.date.Now

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.date
from nodetool.workflows.base_node import BaseNode
import nodetool.nodes.lib.date


class ParseDate(SingleOutputGraphNode[types.Date], GraphNode[types.Date]):
    """
    Parse a date string into components.
    date, parse, format
    """

    DateFormat: typing.ClassVar[type] = nodetool.nodes.lib.date.DateFormat
    date_string: str | OutputHandle[str] = connect_field(
        default="", description="The date string to parse"
    )
    input_format: nodetool.nodes.lib.date.DateFormat = Field(
        default=nodetool.nodes.lib.date.DateFormat.ISO,
        description="Format of the input date string",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.date.ParseDate

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.date
from nodetool.workflows.base_node import BaseNode
import nodetool.nodes.lib.date


class ParseDateTime(SingleOutputGraphNode[types.Datetime], GraphNode[types.Datetime]):
    """
    Parse a date/time string into components.
    datetime, parse, format

    Use cases:
    - Extract date components from strings
    - Convert between date formats
    """

    DateFormat: typing.ClassVar[type] = nodetool.nodes.lib.date.DateFormat
    datetime_string: str | OutputHandle[str] = connect_field(
        default="", description="The datetime string to parse"
    )
    input_format: nodetool.nodes.lib.date.DateFormat = Field(
        default=nodetool.nodes.lib.date.DateFormat.ISO,
        description="Format of the input datetime string",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.date.ParseDateTime

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.date
from nodetool.workflows.base_node import BaseNode
import nodetool.nodes.lib.date
import nodetool.nodes.lib.date


class RelativeTime(SingleOutputGraphNode[types.Datetime], GraphNode[types.Datetime]):
    """
    Get datetime relative to current time (past or future).
    datetime, past, future, relative, hours, days, months

    Use cases:
    - Calculate past or future dates
    - Generate relative timestamps
    """

    TimeUnitType: typing.ClassVar[type] = nodetool.nodes.lib.date.TimeUnitType
    TimeDirection: typing.ClassVar[type] = nodetool.nodes.lib.date.TimeDirection
    amount: int | OutputHandle[int] = connect_field(
        default=1, description="Amount of time units"
    )
    unit: nodetool.nodes.lib.date.TimeUnitType = Field(
        default=nodetool.nodes.lib.date.TimeUnitType.DAYS, description="Time unit type"
    )
    direction: nodetool.nodes.lib.date.TimeDirection = Field(
        default=nodetool.nodes.lib.date.TimeDirection.FUTURE,
        description="Past or future",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.date.RelativeTime

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.date
from nodetool.workflows.base_node import BaseNode


class Today(SingleOutputGraphNode[types.Date], GraphNode[types.Date]):
    """
    Get the current date.
    date, today, now
    """

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.date.Today

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
