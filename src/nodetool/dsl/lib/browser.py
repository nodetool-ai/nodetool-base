# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.browser
from nodetool.workflows.base_node import BaseNode


class Browser(GraphNode[nodetool.nodes.lib.browser.Browser.OutputType]):
    """

    Fetches content from a web page using a headless browser.
    browser, web, scraping, content, fetch

    Use cases:
    - Extract content from JavaScript-heavy websites
    - Retrieve text content from web pages
    - Get metadata from web pages
    - Save extracted content to files
    """

    url: str | OutputHandle[str] = connect_field(
        default="", description="URL to navigate to"
    )
    timeout: int | OutputHandle[int] = connect_field(
        default=20000, description="Timeout in milliseconds for page navigation"
    )

    @property
    def out(self) -> "BrowserOutputs":
        return BrowserOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.browser.Browser

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class BrowserOutputs(OutputsProxy):
    @property
    def success(self) -> OutputHandle[bool]:
        return typing.cast(OutputHandle[bool], self["success"])

    @property
    def content(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["content"])

    @property
    def metadata(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self["metadata"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.browser
from nodetool.workflows.base_node import BaseNode


class BrowserNavigation(SingleOutputGraphNode[typing.Any], GraphNode[typing.Any]):
    """

    Navigates and interacts with web pages in a browser session.
    browser, navigation, interaction, click, extract

    Use cases:
    - Perform complex web interactions
    - Navigate through multi-step web processes
    - Extract content after interaction
    """

    Action: typing.ClassVar[type] = nodetool.nodes.lib.browser.BrowserNavigation.Action
    ExtractType: typing.ClassVar[type] = (
        nodetool.nodes.lib.browser.BrowserNavigation.ExtractType
    )

    url: str | OutputHandle[str] = connect_field(
        default="", description="URL to navigate to (required for 'goto' action)"
    )
    action: nodetool.nodes.lib.browser.BrowserNavigation.Action = Field(
        default=nodetool.nodes.lib.browser.BrowserNavigation.Action.GOTO,
        description="Navigation or extraction action to perform",
    )
    selector: str | OutputHandle[str] = connect_field(
        default="",
        description="CSS selector for the element to interact with or extract from",
    )
    timeout: int | OutputHandle[int] = connect_field(
        default=30000, description="Timeout in milliseconds for the action"
    )
    wait_for: str | OutputHandle[str] = connect_field(
        default="",
        description="Optional selector to wait for after performing the action",
    )
    extract_type: nodetool.nodes.lib.browser.BrowserNavigation.ExtractType = Field(
        default=nodetool.nodes.lib.browser.BrowserNavigation.ExtractType.TEXT,
        description="Type of content to extract (for 'extract' action)",
    )
    attribute: str | OutputHandle[str] = connect_field(
        default="",
        description="Attribute name to extract (when extract_type is 'attribute')",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.browser.BrowserNavigation

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.browser
from nodetool.workflows.base_node import BaseNode


class BrowserUseNode(GraphNode[nodetool.nodes.lib.browser.BrowserUseNode.OutputType]):
    """

    Browser agent tool that uses browser_use under the hood.

    This module provides a tool for running browser-based agents using the browser_use library.
    The agent can perform complex web automation tasks like form filling, navigation, data extraction,
    and multi-step workflows using natural language instructions.

    Use cases:
    - Perform complex web automation tasks based on natural language.
    - Automate form filling and data entry.
    - Scrape data after complex navigation or interaction sequences.
    - Automate multi-step web workflows.
    """

    BrowserUseModel: typing.ClassVar[type] = nodetool.nodes.lib.browser.BrowserUseModel

    model: nodetool.nodes.lib.browser.BrowserUseModel = Field(
        default=nodetool.nodes.lib.browser.BrowserUseModel.GPT_4O,
        description="The model to use for the browser agent.",
    )
    task: str | OutputHandle[str] = connect_field(
        default="",
        description="Natural language description of the browser task to perform. Can include complex multi-step instructions like 'Compare prices between websites', 'Fill out forms', or 'Extract specific data'.",
    )
    timeout: int | OutputHandle[int] = connect_field(
        default=300,
        description="Maximum time in seconds to allow for task completion. Complex tasks may require longer timeouts.",
    )
    use_remote_browser: bool | OutputHandle[bool] = connect_field(
        default=True, description="Use a remote browser instead of a local one"
    )

    @property
    def out(self) -> "BrowserUseNodeOutputs":
        return BrowserUseNodeOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.browser.BrowserUseNode

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class BrowserUseNodeOutputs(OutputsProxy):
    @property
    def success(self) -> OutputHandle[bool]:
        return typing.cast(OutputHandle[bool], self["success"])

    @property
    def task(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["task"])

    @property
    def result(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self["result"])

    @property
    def error(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["error"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.browser
from nodetool.workflows.base_node import BaseNode


class DownloadFile(SingleOutputGraphNode[bytes], GraphNode[bytes]):
    """

    Downloads a file from a URL and saves it to disk.
    download, file, web, save

    Use cases:
    - Download documents, images, or other files from the web
    - Save data for further processing
    - Retrieve file assets for analysis
    """

    url: str | OutputHandle[str] = connect_field(
        default="", description="URL of the file to download"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.browser.DownloadFile

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.browser
from nodetool.workflows.base_node import BaseNode


class Screenshot(SingleOutputGraphNode[typing.Any], GraphNode[typing.Any]):
    """

    Takes a screenshot of a web page or specific element.
    browser, screenshot, capture, image

    Use cases:
    - Capture visual representation of web pages
    - Document specific UI elements
    - Create visual records of web content
    """

    url: str | OutputHandle[str] = connect_field(
        default="", description="URL to navigate to before taking screenshot"
    )
    selector: str | OutputHandle[str] = connect_field(
        default="", description="Optional CSS selector for capturing a specific element"
    )
    output_file: str | OutputHandle[str] = connect_field(
        default="screenshot.png",
        description="Path to save the screenshot (relative to workspace)",
    )
    timeout: int | OutputHandle[int] = connect_field(
        default=30000, description="Timeout in milliseconds for page navigation"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.browser.Screenshot

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.browser
from nodetool.workflows.base_node import BaseNode


class WebFetch(SingleOutputGraphNode[str], GraphNode[str]):
    """

    Fetches HTML content from a URL and converts it to text.
    web, fetch, html, markdown, http

    Use cases:
    - Extract text content from web pages
    - Process web content for analysis
    - Save web content to files
    """

    url: str | OutputHandle[str] = connect_field(
        default="", description="URL to fetch content from"
    )
    selector: str | OutputHandle[str] = connect_field(
        default="body", description="CSS selector to extract specific elements"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.browser.WebFetch

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
