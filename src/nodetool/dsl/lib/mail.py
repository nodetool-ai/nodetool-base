# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.mail
from nodetool.workflows.base_node import BaseNode


class AddLabel(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

    Adds a label to a Gmail message.
    email, gmail, label
    """

    message_id: str | OutputHandle[str] = connect_field(
        default="", description="Message ID to label"
    )
    label: str | OutputHandle[str] = connect_field(
        default="", description="Label to add to the message"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.mail.AddLabel

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.mail
from nodetool.workflows.base_node import BaseNode


class EmailFields(GraphNode[nodetool.nodes.lib.mail.EmailFields.OutputType]):
    """

    Decomposes an email into its individual components.
    email, decompose, extract

    Takes an Email object and returns its individual fields:
    - id: Message ID
    - subject: Email subject
    - sender: Sender address
    - date: Datetime of email
    - body: Email body content
    """

    email: types.Email | OutputHandle[types.Email] = connect_field(
        default=types.Email(
            type="email",
            id="",
            sender="",
            subject="",
            date=types.Datetime(
                type="datetime",
                year=0,
                month=0,
                day=0,
                hour=0,
                minute=0,
                second=0,
                microsecond=0,
                tzinfo="UTC",
                utc_offset=0,
            ),
            body="",
        ),
        description="Email object to decompose",
    )

    @property
    def out(self) -> "EmailFieldsOutputs":
        return EmailFieldsOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.mail.EmailFields

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class EmailFieldsOutputs(OutputsProxy):
    @property
    def id(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["id"])

    @property
    def subject(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["subject"])

    @property
    def sender(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["sender"])

    @property
    def date(self) -> OutputHandle[types.Datetime]:
        return typing.cast(OutputHandle[types.Datetime], self["date"])

    @property
    def body(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["body"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.mail
from nodetool.workflows.base_node import BaseNode


class GmailSearch(GraphNode[nodetool.nodes.lib.mail.GmailSearch.OutputType]):
    """

    Searches Gmail using Gmail-specific search operators and yields matching emails.
    email, gmail, search

    Use cases:
    - Search for emails based on specific criteria
    - Retrieve emails from a specific sender
    - Filter emails by subject, sender, or date
    """

    DateFilter: typing.ClassVar[type] = nodetool.nodes.lib.mail.GmailSearch.DateFilter
    GmailFolder: typing.ClassVar[type] = nodetool.nodes.lib.mail.GmailSearch.GmailFolder

    from_address: str | OutputHandle[str] = connect_field(
        default="", description="Sender's email address to search for"
    )
    to_address: str | OutputHandle[str] = connect_field(
        default="", description="Recipient's email address to search for"
    )
    subject: str | OutputHandle[str] = connect_field(
        default="", description="Text to search for in email subject"
    )
    body: str | OutputHandle[str] = connect_field(
        default="", description="Text to search for in email body"
    )
    date_filter: nodetool.nodes.lib.mail.GmailSearch.DateFilter = Field(
        default=nodetool.nodes.lib.mail.GmailSearch.DateFilter.SINCE_ONE_DAY,
        description="Date filter to search for",
    )
    keywords: str | OutputHandle[str] = connect_field(
        default="", description="Custom keywords or labels to search for"
    )
    folder: nodetool.nodes.lib.mail.GmailSearch.GmailFolder = Field(
        default=nodetool.nodes.lib.mail.GmailSearch.GmailFolder.INBOX,
        description="Email folder to search in",
    )
    text: str | OutputHandle[str] = connect_field(
        default="", description="General text to search for anywhere in the email"
    )
    max_results: int | OutputHandle[int] = connect_field(
        default=50, description="Maximum number of emails to return"
    )
    retry_attempts: int | OutputHandle[int] = connect_field(
        default=3, description="Maximum retry attempts for Gmail operations"
    )
    retry_base_delay: float | OutputHandle[float] = connect_field(
        default=0.5, description="Base delay (seconds) for exponential backoff"
    )
    retry_max_delay: float | OutputHandle[float] = connect_field(
        default=5.0, description="Maximum delay (seconds) for exponential backoff"
    )
    retry_factor: float | OutputHandle[float] = connect_field(
        default=2.0, description="Exponential growth factor for backoff"
    )
    retry_jitter: float | OutputHandle[float] = connect_field(
        default=0.1, description="Random jitter (seconds) added to each backoff"
    )

    @property
    def out(self) -> "GmailSearchOutputs":
        return GmailSearchOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.mail.GmailSearch

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class GmailSearchOutputs(OutputsProxy):
    @property
    def email(self) -> OutputHandle[types.Email]:
        return typing.cast(OutputHandle[types.Email], self["email"])

    @property
    def message_id(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["message_id"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.mail
from nodetool.workflows.base_node import BaseNode


class MoveToArchive(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

    Moves specified emails to Gmail archive.
    email, gmail, archive
    """

    message_id: str | OutputHandle[str] = connect_field(
        default="", description="Message ID to archive"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.mail.MoveToArchive

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.mail
from nodetool.workflows.base_node import BaseNode


class SendEmail(SingleOutputGraphNode[bool], GraphNode[bool]):
    """
    Send a plain text email via SMTP.
        email, smtp, send

        Use cases:
        - Send simple notification messages
        - Automate email reports
    """

    smtp_server: str | OutputHandle[str] = connect_field(
        default="smtp.gmail.com", description="SMTP server hostname"
    )
    smtp_port: int | OutputHandle[int] = connect_field(
        default=587, description="SMTP server port"
    )
    username: str | OutputHandle[str] = connect_field(
        default="", description="SMTP username"
    )
    password: str | OutputHandle[str] = connect_field(
        default="", description="SMTP password"
    )
    from_address: str | OutputHandle[str] = connect_field(
        default="", description="Sender email address"
    )
    to_address: str | OutputHandle[str] = connect_field(
        default="", description="Recipient email address"
    )
    subject: str | OutputHandle[str] = connect_field(
        default="", description="Email subject"
    )
    body: str | OutputHandle[str] = connect_field(default="", description="Email body")
    retry_attempts: int | OutputHandle[int] = connect_field(
        default=3, description="Maximum retry attempts for SMTP send"
    )
    retry_base_delay: float | OutputHandle[float] = connect_field(
        default=0.5, description="Base delay (seconds) for exponential backoff"
    )
    retry_max_delay: float | OutputHandle[float] = connect_field(
        default=5.0, description="Maximum delay (seconds) for exponential backoff"
    )
    retry_factor: float | OutputHandle[float] = connect_field(
        default=2.0, description="Exponential growth factor for backoff"
    )
    retry_jitter: float | OutputHandle[float] = connect_field(
        default=0.1, description="Random jitter (seconds) added to each backoff"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.mail.SendEmail

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
