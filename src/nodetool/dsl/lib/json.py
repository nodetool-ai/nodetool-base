# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode

class FilterJSON(SingleOutputGraphNode[list[dict]], GraphNode[list[dict]]):
    """

        Filter JSON array based on a key-value condition.
        json, filter, array

        Use cases:
        - Filter arrays of objects
        - Search JSON data
    """

    array: list[dict] | OutputHandle[list[dict]] = connect_field(default=[], description='Array of JSON objects to filter')
    key: str | OutputHandle[str] = connect_field(default='', description='Key to filter on')
    value: Any | OutputHandle[Any] = connect_field(default={}, description='Value to match')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.FilterJSON

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode

class GetJSONPathBool(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

        Extract a boolean value from a JSON path
        json, path, extract, boolean
    """

    data: Any | OutputHandle[Any] = connect_field(default={}, description='JSON object to extract from')
    path: str | OutputHandle[str] = connect_field(default='', description='Path to the desired value (dot notation)')
    default: bool | OutputHandle[bool] = connect_field(default=False, description='Default value to return if path is not found')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.GetJSONPathBool

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode

class GetJSONPathDict(SingleOutputGraphNode[dict], GraphNode[dict]):
    """

        Extract a dictionary value from a JSON path
        json, path, extract, object
    """

    data: Any | OutputHandle[Any] = connect_field(default={}, description='JSON object to extract from')
    path: str | OutputHandle[str] = connect_field(default='', description='Path to the desired value (dot notation)')
    default: dict | OutputHandle[dict] = connect_field(default={}, description='Default value to return if path is not found')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.GetJSONPathDict

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode

class GetJSONPathFloat(SingleOutputGraphNode[float], GraphNode[float]):
    """

        Extract a float value from a JSON path
        json, path, extract, number
    """

    data: Any | OutputHandle[Any] = connect_field(default={}, description='JSON object to extract from')
    path: str | OutputHandle[str] = connect_field(default='', description='Path to the desired value (dot notation)')
    default: float | OutputHandle[float] = connect_field(default=0.0, description='Default value to return if path is not found')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.GetJSONPathFloat

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode

class GetJSONPathInt(SingleOutputGraphNode[int], GraphNode[int]):
    """

        Extract an integer value from a JSON path
        json, path, extract, number
    """

    data: Any | OutputHandle[Any] = connect_field(default={}, description='JSON object to extract from')
    path: str | OutputHandle[str] = connect_field(default='', description='Path to the desired value (dot notation)')
    default: int | OutputHandle[int] = connect_field(default=0, description='Default value to return if path is not found')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.GetJSONPathInt

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode

class GetJSONPathList(SingleOutputGraphNode[list], GraphNode[list]):
    """

        Extract a list value from a JSON path
        json, path, extract, array
    """

    data: Any | OutputHandle[Any] = connect_field(default={}, description='JSON object to extract from')
    path: str | OutputHandle[str] = connect_field(default='', description='Path to the desired value (dot notation)')
    default: list | OutputHandle[list] = connect_field(default=[], description='Default value to return if path is not found')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.GetJSONPathList

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode

class GetJSONPathStr(SingleOutputGraphNode[str], GraphNode[str]):
    """

        Extract a string value from a JSON path
        json, path, extract, string
    """

    data: Any | OutputHandle[Any] = connect_field(default={}, description='JSON object to extract from')
    path: str | OutputHandle[str] = connect_field(default='', description='Path to the desired value (dot notation)')
    default: str | OutputHandle[str] = connect_field(default='', description='Default value to return if path is not found')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.GetJSONPathStr

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode

class JSONTemplate(SingleOutputGraphNode[dict], GraphNode[dict]):
    """

        Template JSON strings with variable substitution.
        json, template, substitute, variables

        Example:
        template: '{"name": "$user", "age": $age}'
        values: {"user": "John", "age": 30}
        result: '{"name": "John", "age": 30}'

        Use cases:
        - Create dynamic JSON payloads
        - Generate JSON with variable data
        - Build API request templates
    """

    template: str | OutputHandle[str] = connect_field(default='', description='JSON template string with $variable placeholders')
    values: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(default={}, description='Dictionary of values to substitute into the template')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.JSONTemplate

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode

class LoadJSONAssets(GraphNode[nodetool.nodes.lib.json.LoadJSONAssets.OutputType]):
    """

        Load JSON files from an asset folder.
        load, json, file, import
    """

    folder: types.FolderRef | OutputHandle[types.FolderRef] = connect_field(default=types.FolderRef(type='folder', uri='', asset_id=None, data=None, metadata=None), description='The asset folder to load the JSON files from.')

    @property
    def out(self) -> "LoadJSONAssetsOutputs":
        return LoadJSONAssetsOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.LoadJSONAssets

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()

class LoadJSONAssetsOutputs(OutputsProxy):
    @property
    def json(self) -> OutputHandle[dict]:
        return typing.cast(OutputHandle[dict], self['json'])

    @property
    def name(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self['name'])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode

class ParseDict(SingleOutputGraphNode[dict], GraphNode[dict]):
    """

        Parse a JSON string into a Python dictionary.
        json, parse, decode, dictionary

        Use cases:
        - Convert JSON API responses to Python dictionaries
        - Process JSON configuration files
        - Parse object-like JSON data
    """

    json_string: str | OutputHandle[str] = connect_field(default='', description='JSON string to parse into a dictionary')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.ParseDict

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode

class ParseList(SingleOutputGraphNode[list], GraphNode[list]):
    """

        Parse a JSON string into a Python list.
        json, parse, decode, array, list

        Use cases:
        - Convert JSON array responses to Python lists
        - Process JSON data collections
        - Parse array-like JSON data
    """

    json_string: str | OutputHandle[str] = connect_field(default='', description='JSON string to parse into a list')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.ParseList

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode

class StringifyJSON(SingleOutputGraphNode[str], GraphNode[str]):
    """

        Convert a Python object to a formatted JSON string.
        json, stringify, encode, serialize

        Use cases:
        - Prepare data for API requests
        - Save data in JSON format
        - Format data for storage or transmission
        - Create human-readable JSON output
    """

    data: Any | OutputHandle[Any] = connect_field(default={}, description='Data to convert to JSON')
    indent: int | OutputHandle[int] = connect_field(default=2, description='Number of spaces for indentation')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.StringifyJSON

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode

class ValidateJSON(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

        Validate JSON data against a schema.
        json, validate, schema

        Use cases:
        - Ensure API payloads match specifications
        - Validate configuration files
    """

    data: Any | OutputHandle[Any] = connect_field(default={}, description='JSON data to validate')
    json_schema: dict | OutputHandle[dict] = connect_field(default={}, description='JSON schema for validation')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.ValidateJSON

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


