# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json


class FilterJSON(GraphNode[list[dict]]):
    """
    Filter JSON array based on a key-value condition.
    json, filter, array

    Use cases:
    - Filter arrays of objects
    - Search JSON data
    """

    array: list[dict] | OutputHandle[list[dict]] = connect_field(
        default=[], description="Array of JSON objects to filter"
    )
    key: str | OutputHandle[str] = connect_field(
        default="", description="Key to filter on"
    )
    value: Any | OutputHandle[Any] = connect_field(
        default=None, description="Value to match"
    )

    @property
    def output(self) -> OutputHandle[list[dict]]:
        return typing.cast(OutputHandle[list[dict]], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.json.FilterJSON"


FilterJSON.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json


class GetJSONPathBool(GraphNode[bool]):
    """
    Extract a boolean value from a JSON path
    json, path, extract, boolean
    """

    data: Any | OutputHandle[Any] = connect_field(
        default=None, description="JSON object to extract from"
    )
    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to the desired value (dot notation)"
    )
    default: bool | OutputHandle[bool] = connect_field(
        default=False, description="Default value to return if path is not found"
    )

    @property
    def output(self) -> OutputHandle[bool]:
        return typing.cast(OutputHandle[bool], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.json.GetJSONPathBool"


GetJSONPathBool.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json


class GetJSONPathDict(GraphNode[dict]):
    """
    Extract a dictionary value from a JSON path
    json, path, extract, object
    """

    data: Any | OutputHandle[Any] = connect_field(
        default=None, description="JSON object to extract from"
    )
    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to the desired value (dot notation)"
    )
    default: dict | OutputHandle[dict] = connect_field(
        default={}, description="Default value to return if path is not found"
    )

    @property
    def output(self) -> OutputHandle[dict]:
        return typing.cast(OutputHandle[dict], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.json.GetJSONPathDict"


GetJSONPathDict.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json


class GetJSONPathFloat(GraphNode[float]):
    """
    Extract a float value from a JSON path
    json, path, extract, number
    """

    data: Any | OutputHandle[Any] = connect_field(
        default=None, description="JSON object to extract from"
    )
    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to the desired value (dot notation)"
    )
    default: float | OutputHandle[float] = connect_field(
        default=0.0, description="Default value to return if path is not found"
    )

    @property
    def output(self) -> OutputHandle[float]:
        return typing.cast(OutputHandle[float], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.json.GetJSONPathFloat"


GetJSONPathFloat.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json


class GetJSONPathInt(GraphNode[int]):
    """
    Extract an integer value from a JSON path
    json, path, extract, number
    """

    data: Any | OutputHandle[Any] = connect_field(
        default=None, description="JSON object to extract from"
    )
    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to the desired value (dot notation)"
    )
    default: int | OutputHandle[int] = connect_field(
        default=0, description="Default value to return if path is not found"
    )

    @property
    def output(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.json.GetJSONPathInt"


GetJSONPathInt.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json


class GetJSONPathList(GraphNode[list]):
    """
    Extract a list value from a JSON path
    json, path, extract, array
    """

    data: Any | OutputHandle[Any] = connect_field(
        default=None, description="JSON object to extract from"
    )
    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to the desired value (dot notation)"
    )
    default: list | OutputHandle[list] = connect_field(
        default=[], description="Default value to return if path is not found"
    )

    @property
    def output(self) -> OutputHandle[list]:
        return typing.cast(OutputHandle[list], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.json.GetJSONPathList"


GetJSONPathList.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json


class GetJSONPathStr(GraphNode[str]):
    """
    Extract a string value from a JSON path
    json, path, extract, string
    """

    data: Any | OutputHandle[Any] = connect_field(
        default=None, description="JSON object to extract from"
    )
    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to the desired value (dot notation)"
    )
    default: str | OutputHandle[str] = connect_field(
        default="", description="Default value to return if path is not found"
    )

    @property
    def output(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.json.GetJSONPathStr"


GetJSONPathStr.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json


class JSONTemplate(GraphNode[dict]):
    """
    Template JSON strings with variable substitution.
    json, template, substitute, variables

    Example:
    template: '{"name": "$user", "age": $age}'
    values: {"user": "John", "age": 30}
    result: '{"name": "John", "age": 30}'

    Use cases:
    - Create dynamic JSON payloads
    - Generate JSON with variable data
    - Build API request templates
    """

    template: str | OutputHandle[str] = connect_field(
        default="", description="JSON template string with $variable placeholders"
    )
    values: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description="Dictionary of values to substitute into the template"
    )

    @property
    def output(self) -> OutputHandle[dict]:
        return typing.cast(OutputHandle[dict], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.json.JSONTemplate"


JSONTemplate.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json


class LoadJSONAssets(GraphNode[nodetool.nodes.lib.json.LoadJSONAssets.OutputType]):
    """
    Load JSON files from an asset folder.
    load, json, file, import
    """

    folder: types.FolderRef | OutputHandle[types.FolderRef] = connect_field(
        default=types.FolderRef(type="folder", uri="", asset_id=None, data=None),
        description="The asset folder to load the JSON files from.",
    )

    @property
    def out(self) -> "LoadJSONAssetsOutputs":
        return LoadJSONAssetsOutputs(self)

    @classmethod
    def get_node_type(cls):
        return "lib.json.LoadJSONAssets"


class LoadJSONAssetsOutputs(OutputsProxy):
    @property
    def json(self) -> OutputHandle[dict]:
        return typing.cast(OutputHandle[dict], self["json"])

    @property
    def name(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["name"])


LoadJSONAssets.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json


class ParseDict(GraphNode[dict]):
    """
    Parse a JSON string into a Python dictionary.
    json, parse, decode, dictionary

    Use cases:
    - Convert JSON API responses to Python dictionaries
    - Process JSON configuration files
    - Parse object-like JSON data
    """

    json_string: str | OutputHandle[str] = connect_field(
        default="", description="JSON string to parse into a dictionary"
    )

    @property
    def output(self) -> OutputHandle[dict]:
        return typing.cast(OutputHandle[dict], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.json.ParseDict"


ParseDict.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json


class ParseList(GraphNode[list]):
    """
    Parse a JSON string into a Python list.
    json, parse, decode, array, list

    Use cases:
    - Convert JSON array responses to Python lists
    - Process JSON data collections
    - Parse array-like JSON data
    """

    json_string: str | OutputHandle[str] = connect_field(
        default="", description="JSON string to parse into a list"
    )

    @property
    def output(self) -> OutputHandle[list]:
        return typing.cast(OutputHandle[list], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.json.ParseList"


ParseList.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json


class StringifyJSON(GraphNode[str]):
    """
    Convert a Python object to a JSON string.
    json, stringify, encode

    Use cases:
    - Prepare data for API requests
    - Save data in JSON format
    """

    data: Any | OutputHandle[Any] = connect_field(
        default={}, description="Data to convert to JSON"
    )
    indent: int | OutputHandle[int] = connect_field(
        default=2, description="Number of spaces for indentation"
    )

    @property
    def output(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.json.StringifyJSON"


StringifyJSON.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json


class ValidateJSON(GraphNode[bool]):
    """
    Validate JSON data against a schema.
    json, validate, schema

    Use cases:
    - Ensure API payloads match specifications
    - Validate configuration files
    """

    data: Any | OutputHandle[Any] = connect_field(
        default=None, description="JSON data to validate"
    )
    json_schema: dict | OutputHandle[dict] = connect_field(
        default={}, description="JSON schema for validation"
    )

    @property
    def output(self) -> OutputHandle[bool]:
        return typing.cast(OutputHandle[bool], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.json.ValidateJSON"


ValidateJSON.model_rebuild(force=True)
