# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode


class FilterJSON(SingleOutputGraphNode[list[dict]], GraphNode[list[dict]]):
    """

    Filter JSON array based on a key-value condition.
    json, filter, array

    Use cases:
    - Filter arrays of objects
    - Search JSON data
    """

    array: list[dict] | OutputHandle[list[dict]] = connect_field(
        default=[], description="Array of JSON objects to filter"
    )
    key: str | OutputHandle[str] = connect_field(
        default="", description="Key to filter on"
    )
    value: Any | OutputHandle[Any] = connect_field(
        default=None, description="Value to match"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.FilterJSON

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode


class GetJSONPathBool(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

    Extract a boolean value from a JSON path
    json, path, extract, boolean
    """

    data: Any | OutputHandle[Any] = connect_field(
        default=None, description="JSON object to extract from"
    )
    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to the desired value (dot notation)"
    )
    default: bool | OutputHandle[bool] = connect_field(
        default=False, description="Default value to return if path is not found"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.GetJSONPathBool

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode


class GetJSONPathDict(SingleOutputGraphNode[dict], GraphNode[dict]):
    """

    Extract a dictionary value from a JSON path
    json, path, extract, object
    """

    data: Any | OutputHandle[Any] = connect_field(
        default=None, description="JSON object to extract from"
    )
    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to the desired value (dot notation)"
    )
    default: dict | OutputHandle[dict] = connect_field(
        default={}, description="Default value to return if path is not found"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.GetJSONPathDict

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode


class GetJSONPathFloat(SingleOutputGraphNode[float], GraphNode[float]):
    """

    Extract a float value from a JSON path
    json, path, extract, number
    """

    data: Any | OutputHandle[Any] = connect_field(
        default=None, description="JSON object to extract from"
    )
    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to the desired value (dot notation)"
    )
    default: float | OutputHandle[float] = connect_field(
        default=0.0, description="Default value to return if path is not found"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.GetJSONPathFloat

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode


class GetJSONPathInt(SingleOutputGraphNode[int], GraphNode[int]):
    """

    Extract an integer value from a JSON path
    json, path, extract, number
    """

    data: Any | OutputHandle[Any] = connect_field(
        default=None, description="JSON object to extract from"
    )
    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to the desired value (dot notation)"
    )
    default: int | OutputHandle[int] = connect_field(
        default=0, description="Default value to return if path is not found"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.GetJSONPathInt

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode


class GetJSONPathList(SingleOutputGraphNode[list], GraphNode[list]):
    """

    Extract a list value from a JSON path
    json, path, extract, array
    """

    data: Any | OutputHandle[Any] = connect_field(
        default=None, description="JSON object to extract from"
    )
    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to the desired value (dot notation)"
    )
    default: list | OutputHandle[list] = connect_field(
        default=[], description="Default value to return if path is not found"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.GetJSONPathList

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode


class GetJSONPathStr(SingleOutputGraphNode[str], GraphNode[str]):
    """

    Extract a string value from a JSON path
    json, path, extract, string
    """

    data: Any | OutputHandle[Any] = connect_field(
        default=None, description="JSON object to extract from"
    )
    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to the desired value (dot notation)"
    )
    default: str | OutputHandle[str] = connect_field(
        default="", description="Default value to return if path is not found"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.GetJSONPathStr

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode


class JSONTemplate(SingleOutputGraphNode[dict], GraphNode[dict]):
    """

    Template JSON strings with variable substitution.
    json, template, substitute, variables

    Example:
    template: '{"name": "$user", "age": $age}'
    values: {"user": "John", "age": 30}
    result: '{"name": "John", "age": 30}'

    Use cases:
    - Create dynamic JSON payloads
    - Generate JSON with variable data
    - Build API request templates
    """

    template: str | OutputHandle[str] = connect_field(
        default="", description="JSON template string with $variable placeholders"
    )
    values: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description="Dictionary of values to substitute into the template"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.JSONTemplate

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode


class LoadJSONAssets(GraphNode[nodetool.nodes.lib.json.LoadJSONAssets.OutputType]):
    """

    Load JSON files from an asset folder.
    load, json, file, import
    """

    folder: types.FolderRef | OutputHandle[types.FolderRef] = connect_field(
        default=types.FolderRef(type="folder", uri="", asset_id=None, data=None),
        description="The asset folder to load the JSON files from.",
    )

    @property
    def out(self) -> "LoadJSONAssetsOutputs":
        return LoadJSONAssetsOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.LoadJSONAssets

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class LoadJSONAssetsOutputs(OutputsProxy):
    @property
    def json(self) -> OutputHandle[dict]:
        return typing.cast(OutputHandle[dict], self["json"])

    @property
    def name(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["name"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode


class ParseDict(SingleOutputGraphNode[dict], GraphNode[dict]):
    """

    Parse a JSON string into a Python dictionary.
    json, parse, decode, dictionary

    Use cases:
    - Convert JSON API responses to Python dictionaries
    - Process JSON configuration files
    - Parse object-like JSON data
    """

    json_string: str | OutputHandle[str] = connect_field(
        default="", description="JSON string to parse into a dictionary"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.ParseDict

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode


class ParseList(SingleOutputGraphNode[list], GraphNode[list]):
    """

    Parse a JSON string into a Python list.
    json, parse, decode, array, list

    Use cases:
    - Convert JSON array responses to Python lists
    - Process JSON data collections
    - Parse array-like JSON data
    """

    json_string: str | OutputHandle[str] = connect_field(
        default="", description="JSON string to parse into a list"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.ParseList

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode


class StringifyJSON(SingleOutputGraphNode[str], GraphNode[str]):
    """

    Convert a Python object to a JSON string.
    json, stringify, encode

    Use cases:
    - Prepare data for API requests
    - Save data in JSON format
    """

    data: Any | OutputHandle[Any] = connect_field(
        default={}, description="Data to convert to JSON"
    )
    indent: int | OutputHandle[int] = connect_field(
        default=2, description="Number of spaces for indentation"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.StringifyJSON

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.json
from nodetool.workflows.base_node import BaseNode


class ValidateJSON(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

    Validate JSON data against a schema.
    json, validate, schema

    Use cases:
    - Ensure API payloads match specifications
    - Validate configuration files
    """

    data: Any | OutputHandle[Any] = connect_field(
        default=None, description="JSON data to validate"
    )
    json_schema: dict | OutputHandle[dict] = connect_field(
        default={}, description="JSON schema for validation"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.json.ValidateJSON

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
