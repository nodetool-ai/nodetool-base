# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

import typing
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.beautifulsoup
from nodetool.workflows.base_node import BaseNode


class BaseUrl(SingleOutputGraphNode[str], GraphNode[str]):
    """

    Extract the base URL from a given URL.
    url parsing, domain extraction, web utilities

    Use cases:
    - Get domain name from full URLs
    - Clean up URLs for comparison
    - Extract root website addresses
    - Standardize URL formats
    """

    url: str | OutputHandle[str] = connect_field(
        default="", description="The URL to extract the base from"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.beautifulsoup.BaseUrl

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


from nodetool.dsl.handles import OutputHandle, connect_field
from nodetool.workflows.base_node import BaseNode


class ExtractAudio(GraphNode[nodetool.nodes.lib.beautifulsoup.ExtractAudio.OutputType]):
    """

    Extract audio elements from HTML content.
    extract, audio, src

    Use cases:
    - Collect audio sources from web pages
    - Analyze audio usage on websites
    - Create audio playlists
    """

    html: str | OutputHandle[str] = connect_field(
        default="", description="The HTML content to extract audio from."
    )
    base_url: str | OutputHandle[str] = connect_field(
        default="",
        description="The base URL of the page, used to resolve relative audio URLs.",
    )

    @property
    def out(self) -> "ExtractAudioOutputs":
        return ExtractAudioOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.beautifulsoup.ExtractAudio

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class ExtractAudioOutputs(OutputsProxy):
    @property
    def audio(self) -> OutputHandle[types.AudioRef]:
        return typing.cast(OutputHandle[types.AudioRef], self["audio"])


from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.beautifulsoup
from nodetool.workflows.base_node import BaseNode


class ExtractImages(
    GraphNode[nodetool.nodes.lib.beautifulsoup.ExtractImages.OutputType]
):
    """

    Extract images from HTML content.
    extract, images, src

    Use cases:
    - Collect images from web pages
    - Analyze image usage on websites
    - Create image galleries
    """

    html: str | OutputHandle[str] = connect_field(
        default="", description="The HTML content to extract images from."
    )
    base_url: str | OutputHandle[str] = connect_field(
        default="",
        description="The base URL of the page, used to resolve relative image URLs.",
    )

    @property
    def out(self) -> "ExtractImagesOutputs":
        return ExtractImagesOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.beautifulsoup.ExtractImages

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class ExtractImagesOutputs(OutputsProxy):
    @property
    def image(self) -> OutputHandle[types.ImageRef]:
        return typing.cast(OutputHandle[types.ImageRef], self["image"])


from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.beautifulsoup
from nodetool.workflows.base_node import BaseNode


class ExtractLinks(GraphNode[nodetool.nodes.lib.beautifulsoup.ExtractLinks.OutputType]):
    """

    Extract links from HTML content.
    extract, links, urls

    Use cases:
    - Analyze website structure
    - Discover related content
    - Build sitemaps
    """

    html: str | OutputHandle[str] = connect_field(
        default="", description="The HTML content to extract links from."
    )
    base_url: str | OutputHandle[str] = connect_field(
        default="",
        description="The base URL of the page, used to determine internal/external links.",
    )

    @property
    def out(self) -> "ExtractLinksOutputs":
        return ExtractLinksOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.beautifulsoup.ExtractLinks

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class ExtractLinksOutputs(OutputsProxy):
    @property
    def href(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["href"])

    @property
    def text(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["text"])

    @property
    def type(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["type"])


from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.beautifulsoup
from nodetool.workflows.base_node import BaseNode


class ExtractMetadata(
    GraphNode[nodetool.nodes.lib.beautifulsoup.ExtractMetadata.OutputType]
):
    """

    Extract metadata from HTML content.
    extract, metadata, seo

    Use cases:
    - Analyze SEO elements
    - Gather page information
    - Extract structured data
    """

    html: str | OutputHandle[str] = connect_field(
        default="", description="The HTML content to extract metadata from."
    )

    @property
    def out(self) -> "ExtractMetadataOutputs":
        return ExtractMetadataOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.beautifulsoup.ExtractMetadata

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class ExtractMetadataOutputs(OutputsProxy):
    @property
    def title(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["title"])

    @property
    def description(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["description"])

    @property
    def keywords(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["keywords"])


from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.beautifulsoup
from nodetool.workflows.base_node import BaseNode


class ExtractVideos(
    GraphNode[nodetool.nodes.lib.beautifulsoup.ExtractVideos.OutputType]
):
    """

    Extract videos from HTML content.
    extract, videos, src

    Use cases:
    - Collect video sources from web pages
    - Analyze video usage on websites
    - Create video playlists
    """

    html: str | OutputHandle[str] = connect_field(
        default="", description="The HTML content to extract videos from."
    )
    base_url: str | OutputHandle[str] = connect_field(
        default="",
        description="The base URL of the page, used to resolve relative video URLs.",
    )

    @property
    def out(self) -> "ExtractVideosOutputs":
        return ExtractVideosOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.beautifulsoup.ExtractVideos

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class ExtractVideosOutputs(OutputsProxy):
    @property
    def video(self) -> OutputHandle[types.VideoRef]:
        return typing.cast(OutputHandle[types.VideoRef], self["video"])


from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.beautifulsoup
from nodetool.workflows.base_node import BaseNode


class HTMLToText(SingleOutputGraphNode[str], GraphNode[str]):
    """

    Converts HTML to plain text by removing tags and decoding entities using BeautifulSoup.
    html, text, convert

    Use cases:
    - Cleaning HTML content for text analysis
    - Extracting readable content from web pages
    - Preparing HTML data for natural language processing
    """

    text: str | OutputHandle[str] = connect_field(default="", description=None)
    preserve_linebreaks: bool | OutputHandle[bool] = connect_field(
        default=True, description="Convert block-level elements to newlines"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.beautifulsoup.HTMLToText

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.beautifulsoup
from nodetool.workflows.base_node import BaseNode


class WebsiteContentExtractor(SingleOutputGraphNode[str], GraphNode[str]):
    """

    Extract main content from a website, removing navigation, ads, and other non-essential elements.
    scrape, web scraping, content extraction, text analysis

    Use cases:
    - Clean web content for further analysis
    - Extract article text from news websites
    - Prepare web content for summarization
    """

    html_content: str | OutputHandle[str] = connect_field(
        default="", description="The raw HTML content of the website."
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.beautifulsoup.WebsiteContentExtractor

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
