# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.svg
from nodetool.workflows.base_node import BaseNode


class CircleNode(SingleOutputGraphNode[types.SVGElement], GraphNode[types.SVGElement]):
    """

    Generate SVG circle element.
    svg, shape, vector, circle
    """

    cx: int | OutputHandle[int] = connect_field(
        default=0, description="Center X coordinate"
    )
    cy: int | OutputHandle[int] = connect_field(
        default=0, description="Center Y coordinate"
    )
    radius: int | OutputHandle[int] = connect_field(default=50, description="Radius")
    fill: types.ColorRef | OutputHandle[types.ColorRef] = connect_field(
        default=types.ColorRef(type="color", value="#000000"), description="Fill color"
    )
    stroke: types.ColorRef | OutputHandle[types.ColorRef] = connect_field(
        default=types.ColorRef(type="color", value="none"), description="Stroke color"
    )
    stroke_width: int | OutputHandle[int] = connect_field(
        default=1, description="Stroke width"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.svg.CircleNode

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.svg
from nodetool.workflows.base_node import BaseNode


class ClipPath(SingleOutputGraphNode[types.SVGElement], GraphNode[types.SVGElement]):
    """

    Create clipping paths for SVG elements.
    svg, clip, mask

    Use cases:
    - Mask parts of elements
    - Create complex shapes through clipping
    - Apply visual effects using masks
    """

    clip_content: types.SVGElement | OutputHandle[types.SVGElement] = connect_field(
        default=None, description="SVG element to use as clip path"
    )
    content: types.SVGElement | OutputHandle[types.SVGElement] = connect_field(
        default=None, description="SVG element to clip"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.svg.ClipPath

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.svg
from nodetool.workflows.base_node import BaseNode


class Document(SingleOutputGraphNode[types.SVGRef], GraphNode[types.SVGRef]):
    """

    Combine SVG elements into a complete SVG document.
    svg, document, combine

    Use cases:
    - Combine multiple SVG elements into a single document
    - Set document-level properties like viewBox and dimensions
    - Export complete SVG documents
    """

    content: (
        str
        | nodetool.metadata.types.SVGElement
        | list[nodetool.metadata.types.SVGElement]
        | OutputHandle[
            str
            | nodetool.metadata.types.SVGElement
            | list[nodetool.metadata.types.SVGElement]
        ]
    ) = connect_field(default=[], description="SVG content")
    width: int | OutputHandle[int] = connect_field(
        default=800, description="Document width"
    )
    height: int | OutputHandle[int] = connect_field(
        default=600, description="Document height"
    )
    viewBox: str | OutputHandle[str] = connect_field(
        default="0 0 800 600", description="SVG viewBox attribute"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.svg.Document

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.svg
from nodetool.workflows.base_node import BaseNode


class DropShadow(SingleOutputGraphNode[types.SVGElement], GraphNode[types.SVGElement]):
    """

    Apply drop shadow filter to SVG elements.
    svg, filter, shadow, effects
    """

    std_deviation: float | OutputHandle[float] = connect_field(
        default=3.0, description="Standard deviation for blur"
    )
    dx: int | OutputHandle[int] = connect_field(
        default=2, description="X offset for shadow"
    )
    dy: int | OutputHandle[int] = connect_field(
        default=2, description="Y offset for shadow"
    )
    color: types.ColorRef | OutputHandle[types.ColorRef] = connect_field(
        default=types.ColorRef(type="color", value="#000000"),
        description="Color for shadow",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.svg.DropShadow

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.svg
from nodetool.workflows.base_node import BaseNode


class EllipseNode(SingleOutputGraphNode[types.SVGElement], GraphNode[types.SVGElement]):
    """

    Generate SVG ellipse element.
    svg, shape, vector, ellipse
    """

    cx: int | OutputHandle[int] = connect_field(
        default=0, description="Center X coordinate"
    )
    cy: int | OutputHandle[int] = connect_field(
        default=0, description="Center Y coordinate"
    )
    rx: int | OutputHandle[int] = connect_field(default=100, description="X radius")
    ry: int | OutputHandle[int] = connect_field(default=50, description="Y radius")
    fill: types.ColorRef | OutputHandle[types.ColorRef] = connect_field(
        default=types.ColorRef(type="color", value="#000000"), description="Fill color"
    )
    stroke: types.ColorRef | OutputHandle[types.ColorRef] = connect_field(
        default=types.ColorRef(type="color", value="none"), description="Stroke color"
    )
    stroke_width: int | OutputHandle[int] = connect_field(
        default=1, description="Stroke width"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.svg.EllipseNode

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.svg
from nodetool.workflows.base_node import BaseNode


class GaussianBlur(
    SingleOutputGraphNode[types.SVGElement], GraphNode[types.SVGElement]
):
    """

    Apply Gaussian blur filter to SVG elements.
    svg, filter, blur, effects
    """

    std_deviation: float | OutputHandle[float] = connect_field(
        default=3.0, description="Standard deviation for blur"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.svg.GaussianBlur

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.svg
from nodetool.workflows.base_node import BaseNode


class Gradient(SingleOutputGraphNode[types.SVGElement], GraphNode[types.SVGElement]):
    """

    Create linear or radial gradients for SVG elements.
    svg, gradient, color

    Use cases:
    - Add smooth color transitions
    - Create complex color effects
    - Define reusable gradient definitions
    """

    GradientType: typing.ClassVar[type] = nodetool.nodes.lib.svg.Gradient.GradientType

    gradient_type: nodetool.nodes.lib.svg.Gradient.GradientType = Field(
        default=nodetool.nodes.lib.svg.Gradient.GradientType.LINEAR,
        description="Type of gradient",
    )
    x1: float | OutputHandle[float] = connect_field(
        default=0, description="Start X position (linear) or center X (radial)"
    )
    y1: float | OutputHandle[float] = connect_field(
        default=0, description="Start Y position (linear) or center Y (radial)"
    )
    x2: float | OutputHandle[float] = connect_field(
        default=100, description="End X position (linear) or radius X (radial)"
    )
    y2: float | OutputHandle[float] = connect_field(
        default=100, description="End Y position (linear) or radius Y (radial)"
    )
    color1: types.ColorRef | OutputHandle[types.ColorRef] = connect_field(
        default=types.ColorRef(type="color", value="#000000"),
        description="Start color of gradient",
    )
    color2: types.ColorRef | OutputHandle[types.ColorRef] = connect_field(
        default=types.ColorRef(type="color", value="#FFFFFF"),
        description="End color of gradient",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.svg.Gradient

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.svg
from nodetool.workflows.base_node import BaseNode


class LineNode(SingleOutputGraphNode[types.SVGElement], GraphNode[types.SVGElement]):
    """

    Generate SVG line element.
    svg, shape, vector, line
    """

    x1: int | OutputHandle[int] = connect_field(
        default=0, description="Start X coordinate"
    )
    y1: int | OutputHandle[int] = connect_field(
        default=0, description="Start Y coordinate"
    )
    x2: int | OutputHandle[int] = connect_field(
        default=100, description="End X coordinate"
    )
    y2: int | OutputHandle[int] = connect_field(
        default=100, description="End Y coordinate"
    )
    stroke: types.ColorRef | OutputHandle[types.ColorRef] = connect_field(
        default=types.ColorRef(type="color", value="#000000"),
        description="Stroke color",
    )
    stroke_width: int | OutputHandle[int] = connect_field(
        default=1, description="Stroke width"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.svg.LineNode

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.svg
from nodetool.workflows.base_node import BaseNode


class PathNode(SingleOutputGraphNode[types.SVGElement], GraphNode[types.SVGElement]):
    """

    Generate SVG path element.
    svg, shape, vector, path
    """

    path_data: str | OutputHandle[str] = connect_field(
        default=PydanticUndefined, description="SVG path data (d attribute)"
    )
    fill: types.ColorRef | OutputHandle[types.ColorRef] = connect_field(
        default=types.ColorRef(type="color", value="#000000"), description="Fill color"
    )
    stroke: types.ColorRef | OutputHandle[types.ColorRef] = connect_field(
        default=types.ColorRef(type="color", value="none"), description="Stroke color"
    )
    stroke_width: int | OutputHandle[int] = connect_field(
        default=1, description="Stroke width"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.svg.PathNode

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.svg
from nodetool.workflows.base_node import BaseNode


class PolygonNode(SingleOutputGraphNode[types.SVGElement], GraphNode[types.SVGElement]):
    """

    Generate SVG polygon element.
    svg, shape, vector, polygon
    """

    points: str | OutputHandle[str] = connect_field(
        default=PydanticUndefined, description="Points in format 'x1,y1 x2,y2 x3,y3...'"
    )
    fill: types.ColorRef | OutputHandle[types.ColorRef] = connect_field(
        default=types.ColorRef(type="color", value="#000000"), description="Fill color"
    )
    stroke: types.ColorRef | OutputHandle[types.ColorRef] = connect_field(
        default=types.ColorRef(type="color", value="none"), description="Stroke color"
    )
    stroke_width: int | OutputHandle[int] = connect_field(
        default=1, description="Stroke width"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.svg.PolygonNode

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.svg
from nodetool.workflows.base_node import BaseNode


class RectNode(SingleOutputGraphNode[types.SVGElement], GraphNode[types.SVGElement]):
    """

    Generate SVG rectangle element.
    svg, shape, vector, rectangle
    """

    x: int | OutputHandle[int] = connect_field(default=0, description="X coordinate")
    y: int | OutputHandle[int] = connect_field(default=0, description="Y coordinate")
    width: int | OutputHandle[int] = connect_field(default=100, description="Width")
    height: int | OutputHandle[int] = connect_field(default=100, description="Height")
    fill: types.ColorRef | OutputHandle[types.ColorRef] = connect_field(
        default=types.ColorRef(type="color", value="#000000"), description="Fill color"
    )
    stroke: types.ColorRef | OutputHandle[types.ColorRef] = connect_field(
        default=types.ColorRef(type="color", value="none"), description="Stroke color"
    )
    stroke_width: int | OutputHandle[int] = connect_field(
        default=1, description="Stroke width"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.svg.RectNode

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.svg
from nodetool.workflows.base_node import BaseNode


class SVGToImage(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """

    Create an SVG document and convert it to a raster image in one step.
    svg, document, raster, convert

    Use cases:
    - Create and rasterize SVG documents in a single operation
    - Generate image files from SVG elements
    - Convert vector graphics to bitmap format with custom dimensions
    """

    content: (
        str
        | nodetool.metadata.types.SVGElement
        | list[nodetool.metadata.types.SVGElement]
        | OutputHandle[
            str
            | nodetool.metadata.types.SVGElement
            | list[nodetool.metadata.types.SVGElement]
        ]
    ) = connect_field(default=[], description="SVG content")
    width: int | OutputHandle[int] = connect_field(
        default=800, description="Document width"
    )
    height: int | OutputHandle[int] = connect_field(
        default=600, description="Document height"
    )
    viewBox: str | OutputHandle[str] = connect_field(
        default="0 0 800 600", description="SVG viewBox attribute"
    )
    scale: int | OutputHandle[int] = connect_field(
        default=1, description="Scale factor for rasterization"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.svg.SVGToImage

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.svg
from nodetool.workflows.base_node import BaseNode


class Text(SingleOutputGraphNode[types.SVGElement], GraphNode[types.SVGElement]):
    """

    Add text elements to SVG.
    svg, text, typography

    Use cases:
    - Add labels to vector graphics
    - Create text-based logos
    - Generate dynamic text content in SVGs
    """

    SVGTextAnchor: typing.ClassVar[type] = nodetool.nodes.lib.svg.SVGTextAnchor

    text: str | OutputHandle[str] = connect_field(
        default="", description="Text content"
    )
    x: int | OutputHandle[int] = connect_field(default=0, description="X coordinate")
    y: int | OutputHandle[int] = connect_field(default=0, description="Y coordinate")
    font_family: str | OutputHandle[str] = connect_field(
        default="Arial", description="Font family"
    )
    font_size: int | OutputHandle[int] = connect_field(
        default=16, description="Font size"
    )
    fill: types.ColorRef | OutputHandle[types.ColorRef] = connect_field(
        default=types.ColorRef(type="color", value="#000000"), description="Text color"
    )
    text_anchor: nodetool.nodes.lib.svg.SVGTextAnchor = Field(
        default=nodetool.nodes.lib.svg.SVGTextAnchor.START,
        description="Text anchor position",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.svg.Text

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.svg
from nodetool.workflows.base_node import BaseNode


class Transform(SingleOutputGraphNode[types.SVGElement], GraphNode[types.SVGElement]):
    """

    Apply transformations to SVG elements.
    svg, transform, animation

    Use cases:
    - Rotate, scale, or translate elements
    - Create complex transformations
    - Prepare elements for animation
    """

    content: types.SVGElement | OutputHandle[types.SVGElement] = connect_field(
        default=None, description="SVG element to transform"
    )
    translate_x: float | OutputHandle[float] = connect_field(
        default=0, description="X translation"
    )
    translate_y: float | OutputHandle[float] = connect_field(
        default=0, description="Y translation"
    )
    rotate: float | OutputHandle[float] = connect_field(
        default=0, description="Rotation angle in degrees"
    )
    scale_x: float | OutputHandle[float] = connect_field(
        default=1, description="X scale factor"
    )
    scale_y: float | OutputHandle[float] = connect_field(
        default=1, description="Y scale factor"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.svg.Transform

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
