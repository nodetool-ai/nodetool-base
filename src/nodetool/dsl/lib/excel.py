# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.excel


class AutoFitColumns(GraphNode[Any]):
    """
    Automatically adjusts column widths to fit content.
    excel, format, columns

    Use cases:
    - Improve spreadsheet readability
    - Professional presentation
    """

    workbook: types.ExcelRef | OutputHandle[types.ExcelRef] = connect_field(
        default=types.ExcelRef(type="excel", uri="", asset_id=None, data=None),
        description="The Excel workbook to format",
    )
    sheet_name: str | OutputHandle[str] = connect_field(
        default="Sheet1", description="Target worksheet name"
    )

    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.excel.AutoFitColumns"


AutoFitColumns.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.excel


class CreateWorkbook(GraphNode[types.ExcelRef]):
    """
    Creates a new Excel workbook.
    excel, workbook, create

    Use cases:
    - Initialize new Excel files
    - Start spreadsheet creation workflows
    """

    sheet_name: str | OutputHandle[str] = connect_field(
        default="Sheet1", description="Name for the first worksheet"
    )

    @property
    def output(self) -> OutputHandle[types.ExcelRef]:
        return typing.cast(OutputHandle[types.ExcelRef], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.excel.CreateWorkbook"


CreateWorkbook.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.excel


class DataFrameToExcel(GraphNode[Any]):
    """
    Writes a DataFrame to an Excel worksheet.
    excel, dataframe, export

    Use cases:
    - Export data analysis results
    - Create reports from data
    """

    workbook: types.ExcelRef | OutputHandle[types.ExcelRef] = connect_field(
        default=types.ExcelRef(type="excel", uri="", asset_id=None, data=None),
        description="The Excel workbook to write to",
    )
    dataframe: types.DataframeRef | OutputHandle[types.DataframeRef] = connect_field(
        default=types.DataframeRef(
            type="dataframe", uri="", asset_id=None, data=None, columns=None
        ),
        description="DataFrame to write",
    )
    sheet_name: str | OutputHandle[str] = connect_field(
        default="Sheet1", description="Target worksheet name"
    )
    start_cell: str | OutputHandle[str] = connect_field(
        default="A1", description="Starting cell for data"
    )
    include_header: bool | OutputHandle[bool] = connect_field(
        default=True, description="Include column headers"
    )

    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.excel.DataFrameToExcel"


DataFrameToExcel.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.excel


class ExcelToDataFrame(GraphNode[types.DataframeRef]):
    """
    Reads an Excel worksheet into a pandas DataFrame.
    excel, dataframe, import

    Use cases:
    - Import Excel data for analysis
    - Process spreadsheet contents
    """

    workbook: types.ExcelRef | OutputHandle[types.ExcelRef] = connect_field(
        default=types.ExcelRef(type="excel", uri="", asset_id=None, data=None),
        description="The Excel workbook to read from",
    )
    sheet_name: str | OutputHandle[str] = connect_field(
        default="Sheet1", description="Source worksheet name"
    )
    has_header: bool | OutputHandle[bool] = connect_field(
        default=True, description="First row contains headers"
    )

    @property
    def output(self) -> OutputHandle[types.DataframeRef]:
        return typing.cast(
            OutputHandle[types.DataframeRef], self._single_output_handle()
        )

    @classmethod
    def get_node_type(cls):
        return "lib.excel.ExcelToDataFrame"


ExcelToDataFrame.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.excel


class FormatCells(GraphNode[Any]):
    """
    Applies formatting to a range of cells.
    excel, format, style

    Use cases:
    - Highlight important data
    - Create professional looking reports
    """

    workbook: types.ExcelRef | OutputHandle[types.ExcelRef] = connect_field(
        default=types.ExcelRef(type="excel", uri="", asset_id=None, data=None),
        description="The Excel workbook to format",
    )
    sheet_name: str | OutputHandle[str] = connect_field(
        default="Sheet1", description="Target worksheet name"
    )
    cell_range: str | OutputHandle[str] = connect_field(
        default="A1:B10", description="Cell range to format (e.g. 'A1:B10')"
    )
    bold: bool | OutputHandle[bool] = connect_field(
        default=False, description="Make text bold"
    )
    background_color: str | OutputHandle[str] = connect_field(
        default="FFFF00",
        description="Background color in hex format (e.g. 'FFFF00' for yellow)",
    )
    text_color: str | OutputHandle[str] = connect_field(
        default="000000", description="Text color in hex format"
    )

    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.excel.FormatCells"


FormatCells.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.excel


class SaveWorkbook(GraphNode[typing.Any]):
    """
    Saves an Excel workbook to disk.
    excel, save, export

    Use cases:
    - Export final spreadsheet
    - Save work in progress
    """

    workbook: types.ExcelRef | OutputHandle[types.ExcelRef] = connect_field(
        default=types.ExcelRef(type="excel", uri="", asset_id=None, data=None),
        description="The Excel workbook to save",
    )
    folder: types.FilePath | OutputHandle[types.FilePath] = connect_field(
        default=types.FilePath(type="file_path", path=""),
        description="The folder to save the file to.",
    )
    filename: str | OutputHandle[str] = connect_field(
        default="",
        description="\n        The filename to save the file to.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        ",
    )

    @property
    def output(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.excel.SaveWorkbook"


SaveWorkbook.model_rebuild(force=True)
