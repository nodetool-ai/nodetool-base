# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class AbsolutePath(GraphNode[str]):
    """
    Return the absolute path of a file or directory.
    files, path, absolute

    Use cases:
    - Convert relative paths to absolute
    - Get full system path
    - Resolve path references
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to convert to absolute"
    )

    @property
    def output(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.AbsolutePath"


AbsolutePath.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class AccessedTime(GraphNode[types.Datetime]):
    """
    Get file last accessed timestamp.
    files, metadata, accessed, time
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to file"
    )

    @property
    def output(self) -> OutputHandle[types.Datetime]:
        return typing.cast(OutputHandle[types.Datetime], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.AccessedTime"


AccessedTime.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class Basename(GraphNode[str]):
    """
    Get the base name component of a file path.
    files, path, basename

    Use cases:
    - Extract filename from full path
    - Get file name without directory
    - Process file names independently
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="File path to get basename from"
    )
    remove_extension: bool | OutputHandle[bool] = connect_field(
        default=False, description="Remove file extension from basename"
    )

    @property
    def output(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.Basename"


Basename.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class CopyFile(GraphNode[typing.Any]):
    """
    Copy a file from source to destination path.
    files, copy, manage

    Use cases:
    - Create file backups
    - Duplicate files for processing
    - Copy files to new locations
    """

    source_path: str | OutputHandle[str] = connect_field(
        default="", description="Source file path"
    )
    destination_path: str | OutputHandle[str] = connect_field(
        default="", description="Destination file path"
    )

    @property
    def output(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.CopyFile"


CopyFile.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class CreateDirectory(GraphNode[typing.Any]):
    """
    Create a new directory at specified path.
    files, directory, create

    Use cases:
    - Set up directory structure for file organization
    - Create output directories for processed files
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Directory path to create"
    )
    exist_ok: bool | OutputHandle[bool] = connect_field(
        default=True, description="Don't error if directory already exists"
    )

    @property
    def output(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.CreateDirectory"


CreateDirectory.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class CreatedTime(GraphNode[types.Datetime]):
    """
    Get file creation timestamp.
    files, metadata, created, time
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to file"
    )

    @property
    def output(self) -> OutputHandle[types.Datetime]:
        return typing.cast(OutputHandle[types.Datetime], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.CreatedTime"


CreatedTime.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class Dirname(GraphNode[str]):
    """
    Get the directory name component of a file path.
    files, path, dirname

    Use cases:
    - Extract directory path from full path
    - Get parent directory
    - Process directory paths
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="File path to get dirname from"
    )

    @property
    def output(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.Dirname"


Dirname.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class FileExists(GraphNode[bool]):
    """
    Check if a file or directory exists at the specified path.
    files, check, exists

    Use cases:
    - Validate file presence before processing
    - Implement conditional logic based on file existence
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to check for existence"
    )

    @property
    def output(self) -> OutputHandle[bool]:
        return typing.cast(OutputHandle[bool], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.FileExists"


FileExists.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class FileExtension(GraphNode[str]):
    """
    Get file extension.
    files, metadata, extension
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to file"
    )

    @property
    def output(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.FileExtension"


FileExtension.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class FileName(GraphNode[str]):
    """
    Get file name without path.
    files, metadata, name
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to file"
    )

    @property
    def output(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.FileName"


FileName.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class FileNameMatch(GraphNode[bool]):
    """
    Match a filename against a pattern using Unix shell-style wildcards.
    files, pattern, match, filter

    Use cases:
    - Filter files by name pattern
    - Validate file naming conventions
    - Match file extensions
    """

    filename: str | OutputHandle[str] = connect_field(
        default="", description="Filename to check"
    )
    pattern: str | OutputHandle[str] = connect_field(
        default="*", description="Pattern to match against (e.g. *.txt, data_*.csv)"
    )
    case_sensitive: bool | OutputHandle[bool] = connect_field(
        default=True,
        description="Whether the pattern matching should be case-sensitive",
    )

    @property
    def output(self) -> OutputHandle[bool]:
        return typing.cast(OutputHandle[bool], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.FileNameMatch"


FileNameMatch.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class FilterFileNames(GraphNode[list[str]]):
    """
    Filter a list of filenames using Unix shell-style wildcards.
    files, pattern, filter, list

    Use cases:
    - Filter multiple files by pattern
    - Batch process files matching criteria
    - Select files by extension
    """

    filenames: list[str] | OutputHandle[list[str]] = connect_field(
        default=[], description="list of filenames to filter"
    )
    pattern: str | OutputHandle[str] = connect_field(
        default="*", description="Pattern to filter by (e.g. *.txt, data_*.csv)"
    )
    case_sensitive: bool | OutputHandle[bool] = connect_field(
        default=True,
        description="Whether the pattern matching should be case-sensitive",
    )

    @property
    def output(self) -> OutputHandle[list[str]]:
        return typing.cast(OutputHandle[list[str]], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.FilterFileNames"


FilterFileNames.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class GetDirectory(GraphNode[str]):
    """
    Get directory containing the file.
    files, metadata, directory
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to file"
    )

    @property
    def output(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.GetDirectory"


GetDirectory.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class GetEnvironmentVariable(GraphNode[str | None]):
    """
    Gets an environment variable value.
    environment, variable, system

    Use cases:
    - Access configuration
    - Get system settings
    """

    name: str | OutputHandle[str] = connect_field(
        default="", description="Environment variable name"
    )
    default: str | OutputHandle[str] | None = connect_field(
        default=None, description="Default value if not found"
    )

    @property
    def output(self) -> OutputHandle[str | None]:
        return typing.cast(OutputHandle[str | None], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.GetEnvironmentVariable"


GetEnvironmentVariable.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class GetFileSize(GraphNode[int]):
    """
    Get file size in bytes.
    files, metadata, size
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to file"
    )

    @property
    def output(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.GetFileSize"


GetFileSize.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class GetPathInfo(GraphNode[dict]):
    """
    Gets information about a path.
    path, info, metadata

    Use cases:
    - Extract path components
    - Parse file paths
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to analyze"
    )

    @property
    def output(self) -> OutputHandle[dict]:
        return typing.cast(OutputHandle[dict], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.GetPathInfo"


GetPathInfo.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class GetSystemInfo(GraphNode[dict]):
    """
    Gets system information.
    system, info, platform

    Use cases:
    - Check system compatibility
    - Platform-specific logic
    """

    @property
    def output(self) -> OutputHandle[dict]:
        return typing.cast(OutputHandle[dict], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.GetSystemInfo"


GetSystemInfo.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class IsDirectory(GraphNode[bool]):
    """
    Check if path is a directory.
    files, metadata, type
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to check"
    )

    @property
    def output(self) -> OutputHandle[bool]:
        return typing.cast(OutputHandle[bool], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.IsDirectory"


IsDirectory.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class IsFile(GraphNode[bool]):
    """
    Check if path is a file.
    files, metadata, type
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to check"
    )

    @property
    def output(self) -> OutputHandle[bool]:
        return typing.cast(OutputHandle[bool], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.IsFile"


IsFile.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class JoinPaths(GraphNode[str]):
    """
    Joins path components.
    path, join, combine

    Use cases:
    - Build file paths
    - Create cross-platform paths
    """

    paths: list[str] | OutputHandle[list[str]] = connect_field(
        default=[], description="Path components to join"
    )

    @property
    def output(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.JoinPaths"


JoinPaths.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class ListFiles(GraphNode[nodetool.nodes.lib.os.ListFiles.OutputType]):
    """
    list files in a directory matching a pattern.
    files, list, directory

    Use cases:
    - Get files for batch processing
    - Filter files by extension or pattern
    """

    folder: str | OutputHandle[str] = connect_field(
        default="~", description="Directory to scan"
    )
    pattern: str | OutputHandle[str] = connect_field(
        default="*", description="File pattern to match (e.g. *.txt)"
    )
    include_subdirectories: bool | OutputHandle[bool] = connect_field(
        default=False, description="Search subdirectories"
    )

    @property
    def out(self) -> "ListFilesOutputs":
        return ListFilesOutputs(self)

    @classmethod
    def get_node_type(cls):
        return "lib.os.ListFiles"


class ListFilesOutputs(OutputsProxy):
    @property
    def file(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["file"])


ListFiles.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class ModifiedTime(GraphNode[types.Datetime]):
    """
    Get file last modified timestamp.
    files, metadata, modified, time
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to file"
    )

    @property
    def output(self) -> OutputHandle[types.Datetime]:
        return typing.cast(OutputHandle[types.Datetime], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.ModifiedTime"


ModifiedTime.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class MoveFile(GraphNode[typing.Any]):
    """
    Move a file from source to destination path.
    files, move, manage

    Use cases:
    - Organize files into directories
    - Process and archive files
    - Relocate completed files
    """

    source_path: str | OutputHandle[str] = connect_field(
        default="", description="Source file path"
    )
    destination_path: str | OutputHandle[str] = connect_field(
        default="", description="Destination file path"
    )

    @property
    def output(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.MoveFile"


MoveFile.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class NormalizePath(GraphNode[str]):
    """
    Normalizes a path.
    path, normalize, clean

    Use cases:
    - Standardize paths
    - Remove redundant separators
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to normalize"
    )

    @property
    def output(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.NormalizePath"


NormalizePath.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class OpenWorkspaceDirectory(GraphNode[NoneType]):
    """
    Open the workspace directory.
    files, workspace, directory
    """

    @property
    def output(self) -> OutputHandle[NoneType]:
        return typing.cast(OutputHandle[NoneType], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.OpenWorkspaceDirectory"


OpenWorkspaceDirectory.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class PathToString(GraphNode[str]):
    """
    Convert a FilePath object to a string.
    files, path, string, convert

    Use cases:
    - Get raw string path from FilePath object
    - Convert FilePath for string operations
    - Extract path string for external use
    """

    file_path: str | OutputHandle[str] = connect_field(
        default="", description="File path to convert to string"
    )

    @property
    def output(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.PathToString"


PathToString.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class RelativePath(GraphNode[str]):
    """
    Return a relative path to a target from a start directory.
    files, path, relative

    Use cases:
    - Create relative path references
    - Generate portable paths
    - Compare file locations
    """

    target_path: str | OutputHandle[str] = connect_field(
        default="", description="Target path to convert to relative"
    )
    start_path: str | OutputHandle[str] = connect_field(
        default=".", description="Start path for relative conversion"
    )

    @property
    def output(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.RelativePath"


RelativePath.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class SetEnvironmentVariable(GraphNode[NoneType]):
    """
    Sets an environment variable.
    environment, variable, system

    Use cases:
    - Configure runtime settings
    - Set up process environment
    """

    name: str | OutputHandle[str] = connect_field(
        default="", description="Environment variable name"
    )
    value: str | OutputHandle[str] = connect_field(
        default="", description="Environment variable value"
    )

    @property
    def output(self) -> OutputHandle[NoneType]:
        return typing.cast(OutputHandle[NoneType], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.SetEnvironmentVariable"


SetEnvironmentVariable.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class ShowNotification(GraphNode[NoneType]):
    """
    Shows a system notification.
    notification, system, alert

    Use cases:
    - Alert user of completed tasks
    - Show process status
    - Display important messages
    """

    title: str | OutputHandle[str] = connect_field(
        default="", description="Title of the notification"
    )
    message: str | OutputHandle[str] = connect_field(
        default="", description="Content of the notification"
    )
    timeout: int | OutputHandle[int] = connect_field(
        default=10,
        description="How long the notification should stay visible (in seconds)",
    )

    @property
    def output(self) -> OutputHandle[NoneType]:
        return typing.cast(OutputHandle[NoneType], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.ShowNotification"


ShowNotification.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class SplitExtension(GraphNode[dict]):
    """
    Split a path into root and extension components.
    files, path, extension, split

    Use cases:
    - Extract file extension
    - Process filename without extension
    - Handle file types
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to split"
    )

    @property
    def output(self) -> OutputHandle[dict]:
        return typing.cast(OutputHandle[dict], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.SplitExtension"


SplitExtension.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class SplitPath(GraphNode[dict]):
    """
    Split a path into directory and file components.
    files, path, split

    Use cases:
    - Separate directory from filename
    - Process path components separately
    - Extract path parts
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to split"
    )

    @property
    def output(self) -> OutputHandle[dict]:
        return typing.cast(OutputHandle[dict], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.SplitPath"


SplitPath.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.os


class WorkspaceDirectory(GraphNode[str]):
    """
    Get the workspace directory.
    files, workspace, directory
    """

    @property
    def output(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.os.WorkspaceDirectory"


WorkspaceDirectory.model_rebuild(force=True)
