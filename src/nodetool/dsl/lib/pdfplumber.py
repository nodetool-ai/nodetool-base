# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.pdfplumber


class ExtractImages(GraphNode[typing.Any]):
    """
    Extract images from a PDF file.
    pdf, image, extract

    Use cases:
    - Extract embedded images from PDF documents
    - Save PDF images as separate files
    - Process PDF images for analysis
    """

    pdf: types.DocumentRef | OutputHandle[types.DocumentRef] = connect_field(
        default=PydanticUndefined, description="The PDF file to extract images from"
    )
    start_page: int | OutputHandle[int] = connect_field(
        default=0, description="The start page to extract"
    )
    end_page: int | OutputHandle[int] = connect_field(
        default=4, description="The end page to extract"
    )

    @property
    def output(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.pdfplumber.ExtractImages"


ExtractImages.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.pdfplumber


class ExtractPageMetadata(GraphNode[typing.Any]):
    """
    Extract metadata from PDF pages like dimensions, rotation, etc.
    pdf, metadata, pages

    Use cases:
    - Analyze page layouts
    - Get page dimensions
    - Check page orientations
    """

    pdf: types.DocumentRef | OutputHandle[types.DocumentRef] = connect_field(
        default=PydanticUndefined, description="The PDF file to analyze"
    )
    start_page: int | OutputHandle[int] = connect_field(
        default=0, description="The start page to extract. 0-based indexing"
    )
    end_page: int | OutputHandle[int] = connect_field(
        default=4, description="The end page to extract. -1 for all pages"
    )

    @property
    def output(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.pdfplumber.ExtractPageMetadata"


ExtractPageMetadata.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.pdfplumber


class ExtractTables(GraphNode[typing.Any]):
    """
    Extract tables from a PDF file into dataframes.
    pdf, tables, dataframe, extract

    Use cases:
    - Extract tabular data from PDF documents
    - Convert PDF tables to structured data formats
    - Process PDF tables for analysis
    - Import PDF reports into data analysis pipelines
    """

    pdf: types.DocumentRef | OutputHandle[types.DocumentRef] = connect_field(
        default=types.DocumentRef(type="document", uri="", asset_id=None, data=None),
        description="The PDF document to extract tables from",
    )
    start_page: int | OutputHandle[int] = connect_field(
        default=0,
        description="First page to extract tables from (0-based, None for first page)",
    )
    end_page: int | OutputHandle[int] = connect_field(
        default=4,
        description="Last page to extract tables from (0-based, None for last page)",
    )
    table_settings: dict | OutputHandle[dict] = connect_field(
        default={
            "vertical_strategy": "text",
            "horizontal_strategy": "text",
            "snap_tolerance": 3,
            "join_tolerance": 3,
            "edge_min_length": 3,
            "min_words_vertical": 3,
            "min_words_horizontal": 1,
            "keep_blank_chars": False,
            "text_tolerance": 3,
            "text_x_tolerance": 3,
            "text_y_tolerance": 3,
        },
        description="Settings for table extraction algorithm",
    )

    @property
    def output(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.pdfplumber.ExtractTables"


ExtractTables.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.pdfplumber


class ExtractText(GraphNode[str]):
    """
    Extract text content from a PDF file.
    pdf, text, extract

    Use cases:
    - Convert PDF documents to plain text
    - Extract content for analysis
    - Enable text search in PDF documents
    """

    pdf: types.DocumentRef | OutputHandle[types.DocumentRef] = connect_field(
        default=types.DocumentRef(type="document", uri="", asset_id=None, data=None),
        description="The PDF file to extract text from",
    )
    start_page: int | OutputHandle[int] = connect_field(
        default=0, description="The start page to extract. 0-based indexing"
    )
    end_page: int | OutputHandle[int] = connect_field(
        default=4, description="The end page to extract. -1 for all pages"
    )

    @property
    def output(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.pdfplumber.ExtractText"


ExtractText.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.lib.pdfplumber


class GetPageCount(GraphNode[int]):
    """
    Get the total number of pages in a PDF file.
    pdf, pages, count

    Use cases:
    - Check document length
    - Plan batch processing
    """

    pdf: types.DocumentRef | OutputHandle[types.DocumentRef] = connect_field(
        default=PydanticUndefined, description="The PDF file to analyze"
    )

    @property
    def output(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "lib.pdfplumber.GetPageCount"


GetPageCount.model_rebuild(force=True)
