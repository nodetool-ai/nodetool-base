# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import (
    OutputHandle,
    OutputsProxy,
    DynamicOutputsProxy,
    connect_field,
)
import nodetool.nodes.lib.http_server
from nodetool.workflows.base_node import BaseNode


class SimpleHttpServer(
    GraphNode[nodetool.nodes.lib.http_server.SimpleHttpServer.OutputType]
):
    """

    Starts a simple HTTP server inside Docker and streams logs.
    http, server, web

    Emits the reachable endpoint URL on the "endpoint" output when ready,
    then streams stdout/stderr lines on the corresponding outputs.
    """

    image: str | OutputHandle[str] = connect_field(
        default="python:3.11-slim", description="Docker image to run the server in"
    )
    container_port: int | OutputHandle[int] = connect_field(
        default=8000, description="Port the server listens on inside the container"
    )
    command: str | OutputHandle[str] = connect_field(
        default="",
        description="Startup command. If empty, uses 'python -m http.server <container_port> --bind 0.0.0.0'",
    )
    timeout_seconds: int | OutputHandle[int] = connect_field(
        default=600, description="Max lifetime of the server container (seconds)"
    )
    ready_timeout_seconds: int | OutputHandle[int] = connect_field(
        default=15, description="Seconds to wait for server readiness"
    )

    def __init__(
        self,
        *,
        dynamic_outputs: dict[str, typing.Any] | None = None,
        **kwargs: typing.Any,
    ) -> None:
        """
        Initialize a SimpleHttpServer node.

        Dynamic outputs declared here will be forwarded to the underlying node
        so they are available when the workflow executes. Provide Python types
        such as str or list[int] for each output.

        Args:
            dynamic_outputs: Optional mapping from output names to Python types.
            **kwargs: Field values for the node.
        """

        outputs = {} if dynamic_outputs is None else dict(dynamic_outputs)
        super().__init__(dynamic_outputs=outputs, **kwargs)

    @property
    def out(self) -> "SimpleHttpServerOutputs":
        return SimpleHttpServerOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.http_server.SimpleHttpServer

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class SimpleHttpServerOutputs(DynamicOutputsProxy):
    @property
    def endpoint(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["endpoint"])

    @property
    def stdout(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stdout"])

    @property
    def stderr(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stderr"])
