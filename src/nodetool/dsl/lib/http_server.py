# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

import typing
import nodetool.metadata.types
from nodetool.dsl.graph import GraphNode

from nodetool.dsl.handles import (
    OutputHandle,
    DynamicOutputsProxy,
    connect_field,
)
import nodetool.nodes.lib.http_server
from nodetool.workflows.base_node import BaseNode


class SimpleHttpServer(
    GraphNode[nodetool.nodes.lib.http_server.SimpleHttpServer.OutputType]
):
    """

    Starts a simple HTTP server inside Docker and streams logs.
    http, server, web

    Emits the reachable endpoint URL on the "endpoint" output when ready,
    then streams stdout/stderr lines on the corresponding outputs.
    """

    image: str | OutputHandle[str] = connect_field(
        default="python:3.11-slim", description="Docker image to run the server in"
    )
    container_port: int | OutputHandle[int] = connect_field(
        default=8000, description="Port the server listens on inside the container"
    )
    command: str | OutputHandle[str] = connect_field(
        default="",
        description="Startup command. If empty, uses 'python -m http.server <container_port> --bind 0.0.0.0'",
    )
    timeout_seconds: int | OutputHandle[int] = connect_field(
        default=600, description="Max lifetime of the server container (seconds)"
    )
    ready_timeout_seconds: int | OutputHandle[int] = connect_field(
        default=15, description="Seconds to wait for server readiness"
    )

    def __init__(
        self,
        *,
        dynamic_outputs: dict[str, typing.Any] | None = None,
        **kwargs: typing.Any,
    ) -> None:
        """
        Initialize a SimpleHttpServer node.

        Dynamic outputs declared here will be forwarded to the underlying node
        so they are available when the workflow executes. Provide Python types
        such as str or list[int] for each output.

        Args:
            dynamic_outputs: Optional mapping from output names to Python types.
            **kwargs: Field values for the node.
        """

        outputs = {} if dynamic_outputs is None else dict(dynamic_outputs)
        super().__init__(dynamic_outputs=outputs, **kwargs)

    @property
    def out(self) -> "SimpleHttpServerOutputs":
        return SimpleHttpServerOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.lib.http_server.SimpleHttpServer

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class SimpleHttpServerOutputs(DynamicOutputsProxy):
    @property
    def endpoint(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["endpoint"])

    @property
    def stdout(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stdout"])

    @property
    def stderr(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stderr"])
