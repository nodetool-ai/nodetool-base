# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.output
from nodetool.workflows.base_node import BaseNode


class ArrayOutput(GraphNode[nodetool.workflows.base_node.OutputNode.OutputType]):
    """

    Output node for generic array data, typically numerical ('NPArray').
    array, numerical, list, tensor, vector, matrix

    Use cases:
    - Outputting results from machine learning models (e.g., embeddings, predictions).
    - Representing complex numerical data structures.
    - Passing arrays of numbers between processing steps.
    """

    name: str | OutputHandle[str] = connect_field(
        default="", description="The parameter name for the workflow."
    )
    value: types.NPArray | OutputHandle[types.NPArray] = connect_field(
        default=types.NPArray(type="np_array", value=None, dtype="<i8", shape=(1,)),
        description=None,
    )
    description: str | OutputHandle[str] = connect_field(
        default="", description="The description of the output for the workflow."
    )

    @property
    def out(self) -> "ArrayOutputOutputs":
        return ArrayOutputOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.output.ArrayOutput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class ArrayOutputOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self["output"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.output
from nodetool.workflows.base_node import BaseNode


class AudioOutput(GraphNode[nodetool.workflows.base_node.OutputNode.OutputType]):
    """

    Output node for audio content references ('AudioRef').
    audio, sound, media, voice, speech, asset, reference

    Use cases:
    - Displaying or returning processed or generated audio.
    - Passing audio data (as an 'AudioRef') between workflow nodes.
    - Returning results of audio analysis (e.g., transcription reference, audio features).
    """

    name: str | OutputHandle[str] = connect_field(
        default="", description="The parameter name for the workflow."
    )
    value: types.AudioRef | OutputHandle[types.AudioRef] = connect_field(
        default=types.AudioRef(type="audio", uri="", asset_id=None, data=None),
        description=None,
    )
    description: str | OutputHandle[str] = connect_field(
        default="", description="The description of the output for the workflow."
    )

    @property
    def out(self) -> "AudioOutputOutputs":
        return AudioOutputOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.output.AudioOutput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class AudioOutputOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self["output"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.output
from nodetool.workflows.base_node import BaseNode


class BooleanOutput(GraphNode[nodetool.workflows.base_node.OutputNode.OutputType]):
    """

    Output node for a single boolean value.
    boolean, true, false, flag, condition, flow-control, branch, else, switch, toggle

    Use cases:
    - Returning binary results (yes/no, true/false)
    - Controlling conditional logic in workflows
    - Indicating success/failure of operations
    """

    name: str | OutputHandle[str] = connect_field(
        default="", description="The parameter name for the workflow."
    )
    value: bool | OutputHandle[bool] = connect_field(default=False, description=None)
    description: str | OutputHandle[str] = connect_field(
        default="", description="The description of the output for the workflow."
    )

    @property
    def out(self) -> "BooleanOutputOutputs":
        return BooleanOutputOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.output.BooleanOutput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class BooleanOutputOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self["output"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.output
from nodetool.workflows.base_node import BaseNode


class DataframeOutput(GraphNode[nodetool.workflows.base_node.OutputNode.OutputType]):
    """

    Output node for structured data references, typically tabular ('DataframeRef').
    dataframe, table, structured, csv, tabular_data, rows, columns

    Use cases:
    - Outputting tabular data results from analysis or queries.
    - Passing structured datasets between processing or analysis steps.
    - Displaying data in a table format or making it available for download.
    """

    name: str | OutputHandle[str] = connect_field(
        default="", description="The parameter name for the workflow."
    )
    value: types.DataframeRef | OutputHandle[types.DataframeRef] = connect_field(
        default=types.DataframeRef(
            type="dataframe", uri="", asset_id=None, data=None, columns=None
        ),
        description=None,
    )
    description: str | OutputHandle[str] = connect_field(
        default="", description="The description of the output for the workflow."
    )

    @property
    def out(self) -> "DataframeOutputOutputs":
        return DataframeOutputOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.output.DataframeOutput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class DataframeOutputOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self["output"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.output
from nodetool.workflows.base_node import BaseNode


class DictionaryOutput(GraphNode[nodetool.workflows.base_node.OutputNode.OutputType]):
    """

    Output node for key-value pair data (dictionary).
    dictionary, key-value, mapping, object, json_object, struct

    Use cases:
    - Returning multiple named values as a single structured output.
    - Passing complex data structures or configurations between nodes.
    - Organizing heterogeneous output data into a named map.
    """

    name: str | OutputHandle[str] = connect_field(
        default="", description="The parameter name for the workflow."
    )
    value: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description=None
    )
    description: str | OutputHandle[str] = connect_field(
        default="", description="The description of the output for the workflow."
    )

    @property
    def out(self) -> "DictionaryOutputOutputs":
        return DictionaryOutputOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.output.DictionaryOutput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class DictionaryOutputOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self["output"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.output
from nodetool.workflows.base_node import BaseNode


class DocumentOutput(GraphNode[nodetool.workflows.base_node.OutputNode.OutputType]):
    """

    Output node for document content references ('DocumentRef').
    document, file, pdf, text_file, asset, reference

    Use cases:
    - Displaying or returning processed or generated documents.
    - Passing document data (as a 'DocumentRef') between workflow nodes.
    - Returning results of document analysis or manipulation.
    """

    name: str | OutputHandle[str] = connect_field(
        default="", description="The parameter name for the workflow."
    )
    value: types.DocumentRef | OutputHandle[types.DocumentRef] = connect_field(
        default=types.DocumentRef(type="document", uri="", asset_id=None, data=None),
        description=None,
    )
    description: str | OutputHandle[str] = connect_field(
        default="", description="The description of the output for the workflow."
    )

    @property
    def out(self) -> "DocumentOutputOutputs":
        return DocumentOutputOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.output.DocumentOutput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class DocumentOutputOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self["output"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.output
from nodetool.workflows.base_node import BaseNode


class FilePathOutput(GraphNode[nodetool.workflows.base_node.OutputNode.OutputType]):
    """

    Output node for a file path.
    file, path, file_path
    """

    name: str | OutputHandle[str] = connect_field(
        default="", description="The parameter name for the workflow."
    )
    value: types.FilePath | OutputHandle[types.FilePath] = connect_field(
        default=types.FilePath(type="file_path", path=""), description=None
    )
    description: str | OutputHandle[str] = connect_field(
        default="", description="The description of the output for the workflow."
    )

    @property
    def out(self) -> "FilePathOutputOutputs":
        return FilePathOutputOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.output.FilePathOutput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class FilePathOutputOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self["output"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.output
from nodetool.workflows.base_node import BaseNode


class FloatOutput(GraphNode[nodetool.workflows.base_node.OutputNode.OutputType]):
    """

    Output node for a single float value.
    float, decimal, number

    Use cases:
    - Returning decimal results (e.g. percentages, ratios)
    - Passing floating-point parameters between nodes
    - Displaying numeric metrics with decimal precision
    """

    name: str | OutputHandle[str] = connect_field(
        default="", description="The parameter name for the workflow."
    )
    value: float | OutputHandle[float] = connect_field(default=0, description=None)
    description: str | OutputHandle[str] = connect_field(
        default="", description="The description of the output for the workflow."
    )

    @property
    def out(self) -> "FloatOutputOutputs":
        return FloatOutputOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.output.FloatOutput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class FloatOutputOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self["output"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.output
from nodetool.workflows.base_node import BaseNode


class FolderPathOutput(GraphNode[nodetool.workflows.base_node.OutputNode.OutputType]):
    """

    Output node for a folder path.
    folder, path, folder_path
    """

    name: str | OutputHandle[str] = connect_field(
        default="", description="The parameter name for the workflow."
    )
    value: types.FolderPath | OutputHandle[types.FolderPath] = connect_field(
        default=types.FolderPath(type="folder_path", path=""), description=None
    )
    description: str | OutputHandle[str] = connect_field(
        default="", description="The description of the output for the workflow."
    )

    @property
    def out(self) -> "FolderPathOutputOutputs":
        return FolderPathOutputOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.output.FolderPathOutput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class FolderPathOutputOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self["output"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.output
from nodetool.workflows.base_node import BaseNode


class ImageOutput(GraphNode[nodetool.workflows.base_node.OutputNode.OutputType]):
    """

    Output node for a single image reference ('ImageRef').
    image, picture, visual, asset, reference

    Use cases:
    - Displaying a single processed or generated image.
    - Passing image data (as an 'ImageRef') between workflow nodes.
    - Returning image analysis results encapsulated in an 'ImageRef'.
    """

    name: str | OutputHandle[str] = connect_field(
        default="", description="The parameter name for the workflow."
    )
    value: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description=None,
    )
    description: str | OutputHandle[str] = connect_field(
        default="", description="The description of the output for the workflow."
    )

    @property
    def out(self) -> "ImageOutputOutputs":
        return ImageOutputOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.output.ImageOutput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class ImageOutputOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self["output"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.output
from nodetool.workflows.base_node import BaseNode


class IntegerOutput(GraphNode[nodetool.workflows.base_node.OutputNode.OutputType]):
    """

    Output node for a single integer value.
    integer, number, count

    Use cases:
    - Returning numeric results (e.g. counts, indices)
    - Passing integer parameters between nodes
    - Displaying numeric metrics
    """

    name: str | OutputHandle[str] = connect_field(
        default="", description="The parameter name for the workflow."
    )
    value: int | OutputHandle[int] = connect_field(default=0, description=None)
    description: str | OutputHandle[str] = connect_field(
        default="", description="The description of the output for the workflow."
    )

    @property
    def out(self) -> "IntegerOutputOutputs":
        return IntegerOutputOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.output.IntegerOutput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class IntegerOutputOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self["output"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.output
from nodetool.workflows.base_node import BaseNode


class ListOutput(GraphNode[nodetool.workflows.base_node.OutputNode.OutputType]):
    """

    Output node for a list of arbitrary values.
    list, output, any

    Use cases:
    - Returning multiple results from a workflow
    - Aggregating outputs from multiple nodes
    """

    name: str | OutputHandle[str] = connect_field(
        default="", description="The parameter name for the workflow."
    )
    value: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )
    description: str | OutputHandle[str] = connect_field(
        default="", description="The description of the output for the workflow."
    )

    @property
    def out(self) -> "ListOutputOutputs":
        return ListOutputOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.output.ListOutput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class ListOutputOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self["output"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.output
from nodetool.workflows.base_node import BaseNode


class StringOutput(GraphNode[nodetool.workflows.base_node.OutputNode.OutputType]):
    """

    Output node for a string value.
    string, text, output, label, name

    Use cases:
    - Returning short text results or messages.
    - Passing concise string parameters or identifiers between nodes.
    - Displaying brief textual outputs.
    - For multi-line text or structured document content, use appropriate output nodes if available or consider how data is structured.
    """

    name: str | OutputHandle[str] = connect_field(
        default="", description="The parameter name for the workflow."
    )
    value: str | OutputHandle[str] = connect_field(default="", description=None)
    description: str | OutputHandle[str] = connect_field(
        default="", description="The description of the output for the workflow."
    )

    @property
    def out(self) -> "StringOutputOutputs":
        return StringOutputOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.output.StringOutput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class StringOutputOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self["output"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.output
from nodetool.workflows.base_node import BaseNode


class VideoOutput(GraphNode[nodetool.workflows.base_node.OutputNode.OutputType]):
    """

    Output node for video content references ('VideoRef').
    video, media, clip, asset, reference

    Use cases:
    - Displaying processed or generated video content.
    - Passing video data (as a 'VideoRef') between workflow steps.
    - Returning results of video analysis encapsulated in a 'VideoRef'.
    """

    name: str | OutputHandle[str] = connect_field(
        default="", description="The parameter name for the workflow."
    )
    value: types.VideoRef | OutputHandle[types.VideoRef] = connect_field(
        default=types.VideoRef(
            type="video", uri="", asset_id=None, data=None, duration=None, format=None
        ),
        description=None,
    )
    description: str | OutputHandle[str] = connect_field(
        default="", description="The description of the output for the workflow."
    )

    @property
    def out(self) -> "VideoOutputOutputs":
        return VideoOutputOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.output.VideoOutput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class VideoOutputOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self["output"])
