# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import (
    OutputHandle,
    OutputsProxy,
    DynamicOutputsProxy,
    connect_field,
)
import nodetool.nodes.nodetool.code
import nodetool.nodes.nodetool.code
import nodetool.nodes.nodetool.code


class ExecuteBash(GraphNode[nodetool.nodes.nodetool.code.ExecuteBash.OutputType]):
    """
    Executes Bash script with safety restrictions.
    bash, shell, code, execute
    """

    BashImage: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.code.ExecuteBash.BashImage
    )
    ExecutionMode: typing.ClassVar[type] = nodetool.nodes.nodetool.code.ExecutionMode
    code: str | OutputHandle[str] = connect_field(
        default="",
        description="Bash script to execute as-is. Dynamic inputs are provided as env vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'.",
    )
    image: nodetool.nodes.nodetool.code.ExecuteBash.BashImage = Field(
        default=nodetool.nodes.nodetool.code.ExecuteBash.BashImage.UBUNTU_22_04,
        description="Docker image to use for execution",
    )
    execution_mode: nodetool.nodes.nodetool.code.ExecutionMode = Field(
        default=nodetool.nodes.nodetool.code.ExecutionMode.DOCKER,
        description="Execution mode: 'docker' or 'subprocess'",
    )
    stdin: str | OutputHandle[str] = connect_field(
        default="",
        description="String to write to process stdin before any streaming input. Use newlines to separate lines.",
    )

    @property
    def out(self) -> "ExecuteBashOutputs":
        return ExecuteBashOutputs(self)

    @classmethod
    def get_node_type(cls):
        return "nodetool.code.ExecuteBash"


class ExecuteBashOutputs(DynamicOutputsProxy):
    @property
    def stdout(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stdout"])

    @property
    def stderr(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stderr"])


ExecuteBash.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import (
    OutputHandle,
    OutputsProxy,
    DynamicOutputsProxy,
    connect_field,
)
import nodetool.nodes.nodetool.code
import nodetool.nodes.nodetool.code
import nodetool.nodes.nodetool.code


class ExecuteCommand(GraphNode[nodetool.nodes.nodetool.code.ExecuteCommand.OutputType]):
    """
    Executes a single shell command inside a Docker container.
    command, execute, shell, bash, sh

    IMPORTANT: Only enabled in non-production environments
    """

    CommandImage: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.code.ExecuteCommand.CommandImage
    )
    ExecutionMode: typing.ClassVar[type] = nodetool.nodes.nodetool.code.ExecutionMode
    command: str | OutputHandle[str] = connect_field(
        default="",
        description="Single command to run via the selected shell. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'.",
    )
    image: nodetool.nodes.nodetool.code.ExecuteCommand.CommandImage = Field(
        default=nodetool.nodes.nodetool.code.ExecuteCommand.CommandImage.BASH_5_2,
        description="Docker image to use for execution",
    )
    execution_mode: nodetool.nodes.nodetool.code.ExecutionMode = Field(
        default=nodetool.nodes.nodetool.code.ExecutionMode.DOCKER,
        description="Execution mode: 'docker' or 'subprocess'",
    )
    stdin: str | OutputHandle[str] = connect_field(
        default="",
        description="String to write to process stdin before any streaming input. Use newlines to separate lines.",
    )

    @property
    def out(self) -> "ExecuteCommandOutputs":
        return ExecuteCommandOutputs(self)

    @classmethod
    def get_node_type(cls):
        return "nodetool.code.ExecuteCommand"


class ExecuteCommandOutputs(DynamicOutputsProxy):
    @property
    def stdout(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stdout"])

    @property
    def stderr(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stderr"])


ExecuteCommand.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import (
    OutputHandle,
    OutputsProxy,
    DynamicOutputsProxy,
    connect_field,
)
import nodetool.nodes.nodetool.code
import nodetool.nodes.nodetool.code
import nodetool.nodes.nodetool.code


class ExecuteJavaScript(
    GraphNode[nodetool.nodes.nodetool.code.ExecuteJavaScript.OutputType]
):
    """
    Executes JavaScript (Node.js) code with safety restrictions.
    javascript, nodejs, code, execute
    """

    JavaScriptImage: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.code.ExecuteJavaScript.JavaScriptImage
    )
    ExecutionMode: typing.ClassVar[type] = nodetool.nodes.nodetool.code.ExecutionMode
    code: str | OutputHandle[str] = connect_field(
        default="",
        description="JavaScript code to execute as-is under Node.js. Dynamic inputs are provided as local vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'.",
    )
    image: nodetool.nodes.nodetool.code.ExecuteJavaScript.JavaScriptImage = Field(
        default=nodetool.nodes.nodetool.code.ExecuteJavaScript.JavaScriptImage.NODE_22_ALPINE,
        description="Docker image to use for execution",
    )
    execution_mode: nodetool.nodes.nodetool.code.ExecutionMode = Field(
        default=nodetool.nodes.nodetool.code.ExecutionMode.DOCKER,
        description="Execution mode: 'docker' or 'subprocess'",
    )
    stdin: str | OutputHandle[str] = connect_field(
        default="",
        description="String to write to process stdin before any streaming input. Use newlines to separate lines.",
    )

    @property
    def out(self) -> "ExecuteJavaScriptOutputs":
        return ExecuteJavaScriptOutputs(self)

    @classmethod
    def get_node_type(cls):
        return "nodetool.code.ExecuteJavaScript"


class ExecuteJavaScriptOutputs(DynamicOutputsProxy):
    @property
    def stdout(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stdout"])

    @property
    def stderr(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stderr"])


ExecuteJavaScript.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import (
    OutputHandle,
    OutputsProxy,
    DynamicOutputsProxy,
    connect_field,
)
import nodetool.nodes.nodetool.code
import nodetool.nodes.nodetool.code
import nodetool.nodes.nodetool.code


class ExecuteLua(GraphNode[nodetool.nodes.nodetool.code.ExecuteLua.OutputType]):
    """
    Executes Lua code with a local sandbox (no Docker).
    lua, code, execute, sandbox
    """

    LuaExecutable: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.code.ExecuteLua.LuaExecutable
    )
    ExecutionMode: typing.ClassVar[type] = nodetool.nodes.nodetool.code.ExecutionMode
    code: str | OutputHandle[str] = connect_field(
        default="",
        description="Lua code to execute as-is in a restricted environment. Dynamic inputs are provided as variables. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'.",
    )
    executable: nodetool.nodes.nodetool.code.ExecuteLua.LuaExecutable = Field(
        default=nodetool.nodes.nodetool.code.ExecuteLua.LuaExecutable.LUA,
        description="Lua executable to use",
    )
    execution_mode: nodetool.nodes.nodetool.code.ExecutionMode = Field(
        default=nodetool.nodes.nodetool.code.ExecutionMode.SUBPROCESS,
        description="Execution mode: 'docker' or 'subprocess'",
    )
    timeout_seconds: int | OutputHandle[int] = connect_field(
        default=10, description="Max seconds to allow execution before forced stop"
    )
    stdin: str | OutputHandle[str] = connect_field(
        default="",
        description="String to write to process stdin before any streaming input. Use newlines to separate lines.",
    )

    @property
    def out(self) -> "ExecuteLuaOutputs":
        return ExecuteLuaOutputs(self)

    @classmethod
    def get_node_type(cls):
        return "nodetool.code.ExecuteLua"


class ExecuteLuaOutputs(DynamicOutputsProxy):
    @property
    def stdout(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stdout"])

    @property
    def stderr(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stderr"])


ExecuteLua.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import (
    OutputHandle,
    OutputsProxy,
    DynamicOutputsProxy,
    connect_field,
)
import nodetool.nodes.nodetool.code
import nodetool.nodes.nodetool.code
import nodetool.nodes.nodetool.code


class ExecutePython(GraphNode[nodetool.nodes.nodetool.code.ExecutePython.OutputType]):
    """
    Executes Python code with safety restrictions.
    python, code, execute

    Use cases:
    - Run custom data transformations
    - Prototype node functionality
    - Debug and testing workflows

    IMPORTANT: Only enabled in non-production environments
    """

    PythonImage: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.code.ExecutePython.PythonImage
    )
    ExecutionMode: typing.ClassVar[type] = nodetool.nodes.nodetool.code.ExecutionMode
    code: str | OutputHandle[str] = connect_field(
        default="",
        description="Python code to execute as-is. Dynamic inputs are provided as local vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'.",
    )
    image: nodetool.nodes.nodetool.code.ExecutePython.PythonImage = Field(
        default=nodetool.nodes.nodetool.code.ExecutePython.PythonImage.PYTHON_3_11_SLIM,
        description="Docker image to use for execution",
    )
    execution_mode: nodetool.nodes.nodetool.code.ExecutionMode = Field(
        default=nodetool.nodes.nodetool.code.ExecutionMode.DOCKER,
        description="Execution mode: 'docker' or 'subprocess'",
    )
    stdin: str | OutputHandle[str] = connect_field(
        default="",
        description="String to write to process stdin before any streaming input. Use newlines to separate lines.",
    )

    @property
    def out(self) -> "ExecutePythonOutputs":
        return ExecutePythonOutputs(self)

    @classmethod
    def get_node_type(cls):
        return "nodetool.code.ExecutePython"


class ExecutePythonOutputs(DynamicOutputsProxy):
    @property
    def stdout(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stdout"])

    @property
    def stderr(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stderr"])


ExecutePython.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import (
    OutputHandle,
    OutputsProxy,
    DynamicOutputsProxy,
    connect_field,
)
import nodetool.nodes.nodetool.code
import nodetool.nodes.nodetool.code
import nodetool.nodes.nodetool.code


class ExecuteRuby(GraphNode[nodetool.nodes.nodetool.code.ExecuteRuby.OutputType]):
    """
    Executes Ruby code with safety restrictions.
    ruby, code, execute
    """

    RubyImage: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.code.ExecuteRuby.RubyImage
    )
    ExecutionMode: typing.ClassVar[type] = nodetool.nodes.nodetool.code.ExecutionMode
    code: str | OutputHandle[str] = connect_field(
        default="",
        description="Ruby code to execute as-is. Dynamic inputs are provided as env vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'.",
    )
    image: nodetool.nodes.nodetool.code.ExecuteRuby.RubyImage = Field(
        default=nodetool.nodes.nodetool.code.ExecuteRuby.RubyImage.RUBY_3_3_ALPINE,
        description="Docker image to use for execution",
    )
    execution_mode: nodetool.nodes.nodetool.code.ExecutionMode = Field(
        default=nodetool.nodes.nodetool.code.ExecutionMode.DOCKER,
        description="Execution mode: 'docker' or 'subprocess'",
    )
    stdin: str | OutputHandle[str] = connect_field(
        default="",
        description="String to write to process stdin before any streaming input. Use newlines to separate lines.",
    )

    @property
    def out(self) -> "ExecuteRubyOutputs":
        return ExecuteRubyOutputs(self)

    @classmethod
    def get_node_type(cls):
        return "nodetool.code.ExecuteRuby"


class ExecuteRubyOutputs(DynamicOutputsProxy):
    @property
    def stdout(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stdout"])

    @property
    def stderr(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stderr"])


ExecuteRuby.model_rebuild(force=True)
