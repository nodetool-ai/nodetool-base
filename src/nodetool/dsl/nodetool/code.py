# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import (
    OutputHandle,
    OutputsProxy,
    DynamicOutputsProxy,
    connect_field,
)
import nodetool.nodes.nodetool.code
from nodetool.workflows.base_node import BaseNode
import nodetool.nodes.nodetool.code
import nodetool.nodes.nodetool.code


class ExecuteBash(GraphNode[nodetool.nodes.nodetool.code.ExecuteBash.OutputType]):
    """
    Executes Bash script with safety restrictions.
    bash, shell, code, execute


    This node supports dynamic properties. Additional properties can be passed
    as keyword arguments during initialization and will be stored in the node's
    dynamic_properties dictionary.

    Example:
        node = ExecuteBash(prop1=value1, prop2=value2)
    """

    BashImage: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.code.ExecuteBash.BashImage
    )
    ExecutionMode: typing.ClassVar[type] = nodetool.nodes.nodetool.code.ExecutionMode
    code: str | OutputHandle[str] = connect_field(
        default="",
        description="Bash script to execute as-is. Dynamic inputs are provided as env vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'.",
    )
    image: nodetool.nodes.nodetool.code.ExecuteBash.BashImage = Field(
        default=nodetool.nodes.nodetool.code.ExecuteBash.BashImage.UBUNTU_22_04,
        description="Docker image to use for execution",
    )
    execution_mode: nodetool.nodes.nodetool.code.ExecutionMode = Field(
        default=nodetool.nodes.nodetool.code.ExecutionMode.DOCKER,
        description="Execution mode: 'docker' or 'subprocess'",
    )
    stdin: str | OutputHandle[str] = connect_field(
        default="",
        description="String to write to process stdin before any streaming input. Use newlines to separate lines.",
    )

    def __init__(self, **kwargs: typing.Any) -> None:
        """
        Initialize a ExecuteBash node.

        Extra keyword arguments beyond the defined fields will be treated as
        dynamic properties and automatically passed to the underlying BaseNode
        as dynamic_properties.

        Args:
            **kwargs: Field values and dynamic properties.
        """
        # Separate known fields from dynamic properties
        from pydantic import ConfigDict

        super().__init__(**kwargs)

    @property
    def out(self) -> "ExecuteBashOutputs":
        return ExecuteBashOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.code.ExecuteBash

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class ExecuteBashOutputs(DynamicOutputsProxy):
    @property
    def stdout(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stdout"])

    @property
    def stderr(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stderr"])


import typing
from pydantic import Field
from nodetool.dsl.handles import (
    OutputHandle,
    OutputsProxy,
    DynamicOutputsProxy,
    connect_field,
)
import nodetool.nodes.nodetool.code
from nodetool.workflows.base_node import BaseNode
import nodetool.nodes.nodetool.code
import nodetool.nodes.nodetool.code


class ExecuteCommand(GraphNode[nodetool.nodes.nodetool.code.ExecuteCommand.OutputType]):
    """
    Executes a single shell command inside a Docker container.
    command, execute, shell, bash, sh

    IMPORTANT: Only enabled in non-production environments


    This node supports dynamic properties. Additional properties can be passed
    as keyword arguments during initialization and will be stored in the node's
    dynamic_properties dictionary.

    Example:
        node = ExecuteCommand(prop1=value1, prop2=value2)
    """

    CommandImage: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.code.ExecuteCommand.CommandImage
    )
    ExecutionMode: typing.ClassVar[type] = nodetool.nodes.nodetool.code.ExecutionMode
    command: str | OutputHandle[str] = connect_field(
        default="",
        description="Single command to run via the selected shell. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'.",
    )
    image: nodetool.nodes.nodetool.code.ExecuteCommand.CommandImage = Field(
        default=nodetool.nodes.nodetool.code.ExecuteCommand.CommandImage.BASH_5_2,
        description="Docker image to use for execution",
    )
    execution_mode: nodetool.nodes.nodetool.code.ExecutionMode = Field(
        default=nodetool.nodes.nodetool.code.ExecutionMode.DOCKER,
        description="Execution mode: 'docker' or 'subprocess'",
    )
    stdin: str | OutputHandle[str] = connect_field(
        default="",
        description="String to write to process stdin before any streaming input. Use newlines to separate lines.",
    )

    def __init__(self, **kwargs: typing.Any) -> None:
        """
        Initialize a ExecuteCommand node.

        Extra keyword arguments beyond the defined fields will be treated as
        dynamic properties and automatically passed to the underlying BaseNode
        as dynamic_properties.

        Args:
            **kwargs: Field values and dynamic properties.
        """
        # Separate known fields from dynamic properties
        from pydantic import ConfigDict

        super().__init__(**kwargs)

    @property
    def out(self) -> "ExecuteCommandOutputs":
        return ExecuteCommandOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.code.ExecuteCommand

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class ExecuteCommandOutputs(DynamicOutputsProxy):
    @property
    def stdout(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stdout"])

    @property
    def stderr(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stderr"])


import typing
from pydantic import Field
from nodetool.dsl.handles import (
    OutputHandle,
    OutputsProxy,
    DynamicOutputsProxy,
    connect_field,
)
import nodetool.nodes.nodetool.code
from nodetool.workflows.base_node import BaseNode
import nodetool.nodes.nodetool.code
import nodetool.nodes.nodetool.code


class ExecuteJavaScript(
    GraphNode[nodetool.nodes.nodetool.code.ExecuteJavaScript.OutputType]
):
    """
    Executes JavaScript (Node.js) code with safety restrictions.
    javascript, nodejs, code, execute


    This node supports dynamic properties. Additional properties can be passed
    as keyword arguments during initialization and will be stored in the node's
    dynamic_properties dictionary.

    Example:
        node = ExecuteJavaScript(prop1=value1, prop2=value2)
    """

    JavaScriptImage: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.code.ExecuteJavaScript.JavaScriptImage
    )
    ExecutionMode: typing.ClassVar[type] = nodetool.nodes.nodetool.code.ExecutionMode
    code: str | OutputHandle[str] = connect_field(
        default="",
        description="JavaScript code to execute as-is under Node.js. Dynamic inputs are provided as local vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'.",
    )
    image: nodetool.nodes.nodetool.code.ExecuteJavaScript.JavaScriptImage = Field(
        default=nodetool.nodes.nodetool.code.ExecuteJavaScript.JavaScriptImage.NODE_22_ALPINE,
        description="Docker image to use for execution",
    )
    execution_mode: nodetool.nodes.nodetool.code.ExecutionMode = Field(
        default=nodetool.nodes.nodetool.code.ExecutionMode.DOCKER,
        description="Execution mode: 'docker' or 'subprocess'",
    )
    stdin: str | OutputHandle[str] = connect_field(
        default="",
        description="String to write to process stdin before any streaming input. Use newlines to separate lines.",
    )

    def __init__(self, **kwargs: typing.Any) -> None:
        """
        Initialize a ExecuteJavaScript node.

        Extra keyword arguments beyond the defined fields will be treated as
        dynamic properties and automatically passed to the underlying BaseNode
        as dynamic_properties.

        Args:
            **kwargs: Field values and dynamic properties.
        """
        # Separate known fields from dynamic properties
        from pydantic import ConfigDict

        super().__init__(**kwargs)

    @property
    def out(self) -> "ExecuteJavaScriptOutputs":
        return ExecuteJavaScriptOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.code.ExecuteJavaScript

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class ExecuteJavaScriptOutputs(DynamicOutputsProxy):
    @property
    def stdout(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stdout"])

    @property
    def stderr(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stderr"])


import typing
from pydantic import Field
from nodetool.dsl.handles import (
    OutputHandle,
    OutputsProxy,
    DynamicOutputsProxy,
    connect_field,
)
import nodetool.nodes.nodetool.code
from nodetool.workflows.base_node import BaseNode
import nodetool.nodes.nodetool.code
import nodetool.nodes.nodetool.code


class ExecuteLua(GraphNode[nodetool.nodes.nodetool.code.ExecuteLua.OutputType]):
    """
    Executes Lua code with a local sandbox (no Docker).
    lua, code, execute, sandbox


    This node supports dynamic properties. Additional properties can be passed
    as keyword arguments during initialization and will be stored in the node's
    dynamic_properties dictionary.

    Example:
        node = ExecuteLua(prop1=value1, prop2=value2)
    """

    LuaExecutable: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.code.ExecuteLua.LuaExecutable
    )
    ExecutionMode: typing.ClassVar[type] = nodetool.nodes.nodetool.code.ExecutionMode
    code: str | OutputHandle[str] = connect_field(
        default="",
        description="Lua code to execute as-is in a restricted environment. Dynamic inputs are provided as variables. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'.",
    )
    executable: nodetool.nodes.nodetool.code.ExecuteLua.LuaExecutable = Field(
        default=nodetool.nodes.nodetool.code.ExecuteLua.LuaExecutable.LUA,
        description="Lua executable to use",
    )
    execution_mode: nodetool.nodes.nodetool.code.ExecutionMode = Field(
        default=nodetool.nodes.nodetool.code.ExecutionMode.SUBPROCESS,
        description="Execution mode: 'docker' or 'subprocess'",
    )
    timeout_seconds: int | OutputHandle[int] = connect_field(
        default=10, description="Max seconds to allow execution before forced stop"
    )
    stdin: str | OutputHandle[str] = connect_field(
        default="",
        description="String to write to process stdin before any streaming input. Use newlines to separate lines.",
    )

    def __init__(self, **kwargs: typing.Any) -> None:
        """
        Initialize a ExecuteLua node.

        Extra keyword arguments beyond the defined fields will be treated as
        dynamic properties and automatically passed to the underlying BaseNode
        as dynamic_properties.

        Args:
            **kwargs: Field values and dynamic properties.
        """
        # Separate known fields from dynamic properties
        from pydantic import ConfigDict

        super().__init__(**kwargs)

    @property
    def out(self) -> "ExecuteLuaOutputs":
        return ExecuteLuaOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.code.ExecuteLua

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class ExecuteLuaOutputs(DynamicOutputsProxy):
    @property
    def stdout(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stdout"])

    @property
    def stderr(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stderr"])


import typing
from pydantic import Field
from nodetool.dsl.handles import (
    OutputHandle,
    OutputsProxy,
    DynamicOutputsProxy,
    connect_field,
)
import nodetool.nodes.nodetool.code
from nodetool.workflows.base_node import BaseNode
import nodetool.nodes.nodetool.code
import nodetool.nodes.nodetool.code


class ExecutePython(GraphNode[nodetool.nodes.nodetool.code.ExecutePython.OutputType]):
    """
    Executes Python code with safety restrictions.
    python, code, execute

    Use cases:
    - Run custom data transformations
    - Prototype node functionality
    - Debug and testing workflows

    IMPORTANT: Only enabled in non-production environments


    This node supports dynamic properties. Additional properties can be passed
    as keyword arguments during initialization and will be stored in the node's
    dynamic_properties dictionary.

    Example:
        node = ExecutePython(prop1=value1, prop2=value2)
    """

    PythonImage: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.code.ExecutePython.PythonImage
    )
    ExecutionMode: typing.ClassVar[type] = nodetool.nodes.nodetool.code.ExecutionMode
    code: str | OutputHandle[str] = connect_field(
        default="",
        description="Python code to execute as-is. Dynamic inputs are provided as local vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'.",
    )
    image: nodetool.nodes.nodetool.code.ExecutePython.PythonImage = Field(
        default=nodetool.nodes.nodetool.code.ExecutePython.PythonImage.PYTHON_3_11_SLIM,
        description="Docker image to use for execution",
    )
    execution_mode: nodetool.nodes.nodetool.code.ExecutionMode = Field(
        default=nodetool.nodes.nodetool.code.ExecutionMode.DOCKER,
        description="Execution mode: 'docker' or 'subprocess'",
    )
    stdin: str | OutputHandle[str] = connect_field(
        default="",
        description="String to write to process stdin before any streaming input. Use newlines to separate lines.",
    )

    def __init__(self, **kwargs: typing.Any) -> None:
        """
        Initialize a ExecutePython node.

        Extra keyword arguments beyond the defined fields will be treated as
        dynamic properties and automatically passed to the underlying BaseNode
        as dynamic_properties.

        Args:
            **kwargs: Field values and dynamic properties.
        """
        # Separate known fields from dynamic properties
        from pydantic import ConfigDict

        super().__init__(**kwargs)

    @property
    def out(self) -> "ExecutePythonOutputs":
        return ExecutePythonOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.code.ExecutePython

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class ExecutePythonOutputs(DynamicOutputsProxy):
    @property
    def stdout(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stdout"])

    @property
    def stderr(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stderr"])


import typing
from pydantic import Field
from nodetool.dsl.handles import (
    OutputHandle,
    OutputsProxy,
    DynamicOutputsProxy,
    connect_field,
)
import nodetool.nodes.nodetool.code
from nodetool.workflows.base_node import BaseNode
import nodetool.nodes.nodetool.code
import nodetool.nodes.nodetool.code


class ExecuteRuby(GraphNode[nodetool.nodes.nodetool.code.ExecuteRuby.OutputType]):
    """
    Executes Ruby code with safety restrictions.
    ruby, code, execute


    This node supports dynamic properties. Additional properties can be passed
    as keyword arguments during initialization and will be stored in the node's
    dynamic_properties dictionary.

    Example:
        node = ExecuteRuby(prop1=value1, prop2=value2)
    """

    RubyImage: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.code.ExecuteRuby.RubyImage
    )
    ExecutionMode: typing.ClassVar[type] = nodetool.nodes.nodetool.code.ExecutionMode
    code: str | OutputHandle[str] = connect_field(
        default="",
        description="Ruby code to execute as-is. Dynamic inputs are provided as env vars. Stdout lines are emitted on 'stdout'; stderr lines on 'stderr'.",
    )
    image: nodetool.nodes.nodetool.code.ExecuteRuby.RubyImage = Field(
        default=nodetool.nodes.nodetool.code.ExecuteRuby.RubyImage.RUBY_3_3_ALPINE,
        description="Docker image to use for execution",
    )
    execution_mode: nodetool.nodes.nodetool.code.ExecutionMode = Field(
        default=nodetool.nodes.nodetool.code.ExecutionMode.DOCKER,
        description="Execution mode: 'docker' or 'subprocess'",
    )
    stdin: str | OutputHandle[str] = connect_field(
        default="",
        description="String to write to process stdin before any streaming input. Use newlines to separate lines.",
    )

    def __init__(self, **kwargs: typing.Any) -> None:
        """
        Initialize a ExecuteRuby node.

        Extra keyword arguments beyond the defined fields will be treated as
        dynamic properties and automatically passed to the underlying BaseNode
        as dynamic_properties.

        Args:
            **kwargs: Field values and dynamic properties.
        """
        # Separate known fields from dynamic properties
        from pydantic import ConfigDict

        super().__init__(**kwargs)

    @property
    def out(self) -> "ExecuteRubyOutputs":
        return ExecuteRubyOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.code.ExecuteRuby

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class ExecuteRubyOutputs(DynamicOutputsProxy):
    @property
    def stdout(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stdout"])

    @property
    def stderr(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["stderr"])
