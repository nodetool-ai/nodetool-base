# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import Field
import typing
from typing import Any
import nodetool.metadata.types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

from nodetool.dsl.handles import OutputHandle, connect_field
import nodetool.nodes.nodetool.boolean
from nodetool.workflows.base_node import BaseNode


class All(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

    Checks if all boolean values in a list are True.
    boolean, all, check, logic, condition, flow-control, branch


    Use cases:
    - Ensure all conditions in a set are met
    - Implement comprehensive checks
    - Validate multiple criteria simultaneously
    """

    values: list[bool] | OutputHandle[list[bool]] = connect_field(
        default=[], description="List of boolean values to check"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.boolean.All

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


from nodetool.dsl.handles import OutputHandle, connect_field
from nodetool.workflows.base_node import BaseNode


class Compare(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

    Compares two values using a specified comparison operator.
    compare, condition, logic

    Use cases:
    - Implement decision points in workflows
    - Filter data based on specific criteria
    - Create dynamic thresholds or limits
    """

    Comparison: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.boolean.Compare.Comparison
    )

    a: int | float | OutputHandle[int | float] = connect_field(
        default=0, description="First value to compare"
    )
    b: int | float | OutputHandle[int | float] = connect_field(
        default=0, description="Second value to compare"
    )
    comparison: nodetool.nodes.nodetool.boolean.Compare.Comparison = Field(
        default=nodetool.nodes.nodetool.boolean.Compare.Comparison.EQUAL,
        description="Comparison operator to use",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.boolean.Compare

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, connect_field
import nodetool.nodes.nodetool.boolean
from nodetool.workflows.base_node import BaseNode


class ConditionalSwitch(SingleOutputGraphNode[Any], GraphNode[Any]):
    """

    Performs a conditional check on a boolean input and returns a value based on the result.
    if, condition, flow-control, branch, true, false, switch, toggle

    Use cases:
    - Implement conditional logic in workflows
    - Create dynamic branches in workflows
    - Implement decision points in workflows
    """

    condition: bool | OutputHandle[bool] = connect_field(
        default=False, description="The condition to check"
    )
    if_true: Any | OutputHandle[Any] = connect_field(
        default=(), description="The value to return if the condition is true"
    )
    if_false: Any | OutputHandle[Any] = connect_field(
        default=(), description="The value to return if the condition is false"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.boolean.ConditionalSwitch

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, connect_field
import nodetool.nodes.nodetool.boolean
from nodetool.workflows.base_node import BaseNode


class IsIn(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

    Checks if a value is present in a list of options.
    membership, contains, check

    Use cases:
    - Validate input against a set of allowed values
    - Implement category or group checks
    - Filter data based on inclusion criteria
    """

    value: Any | OutputHandle[Any] = connect_field(
        default=(), description="The value to check for membership"
    )
    options: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description="The list of options to check against"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.boolean.IsIn

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, connect_field
import nodetool.nodes.nodetool.boolean
from nodetool.workflows.base_node import BaseNode


class IsNone(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

    Checks if a value is None.
    null, none, check

    Use cases:
    - Validate input presence
    - Handle optional parameters
    - Implement null checks in data processing
    """

    value: Any | OutputHandle[Any] = connect_field(
        default=(), description="The value to check for None"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.boolean.IsNone

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, connect_field
import nodetool.nodes.nodetool.boolean
from nodetool.workflows.base_node import BaseNode


class LogicalOperator(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

    Performs logical operations on two boolean inputs.
    boolean, logic, operator, condition, flow-control, branch, else, true, false, switch, toggle

    Use cases:
    - Combine multiple conditions in decision-making
    - Implement complex logical rules in workflows
    - Create advanced filters or triggers
    """

    BooleanOperation: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.boolean.LogicalOperator.BooleanOperation
    )

    a: bool | OutputHandle[bool] = connect_field(
        default=False, description="First boolean input"
    )
    b: bool | OutputHandle[bool] = connect_field(
        default=False, description="Second boolean input"
    )
    operation: nodetool.nodes.nodetool.boolean.LogicalOperator.BooleanOperation = Field(
        default=nodetool.nodes.nodetool.boolean.LogicalOperator.BooleanOperation.AND,
        description="Logical operation to perform",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.boolean.LogicalOperator

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, connect_field
import nodetool.nodes.nodetool.boolean
from nodetool.workflows.base_node import BaseNode


class Not(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

    Performs logical NOT operation on a boolean input.
    boolean, logic, not, invert, !, negation, condition, else, true, false, switch, toggle, flow-control, branch

    Use cases:
    - Invert a condition's result
    - Implement toggle functionality
    - Create opposite logic branches
    """

    value: bool | OutputHandle[bool] = connect_field(
        default=False, description="Boolean input to negate"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.boolean.Not

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, connect_field
import nodetool.nodes.nodetool.boolean
from nodetool.workflows.base_node import BaseNode


class Some(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

    Checks if any boolean value in a list is True.
    boolean, any, check, logic, condition, flow-control, branch

    Use cases:
    - Check if at least one condition in a set is met
    - Implement optional criteria checks
    - Create flexible validation rules
    """

    values: list[bool] | OutputHandle[list[bool]] = connect_field(
        default=[], description="List of boolean values to check"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.boolean.Some

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
