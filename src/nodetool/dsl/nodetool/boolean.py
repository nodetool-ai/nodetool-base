# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.boolean
from nodetool.workflows.base_node import BaseNode


class All(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

    Checks if all boolean values in a list are True.
    boolean, all, check, logic, condition, flow-control, branch


    Use cases:
    - Ensure all conditions in a set are met
    - Implement comprehensive checks
    - Validate multiple criteria simultaneously
    """

    values: list[bool] | OutputHandle[list[bool]] = connect_field(
        default=[], description="List of boolean values to check"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.boolean.All

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.boolean
from nodetool.workflows.base_node import BaseNode


class Compare(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

    Compares two values using a specified comparison operator.
    compare, condition, logic

    Use cases:
    - Implement decision points in workflows
    - Filter data based on specific criteria
    - Create dynamic thresholds or limits
    """

    Comparison: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.boolean.Compare.Comparison
    )

    a: Any | OutputHandle[Any] = connect_field(
        default=None, description="First value to compare"
    )
    b: Any | OutputHandle[Any] = connect_field(
        default=None, description="Second value to compare"
    )
    comparison: nodetool.nodes.nodetool.boolean.Compare.Comparison = Field(
        default=nodetool.nodes.nodetool.boolean.Compare.Comparison.EQUAL,
        description="Comparison operator to use",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.boolean.Compare

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.boolean
from nodetool.workflows.base_node import BaseNode


class ConditionalSwitch(SingleOutputGraphNode[Any], GraphNode[Any]):
    """

    Performs a conditional check on a boolean input and returns a value based on the result.
    if, condition, flow-control, branch, true, false, switch, toggle

    Use cases:
    - Implement conditional logic in workflows
    - Create dynamic branches in workflows
    - Implement decision points in workflows
    """

    condition: bool | OutputHandle[bool] = connect_field(
        default=False, description="The condition to check"
    )
    if_true: Any | OutputHandle[Any] = connect_field(
        default=None, description="The value to return if the condition is true"
    )
    if_false: Any | OutputHandle[Any] = connect_field(
        default=None, description="The value to return if the condition is false"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.boolean.ConditionalSwitch

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.boolean
from nodetool.workflows.base_node import BaseNode


class IsIn(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

    Checks if a value is present in a list of options.
    membership, contains, check

    Use cases:
    - Validate input against a set of allowed values
    - Implement category or group checks
    - Filter data based on inclusion criteria
    """

    value: Any | OutputHandle[Any] = connect_field(
        default=None, description="The value to check for membership"
    )
    options: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description="The list of options to check against"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.boolean.IsIn

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.boolean
from nodetool.workflows.base_node import BaseNode


class IsNone(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

    Checks if a value is None.
    null, none, check

    Use cases:
    - Validate input presence
    - Handle optional parameters
    - Implement null checks in data processing
    """

    value: Any | OutputHandle[Any] = connect_field(
        default=None, description="The value to check for None"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.boolean.IsNone

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.boolean
from nodetool.workflows.base_node import BaseNode


class LogicalOperator(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

    Performs logical operations on two boolean inputs.
    boolean, logic, operator, condition, flow-control, branch, else, true, false, switch, toggle

    Use cases:
    - Combine multiple conditions in decision-making
    - Implement complex logical rules in workflows
    - Create advanced filters or triggers
    """

    BooleanOperation: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.boolean.LogicalOperator.BooleanOperation
    )

    a: bool | OutputHandle[bool] = connect_field(
        default=False, description="First boolean input"
    )
    b: bool | OutputHandle[bool] = connect_field(
        default=False, description="Second boolean input"
    )
    operation: nodetool.nodes.nodetool.boolean.LogicalOperator.BooleanOperation = Field(
        default=nodetool.nodes.nodetool.boolean.LogicalOperator.BooleanOperation.AND,
        description="Logical operation to perform",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.boolean.LogicalOperator

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.boolean
from nodetool.workflows.base_node import BaseNode


class Not(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

    Performs logical NOT operation on a boolean input.
    boolean, logic, not, invert, !, negation, condition, else, true, false, switch, toggle, flow-control, branch

    Use cases:
    - Invert a condition's result
    - Implement toggle functionality
    - Create opposite logic branches
    """

    value: bool | OutputHandle[bool] = connect_field(
        default=False, description="Boolean input to negate"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.boolean.Not

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.boolean
from nodetool.workflows.base_node import BaseNode


class Some(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

    Checks if any boolean value in a list is True.
    boolean, any, check, logic, condition, flow-control, branch

    Use cases:
    - Check if at least one condition in a set is met
    - Implement optional criteria checks
    - Create flexible validation rules
    """

    values: list[bool] | OutputHandle[list[bool]] = connect_field(
        default=[], description="List of boolean values to check"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.boolean.Some

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
