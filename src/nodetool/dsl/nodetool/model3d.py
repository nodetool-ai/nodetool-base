# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.model3d
from nodetool.workflows.base_node import BaseNode


class Boolean3D(SingleOutputGraphNode[types.Model3DRef], GraphNode[types.Model3DRef]):
    """

    Perform boolean operations on 3D meshes.
    3d, mesh, model, boolean, union, difference, intersection, combine, subtract

    Use cases:
    - Combine multiple objects (union)
    - Cut holes in objects (difference)
    - Find overlapping regions (intersection)
    - Hard-surface modeling operations
    - 3D printing preparation
    """

    BooleanOperation: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.model3d.BooleanOperation
    )

    model_a: types.Model3DRef | OutputHandle[types.Model3DRef] = connect_field(
        default=types.Model3DRef(
            type="model_3d",
            uri="",
            asset_id=None,
            data=None,
            metadata=None,
            format=None,
        ),
        description="First 3D model (base)",
    )
    model_b: types.Model3DRef | OutputHandle[types.Model3DRef] = connect_field(
        default=types.Model3DRef(
            type="model_3d",
            uri="",
            asset_id=None,
            data=None,
            metadata=None,
            format=None,
        ),
        description="Second 3D model (tool)",
    )
    operation: nodetool.nodes.nodetool.model3d.BooleanOperation = Field(
        default=nodetool.nodes.nodetool.model3d.BooleanOperation.UNION,
        description="Boolean operation to perform",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.model3d.Boolean3D

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.model3d
from nodetool.workflows.base_node import BaseNode


class CenterMesh(SingleOutputGraphNode[types.Model3DRef], GraphNode[types.Model3DRef]):
    """

    Center a mesh at the origin.
    3d, mesh, model, center, origin, align

    Use cases:
    - Center models for consistent positioning
    - Prepare models for rotation
    - Align multiple models
    """

    model: types.Model3DRef | OutputHandle[types.Model3DRef] = connect_field(
        default=types.Model3DRef(
            type="model_3d",
            uri="",
            asset_id=None,
            data=None,
            metadata=None,
            format=None,
        ),
        description="The 3D model to center",
    )
    use_centroid: bool | OutputHandle[bool] = connect_field(
        default=True,
        description="Use geometric centroid (True) or bounding box center (False)",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.model3d.CenterMesh

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.model3d
from nodetool.workflows.base_node import BaseNode


class Decimate(SingleOutputGraphNode[types.Model3DRef], GraphNode[types.Model3DRef]):
    """

    Reduce polygon count while preserving shape using Quadric Error Metrics.
    3d, mesh, model, decimate, simplify, reduce, polygon, optimize, LOD

    Use cases:
    - Create level-of-detail (LOD) versions
    - Optimize models for real-time rendering
    - Reduce file size for web deployment
    - Prepare models for mobile/VR applications
    """

    model: types.Model3DRef | OutputHandle[types.Model3DRef] = connect_field(
        default=types.Model3DRef(
            type="model_3d",
            uri="",
            asset_id=None,
            data=None,
            metadata=None,
            format=None,
        ),
        description="The 3D model to decimate",
    )
    target_ratio: float | OutputHandle[float] = connect_field(
        default=0.5, description="Target ratio of faces to keep (0.5 = 50% reduction)"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.model3d.Decimate

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.model3d
from nodetool.workflows.base_node import BaseNode


class FlipNormals(SingleOutputGraphNode[types.Model3DRef], GraphNode[types.Model3DRef]):
    """

    Flip all face normals of a mesh.
    3d, mesh, model, normals, flip, invert, inside_out

    Use cases:
    - Fix inside-out meshes
    - Invert normals for specific rendering effects
    - Repair meshes from incompatible software
    """

    model: types.Model3DRef | OutputHandle[types.Model3DRef] = connect_field(
        default=types.Model3DRef(
            type="model_3d",
            uri="",
            asset_id=None,
            data=None,
            metadata=None,
            format=None,
        ),
        description="The 3D model to process",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.model3d.FlipNormals

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.model3d
from nodetool.workflows.base_node import BaseNode


class FormatConverter(
    SingleOutputGraphNode[types.Model3DRef], GraphNode[types.Model3DRef]
):
    """

    Convert a 3D model to a different format.
    3d, mesh, model, convert, format, obj, glb, stl, ply, usdz, export

    Use cases:
    - Convert high-poly sculpts to web-friendly GLB
    - Export models for 3D printing (STL)
    - Create cross-platform 3D assets
    """

    OutputFormat: typing.ClassVar[type] = nodetool.nodes.nodetool.model3d.OutputFormat

    model: types.Model3DRef | OutputHandle[types.Model3DRef] = connect_field(
        default=types.Model3DRef(
            type="model_3d",
            uri="",
            asset_id=None,
            data=None,
            metadata=None,
            format=None,
        ),
        description="The 3D model to convert",
    )
    output_format: nodetool.nodes.nodetool.model3d.OutputFormat = Field(
        default=nodetool.nodes.nodetool.model3d.OutputFormat.GLB,
        description="Target format for conversion",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.model3d.FormatConverter

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.model3d
from nodetool.workflows.base_node import BaseNode


class GetModel3DMetadata(
    GraphNode[nodetool.nodes.nodetool.model3d.GetModel3DMetadata.OutputType]
):
    """

    Get metadata about a 3D model.
    3d, mesh, model, metadata, info, properties

    Use cases:
    - Get vertex and face counts for processing decisions
    - Analyze model properties
    - Gather information for model cataloging
    """

    model: types.Model3DRef | OutputHandle[types.Model3DRef] = connect_field(
        default=types.Model3DRef(
            type="model_3d",
            uri="",
            asset_id=None,
            data=None,
            metadata=None,
            format=None,
        ),
        description="The 3D model to analyze",
    )

    @property
    def out(self) -> "GetModel3DMetadataOutputs":
        return GetModel3DMetadataOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.model3d.GetModel3DMetadata

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class GetModel3DMetadataOutputs(OutputsProxy):
    @property
    def format(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self["format"])

    @property
    def vertex_count(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self["vertex_count"])

    @property
    def face_count(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self["face_count"])

    @property
    def is_watertight(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self["is_watertight"])

    @property
    def bounds_min(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self["bounds_min"])

    @property
    def bounds_max(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self["bounds_max"])

    @property
    def center_of_mass(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self["center_of_mass"])

    @property
    def volume(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self["volume"])

    @property
    def surface_area(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self["surface_area"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.model3d
from nodetool.workflows.base_node import BaseNode


class LoadModel3DFile(
    SingleOutputGraphNode[types.Model3DRef], GraphNode[types.Model3DRef]
):
    """

    Load a 3D model file from disk.
    3d, mesh, model, input, load, file, obj, glb, stl, ply

    Use cases:
    - Load 3D models for processing
    - Import meshes from CAD software
    - Read 3D assets for a workflow
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to the 3D model file to read"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.model3d.LoadModel3DFile

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.model3d
from nodetool.workflows.base_node import BaseNode


class MergeMeshes(SingleOutputGraphNode[types.Model3DRef], GraphNode[types.Model3DRef]):
    """

    Merge multiple meshes into a single mesh.
    3d, mesh, model, merge, combine, concatenate

    Use cases:
    - Combine multiple parts into one model
    - Merge imported components
    - Prepare models for boolean operations
    """

    models: list[types.Model3DRef] | OutputHandle[list[types.Model3DRef]] = (
        connect_field(default=[], description="List of 3D models to merge")
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.model3d.MergeMeshes

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.model3d
from nodetool.workflows.base_node import BaseNode


class RecalculateNormals(
    SingleOutputGraphNode[types.Model3DRef], GraphNode[types.Model3DRef]
):
    """

    Recalculate mesh normals for proper shading.
    3d, mesh, model, normals, fix, shading, smooth, flat, faces

    Use cases:
    - Fix inverted or broken normals
    - Switch between smooth and flat shading
    - Repair imported meshes with bad normals
    - Prepare models for rendering
    """

    ShadingMode: typing.ClassVar[type] = nodetool.nodes.nodetool.model3d.ShadingMode

    model: types.Model3DRef | OutputHandle[types.Model3DRef] = connect_field(
        default=types.Model3DRef(
            type="model_3d",
            uri="",
            asset_id=None,
            data=None,
            metadata=None,
            format=None,
        ),
        description="The 3D model to process",
    )
    mode: nodetool.nodes.nodetool.model3d.ShadingMode = Field(
        default=nodetool.nodes.nodetool.model3d.ShadingMode.AUTO,
        description="Shading mode: smooth, flat, or auto (uses mesh default)",
    )
    fix_winding: bool | OutputHandle[bool] = connect_field(
        default=True, description="Fix inconsistent face winding (inverted faces)"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.model3d.RecalculateNormals

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.model3d
from nodetool.workflows.base_node import BaseNode


class SaveModel3D(SingleOutputGraphNode[types.Model3DRef], GraphNode[types.Model3DRef]):
    """

    Save a 3D model to an asset folder with customizable name format.
    save, 3d, mesh, model, folder, naming, asset

    Use cases:
    - Save generated 3D models with timestamps
    - Organize outputs into specific folders
    - Create backups of processed models
    """

    model: types.Model3DRef | OutputHandle[types.Model3DRef] = connect_field(
        default=types.Model3DRef(
            type="model_3d",
            uri="",
            asset_id=None,
            data=None,
            metadata=None,
            format=None,
        ),
        description="The 3D model to save.",
    )
    folder: types.FolderRef | OutputHandle[types.FolderRef] = connect_field(
        default=types.FolderRef(
            type="folder", uri="", asset_id=None, data=None, metadata=None
        ),
        description="The asset folder to save the 3D model in.",
    )
    name: str | OutputHandle[str] = connect_field(
        default="%Y-%m-%d_%H-%M-%S.glb",
        description="\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        ",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.model3d.SaveModel3D

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.model3d
from nodetool.workflows.base_node import BaseNode


class SaveModel3DFile(
    SingleOutputGraphNode[types.Model3DRef], GraphNode[types.Model3DRef]
):
    """

    Save a 3D model to disk.
    3d, mesh, model, output, save, file, export

    Use cases:
    - Save processed 3D models
    - Export meshes to different formats
    - Archive 3D model results
    """

    model: types.Model3DRef | OutputHandle[types.Model3DRef] = connect_field(
        default=types.Model3DRef(
            type="model_3d",
            uri="",
            asset_id=None,
            data=None,
            metadata=None,
            format=None,
        ),
        description="The 3D model to save",
    )
    folder: str | OutputHandle[str] = connect_field(
        default="", description="Folder where the file will be saved"
    )
    filename: str | OutputHandle[str] = connect_field(
        default="",
        description="\n        The name of the 3D model file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        ",
    )
    overwrite: bool | OutputHandle[bool] = connect_field(
        default=False,
        description="Overwrite the file if it already exists, otherwise file will be renamed",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.model3d.SaveModel3DFile

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.model3d
from nodetool.workflows.base_node import BaseNode


class Transform3D(SingleOutputGraphNode[types.Model3DRef], GraphNode[types.Model3DRef]):
    """

    Apply translation, rotation, and scaling to a 3D model.
    3d, mesh, model, transform, translate, rotate, scale, move

    Use cases:
    - Position models in 3D space
    - Scale models to specific dimensions
    - Rotate models for proper orientation
    """

    model: types.Model3DRef | OutputHandle[types.Model3DRef] = connect_field(
        default=types.Model3DRef(
            type="model_3d",
            uri="",
            asset_id=None,
            data=None,
            metadata=None,
            format=None,
        ),
        description="The 3D model to transform",
    )
    translate_x: float | OutputHandle[float] = connect_field(
        default=0.0, description="Translation along X axis"
    )
    translate_y: float | OutputHandle[float] = connect_field(
        default=0.0, description="Translation along Y axis"
    )
    translate_z: float | OutputHandle[float] = connect_field(
        default=0.0, description="Translation along Z axis"
    )
    rotate_x: float | OutputHandle[float] = connect_field(
        default=0.0, description="Rotation around X axis in degrees"
    )
    rotate_y: float | OutputHandle[float] = connect_field(
        default=0.0, description="Rotation around Y axis in degrees"
    )
    rotate_z: float | OutputHandle[float] = connect_field(
        default=0.0, description="Rotation around Z axis in degrees"
    )
    scale_x: float | OutputHandle[float] = connect_field(
        default=1.0, description="Scale factor along X axis"
    )
    scale_y: float | OutputHandle[float] = connect_field(
        default=1.0, description="Scale factor along Y axis"
    )
    scale_z: float | OutputHandle[float] = connect_field(
        default=1.0, description="Scale factor along Z axis"
    )
    uniform_scale: float | OutputHandle[float] = connect_field(
        default=1.0, description="Uniform scale factor (applied after axis scales)"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.model3d.Transform3D

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
