# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class ASRModelConstant(
    SingleOutputGraphNode[types.ASRModel], GraphNode[types.ASRModel]
):
    """
    Represents an automatic speech recognition model constant in the workflow.
        asr, speech, recognition, transcription, model

        Use cases:
        - Provide a fixed ASR model for transcription
        - Set default ASR model for the workflow
        - Configure model selection without user input
    """

    value: types.ASRModel | OutputHandle[types.ASRModel] = connect_field(
        default=PydanticUndefined, description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.ASRModelConstant

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Audio(SingleOutputGraphNode[types.AudioRef], GraphNode[types.AudioRef]):
    """
    Represents an audio file constant in the workflow.
        audio, file, mp3, wav

        Use cases:
        - Provide a fixed audio input for audio processing nodes
        - Reference a specific audio file in the workflow
        - Set default audio for testing or demonstration purposes
    """

    value: types.AudioRef | OutputHandle[types.AudioRef] = connect_field(
        default=types.AudioRef(
            type="audio", uri="", asset_id=None, data=None, metadata=None
        ),
        description=None,
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Audio

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class AudioList(
    SingleOutputGraphNode[list[types.AudioRef]], GraphNode[list[types.AudioRef]]
):
    """
    Represents a list of audio file constants in the workflow.
        audios, sounds, audio files, collection

        Use cases:
        - Provide a fixed list of audio files for batch processing
        - Reference multiple audio files in the workflow
        - Set default audio list for testing or demonstration purposes
    """

    value: list[types.AudioRef] | OutputHandle[list[types.AudioRef]] = connect_field(
        default=PydanticUndefined, description="List of audio references"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.AudioList

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Bool(SingleOutputGraphNode[bool], GraphNode[bool]):
    """
    Represents a boolean constant in the workflow.
        boolean, logic, flag

        Use cases:
        - Control flow decisions in conditional nodes
        - Toggle features or behaviors in the workflow
        - Set default boolean values for configuration
    """

    value: bool | OutputHandle[bool] = connect_field(default=False, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Bool

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Constant(SingleOutputGraphNode[typing.Any], GraphNode[typing.Any]):
    """
    Base class for fixed-value nodes.

        constant, parameter, default

        Use cases:
        - Provide static inputs to a workflow
        - Hold configuration values
        - Simplify testing with deterministic outputs
    """

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Constant

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class DataFrame(
    SingleOutputGraphNode[types.DataframeRef], GraphNode[types.DataframeRef]
):
    """
    Represents a fixed DataFrame constant in the workflow.
        table, data, dataframe, pandas

        Use cases:
        - Provide static data for analysis or processing
        - Define lookup tables or reference data
        - Set sample data for testing or demonstration
    """

    value: types.DataframeRef | OutputHandle[types.DataframeRef] = connect_field(
        default=types.DataframeRef(
            type="dataframe",
            uri="",
            asset_id=None,
            data=None,
            metadata=None,
            columns=None,
        ),
        description=None,
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.DataFrame

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Date(SingleOutputGraphNode[types.Date], GraphNode[types.Date]):
    """

    Make a date object from year, month, day.
    date, make, create
    """

    year: int | OutputHandle[int] = connect_field(
        default=1900, description="Year of the date"
    )
    month: int | OutputHandle[int] = connect_field(
        default=1, description="Month of the date"
    )
    day: int | OutputHandle[int] = connect_field(
        default=1, description="Day of the date"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Date

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class DateTime(SingleOutputGraphNode[types.Datetime], GraphNode[types.Datetime]):
    """

    Make a datetime object from year, month, day, hour, minute, second.
    datetime, make, create
    """

    year: int | OutputHandle[int] = connect_field(
        default=1900, description="Year of the datetime"
    )
    month: int | OutputHandle[int] = connect_field(
        default=1, description="Month of the datetime"
    )
    day: int | OutputHandle[int] = connect_field(
        default=1, description="Day of the datetime"
    )
    hour: int | OutputHandle[int] = connect_field(
        default=0, description="Hour of the datetime"
    )
    minute: int | OutputHandle[int] = connect_field(
        default=0, description="Minute of the datetime"
    )
    second: int | OutputHandle[int] = connect_field(
        default=0, description="Second of the datetime"
    )
    millisecond: int | OutputHandle[int] = connect_field(
        default=0, description="Millisecond of the datetime"
    )
    tzinfo: str | OutputHandle[str] = connect_field(
        default="UTC", description="Timezone of the datetime"
    )
    utc_offset: int | OutputHandle[int] = connect_field(
        default=0, description="UTC offset of the datetime in minutes"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.DateTime

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Dict(SingleOutputGraphNode[dict[str, Any]], GraphNode[dict[str, Any]]):
    """
    Represents a dictionary constant in the workflow.
        dictionary, key-value, mapping

        Use cases:
        - Store configuration settings
        - Provide structured data inputs
        - Define parameter sets for other nodes
    """

    value: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Dict

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Document(SingleOutputGraphNode[types.DocumentRef], GraphNode[types.DocumentRef]):
    """
    Represents a document constant in the workflow.
        document, pdf, word, docx
    """

    value: types.DocumentRef | OutputHandle[types.DocumentRef] = connect_field(
        default=types.DocumentRef(
            type="document", uri="", asset_id=None, data=None, metadata=None
        ),
        description=None,
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Document

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class EmbeddingModelConstant(
    SingleOutputGraphNode[types.EmbeddingModel], GraphNode[types.EmbeddingModel]
):
    """
    Represents an embedding model constant in the workflow.
        embedding, model, vector, semantic

        Use cases:
        - Provide a fixed embedding model for vectorization
        - Set default embedding model for the workflow
        - Configure model selection without user input
    """

    value: types.EmbeddingModel | OutputHandle[types.EmbeddingModel] = connect_field(
        default=PydanticUndefined, description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.EmbeddingModelConstant

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Float(SingleOutputGraphNode[float], GraphNode[float]):
    """
    Represents a floating-point number constant in the workflow.
        number, decimal, float

        Use cases:
        - Set numerical parameters for calculations
        - Define thresholds or limits
        - Provide fixed numerical inputs for processing
    """

    value: float | OutputHandle[float] = connect_field(default=0.0, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Float

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Image(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """
    Represents an image file constant in the workflow.
        picture, photo, image

        Use cases:
        - Provide a fixed image input for image processing nodes
        - Reference a specific image file in the workflow
        - Set default image for testing or demonstration purposes
    """

    value: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(
            type="image", uri="", asset_id=None, data=None, metadata=None
        ),
        description=None,
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Image

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class ImageList(
    SingleOutputGraphNode[list[types.ImageRef]], GraphNode[list[types.ImageRef]]
):
    """
    Represents a list of image file constants in the workflow.
        pictures, photos, images, collection

        Use cases:
        - Provide a fixed list of images for batch processing
        - Reference multiple image files in the workflow
        - Set default image list for testing or demonstration purposes
    """

    value: list[types.ImageRef] | OutputHandle[list[types.ImageRef]] = connect_field(
        default=PydanticUndefined, description="List of image references"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.ImageList

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class ImageModelConstant(
    SingleOutputGraphNode[types.ImageModel], GraphNode[types.ImageModel]
):
    """
    Represents an image generation model constant in the workflow.
        image, model, ai, generation, diffusion

        Use cases:
        - Provide a fixed image model for generation
        - Set default image model for the workflow
        - Configure model selection without user input
    """

    value: types.ImageModel | OutputHandle[types.ImageModel] = connect_field(
        default=PydanticUndefined, description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.ImageModelConstant

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class ImageSize(GraphNode[nodetool.nodes.nodetool.constant.ImageSize.OutputType]):
    value: types.ImageSize | OutputHandle[types.ImageSize] = connect_field(
        default=PydanticUndefined, description=None
    )

    @property
    def out(self) -> "ImageSizeOutputs":
        return ImageSizeOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.ImageSize

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class ImageSizeOutputs(OutputsProxy):
    @property
    def image_size(self) -> OutputHandle[types.ImageSize]:
        return typing.cast(OutputHandle[types.ImageSize], self["image_size"])

    @property
    def width(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self["width"])

    @property
    def height(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self["height"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Integer(SingleOutputGraphNode[int], GraphNode[int]):
    """
    Represents an integer constant in the workflow.
        number, integer, whole

        Use cases:
        - Set numerical parameters for calculations
        - Define counts, indices, or sizes
        - Provide fixed numerical inputs for processing
    """

    value: int | OutputHandle[int] = connect_field(default=0, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Integer

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class JSON(SingleOutputGraphNode[types.JSONRef], GraphNode[types.JSONRef]):
    """
    Represents a JSON constant in the workflow.
        json, object, dictionary
    """

    value: types.JSONRef | OutputHandle[types.JSONRef] = connect_field(
        default=types.JSONRef(
            type="json", uri="", asset_id=None, data=None, metadata=None
        ),
        description=None,
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.JSON

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class LanguageModelConstant(
    SingleOutputGraphNode[types.LanguageModel], GraphNode[types.LanguageModel]
):
    """
    Represents a language model constant in the workflow.
        llm, language, model, ai, chat, gpt

        Use cases:
        - Provide a fixed language model for chat or text generation
        - Set default language model for the workflow
        - Configure model selection without user input
    """

    value: types.LanguageModel | OutputHandle[types.LanguageModel] = connect_field(
        default=PydanticUndefined, description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.LanguageModelConstant

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class List(SingleOutputGraphNode[list[Any]], GraphNode[list[Any]]):
    """
    Represents a list constant in the workflow.
        array, sequence, collection

        Use cases:
        - Store multiple values of the same type
        - Provide ordered data inputs
        - Define sequences for iteration in other nodes
    """

    value: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.List

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Model3D(SingleOutputGraphNode[types.Model3DRef], GraphNode[types.Model3DRef]):
    """
    Represents a 3D model constant in the workflow.
        3d, model, mesh, glb, obj, stl

        Use cases:
        - Provide a fixed 3D model input for processing nodes
        - Reference a specific 3D model file in the workflow
        - Set default 3D model for testing or demonstration purposes
    """

    value: types.Model3DRef | OutputHandle[types.Model3DRef] = connect_field(
        default=types.Model3DRef(
            type="model_3d",
            uri="",
            asset_id=None,
            data=None,
            metadata=None,
            format=None,
            material_file=None,
            texture_files=[],
        ),
        description=None,
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Model3D

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Select(SingleOutputGraphNode[str], GraphNode[str]):
    """
    Represents a selection from a predefined set of options in the workflow.
        select, enum, dropdown, choice, options

        Use cases:
        - Choose from a fixed set of values
        - Configure options for downstream nodes
        - Provide enum-compatible inputs for nodes that expect specific values

        The output is a string that can be connected to enum-typed inputs.
    """

    value: str | OutputHandle[str] = connect_field(
        default="", description="The currently selected value."
    )
    options: list[str] | OutputHandle[list[str]] = connect_field(
        default=[], description="The list of available options to choose from."
    )
    enum_type_name: str | OutputHandle[str] = connect_field(
        default="",
        description="The enum type name this select corresponds to (for type matching).",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Select

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class String(SingleOutputGraphNode[str], GraphNode[str]):
    """
    Represents a string constant in the workflow.
        text, string, characters

        Use cases:
        - Provide fixed text inputs for processing
        - Define labels, identifiers, or names
        - Set default text values for configuration
    """

    value: str | OutputHandle[str] = connect_field(default="", description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.String

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class TTSModelConstant(
    SingleOutputGraphNode[types.TTSModel], GraphNode[types.TTSModel]
):
    """
    Represents a text-to-speech model constant in the workflow.
        tts, speech, voice, model, audio

        Use cases:
        - Provide a fixed TTS model for speech synthesis
        - Set default TTS model for the workflow
        - Configure model selection without user input
    """

    value: types.TTSModel | OutputHandle[types.TTSModel] = connect_field(
        default=PydanticUndefined, description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.TTSModelConstant

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class TextList(SingleOutputGraphNode[list[str]], GraphNode[list[str]]):
    """
    Represents a list of text strings in the workflow.
        texts, strings, text collection

        Use cases:
        - Provide a fixed list of text strings for batch processing
        - Reference multiple text values in the workflow
        - Set default text list for testing or demonstration purposes
    """

    value: list[str] | OutputHandle[list[str]] = connect_field(
        default=PydanticUndefined, description="List of text strings"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.TextList

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Video(SingleOutputGraphNode[types.VideoRef], GraphNode[types.VideoRef]):
    """
    Represents a video file constant in the workflow.
        video, movie, mp4, file

        Use cases:
        - Provide a fixed video input for video processing nodes
        - Reference a specific video file in the workflow
        - Set default video for testing or demonstration purposes
    """

    value: types.VideoRef | OutputHandle[types.VideoRef] = connect_field(
        default=types.VideoRef(
            type="video",
            uri="",
            asset_id=None,
            data=None,
            metadata=None,
            duration=None,
            format=None,
        ),
        description=None,
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Video

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class VideoList(
    SingleOutputGraphNode[list[types.VideoRef]], GraphNode[list[types.VideoRef]]
):
    """
    Represents a list of video file constants in the workflow.
        videos, movies, clips, collection

        Use cases:
        - Provide a fixed list of videos for batch processing
        - Reference multiple video files in the workflow
        - Set default video list for testing or demonstration purposes
    """

    value: list[types.VideoRef] | OutputHandle[list[types.VideoRef]] = connect_field(
        default=PydanticUndefined, description="List of video references"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.VideoList

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class VideoModelConstant(
    SingleOutputGraphNode[types.VideoModel], GraphNode[types.VideoModel]
):
    """
    Represents a video generation model constant in the workflow.
        video, model, ai, generation

        Use cases:
        - Provide a fixed video model for generation
        - Set default video model for the workflow
        - Configure model selection without user input
    """

    value: types.VideoModel | OutputHandle[types.VideoModel] = connect_field(
        default=PydanticUndefined, description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.VideoModelConstant

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
