# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Audio(SingleOutputGraphNode[types.AudioRef], GraphNode[types.AudioRef]):
    """Represents an audio file constant in the workflow.
    audio, file, mp3, wav

    Use cases:
    - Provide a fixed audio input for audio processing nodes
    - Reference a specific audio file in the workflow
    - Set default audio for testing or demonstration purposes
    """

    value: types.AudioRef | OutputHandle[types.AudioRef] = connect_field(
        default=types.AudioRef(type="audio", uri="", asset_id=None, data=None),
        description=None,
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Audio

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Bool(SingleOutputGraphNode[bool], GraphNode[bool]):
    """Represents a boolean constant in the workflow.
    boolean, logic, flag

    Use cases:
    - Control flow decisions in conditional nodes
    - Toggle features or behaviors in the workflow
    - Set default boolean values for configuration
    """

    value: bool | OutputHandle[bool] = connect_field(default=False, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Bool

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Constant(SingleOutputGraphNode[typing.Any], GraphNode[typing.Any]):
    """Base class for fixed-value nodes.

    constant, parameter, default

    Use cases:
    - Provide static inputs to a workflow
    - Hold configuration values
    - Simplify testing with deterministic outputs
    """

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Constant

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class DataFrame(
    SingleOutputGraphNode[types.DataframeRef], GraphNode[types.DataframeRef]
):
    """Represents a fixed DataFrame constant in the workflow.
    table, data, dataframe, pandas

    Use cases:
    - Provide static data for analysis or processing
    - Define lookup tables or reference data
    - Set sample data for testing or demonstration
    """

    value: types.DataframeRef | OutputHandle[types.DataframeRef] = connect_field(
        default=types.DataframeRef(
            type="dataframe", uri="", asset_id=None, data=None, columns=None
        ),
        description=None,
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.DataFrame

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Date(SingleOutputGraphNode[types.Date], GraphNode[types.Date]):
    """
    Make a date object from year, month, day.
    date, make, create
    """

    year: int | OutputHandle[int] = connect_field(
        default=1900, description="Year of the date"
    )
    month: int | OutputHandle[int] = connect_field(
        default=1, description="Month of the date"
    )
    day: int | OutputHandle[int] = connect_field(
        default=1, description="Day of the date"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Date

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class DateTime(SingleOutputGraphNode[types.Datetime], GraphNode[types.Datetime]):
    """
    Make a datetime object from year, month, day, hour, minute, second.
    datetime, make, create
    """

    year: int | OutputHandle[int] = connect_field(
        default=1900, description="Year of the datetime"
    )
    month: int | OutputHandle[int] = connect_field(
        default=1, description="Month of the datetime"
    )
    day: int | OutputHandle[int] = connect_field(
        default=1, description="Day of the datetime"
    )
    hour: int | OutputHandle[int] = connect_field(
        default=0, description="Hour of the datetime"
    )
    minute: int | OutputHandle[int] = connect_field(
        default=0, description="Minute of the datetime"
    )
    second: int | OutputHandle[int] = connect_field(
        default=0, description="Second of the datetime"
    )
    microsecond: int | OutputHandle[int] = connect_field(
        default=0, description="Microsecond of the datetime"
    )
    tzinfo: str | OutputHandle[str] = connect_field(
        default="UTC", description="Timezone of the datetime"
    )
    utc_offset: int | OutputHandle[int] = connect_field(
        default=0, description="UTC offset of the datetime"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.DateTime

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Dict(SingleOutputGraphNode[dict[str, Any]], GraphNode[dict[str, Any]]):
    """Represents a dictionary constant in the workflow.
    dictionary, key-value, mapping

    Use cases:
    - Store configuration settings
    - Provide structured data inputs
    - Define parameter sets for other nodes
    """

    value: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Dict

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Document(SingleOutputGraphNode[types.DocumentRef], GraphNode[types.DocumentRef]):
    """Represents a document constant in the workflow.
    document, pdf, word, docx
    """

    value: types.DocumentRef | OutputHandle[types.DocumentRef] = connect_field(
        default=types.DocumentRef(type="document", uri="", asset_id=None, data=None),
        description=None,
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Document

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Float(SingleOutputGraphNode[float], GraphNode[float]):
    """Represents a floating-point number constant in the workflow.
    number, decimal, float

    Use cases:
    - Set numerical parameters for calculations
    - Define thresholds or limits
    - Provide fixed numerical inputs for processing
    """

    value: float | OutputHandle[float] = connect_field(default=0.0, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Float

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Image(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """Represents an image file constant in the workflow.
    picture, photo, image

    Use cases:
    - Provide a fixed image input for image processing nodes
    - Reference a specific image file in the workflow
    - Set default image for testing or demonstration purposes
    """

    value: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description=None,
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Image

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Integer(SingleOutputGraphNode[int], GraphNode[int]):
    """Represents an integer constant in the workflow.
    number, integer, whole

    Use cases:
    - Set numerical parameters for calculations
    - Define counts, indices, or sizes
    - Provide fixed numerical inputs for processing
    """

    value: int | OutputHandle[int] = connect_field(default=0, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Integer

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class JSON(SingleOutputGraphNode[types.JSONRef], GraphNode[types.JSONRef]):
    """Represents a JSON constant in the workflow.
    json, object, dictionary
    """

    value: types.JSONRef | OutputHandle[types.JSONRef] = connect_field(
        default=types.JSONRef(type="json", uri="", asset_id=None, data=None),
        description=None,
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.JSON

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class List(SingleOutputGraphNode[list[Any]], GraphNode[list[Any]]):
    """Represents a list constant in the workflow.
    array, sequence, collection

    Use cases:
    - Store multiple values of the same type
    - Provide ordered data inputs
    - Define sequences for iteration in other nodes
    """

    value: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.List

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class String(SingleOutputGraphNode[str], GraphNode[str]):
    """Represents a string constant in the workflow.
    text, string, characters

    Use cases:
    - Provide fixed text inputs for processing
    - Define labels, identifiers, or names
    - Set default text values for configuration
    """

    value: str | OutputHandle[str] = connect_field(default="", description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.String

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant
from nodetool.workflows.base_node import BaseNode


class Video(SingleOutputGraphNode[types.VideoRef], GraphNode[types.VideoRef]):
    """Represents a video file constant in the workflow.
    video, movie, mp4, file

    Use cases:
    - Provide a fixed video input for video processing nodes
    - Reference a specific video file in the workflow
    - Set default video for testing or demonstration purposes
    """

    value: types.VideoRef | OutputHandle[types.VideoRef] = connect_field(
        default=types.VideoRef(
            type="video", uri="", asset_id=None, data=None, duration=None, format=None
        ),
        description=None,
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.constant.Video

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
