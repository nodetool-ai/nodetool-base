# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant


class Audio(GraphNode[types.AudioRef]):
    """Represents an audio file constant in the workflow.
    audio, file, mp3, wav

    Use cases:
    - Provide a fixed audio input for audio processing nodes
    - Reference a specific audio file in the workflow
    - Set default audio for testing or demonstration purposes
    """

    value: types.AudioRef | OutputHandle[types.AudioRef] = connect_field(
        default=types.AudioRef(type="audio", uri="", asset_id=None, data=None),
        description=None,
    )

    @property
    def output(self) -> OutputHandle[types.AudioRef]:
        return typing.cast(OutputHandle[types.AudioRef], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.constant.Audio"


Audio.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant


class Bool(GraphNode[bool]):
    """Represents a boolean constant in the workflow.
    boolean, logic, flag

    Use cases:
    - Control flow decisions in conditional nodes
    - Toggle features or behaviors in the workflow
    - Set default boolean values for configuration
    """

    value: bool | OutputHandle[bool] = connect_field(default=False, description=None)

    @property
    def output(self) -> OutputHandle[bool]:
        return typing.cast(OutputHandle[bool], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.constant.Bool"


Bool.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant


class Constant(GraphNode[typing.Any]):
    """Base class for fixed-value nodes.

    constant, parameter, default

    Use cases:
    - Provide static inputs to a workflow
    - Hold configuration values
    - Simplify testing with deterministic outputs
    """

    @property
    def output(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.constant.Constant"


Constant.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant


class DataFrame(GraphNode[types.DataframeRef]):
    """Represents a fixed DataFrame constant in the workflow.
    table, data, dataframe, pandas

    Use cases:
    - Provide static data for analysis or processing
    - Define lookup tables or reference data
    - Set sample data for testing or demonstration
    """

    value: types.DataframeRef | OutputHandle[types.DataframeRef] = connect_field(
        default=types.DataframeRef(
            type="dataframe", uri="", asset_id=None, data=None, columns=None
        ),
        description=None,
    )

    @property
    def output(self) -> OutputHandle[types.DataframeRef]:
        return typing.cast(
            OutputHandle[types.DataframeRef], self._single_output_handle()
        )

    @classmethod
    def get_node_type(cls):
        return "nodetool.constant.DataFrame"


DataFrame.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant


class Date(GraphNode[types.Date]):
    """
    Make a date object from year, month, day.
    date, make, create
    """

    year: int | OutputHandle[int] = connect_field(
        default=1900, description="Year of the date"
    )
    month: int | OutputHandle[int] = connect_field(
        default=1, description="Month of the date"
    )
    day: int | OutputHandle[int] = connect_field(
        default=1, description="Day of the date"
    )

    @property
    def output(self) -> OutputHandle[types.Date]:
        return typing.cast(OutputHandle[types.Date], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.constant.Date"


Date.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant


class DateTime(GraphNode[types.Datetime]):
    """
    Make a datetime object from year, month, day, hour, minute, second.
    datetime, make, create
    """

    year: int | OutputHandle[int] = connect_field(
        default=1900, description="Year of the datetime"
    )
    month: int | OutputHandle[int] = connect_field(
        default=1, description="Month of the datetime"
    )
    day: int | OutputHandle[int] = connect_field(
        default=1, description="Day of the datetime"
    )
    hour: int | OutputHandle[int] = connect_field(
        default=0, description="Hour of the datetime"
    )
    minute: int | OutputHandle[int] = connect_field(
        default=0, description="Minute of the datetime"
    )
    second: int | OutputHandle[int] = connect_field(
        default=0, description="Second of the datetime"
    )
    microsecond: int | OutputHandle[int] = connect_field(
        default=0, description="Microsecond of the datetime"
    )
    tzinfo: str | OutputHandle[str] = connect_field(
        default="UTC", description="Timezone of the datetime"
    )
    utc_offset: int | OutputHandle[int] = connect_field(
        default=0, description="UTC offset of the datetime"
    )

    @property
    def output(self) -> OutputHandle[types.Datetime]:
        return typing.cast(OutputHandle[types.Datetime], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.constant.DateTime"


DateTime.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant


class Dict(GraphNode[dict[str, Any]]):
    """Represents a dictionary constant in the workflow.
    dictionary, key-value, mapping

    Use cases:
    - Store configuration settings
    - Provide structured data inputs
    - Define parameter sets for other nodes
    """

    value: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description=None
    )

    @property
    def output(self) -> OutputHandle[dict[str, Any]]:
        return typing.cast(OutputHandle[dict[str, Any]], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.constant.Dict"


Dict.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant


class Document(GraphNode[types.DocumentRef]):
    """Represents a document constant in the workflow.
    document, pdf, word, docx
    """

    value: types.DocumentRef | OutputHandle[types.DocumentRef] = connect_field(
        default=types.DocumentRef(type="document", uri="", asset_id=None, data=None),
        description=None,
    )

    @property
    def output(self) -> OutputHandle[types.DocumentRef]:
        return typing.cast(
            OutputHandle[types.DocumentRef], self._single_output_handle()
        )

    @classmethod
    def get_node_type(cls):
        return "nodetool.constant.Document"


Document.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant


class Float(GraphNode[float]):
    """Represents a floating-point number constant in the workflow.
    number, decimal, float

    Use cases:
    - Set numerical parameters for calculations
    - Define thresholds or limits
    - Provide fixed numerical inputs for processing
    """

    value: float | OutputHandle[float] = connect_field(default=0.0, description=None)

    @property
    def output(self) -> OutputHandle[float]:
        return typing.cast(OutputHandle[float], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.constant.Float"


Float.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant


class Image(GraphNode[types.ImageRef]):
    """Represents an image file constant in the workflow.
    picture, photo, image

    Use cases:
    - Provide a fixed image input for image processing nodes
    - Reference a specific image file in the workflow
    - Set default image for testing or demonstration purposes
    """

    value: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description=None,
    )

    @property
    def output(self) -> OutputHandle[types.ImageRef]:
        return typing.cast(OutputHandle[types.ImageRef], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.constant.Image"


Image.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant


class Integer(GraphNode[int]):
    """Represents an integer constant in the workflow.
    number, integer, whole

    Use cases:
    - Set numerical parameters for calculations
    - Define counts, indices, or sizes
    - Provide fixed numerical inputs for processing
    """

    value: int | OutputHandle[int] = connect_field(default=0, description=None)

    @property
    def output(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.constant.Integer"


Integer.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant


class JSON(GraphNode[types.JSONRef]):
    """Represents a JSON constant in the workflow.
    json, object, dictionary
    """

    value: types.JSONRef | OutputHandle[types.JSONRef] = connect_field(
        default=types.JSONRef(type="json", uri="", asset_id=None, data=None),
        description=None,
    )

    @property
    def output(self) -> OutputHandle[types.JSONRef]:
        return typing.cast(OutputHandle[types.JSONRef], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.constant.JSON"


JSON.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant


class List(GraphNode[list[Any]]):
    """Represents a list constant in the workflow.
    array, sequence, collection

    Use cases:
    - Store multiple values of the same type
    - Provide ordered data inputs
    - Define sequences for iteration in other nodes
    """

    value: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )

    @property
    def output(self) -> OutputHandle[list[Any]]:
        return typing.cast(OutputHandle[list[Any]], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.constant.List"


List.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant


class String(GraphNode[str]):
    """Represents a string constant in the workflow.
    text, string, characters

    Use cases:
    - Provide fixed text inputs for processing
    - Define labels, identifiers, or names
    - Set default text values for configuration
    """

    value: str | OutputHandle[str] = connect_field(default="", description=None)

    @property
    def output(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.constant.String"


String.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.constant


class Video(GraphNode[types.VideoRef]):
    """Represents a video file constant in the workflow.
    video, movie, mp4, file

    Use cases:
    - Provide a fixed video input for video processing nodes
    - Reference a specific video file in the workflow
    - Set default video for testing or demonstration purposes
    """

    value: types.VideoRef | OutputHandle[types.VideoRef] = connect_field(
        default=types.VideoRef(
            type="video", uri="", asset_id=None, data=None, duration=None, format=None
        ),
        description=None,
    )

    @property
    def output(self) -> OutputHandle[types.VideoRef]:
        return typing.cast(OutputHandle[types.VideoRef], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.constant.Video"


Video.model_rebuild(force=True)
