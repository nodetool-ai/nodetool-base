# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.control


class Collect(GraphNode[nodetool.nodes.nodetool.control.Collect.OutputType]):
    """
    Collect items until the end of the stream and return them as a list.
    collector, aggregate, list, stream

    Use cases:
    - Gather results from multiple processing steps
    - Collect streaming data into batches
    - Aggregate outputs from parallel operations
    """

    input_item: Any | OutputHandle[Any] = connect_field(
        default=None, description="The input item to collect."
    )

    @property
    def out(self) -> "CollectOutputs":
        return CollectOutputs(self)

    @classmethod
    def get_node_type(cls):
        return "nodetool.control.Collect"


class CollectOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[list[Any]]:
        return typing.cast(OutputHandle[list[Any]], self["output"])


Collect.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.control


class ForEach(GraphNode[nodetool.nodes.nodetool.control.ForEach.OutputType]):
    """
    Iterate over a list and emit each item sequentially.
    iterator, loop, list, sequence

    Use cases:
    - Process each item of a collection in order
    - Drive downstream nodes with individual elements
    """

    input_list: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description="The list of items to iterate over."
    )

    @property
    def out(self) -> "ForEachOutputs":
        return ForEachOutputs(self)

    @classmethod
    def get_node_type(cls):
        return "nodetool.control.ForEach"


class ForEachOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self["output"])

    @property
    def index(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self["index"])


ForEach.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.control


class If(GraphNode[nodetool.nodes.nodetool.control.If.OutputType]):
    """
    Conditionally executes one of two branches based on a condition.
    control, flow, condition, logic, else, true, false, switch, toggle, flow-control

    Use cases:
    - Branch workflow based on conditions
    - Handle different cases in data processing
    - Implement decision logic
    """

    condition: bool | OutputHandle[bool] = connect_field(
        default=False, description="The condition to evaluate"
    )
    value: Any | OutputHandle[Any] = connect_field(
        default=None, description="The value to pass to the next node"
    )

    @property
    def out(self) -> "IfOutputs":
        return IfOutputs(self)

    @classmethod
    def get_node_type(cls):
        return "nodetool.control.If"


class IfOutputs(OutputsProxy):
    @property
    def if_true(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self["if_true"])

    @property
    def if_false(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self["if_false"])


If.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.control


class Reroute(GraphNode[Any]):
    """
    Pass data through unchanged for tidier workflow layouts.
    reroute, passthrough, organize, tidy, flow, connection, redirect

    Use cases:
    - Organize complex workflows by routing connections
    - Create cleaner visual layouts
    - Redirect data flow without modification
    """

    input_value: Any | OutputHandle[Any] = connect_field(
        default=None, description="Value to pass through unchanged"
    )

    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.control.Reroute"


Reroute.model_rebuild(force=True)
