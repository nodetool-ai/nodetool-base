# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode


class Collect(GraphNode):
    """
    Collect items until the end of the stream and return them as a list.
    collector, aggregate, list, stream

    Use cases:
    - Gather results from multiple processing steps
    - Collect streaming data into batches
    - Aggregate outputs from parallel operations
    """

    input_item: Any | GraphNode | tuple[GraphNode, str] = Field(
        default=None, description="The input item to collect."
    )

    @classmethod
    def get_node_type(cls):
        return "nodetool.control.Collect"


class ForEach(GraphNode):
    """
    Iterate over a list and emit each item sequentially.
    iterator, loop, list, sequence

    Use cases:
    - Process each item of a collection in order
    - Drive downstream nodes with individual elements
    """

    input_list: list[Any] | GraphNode | tuple[GraphNode, str] = Field(
        default=[], description="The list of items to iterate over."
    )

    @classmethod
    def get_node_type(cls):
        return "nodetool.control.ForEach"


class If(GraphNode):
    """
    Conditionally executes one of two branches based on a condition.
    control, flow, condition, logic, else, true, false, switch, toggle, flow-control

    Use cases:
    - Branch workflow based on conditions
    - Handle different cases in data processing
    - Implement decision logic
    """

    condition: bool | GraphNode | tuple[GraphNode, str] = Field(
        default=False, description="The condition to evaluate"
    )
    value: Any | GraphNode | tuple[GraphNode, str] = Field(
        default=None, description="The value to pass to the next node"
    )

    @classmethod
    def get_node_type(cls):
        return "nodetool.control.If"


class Reroute(GraphNode):
    """
    Pass data through unchanged for tidier workflow layouts.
    reroute, passthrough, organize, tidy, flow, connection, redirect

    Use cases:
    - Organize complex workflows by routing connections
    - Create cleaner visual layouts
    - Redirect data flow without modification
    """

    input_value: Any | GraphNode | tuple[GraphNode, str] = Field(
        default=None, description="Value to pass through unchanged"
    )

    @classmethod
    def get_node_type(cls):
        return "nodetool.control.Reroute"
