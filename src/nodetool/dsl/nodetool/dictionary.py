# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary


class ArgMax(GraphNode[str]):
    """
    Returns the label associated with the highest value in a dictionary.
    dictionary, maximum, label, argmax

    Use cases:
    - Get the most likely class from classification probabilities
    - Find the category with highest score
    - Identify the winner in a voting/ranking system
    """

    scores: dict[str, float] | OutputHandle[dict[str, float]] = connect_field(
        default={},
        description="Dictionary mapping labels to their corresponding scores/values",
    )

    @property
    def output(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.dictionary.ArgMax"


ArgMax.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary


class Combine(GraphNode[dict[str, Any]]):
    """
    Merges two dictionaries, with second dictionary values taking precedence.
    dictionary, merge, update, +, add, concatenate

    Use cases:
    - Combine default and custom configurations
    - Merge partial updates with existing data
    - Create aggregate data structures
    """

    dict_a: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description=None
    )
    dict_b: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description=None
    )

    @property
    def output(self) -> OutputHandle[dict[str, Any]]:
        return typing.cast(OutputHandle[dict[str, Any]], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.dictionary.Combine"


Combine.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary


class Filter(GraphNode[dict[str, Any]]):
    """
    Creates a new dictionary with only specified keys from the input.
    dictionary, filter, select

    Use cases:
    - Extract relevant fields from a larger data structure
    - Implement data access controls
    - Prepare specific data subsets for processing
    """

    dictionary: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description=None
    )
    keys: list[str] | OutputHandle[list[str]] = connect_field(
        default=[], description=None
    )

    @property
    def output(self) -> OutputHandle[dict[str, Any]]:
        return typing.cast(OutputHandle[dict[str, Any]], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.dictionary.Filter"


Filter.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary


class GetValue(GraphNode[Any]):
    """
    Retrieves a value from a dictionary using a specified key.
    dictionary, get, value, key

    Use cases:
    - Access a specific item in a configuration dictionary
    - Retrieve a value from a parsed JSON object
    - Extract a particular field from a data structure
    """

    dictionary: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description=None
    )
    key: str | OutputHandle[str] = connect_field(default="", description=None)
    default: Any | OutputHandle[Any] = connect_field(default=None, description=None)

    @property
    def output(self) -> OutputHandle[Any]:
        return typing.cast(OutputHandle[Any], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.dictionary.GetValue"


GetValue.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary


class LoadCSVFile(GraphNode[list[dict]]):
    """
    Read a CSV file from disk.
    files, csv, read, input, load, file
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to the CSV file to read"
    )

    @property
    def output(self) -> OutputHandle[list[dict]]:
        return typing.cast(OutputHandle[list[dict]], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.dictionary.LoadCSVFile"


LoadCSVFile.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary


class MakeDictionary(GraphNode[dict[str, Any]]):
    """
    Creates a simple dictionary with up to three key-value pairs.
    dictionary, create, simple

    Use cases:
    - Create configuration entries
    - Initialize simple data structures
    - Build basic key-value mappings
    """

    @property
    def output(self) -> OutputHandle[dict[str, Any]]:
        return typing.cast(OutputHandle[dict[str, Any]], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.dictionary.MakeDictionary"


MakeDictionary.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary


class ParseJSON(GraphNode[dict[str, Any]]):
    """
    Parses a JSON string into a Python dictionary.
    json, parse, dictionary

    Use cases:
    - Process API responses
    - Load configuration files
    - Deserialize stored data
    """

    json_string: str | OutputHandle[str] = connect_field(default="", description=None)

    @property
    def output(self) -> OutputHandle[dict[str, Any]]:
        return typing.cast(OutputHandle[dict[str, Any]], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.dictionary.ParseJSON"


ParseJSON.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
import nodetool.nodes.nodetool.dictionary


class ReduceDictionaries(GraphNode[dict[Any, Any]]):
    """
    Reduces a list of dictionaries into one dictionary based on a specified key field.
    dictionary, reduce, aggregate

    Use cases:
    - Aggregate data by a specific field
    - Create summary dictionaries from list of records
    - Combine multiple data points into a single structure
    """

    ConflictResolution: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.dictionary.ReduceDictionaries.ConflictResolution
    )
    dictionaries: list[dict[str, Any]] | OutputHandle[list[dict[str, Any]]] = (
        connect_field(default=[], description="List of dictionaries to be reduced")
    )
    key_field: str | OutputHandle[str] = connect_field(
        default="",
        description="The field to use as the key in the resulting dictionary",
    )
    value_field: str | OutputHandle[str] | None = connect_field(
        default=None,
        description="Optional field to use as the value. If not specified, the entire dictionary (minus the key field) will be used as the value.",
    )
    conflict_resolution: (
        nodetool.nodes.nodetool.dictionary.ReduceDictionaries.ConflictResolution
    ) = Field(
        default=nodetool.nodes.nodetool.dictionary.ReduceDictionaries.ConflictResolution.FIRST,
        description="How to handle conflicts when the same key appears multiple times",
    )

    @property
    def output(self) -> OutputHandle[dict[Any, Any]]:
        return typing.cast(OutputHandle[dict[Any, Any]], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.dictionary.ReduceDictionaries"


ReduceDictionaries.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary


class Remove(GraphNode[dict[str, Any]]):
    """
    Removes a key-value pair from a dictionary.
    dictionary, remove, delete

    Use cases:
    - Delete a specific configuration option
    - Remove sensitive information before processing
    - Clean up temporary entries in a data structure
    """

    dictionary: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description=None
    )
    key: str | OutputHandle[str] = connect_field(default="", description=None)

    @property
    def output(self) -> OutputHandle[dict[str, Any]]:
        return typing.cast(OutputHandle[dict[str, Any]], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.dictionary.Remove"


Remove.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary


class SaveCSVFile(GraphNode[typing.Any]):
    """
    Write a list of dictionaries to a CSV file.
    files, csv, write, output, save, file

    The filename can include time and date variables:
    %Y - Year, %m - Month, %d - Day
    %H - Hour, %M - Minute, %S - Second
    """

    data: list[dict] | OutputHandle[list[dict]] = connect_field(
        default=[], description="list of dictionaries to write to CSV"
    )
    folder: str | OutputHandle[str] = connect_field(
        default="", description="Folder where the file will be saved"
    )
    filename: str | OutputHandle[str] = connect_field(
        default="",
        description="Name of the CSV file to save. Supports strftime format codes.",
    )

    @property
    def output(self) -> OutputHandle[typing.Any]:
        return typing.cast(OutputHandle[typing.Any], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.dictionary.SaveCSVFile"


SaveCSVFile.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary


class Update(GraphNode[dict[str, Any]]):
    """
    Updates a dictionary with new key-value pairs.
    dictionary, add, update

    Use cases:
    - Extend a configuration with additional settings
    - Add new entries to a cache or lookup table
    - Merge user input with existing data
    """

    dictionary: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description=None
    )
    new_pairs: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description=None
    )

    @property
    def output(self) -> OutputHandle[dict[str, Any]]:
        return typing.cast(OutputHandle[dict[str, Any]], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.dictionary.Update"


Update.model_rebuild(force=True)


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary


class Zip(GraphNode[dict[Any, Any]]):
    """
    Creates a dictionary from parallel lists of keys and values.
    dictionary, create, zip

    Use cases:
    - Convert separate data columns into key-value pairs
    - Create lookups from parallel data structures
    - Transform list data into associative arrays
    """

    keys: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )
    values: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )

    @property
    def output(self) -> OutputHandle[dict[Any, Any]]:
        return typing.cast(OutputHandle[dict[Any, Any]], self._single_output_handle())

    @classmethod
    def get_node_type(cls):
        return "nodetool.dictionary.Zip"


Zip.model_rebuild(force=True)
