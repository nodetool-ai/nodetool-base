# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode

class ArgMax(SingleOutputGraphNode[str], GraphNode[str]):
    """

        Returns the label associated with the highest value in a dictionary.
        dictionary, maximum, label, argmax

        Use cases:
        - Get the most likely class from classification probabilities
        - Find the category with highest score
        - Identify the winner in a voting/ranking system
    """

    scores: dict[str, float] | OutputHandle[dict[str, float]] = connect_field(default={}, description='Dictionary mapping labels to their corresponding scores/values')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.ArgMax

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode

class Combine(SingleOutputGraphNode[dict[str, Any]], GraphNode[dict[str, Any]]):
    """

        Merges two dictionaries, with second dictionary values taking precedence.
        dictionary, merge, update, +, add, concatenate

        Use cases:
        - Combine default and custom configurations
        - Merge partial updates with existing data
        - Create aggregate data structures
    """

    dict_a: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(default={}, description=None)
    dict_b: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(default={}, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.Combine

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode

class Filter(SingleOutputGraphNode[dict[str, Any]], GraphNode[dict[str, Any]]):
    """

        Creates a new dictionary with only specified keys from the input.
        dictionary, filter, select

        Use cases:
        - Extract relevant fields from a larger data structure
        - Implement data access controls
        - Prepare specific data subsets for processing
    """

    dictionary: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(default={}, description=None)
    keys: list[str] | OutputHandle[list[str]] = connect_field(default=[], description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.Filter

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode

class FilterDictByNumber(GraphNode[nodetool.nodes.nodetool.dictionary.FilterDictByNumber.OutputType]):
    """

        Filters a stream of dictionaries based on numeric values for a specified key.
        filter, dictionary, numbers, numeric, stream

        Use cases:
        - Filter dictionaries by numeric comparisons (greater than, less than, equal to)
        - Filter records with even/odd numeric values
    """

    FilterDictNumberType: typing.ClassVar[type] = nodetool.nodes.nodetool.dictionary.FilterDictByNumber.FilterDictNumberType

    value: dict | OutputHandle[dict] = connect_field(default={}, description='Input dictionary stream')
    key: str | OutputHandle[str] = connect_field(default='', description='The dictionary key to check')
    filter_type: nodetool.nodes.nodetool.dictionary.FilterDictByNumber.FilterDictNumberType = Field(default=nodetool.nodes.nodetool.dictionary.FilterDictByNumber.FilterDictNumberType.GREATER_THAN, description=None)
    compare_value: float | OutputHandle[float] = connect_field(default=0, description='Comparison value')

    @property
    def out(self) -> "FilterDictByNumberOutputs":
        return FilterDictByNumberOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.FilterDictByNumber

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()

class FilterDictByNumberOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[dict]:
        return typing.cast(OutputHandle[dict], self['output'])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode

class FilterDictByQuery(GraphNode[nodetool.nodes.nodetool.dictionary.FilterDictByQuery.OutputType]):
    """

        Filter a stream of dictionary objects based on a pandas query condition.
        filter, query, condition, dictionary, stream

        Basic Operators:
        - Comparison: >, <, >=, <=, ==, !=
        - Logical: and, or, not
        - Membership: in, not in

        Use cases:
        - Filter dictionary objects based on complex criteria
        - Extract subset of data meeting specific conditions
    """

    value: dict | OutputHandle[dict] = connect_field(default={}, description='Input dictionary stream')
    condition: str | OutputHandle[str] = connect_field(default='', description='The filtering condition using pandas query syntax.')

    @property
    def out(self) -> "FilterDictByQueryOutputs":
        return FilterDictByQueryOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.FilterDictByQuery

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()

class FilterDictByQueryOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[dict]:
        return typing.cast(OutputHandle[dict], self['output'])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode

class FilterDictByRange(GraphNode[nodetool.nodes.nodetool.dictionary.FilterDictByRange.OutputType]):
    """

        Filters a stream of dictionaries based on a numeric range for a specified key.
        filter, dictionary, range, between, stream

        Use cases:
        - Filter records based on numeric ranges (e.g., price range, age range)
        - Find entries with values within specified bounds
    """

    value: dict | OutputHandle[dict] = connect_field(default={}, description='Input dictionary stream')
    key: str | OutputHandle[str] = connect_field(default='', description='The dictionary key to check for the range')
    min_value: float | OutputHandle[float] = connect_field(default=0, description='The minimum value (inclusive) of the range')
    max_value: float | OutputHandle[float] = connect_field(default=0, description='The maximum value (inclusive) of the range')
    inclusive: bool | OutputHandle[bool] = connect_field(default=True, description='If True, includes the min and max values in the results')

    @property
    def out(self) -> "FilterDictByRangeOutputs":
        return FilterDictByRangeOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.FilterDictByRange

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()

class FilterDictByRangeOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[dict]:
        return typing.cast(OutputHandle[dict], self['output'])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode

class FilterDictByValue(GraphNode[nodetool.nodes.nodetool.dictionary.FilterDictByValue.OutputType]):
    """

        Filters a stream of dictionaries based on their values using various criteria.
        filter, dictionary, values, stream

        Use cases:
        - Filter dictionaries by value content
        - Filter dictionaries by value type
        - Filter dictionaries by value patterns
    """

    FilterType: typing.ClassVar[type] = nodetool.nodes.nodetool.dictionary.FilterDictByValue.FilterType

    value: dict | OutputHandle[dict] = connect_field(default={}, description='Input dictionary stream')
    key: str | OutputHandle[str] = connect_field(default='', description='The dictionary key to check')
    filter_type: nodetool.nodes.nodetool.dictionary.FilterDictByValue.FilterType = Field(default=nodetool.nodes.nodetool.dictionary.FilterDictByValue.FilterType.CONTAINS, description='The type of filter to apply')
    criteria: str | OutputHandle[str] = connect_field(default='', description='The filtering criteria (text to match, type name, or length as string)')

    @property
    def out(self) -> "FilterDictByValueOutputs":
        return FilterDictByValueOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.FilterDictByValue

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()

class FilterDictByValueOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[dict]:
        return typing.cast(OutputHandle[dict], self['output'])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode

class FilterDictRegex(GraphNode[nodetool.nodes.nodetool.dictionary.FilterDictRegex.OutputType]):
    """

        Filters a stream of dictionaries using regular expressions on specified keys.
        filter, regex, dictionary, pattern, stream

        Use cases:
        - Filter dictionaries with values matching complex patterns
        - Search for dictionaries containing emails, dates, or specific formats
    """

    value: dict | OutputHandle[dict] = connect_field(default={}, description='Input dictionary stream')
    key: str | OutputHandle[str] = connect_field(default='', description='The dictionary key to check')
    pattern: str | OutputHandle[str] = connect_field(default='', description='The regex pattern')
    full_match: bool | OutputHandle[bool] = connect_field(default=False, description='Full match or partial')

    @property
    def out(self) -> "FilterDictRegexOutputs":
        return FilterDictRegexOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.FilterDictRegex

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()

class FilterDictRegexOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[dict]:
        return typing.cast(OutputHandle[dict], self['output'])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode

class GetValue(SingleOutputGraphNode[Any], GraphNode[Any]):
    """

        Retrieves a value from a dictionary using a specified key.
        dictionary, get, value, key

        Use cases:
        - Access a specific item in a configuration dictionary
        - Retrieve a value from a parsed JSON object
        - Extract a particular field from a data structure
    """

    dictionary: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(default={}, description=None)
    key: str | OutputHandle[str] = connect_field(default='', description=None)
    default: Any | OutputHandle[Any] = connect_field(default=(), description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.GetValue

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode

class LoadCSVFile(SingleOutputGraphNode[list[dict]], GraphNode[list[dict]]):
    """

        Read a CSV file from disk.
        files, csv, read, input, load, file
    """

    path: str | OutputHandle[str] = connect_field(default='', description='Path to the CSV file to read')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.LoadCSVFile

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode

class MakeDictionary(SingleOutputGraphNode[dict[str, Any]], GraphNode[dict[str, Any]]):
    """

        Creates a simple dictionary with up to three key-value pairs.
        dictionary, create, simple

        Use cases:
        - Create configuration entries
        - Initialize simple data structures
        - Build basic key-value mappings

    This node supports dynamic properties. Additional properties can be passed
    as keyword arguments during initialization and will be stored in the node's
    dynamic_properties dictionary.

    Example:
        node = MakeDictionary(prop1=value1, prop2=value2)
    """

    def __init__(self, **kwargs: typing.Any) -> None:
        """
        Initialize a MakeDictionary node.

        Extra keyword arguments beyond the defined fields will be treated as
        dynamic properties and automatically passed to the underlying BaseNode
        as dynamic_properties.

        Args:
            **kwargs: Field values and dynamic properties.
        """

        super().__init__(**kwargs)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.MakeDictionary

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode

class ParseJSON(SingleOutputGraphNode[dict[str, Any]], GraphNode[dict[str, Any]]):
    """

        Parses a JSON string into a Python dictionary.
        json, parse, dictionary

        Use cases:
        - Process API responses
        - Load configuration files
        - Deserialize stored data
    """

    json_string: str | OutputHandle[str] = connect_field(default='', description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.ParseJSON

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode

class ReduceDictionaries(SingleOutputGraphNode[dict[Any, Any]], GraphNode[dict[Any, Any]]):
    """

        Reduces a list of dictionaries into one dictionary based on a specified key field.
        dictionary, reduce, aggregate

        Use cases:
        - Aggregate data by a specific field
        - Create summary dictionaries from list of records
        - Combine multiple data points into a single structure
    """

    ConflictResolution: typing.ClassVar[type] = nodetool.nodes.nodetool.dictionary.ReduceDictionaries.ConflictResolution

    dictionaries: list[dict[str, Any]] | OutputHandle[list[dict[str, Any]]] = connect_field(default=[], description='List of dictionaries to be reduced')
    key_field: str | OutputHandle[str] = connect_field(default='', description='The field to use as the key in the resulting dictionary')
    value_field: str | OutputHandle[str] = connect_field(default='', description='Optional field to use as the value. If not specified, the entire dictionary (minus the key field) will be used as the value.')
    conflict_resolution: nodetool.nodes.nodetool.dictionary.ReduceDictionaries.ConflictResolution = Field(default=nodetool.nodes.nodetool.dictionary.ReduceDictionaries.ConflictResolution.FIRST, description='How to handle conflicts when the same key appears multiple times')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.ReduceDictionaries

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode

class Remove(SingleOutputGraphNode[dict[str, Any]], GraphNode[dict[str, Any]]):
    """

        Removes a key-value pair from a dictionary.
        dictionary, remove, delete

        Use cases:
        - Delete a specific configuration option
        - Remove sensitive information before processing
        - Clean up temporary entries in a data structure
    """

    dictionary: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(default={}, description=None)
    key: str | OutputHandle[str] = connect_field(default='', description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.Remove

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode

class SaveCSVFile(SingleOutputGraphNode[typing.Any], GraphNode[typing.Any]):
    """

        Write a list of dictionaries to a CSV file.
        files, csv, write, output, save, file

        The filename can include time and date variables:
        %Y - Year, %m - Month, %d - Day
        %H - Hour, %M - Minute, %S - Second
    """

    data: list[dict] | OutputHandle[list[dict]] = connect_field(default=[], description='list of dictionaries to write to CSV')
    folder: str | OutputHandle[str] = connect_field(default='', description='Folder where the file will be saved')
    filename: str | OutputHandle[str] = connect_field(default='', description='Name of the CSV file to save. Supports strftime format codes.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.SaveCSVFile

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode

class Update(SingleOutputGraphNode[dict[str, Any]], GraphNode[dict[str, Any]]):
    """

        Updates a dictionary with new key-value pairs.
        dictionary, add, update

        Use cases:
        - Extend a configuration with additional settings
        - Add new entries to a cache or lookup table
        - Merge user input with existing data
    """

    dictionary: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(default={}, description=None)
    new_pairs: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(default={}, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.Update

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode

class Zip(SingleOutputGraphNode[dict[Any, Any]], GraphNode[dict[Any, Any]]):
    """

        Creates a dictionary from parallel lists of keys and values.
        dictionary, create, zip

        Use cases:
        - Convert separate data columns into key-value pairs
        - Create lookups from parallel data structures
        - Transform list data into associative arrays
    """

    keys: list[Any] | OutputHandle[list[Any]] = connect_field(default=[], description=None)
    values: list[Any] | OutputHandle[list[Any]] = connect_field(default=[], description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.Zip

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


