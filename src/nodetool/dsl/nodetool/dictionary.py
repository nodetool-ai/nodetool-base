# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode


class ArgMax(SingleOutputGraphNode[str], GraphNode[str]):
    """

    Returns the label associated with the highest value in a dictionary.
    dictionary, maximum, label, argmax

    Use cases:
    - Get the most likely class from classification probabilities
    - Find the category with highest score
    - Identify the winner in a voting/ranking system
    """

    scores: dict[str, float] | OutputHandle[dict[str, float]] = connect_field(
        default={},
        description="Dictionary mapping labels to their corresponding scores/values",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.ArgMax

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode


class Combine(SingleOutputGraphNode[dict[str, Any]], GraphNode[dict[str, Any]]):
    """

    Merges two dictionaries, with second dictionary values taking precedence.
    dictionary, merge, update, +, add, concatenate

    Use cases:
    - Combine default and custom configurations
    - Merge partial updates with existing data
    - Create aggregate data structures
    """

    dict_a: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description=None
    )
    dict_b: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.Combine

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode


class Filter(SingleOutputGraphNode[dict[str, Any]], GraphNode[dict[str, Any]]):
    """

    Creates a new dictionary with only specified keys from the input.
    dictionary, filter, select

    Use cases:
    - Extract relevant fields from a larger data structure
    - Implement data access controls
    - Prepare specific data subsets for processing
    """

    dictionary: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description=None
    )
    keys: list[str] | OutputHandle[list[str]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.Filter

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode


class GetValue(SingleOutputGraphNode[Any], GraphNode[Any]):
    """

    Retrieves a value from a dictionary using a specified key.
    dictionary, get, value, key

    Use cases:
    - Access a specific item in a configuration dictionary
    - Retrieve a value from a parsed JSON object
    - Extract a particular field from a data structure
    """

    dictionary: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description=None
    )
    key: str | OutputHandle[str] = connect_field(default="", description=None)
    default: Any | OutputHandle[Any] = connect_field(default=None, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.GetValue

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode


class LoadCSVFile(SingleOutputGraphNode[list[dict]], GraphNode[list[dict]]):
    """

    Read a CSV file from disk.
    files, csv, read, input, load, file
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to the CSV file to read"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.LoadCSVFile

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode


class MakeDictionary(SingleOutputGraphNode[dict[str, Any]], GraphNode[dict[str, Any]]):
    """

        Creates a simple dictionary with up to three key-value pairs.
        dictionary, create, simple

        Use cases:
        - Create configuration entries
        - Initialize simple data structures
        - Build basic key-value mappings

    This node supports dynamic properties. Additional properties can be passed
    as keyword arguments during initialization and will be stored in the node's
    dynamic_properties dictionary.

    Example:
        node = MakeDictionary(prop1=value1, prop2=value2)
    """

    def __init__(self, **kwargs: typing.Any) -> None:
        """
        Initialize a MakeDictionary node.

        Extra keyword arguments beyond the defined fields will be treated as
        dynamic properties and automatically passed to the underlying BaseNode
        as dynamic_properties.

        Args:
            **kwargs: Field values and dynamic properties.
        """

        super().__init__(**kwargs)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.MakeDictionary

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode


class ParseJSON(SingleOutputGraphNode[dict[str, Any]], GraphNode[dict[str, Any]]):
    """

    Parses a JSON string into a Python dictionary.
    json, parse, dictionary

    Use cases:
    - Process API responses
    - Load configuration files
    - Deserialize stored data
    """

    json_string: str | OutputHandle[str] = connect_field(default="", description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.ParseJSON

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode


class ReduceDictionaries(
    SingleOutputGraphNode[dict[Any, Any]], GraphNode[dict[Any, Any]]
):
    """

    Reduces a list of dictionaries into one dictionary based on a specified key field.
    dictionary, reduce, aggregate

    Use cases:
    - Aggregate data by a specific field
    - Create summary dictionaries from list of records
    - Combine multiple data points into a single structure
    """

    ConflictResolution: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.dictionary.ReduceDictionaries.ConflictResolution
    )

    dictionaries: list[dict[str, Any]] | OutputHandle[list[dict[str, Any]]] = (
        connect_field(default=[], description="List of dictionaries to be reduced")
    )
    key_field: str | OutputHandle[str] = connect_field(
        default="",
        description="The field to use as the key in the resulting dictionary",
    )
    value_field: str | OutputHandle[str] | None = connect_field(
        default=None,
        description="Optional field to use as the value. If not specified, the entire dictionary (minus the key field) will be used as the value.",
    )
    conflict_resolution: (
        nodetool.nodes.nodetool.dictionary.ReduceDictionaries.ConflictResolution
    ) = Field(
        default=nodetool.nodes.nodetool.dictionary.ReduceDictionaries.ConflictResolution.FIRST,
        description="How to handle conflicts when the same key appears multiple times",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.ReduceDictionaries

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode


class Remove(SingleOutputGraphNode[dict[str, Any]], GraphNode[dict[str, Any]]):
    """

    Removes a key-value pair from a dictionary.
    dictionary, remove, delete

    Use cases:
    - Delete a specific configuration option
    - Remove sensitive information before processing
    - Clean up temporary entries in a data structure
    """

    dictionary: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description=None
    )
    key: str | OutputHandle[str] = connect_field(default="", description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.Remove

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode


class SaveCSVFile(SingleOutputGraphNode[typing.Any], GraphNode[typing.Any]):
    """

    Write a list of dictionaries to a CSV file.
    files, csv, write, output, save, file

    The filename can include time and date variables:
    %Y - Year, %m - Month, %d - Day
    %H - Hour, %M - Minute, %S - Second
    """

    data: list[dict] | OutputHandle[list[dict]] = connect_field(
        default=[], description="list of dictionaries to write to CSV"
    )
    folder: str | OutputHandle[str] = connect_field(
        default="", description="Folder where the file will be saved"
    )
    filename: str | OutputHandle[str] = connect_field(
        default="",
        description="Name of the CSV file to save. Supports strftime format codes.",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.SaveCSVFile

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode


class Update(SingleOutputGraphNode[dict[str, Any]], GraphNode[dict[str, Any]]):
    """

    Updates a dictionary with new key-value pairs.
    dictionary, add, update

    Use cases:
    - Extend a configuration with additional settings
    - Add new entries to a cache or lookup table
    - Merge user input with existing data
    """

    dictionary: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description=None
    )
    new_pairs: dict[str, Any] | OutputHandle[dict[str, Any]] = connect_field(
        default={}, description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.Update

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.dictionary
from nodetool.workflows.base_node import BaseNode


class Zip(SingleOutputGraphNode[dict[Any, Any]], GraphNode[dict[Any, Any]]):
    """

    Creates a dictionary from parallel lists of keys and values.
    dictionary, create, zip

    Use cases:
    - Convert separate data columns into key-value pairs
    - Create lookups from parallel data structures
    - Transform list data into associative arrays
    """

    keys: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )
    values: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.dictionary.Zip

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
