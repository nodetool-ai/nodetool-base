# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class BatchToList(
    SingleOutputGraphNode[list[types.ImageRef]], GraphNode[list[types.ImageRef]]
):
    """
    Convert an image batch to a list of image references.
    batch, list, images, processing

    Use cases:
    - Convert comfy batch outputs to list format
    """

    batch: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The batch of images to convert.",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.BatchToList

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class Crop(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """
    Crop an image to specified coordinates.
    image, crop

    - Remove unwanted borders from images
    - Focus on particular subjects within an image
    - Simplify images by removing distractions
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The image to crop.",
    )
    left: int | OutputHandle[int] = connect_field(
        default=0, description="The left coordinate."
    )
    top: int | OutputHandle[int] = connect_field(
        default=0, description="The top coordinate."
    )
    right: int | OutputHandle[int] = connect_field(
        default=512, description="The right coordinate."
    )
    bottom: int | OutputHandle[int] = connect_field(
        default=512, description="The bottom coordinate."
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.Crop

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class Fit(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """
    Resize an image to fit within specified dimensions while preserving aspect ratio.
    image, resize, fit

    - Resize images for online publishing requirements
    - Preprocess images to uniform sizes for machine learning
    - Control image display sizes for web development
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The image to fit.",
    )
    width: int | OutputHandle[int] = connect_field(
        default=512, description="Width to fit to."
    )
    height: int | OutputHandle[int] = connect_field(
        default=512, description="Height to fit to."
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.Fit

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class GetMetadata(GraphNode[nodetool.nodes.nodetool.image.GetMetadata.OutputType]):
    """
    Get metadata about the input image.
    metadata, properties, analysis, information

    Use cases:
    - Use width and height for layout calculations
    - Analyze image properties for processing decisions
    - Gather information for image cataloging or organization
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The input image.",
    )

    @property
    def out(self) -> "GetMetadataOutputs":
        return GetMetadataOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.GetMetadata

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class GetMetadataOutputs(OutputsProxy):
    @property
    def format(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["format"])

    @property
    def mode(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["mode"])

    @property
    def width(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self["width"])

    @property
    def height(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self["height"])

    @property
    def channels(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self["channels"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class ImageToImage(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """
    Transform images using text prompts with any supported image provider.
    Automatically routes to the appropriate backend (HuggingFace, FAL, MLX).
    image, transformation, AI, image-to-image, i2i

    Use cases:
    - Modify existing images with text instructions
    - Style transfer and artistic modifications
    - Image enhancement and refinement
    - Creative image edits guided by prompts
    """

    model: types.ImageModel | OutputHandle[types.ImageModel] = connect_field(
        default=types.ImageModel(
            type="image_model",
            provider=nodetool.metadata.types.Provider.HuggingFaceFalAI,
            id="fal-ai/flux/dev",
            name="FLUX.1 Dev",
        ),
        description="The image generation model to use",
    )
    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="Input image to transform",
    )
    prompt: str | OutputHandle[str] = connect_field(
        default="A photorealistic version of the input image",
        description="Text prompt describing the desired transformation",
    )
    negative_prompt: str | OutputHandle[str] = connect_field(
        default="", description="Text prompt describing what to avoid"
    )
    strength: float | OutputHandle[float] = connect_field(
        default=0.8,
        description="How much to transform the input image (0.0 = no change, 1.0 = maximum change)",
    )
    guidance_scale: float | OutputHandle[float] = connect_field(
        default=7.5, description="Classifier-free guidance scale"
    )
    num_inference_steps: int | OutputHandle[int] = connect_field(
        default=30, description="Number of denoising steps"
    )
    target_width: int | OutputHandle[int] = connect_field(
        default=512, description="Target width of the output image"
    )
    target_height: int | OutputHandle[int] = connect_field(
        default=512, description="Target height of the output image"
    )
    seed: int | OutputHandle[int] = connect_field(
        default=-1, description="Random seed for reproducibility (-1 for random)"
    )
    scheduler: str | OutputHandle[str] = connect_field(
        default="", description="Scheduler to use (provider-specific)"
    )
    safety_check: bool | OutputHandle[bool] = connect_field(
        default=True, description="Enable safety checker"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.ImageToImage

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class LoadImageAssets(
    GraphNode[nodetool.nodes.nodetool.image.LoadImageAssets.OutputType]
):
    """
    Load images from an asset folder.
    load, image, file, import
    """

    folder: types.FolderRef | OutputHandle[types.FolderRef] = connect_field(
        default=types.FolderRef(type="folder", uri="", asset_id=None, data=None),
        description="The asset folder to load the images from.",
    )

    @property
    def out(self) -> "LoadImageAssetsOutputs":
        return LoadImageAssetsOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.LoadImageAssets

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class LoadImageAssetsOutputs(OutputsProxy):
    @property
    def image(self) -> OutputHandle[types.ImageRef]:
        return typing.cast(OutputHandle[types.ImageRef], self["image"])

    @property
    def name(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["name"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class LoadImageFile(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """
    Read an image file from disk.
    image, input, load, file

    Use cases:
    - Load images for processing
    - Import photos for editing
    - Read image assets for a workflow
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to the image file to read"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.LoadImageFile

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class LoadImageFolder(
    GraphNode[nodetool.nodes.nodetool.image.LoadImageFolder.OutputType]
):
    """
    Load all images from a folder, optionally including subfolders.
    image, load, folder, files

    Use cases:
    - Batch import images for processing
    - Build datasets from a directory tree
    - Iterate over photo collections
    """

    folder: str | OutputHandle[str] = connect_field(
        default="", description="Folder to scan for images"
    )
    include_subdirectories: bool | OutputHandle[bool] = connect_field(
        default=False, description="Include images in subfolders"
    )
    extensions: list[str] | OutputHandle[list[str]] = connect_field(
        default=[".png", ".jpg", ".jpeg", ".bmp", ".gif", ".webp", ".tiff"],
        description="Image file extensions to include",
    )
    pattern: str | OutputHandle[str] = connect_field(
        default="", description="Pattern to match image files"
    )

    @property
    def out(self) -> "LoadImageFolderOutputs":
        return LoadImageFolderOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.LoadImageFolder

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class LoadImageFolderOutputs(OutputsProxy):
    @property
    def image(self) -> OutputHandle[types.ImageRef]:
        return typing.cast(OutputHandle[types.ImageRef], self["image"])

    @property
    def path(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["path"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class Paste(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """
    Paste one image onto another at specified coordinates.
    paste, composite, positioning, overlay

    Use cases:
    - Add watermarks or logos to images
    - Combine multiple image elements
    - Create collages or montages
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The image to paste into.",
    )
    paste: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The image to paste.",
    )
    left: int | OutputHandle[int] = connect_field(
        default=0, description="The left coordinate."
    )
    top: int | OutputHandle[int] = connect_field(
        default=0, description="The top coordinate."
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.Paste

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class Resize(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """
    Change image dimensions to specified width and height.
    image, resize

    - Preprocess images for machine learning model inputs
    - Optimize images for faster web page loading
    - Create uniform image sizes for layouts
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The image to resize.",
    )
    width: int | OutputHandle[int] = connect_field(
        default=512, description="The target width."
    )
    height: int | OutputHandle[int] = connect_field(
        default=512, description="The target height."
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.Resize

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class SaveImage(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """
    Save an image to specified asset folder with customizable name format.
    save, image, folder, naming

    Use cases:
    - Save generated images with timestamps
    - Organize outputs into specific folders
    - Create backups of processed images
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The image to save.",
    )
    folder: types.FolderRef | OutputHandle[types.FolderRef] = connect_field(
        default=types.FolderRef(type="folder", uri="", asset_id=None, data=None),
        description="The asset folder to save the image in.",
    )
    name: str | OutputHandle[str] = connect_field(
        default="%Y-%m-%d_%H-%M-%S.png",
        description="\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        ",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.SaveImage

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class SaveImageFile(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """
    Write an image to disk.
    image, output, save, file

    Use cases:
    - Save processed images
    - Export edited photos
    - Archive image results
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The image to save",
    )
    folder: str | OutputHandle[str] = connect_field(
        default="", description="Folder where the file will be saved"
    )
    filename: str | OutputHandle[str] = connect_field(
        default="",
        description="\n        The name of the image file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        ",
    )
    overwrite: bool | OutputHandle[bool] = connect_field(
        default=False,
        description="Overwrite the file if it already exists, otherwise file will be renamed",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.SaveImageFile

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class Scale(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """
    Enlarge or shrink an image by a scale factor.
    image, resize, scale

    - Adjust image dimensions for display galleries
    - Standardize image sizes for machine learning datasets
    - Create thumbnail versions of images
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The image to scale.",
    )
    scale: float | OutputHandle[float] = connect_field(
        default=1.0, description="The scale factor."
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.Scale

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class TextToImage(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """
    Generate images from text prompts using any supported image provider.
    Automatically routes to the appropriate backend (HuggingFace, FAL, MLX).
    image, generation, AI, text-to-image, t2i

    Use cases:
    - Create images from text descriptions
    - Switch between providers without changing workflows
    - Generate images with different AI models
    - Cost-optimize by choosing different providers
    """

    model: types.ImageModel | OutputHandle[types.ImageModel] = connect_field(
        default=types.ImageModel(
            type="image_model",
            provider=nodetool.metadata.types.Provider.HuggingFaceFalAI,
            id="fal-ai/flux/schnell",
            name="FLUX.1 Schnell",
        ),
        description="The image generation model to use",
    )
    prompt: str | OutputHandle[str] = connect_field(
        default="A cat holding a sign that says hello world",
        description="Text prompt describing the desired image",
    )
    negative_prompt: str | OutputHandle[str] = connect_field(
        default="", description="Text prompt describing what to avoid in the image"
    )
    width: int | OutputHandle[int] = connect_field(
        default=512, description="Width of the generated image"
    )
    height: int | OutputHandle[int] = connect_field(
        default=512, description="Height of the generated image"
    )
    guidance_scale: float | OutputHandle[float] = connect_field(
        default=7.5,
        description="Classifier-free guidance scale (higher = closer to prompt)",
    )
    num_inference_steps: int | OutputHandle[int] = connect_field(
        default=30, description="Number of denoising steps"
    )
    seed: int | OutputHandle[int] = connect_field(
        default=-1, description="Random seed for reproducibility (-1 for random)"
    )
    scheduler: str | OutputHandle[str] = connect_field(
        default="",
        description="Scheduler to use (provider-specific, leave empty for default)",
    )
    safety_check: bool | OutputHandle[bool] = connect_field(
        default=True,
        description="Enable safety checker to filter inappropriate content",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.TextToImage

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
