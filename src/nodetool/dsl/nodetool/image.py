# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

import typing
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class BatchToList(
    SingleOutputGraphNode[list[types.ImageRef]], GraphNode[list[types.ImageRef]]
):
    """

    Convert an image batch to a list of image references.
    batch, list, images, processing

    Use cases:
    - Convert comfy batch outputs to list format
    """

    batch: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The batch of images to convert.",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.BatchToList

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


from nodetool.dsl.handles import OutputHandle, connect_field
from nodetool.workflows.base_node import BaseNode


class Crop(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """

    Crop an image to specified coordinates.
    image, crop

    - Remove unwanted borders from images
    - Focus on particular subjects within an image
    - Simplify images by removing distractions
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The image to crop.",
    )
    left: int | OutputHandle[int] = connect_field(
        default=0, description="The left coordinate."
    )
    top: int | OutputHandle[int] = connect_field(
        default=0, description="The top coordinate."
    )
    right: int | OutputHandle[int] = connect_field(
        default=512, description="The right coordinate."
    )
    bottom: int | OutputHandle[int] = connect_field(
        default=512, description="The bottom coordinate."
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.Crop

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


from nodetool.dsl.handles import OutputHandle, connect_field
from nodetool.workflows.base_node import BaseNode


class Fit(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """

    Resize an image to fit within specified dimensions while preserving aspect ratio.
    image, resize, fit

    - Resize images for online publishing requirements
    - Preprocess images to uniform sizes for machine learning
    - Control image display sizes for web development
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The image to fit.",
    )
    width: int | OutputHandle[int] = connect_field(
        default=512, description="Width to fit to."
    )
    height: int | OutputHandle[int] = connect_field(
        default=512, description="Height to fit to."
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.Fit

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


from nodetool.dsl.handles import OutputHandle, connect_field
from nodetool.workflows.base_node import BaseNode


class GetMetadata(GraphNode[nodetool.nodes.nodetool.image.GetMetadata.OutputType]):
    """

    Get metadata about the input image.
    metadata, properties, analysis, information

    Use cases:
    - Use width and height for layout calculations
    - Analyze image properties for processing decisions
    - Gather information for image cataloging or organization
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The input image.",
    )

    @property
    def out(self) -> "GetMetadataOutputs":
        return GetMetadataOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.GetMetadata

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class GetMetadataOutputs(OutputsProxy):
    @property
    def format(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["format"])

    @property
    def mode(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["mode"])

    @property
    def width(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self["width"])

    @property
    def height(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self["height"])

    @property
    def channels(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self["channels"])


from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class ImageToImage(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """

    Transform images using text prompts with any supported image provider.
    Automatically routes to the appropriate backend (HuggingFace, FAL, MLX).
    image, transformation, AI, image-to-image, i2i

    Use cases:
    - Modify existing images with text instructions
    - Style transfer and artistic modifications
    - Image enhancement and refinement
    - Creative image edits guided by prompts
    """

    model: types.ImageModel | OutputHandle[types.ImageModel] = connect_field(
        default=types.ImageModel(
            type="image_model",
            provider=nodetool.metadata.types.Provider.HuggingFaceFalAI,
            id="fal-ai/flux/dev",
            name="FLUX.1 Dev",
            path=None,
            supported_tasks=[],
        ),
        description="The image generation model to use",
    )
    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="Input image to transform",
    )
    prompt: str | OutputHandle[str] = connect_field(
        default="A photorealistic version of the input image",
        description="Text prompt describing the desired transformation",
    )
    negative_prompt: str | OutputHandle[str] = connect_field(
        default="", description="Text prompt describing what to avoid"
    )
    strength: float | OutputHandle[float] = connect_field(
        default=0.8,
        description="How much to transform the input image (0.0 = no change, 1.0 = maximum change)",
    )
    guidance_scale: float | OutputHandle[float] = connect_field(
        default=7.5, description="Classifier-free guidance scale"
    )
    num_inference_steps: int | OutputHandle[int] = connect_field(
        default=30, description="Number of denoising steps"
    )
    target_width: int | OutputHandle[int] = connect_field(
        default=512, description="Target width of the output image"
    )
    target_height: int | OutputHandle[int] = connect_field(
        default=512, description="Target height of the output image"
    )
    seed: int | OutputHandle[int] = connect_field(
        default=-1, description="Random seed for reproducibility (-1 for random)"
    )
    scheduler: str | OutputHandle[str] = connect_field(
        default="", description="Scheduler to use (provider-specific)"
    )
    safety_check: bool | OutputHandle[bool] = connect_field(
        default=True, description="Enable safety checker"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.ImageToImage

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class LoadImageAssets(
    GraphNode[nodetool.nodes.nodetool.image.LoadImageAssets.OutputType]
):
    """

    Load images from an asset folder.
    load, image, file, import
    """

    folder: types.FolderRef | OutputHandle[types.FolderRef] = connect_field(
        default=types.FolderRef(type="folder", uri="", asset_id=None, data=None),
        description="The asset folder to load the images from.",
    )

    @property
    def out(self) -> "LoadImageAssetsOutputs":
        return LoadImageAssetsOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.LoadImageAssets

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class LoadImageAssetsOutputs(OutputsProxy):
    @property
    def image(self) -> OutputHandle[types.ImageRef]:
        return typing.cast(OutputHandle[types.ImageRef], self["image"])

    @property
    def name(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["name"])


from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class LoadImageFile(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """

    Read an image file from disk.
    image, input, load, file

    Use cases:
    - Load images for processing
    - Import photos for editing
    - Read image assets for a workflow
    """

    path: str | OutputHandle[str] = connect_field(
        default="", description="Path to the image file to read"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.LoadImageFile

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class LoadImageFolder(
    GraphNode[nodetool.nodes.nodetool.image.LoadImageFolder.OutputType]
):
    """

    Load all images from a folder, optionally including subfolders.
    image, load, folder, files

    Use cases:
    - Batch import images for processing
    - Build datasets from a directory tree
    - Iterate over photo collections
    """

    folder: str | OutputHandle[str] = connect_field(
        default="", description="Folder to scan for images"
    )
    include_subdirectories: bool | OutputHandle[bool] = connect_field(
        default=False, description="Include images in subfolders"
    )
    extensions: list[str] | OutputHandle[list[str]] = connect_field(
        default=[".png", ".jpg", ".jpeg", ".bmp", ".gif", ".webp", ".tiff"],
        description="Image file extensions to include",
    )
    pattern: str | OutputHandle[str] = connect_field(
        default="", description="Pattern to match image files"
    )

    @property
    def out(self) -> "LoadImageFolderOutputs":
        return LoadImageFolderOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.LoadImageFolder

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class LoadImageFolderOutputs(OutputsProxy):
    @property
    def image(self) -> OutputHandle[types.ImageRef]:
        return typing.cast(OutputHandle[types.ImageRef], self["image"])

    @property
    def path(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["path"])


from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class Paste(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """

    Paste one image onto another at specified coordinates.
    paste, composite, positioning, overlay

    Use cases:
    - Add watermarks or logos to images
    - Combine multiple image elements
    - Create collages or montages
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The image to paste into.",
    )
    paste: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The image to paste.",
    )
    left: int | OutputHandle[int] = connect_field(
        default=0, description="The left coordinate."
    )
    top: int | OutputHandle[int] = connect_field(
        default=0, description="The top coordinate."
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.Paste

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class Resize(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """

    Change image dimensions to specified width and height.
    image, resize

    - Preprocess images for machine learning model inputs
    - Optimize images for faster web page loading
    - Create uniform image sizes for layouts
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The image to resize.",
    )
    width: int | OutputHandle[int] = connect_field(
        default=512, description="The target width."
    )
    height: int | OutputHandle[int] = connect_field(
        default=512, description="The target height."
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.Resize

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class SaveImage(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """

    Save an image to specified asset folder with customizable name format.
    save, image, folder, naming

    Use cases:
    - Save generated images with timestamps
    - Organize outputs into specific folders
    - Create backups of processed images
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The image to save.",
    )
    folder: types.FolderRef | OutputHandle[types.FolderRef] = connect_field(
        default=types.FolderRef(type="folder", uri="", asset_id=None, data=None),
        description="The asset folder to save the image in.",
    )
    name: str | OutputHandle[str] = connect_field(
        default="%Y-%m-%d_%H-%M-%S.png",
        description="\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        ",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.SaveImage

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class SaveImageFile(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """

    Write an image to disk.
    image, output, save, file

    Use cases:
    - Save processed images
    - Export edited photos
    - Archive image results
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The image to save",
    )
    folder: str | OutputHandle[str] = connect_field(
        default="", description="Folder where the file will be saved"
    )
    filename: str | OutputHandle[str] = connect_field(
        default="",
        description="\n        The name of the image file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        ",
    )
    overwrite: bool | OutputHandle[bool] = connect_field(
        default=False,
        description="Overwrite the file if it already exists, otherwise file will be renamed",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.SaveImageFile

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class Scale(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """

    Enlarge or shrink an image by a scale factor.
    image, resize, scale

    - Adjust image dimensions for display galleries
    - Standardize image sizes for machine learning datasets
    - Create thumbnail versions of images
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(type="image", uri="", asset_id=None, data=None),
        description="The image to scale.",
    )
    scale: float | OutputHandle[float] = connect_field(
        default=1.0, description="The scale factor."
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.Scale

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.image
from nodetool.workflows.base_node import BaseNode


class TextToImage(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """

    Generate images from text prompts using any supported image provider.
    Automatically routes to the appropriate backend (HuggingFace, FAL, MLX).
    image, generation, AI, text-to-image, t2i

    Use cases:
    - Create images from text descriptions
    - Switch between providers without changing workflows
    - Generate images with different AI models
    - Cost-optimize by choosing different providers
    """

    model: types.ImageModel | OutputHandle[types.ImageModel] = connect_field(
        default=types.ImageModel(
            type="image_model",
            provider=nodetool.metadata.types.Provider.HuggingFaceFalAI,
            id="fal-ai/flux/schnell",
            name="FLUX.1 Schnell",
            path=None,
            supported_tasks=[],
        ),
        description="The image generation model to use",
    )
    prompt: str | OutputHandle[str] = connect_field(
        default="A cat holding a sign that says hello world",
        description="Text prompt describing the desired image",
    )
    negative_prompt: str | OutputHandle[str] = connect_field(
        default="", description="Text prompt describing what to avoid in the image"
    )
    width: int | OutputHandle[int] = connect_field(
        default=512, description="Width of the generated image"
    )
    height: int | OutputHandle[int] = connect_field(
        default=512, description="Height of the generated image"
    )
    guidance_scale: float | OutputHandle[float] = connect_field(
        default=7.5,
        description="Classifier-free guidance scale (higher = closer to prompt)",
    )
    num_inference_steps: int | OutputHandle[int] = connect_field(
        default=30, description="Number of denoising steps"
    )
    seed: int | OutputHandle[int] = connect_field(
        default=-1, description="Random seed for reproducibility (-1 for random)"
    )
    safety_check: bool | OutputHandle[bool] = connect_field(
        default=True,
        description="Enable safety checker to filter inappropriate content",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.image.TextToImage

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
