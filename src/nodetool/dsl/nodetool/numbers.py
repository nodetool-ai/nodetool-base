# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import Field
import typing
import nodetool.metadata.types
from nodetool.dsl.graph import GraphNode

from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.numbers
from nodetool.workflows.base_node import BaseNode


class FilterNumber(GraphNode[nodetool.nodes.nodetool.numbers.FilterNumber.OutputType]):
    """

    Filters a stream of numbers based on various numerical conditions.
    filter, numbers, numeric, stream

    Use cases:
    - Filter numbers by comparison (greater than, less than, equal to)
    - Filter even/odd numbers
    - Filter positive/negative numbers
    """

    FilterNumberType: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.numbers.FilterNumber.FilterNumberType
    )

    value: float | OutputHandle[float] = connect_field(
        default=0.0, description="Input number stream"
    )
    filter_type: nodetool.nodes.nodetool.numbers.FilterNumber.FilterNumberType = Field(
        default=nodetool.nodes.nodetool.numbers.FilterNumber.FilterNumberType.GREATER_THAN,
        description="The type of filter to apply",
    )
    compare_value: float | OutputHandle[float] = connect_field(
        default=0,
        description="The comparison value (for greater_than, less_than, equal_to)",
    )

    @property
    def out(self) -> "FilterNumberOutputs":
        return FilterNumberOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.numbers.FilterNumber

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class FilterNumberOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[float]:
        return typing.cast(OutputHandle[float], self["output"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.numbers
from nodetool.workflows.base_node import BaseNode


class FilterNumberRange(
    GraphNode[nodetool.nodes.nodetool.numbers.FilterNumberRange.OutputType]
):
    """

    Filters a stream of numbers to find values within a specified range.
    filter, numbers, range, between, stream

    Use cases:
    - Find numbers within a specific range
    - Filter data points within bounds
    - Implement range-based filtering
    """

    value: float | OutputHandle[float] = connect_field(
        default=0.0, description="Input number stream"
    )
    min_value: float | OutputHandle[float] = connect_field(
        default=0, description="Minimum value"
    )
    max_value: float | OutputHandle[float] = connect_field(
        default=0, description="Maximum value"
    )
    inclusive: bool | OutputHandle[bool] = connect_field(
        default=True, description="Inclusive bounds"
    )

    @property
    def out(self) -> "FilterNumberRangeOutputs":
        return FilterNumberRangeOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.numbers.FilterNumberRange

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class FilterNumberRangeOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[float]:
        return typing.cast(OutputHandle[float], self["output"])
