# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class AssetFolderInput(SingleOutputGraphNode[types.FolderRef], GraphNode[types.FolderRef]):
    """

        Accepts an asset folder as a parameter for workflows.
        input, parameter, folder, path, folderpath, local_folder, filesystem
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: types.FolderRef | OutputHandle[types.FolderRef] = connect_field(default=types.FolderRef(type='folder', uri='', asset_id=None, data=None, metadata=None), description='The folder to use as input.')
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.AssetFolderInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class AudioInput(SingleOutputGraphNode[types.AudioRef], GraphNode[types.AudioRef]):
    """

        Accepts a reference to an audio asset for workflows, specified by an 'AudioRef'.  An 'AudioRef' points to audio data that can be used for playback, transcription, analysis, or processing by audio-capable models.
        input, parameter, audio, sound, voice, speech, asset

        Use cases:
        - Load an audio file for speech-to-text transcription.
        - Analyze sound for specific events or characteristics.
        - Provide audio input to models for tasks like voice recognition or music generation.
        - Process audio for enhancement or feature extraction.
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: types.AudioRef | OutputHandle[types.AudioRef] = connect_field(default=types.AudioRef(type='audio', uri='', asset_id=None, data=None, metadata=None), description='The audio to use as input.')
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.AudioInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class BooleanInput(SingleOutputGraphNode[bool], GraphNode[bool]):
    """

        Accepts a boolean (true/false) value as a parameter for workflows.  This input is used for binary choices, enabling or disabling features, or controlling conditional logic paths.
        input, parameter, boolean, bool, toggle, switch, flag

        Use cases:
        - Toggle features or settings on or off.
        - Set binary flags to control workflow behavior.
        - Make conditional choices within a workflow (e.g., proceed if true).
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: bool | OutputHandle[bool] = connect_field(default=False, description=None)
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.BooleanInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class ColorInput(SingleOutputGraphNode[types.ColorRef], GraphNode[types.ColorRef]):
    """

        Accepts a color value as a parameter for workflows.
        input, parameter, color, color_picker, color_input
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: types.ColorRef | OutputHandle[types.ColorRef] = connect_field(default=types.ColorRef(type='color', value=None), description='The color to use as input.')
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.ColorInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class DataframeInput(SingleOutputGraphNode[types.DataframeRef], GraphNode[types.DataframeRef]):
    """

        Accepts a reference to a dataframe asset for workflows.
        input, parameter, dataframe, table, data
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: types.DataframeRef | OutputHandle[types.DataframeRef] = connect_field(default=types.DataframeRef(type='dataframe', uri='', asset_id=None, data=None, metadata=None, columns=None), description='The dataframe to use as input.')
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.DataframeInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class DocumentFileInput(GraphNode[nodetool.nodes.nodetool.input.DocumentFileInput.OutputType]):
    """

        Accepts a local file path pointing to a document and converts it into a 'DocumentRef'.
        input, parameter, document, file, path, local_file, load

        Use cases:
        - Directly load a document (e.g., PDF, TXT, DOCX) from a specified local file path.
        - Convert a local file path into a 'DocumentRef' that can be consumed by other document-processing nodes.
        - Useful for development or workflows that have legitimate access to the local filesystem.
        - To provide an existing 'DocumentRef', use 'DocumentInput'.
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: str | OutputHandle[str] = connect_field(default='', description='The path to the document file.')
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @property
    def out(self) -> "DocumentFileInputOutputs":
        return DocumentFileInputOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.DocumentFileInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()

class DocumentFileInputOutputs(OutputsProxy):
    @property
    def document(self) -> OutputHandle[types.DocumentRef]:
        return typing.cast(OutputHandle[types.DocumentRef], self['document'])

    @property
    def path(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self['path'])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class DocumentInput(SingleOutputGraphNode[types.DocumentRef], GraphNode[types.DocumentRef]):
    """

        Accepts a reference to a document asset for workflows, specified by a 'DocumentRef'.  A 'DocumentRef' points to a structured document (e.g., PDF, DOCX, TXT) which can be processed or analyzed. This node is used when the workflow needs to operate on a document as a whole entity, potentially including its structure and metadata, rather than just raw text.
        input, parameter, document, file, asset, reference

        Use cases:
        - Load a specific document (e.g., PDF, Word, text file) for content extraction or analysis.
        - Pass a document to models that are designed to process specific document formats.
        - Manage documents as distinct assets within a workflow.
        - If you have a local file path and need to convert it to a 'DocumentRef', consider using 'DocumentFileInput'.
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: types.DocumentRef | OutputHandle[types.DocumentRef] = connect_field(default=types.DocumentRef(type='document', uri='', asset_id=None, data=None, metadata=None), description='The document to use as input.')
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.DocumentInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class FilePathInput(SingleOutputGraphNode[str], GraphNode[str]):
    """

        Accepts a local filesystem path (to a file or directory) as input for workflows.
        input, parameter, path, filepath, directory, local_file, filesystem

        Use cases:
        - Provide a local path to a specific file or directory for processing.
        - Specify an input or output location on the local filesystem for a development task.
        - Load local datasets or configuration files not managed as assets.
        - Not available in production: raises an error if used in a production environment.
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: str | OutputHandle[str] = connect_field(default='', description='The path to use as input.')
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.FilePathInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class FloatInput(SingleOutputGraphNode[float], GraphNode[float]):
    """

        Accepts a floating-point number as a parameter for workflows, typically constrained by a minimum and maximum value.  This input allows for precise numeric settings, such as adjustments, scores, or any value requiring decimal precision.
        input, parameter, float, number, decimal, range

        Use cases:
        - Specify a numeric value within a defined range (e.g., 0.0 to 1.0).
        - Set thresholds, confidence scores, or scaling factors.
        - Configure continuous parameters like opacity, volume, or temperature.
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: float | OutputHandle[float] = connect_field(default=0.0, description=None)
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')
    min: float | OutputHandle[float] = connect_field(default=0, description=None)
    max: float | OutputHandle[float] = connect_field(default=100, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.FloatInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class FolderPathInput(SingleOutputGraphNode[str], GraphNode[str]):
    """

        Accepts a folder path as a parameter for workflows.
        input, parameter, folder, path, folderpath, local_folder, filesystem
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: str | OutputHandle[str] = connect_field(default='', description='The folder path to use as input.')
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.FolderPathInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class HuggingFaceModelInput(SingleOutputGraphNode[types.HuggingFaceModel], GraphNode[types.HuggingFaceModel]):
    """

        Accepts a Hugging Face model as a parameter for workflows.
        input, parameter, model, huggingface, hugging_face, model_name
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: types.HuggingFaceModel | OutputHandle[types.HuggingFaceModel] = connect_field(default=types.HuggingFaceModel(type='hf.model', repo_id='', path=None, variant=None, allow_patterns=None, ignore_patterns=None), description='The Hugging Face model to use as input.')
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.HuggingFaceModelInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class ImageInput(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """

        Accepts a reference to an image asset for workflows, specified by an 'ImageRef'.  An 'ImageRef' points to image data that can be used for display, analysis, or processing by vision models.
        input, parameter, image, picture, graphic, visual, asset

        Use cases:
        - Load an image for visual processing or analysis.
        - Provide an image as input to computer vision models (e.g., object detection, image classification).
        - Select an image for manipulation, enhancement, or inclusion in a document.
        - Display an image within a workflow interface.
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(default=types.ImageRef(type='image', uri='', asset_id=None, data=None, metadata=None), description='The image to use as input.')
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.ImageInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class ImageModelInput(SingleOutputGraphNode[types.ImageModel], GraphNode[types.ImageModel]):
    """

        Accepts an image generation model as a parameter for workflows.
        input, parameter, model, image, generation
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: types.ImageModel | OutputHandle[types.ImageModel] = connect_field(default=types.ImageModel(type='image_model', provider=nodetool.metadata.types.Provider.Empty, id='', name='', path=None, supported_tasks=[]), description='The image generation model to use as input.')
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.ImageModelInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class IntegerInput(SingleOutputGraphNode[int], GraphNode[int]):
    """

        Accepts an integer (whole number) as a parameter for workflows, typically constrained by a minimum and maximum value.  This input is used for discrete numeric values like counts, indices, or iteration limits.
        input, parameter, integer, number, count, index, whole_number

        Use cases:
        - Specify counts or quantities (e.g., number of items, iterations).
        - Set index values for accessing elements in a list or array.
        - Configure discrete numeric parameters like age, steps, or quantity.
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: int | OutputHandle[int] = connect_field(default=0, description=None)
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')
    min: int | OutputHandle[int] = connect_field(default=0, description=None)
    max: int | OutputHandle[int] = connect_field(default=100, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.IntegerInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class LanguageModelInput(SingleOutputGraphNode[types.LanguageModel], GraphNode[types.LanguageModel]):
    """

        Accepts a language model as a parameter for workflows.
        input, parameter, model, language, model_name
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: types.LanguageModel | OutputHandle[types.LanguageModel] = connect_field(default=types.LanguageModel(type='language_model', provider=nodetool.metadata.types.Provider.Empty, id='', name='', path=None, supported_tasks=[]), description='The language model to use as input.')
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.LanguageModelInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class MessageDeconstructor(GraphNode[nodetool.nodes.nodetool.input.MessageDeconstructor.OutputType]):
    """

        Deconstructs a chat message object into its individual fields.
        extract, decompose, message, fields, chat

        Use cases:
        - Extract specific fields from a message (e.g., role, content, thread_id).
        - Access message metadata for workflow logic.
        - Process different parts of a message separately.
    """

    value: types.Message | OutputHandle[types.Message] = connect_field(default=types.Message(type='message', id=None, workflow_id=None, graph=None, thread_id=None, tools=None, tool_call_id=None, role='', name=None, content=None, tool_calls=None, collections=None, input_files=None, created_at=None, provider=None, model=None, agent_mode=None, help_mode=None, agent_execution_id=None, execution_event_type=None, workflow_target=None), description='The message object to deconstruct.')

    @property
    def out(self) -> "MessageDeconstructorOutputs":
        return MessageDeconstructorOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.MessageDeconstructor

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()

class MessageDeconstructorOutputs(OutputsProxy):
    @property
    def id(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self['id'])

    @property
    def thread_id(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self['thread_id'])

    @property
    def role(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self['role'])

    @property
    def text(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self['text'])

    @property
    def image(self) -> OutputHandle[nodetool.metadata.types.ImageRef]:
        return typing.cast(OutputHandle[nodetool.metadata.types.ImageRef], self['image'])

    @property
    def audio(self) -> OutputHandle[nodetool.metadata.types.AudioRef]:
        return typing.cast(OutputHandle[nodetool.metadata.types.AudioRef], self['audio'])

    @property
    def model(self) -> OutputHandle[nodetool.metadata.types.LanguageModel]:
        return typing.cast(OutputHandle[nodetool.metadata.types.LanguageModel], self['model'])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class MessageInput(SingleOutputGraphNode[types.Message], GraphNode[types.Message]):
    """

        Accepts a chat message object for workflows.
        input, parameter, message, chat, conversation
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: types.Message | OutputHandle[types.Message] = connect_field(default=types.Message(type='message', id=None, workflow_id=None, graph=None, thread_id=None, tools=None, tool_call_id=None, role='', name=None, content=None, tool_calls=None, collections=None, input_files=None, created_at=None, provider=None, model=None, agent_mode=None, help_mode=None, agent_execution_id=None, execution_event_type=None, workflow_target=None), description='The message object containing role, content, and metadata.')
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.MessageInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class MessageListInput(SingleOutputGraphNode[list[types.Message]], GraphNode[list[types.Message]]):
    """

        Accepts a list of chat message objects for workflows.
        input, parameter, messages, chat, conversation, history
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: list[types.Message] | OutputHandle[list[types.Message]] = connect_field(default=[], description='The list of message objects representing chat history.')
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.MessageListInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class Model3DInput(SingleOutputGraphNode[types.Model3DRef], GraphNode[types.Model3DRef]):
    """

        Accepts a reference to a 3D model asset for workflows, specified by a 'Model3DRef'.
        A 'Model3DRef' points to 3D model data that can be used for visualization, processing,
        or conversion by 3D-capable nodes.
        input, parameter, 3d, model, mesh, obj, glb, stl, ply, asset

        Use cases:
        - Load a 3D model file for processing or visualization.
        - Provide 3D model input to geometry processing nodes.
        - Convert between 3D formats (OBJ, GLB, STL, PLY, USDZ).
        - Process 3D models for decimation, boolean operations, or transforms.
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: types.Model3DRef | OutputHandle[types.Model3DRef] = connect_field(default=types.Model3DRef(type='model_3d', uri='', asset_id=None, data=None, metadata=None, format=None), description='The 3D model to use as input.')
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.Model3DInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class RealtimeAudioInput(GraphNode[nodetool.nodes.nodetool.input.RealtimeAudioInput.OutputType]):
    """

        Accepts streaming audio data for workflows.
        input, parameter, audio, sound, voice, speech, asset
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: types.AudioRef | OutputHandle[types.AudioRef] = connect_field(default=types.AudioRef(type='audio', uri='', asset_id=None, data=None, metadata=None), description='The audio to use as input.')
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @property
    def out(self) -> "RealtimeAudioInputOutputs":
        return RealtimeAudioInputOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.RealtimeAudioInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()

class RealtimeAudioInputOutputs(OutputsProxy):
    @property
    def chunk(self) -> OutputHandle[types.Chunk]:
        return typing.cast(OutputHandle[types.Chunk], self['chunk'])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class StringInput(SingleOutputGraphNode[str], GraphNode[str]):
    """

        Accepts a string value as a parameter for workflows.
        input, parameter, string, text, label, name, value

        Use cases:
        - Define a name for an entity or process.
        - Specify a label for a component or output.
        - Enter a short keyword or search term.
        - Provide a simple configuration value (e.g., an API key, a model name).
        - If you need to input multi-line text or the content of a file, use 'DocumentFileInput'.
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: str | OutputHandle[str] = connect_field(default='', description=None)
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.StringInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class StringListInput(SingleOutputGraphNode[list[str]], GraphNode[list[str]]):
    """

        Accepts a list of strings as a parameter for workflows.
        input, parameter, string, text, label, name, value
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: list[str] | OutputHandle[list[str]] = connect_field(default=[], description='The list of strings to use as input.')
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.StringListInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.input
from nodetool.workflows.base_node import BaseNode

class VideoInput(SingleOutputGraphNode[types.VideoRef], GraphNode[types.VideoRef]):
    """

        Accepts a reference to a video asset for workflows, specified by a 'VideoRef'.  A 'VideoRef' points to video data that can be used for playback, analysis, frame extraction, or processing by video-capable models.
        input, parameter, video, movie, clip, visual, asset

        Use cases:
        - Load a video file for processing or content analysis.
        - Analyze video content for events, objects, or speech.
        - Extract frames or audio tracks from a video.
        - Provide video input to models that understand video data.
    """

    name: str | OutputHandle[str] = connect_field(default='', description='The parameter name for the workflow.')
    value: types.VideoRef | OutputHandle[types.VideoRef] = connect_field(default=types.VideoRef(type='video', uri='', asset_id=None, data=None, metadata=None, duration=None, format=None), description='The video to use as input.')
    description: str | OutputHandle[str] = connect_field(default='', description='The description of the input for the workflow.')

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.input.VideoInput

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


