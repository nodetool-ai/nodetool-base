# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class Append(SingleOutputGraphNode[list[Any]], GraphNode[list[Any]]):
    """
    Adds a value to the end of a list.
    list, add, insert, extend

    Use cases:
    - Grow a list dynamically
    - Add new elements to an existing list
    - Implement a stack-like structure
    """

    values: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )
    value: Any | OutputHandle[Any] = connect_field(default=None, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Append

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class Average(SingleOutputGraphNode[float], GraphNode[float]):
    """
    Calculates the arithmetic mean of a list of numbers.
    list, average, mean, aggregate, math

    Use cases:
    - Find average value
    - Calculate mean of numeric data
    """

    values: list[float] | OutputHandle[list[float]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Average

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class Chunk(SingleOutputGraphNode[list[list[Any]]], GraphNode[list[list[Any]]]):
    """
    Splits a list into smaller chunks of specified size.
    list, chunk, split, group

    Use cases:
    - Batch processing
    - Pagination
    - Creating sublists of fixed size
    """

    values: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )
    chunk_size: int | OutputHandle[int] = connect_field(default=1, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Chunk

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class Dedupe(SingleOutputGraphNode[list[Any]], GraphNode[list[Any]]):
    """
    Removes duplicate elements from a list, ensuring uniqueness.
    list, unique, distinct, deduplicate

    Use cases:
    - Remove redundant entries
    - Create a set-like structure
    - Ensure list elements are unique
    """

    values: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Dedupe

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class Difference(SingleOutputGraphNode[list[Any]], GraphNode[list[Any]]):
    """
    Finds elements that exist in first list but not in second list.
    list, set, difference, subtract

    Use cases:
    - Find unique elements in one list
    - Remove items present in another list
    - Identify distinct elements
    """

    list1: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )
    list2: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Difference

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class Extend(SingleOutputGraphNode[list[Any]], GraphNode[list[Any]]):
    """
    Merges one list into another, extending the original list.
    list, merge, concatenate, combine

    Use cases:
    - Combine multiple lists
    - Add all elements from one list to another
    """

    values: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )
    other_values: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Extend

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class FilterDicts(SingleOutputGraphNode[list[dict]], GraphNode[list[dict]]):
    """
    Filter a list of dictionaries based on a condition.
    list, filter, query, condition

    Basic Operators:
    - Comparison: >, <, >=, <=, ==, !=
    - Logical: and, or, not
    - Membership: in, not in

    Example Conditions:
    # Basic comparisons
    age > 30
    price <= 100
    status == 'active'

    # Multiple conditions
    age > 30 and salary < 50000
    (price >= 100) and (price <= 200)
    department in ['Sales', 'Marketing']

    # String operations
    name.str.startswith('J')
    email.str.contains('@company.com')

    # Datetime conditions
    date > '2024-01-01'
    date.dt.year == 2024
    date.dt.month >= 6
    date.dt.day_name() == 'Monday'

    # Date ranges
    date.between('2024-01-01', '2024-12-31')
    date >= '2024-01-01' and date < '2025-01-01'

    # Complex datetime
    date.dt.hour < 12
    date.dt.dayofweek <= 4  # Weekdays only

    # Numeric operations
    price.between(100, 200)
    quantity % 2 == 0  # Even numbers

    # Special values
    value.isna()  # Check for NULL/NaN
    value.notna()  # Check for non-NULL/non-NaN

    Note: Dates should be in ISO format (YYYY-MM-DD) or include time (YYYY-MM-DD HH:MM:SS)

    Use cases:
    - Filter list of dictionary objects based on criteria
    - Extract subset of data meeting specific conditions
    - Clean data by removing unwanted entries
    """

    values: list[dict] | OutputHandle[list[dict]] = connect_field(
        default=[], description=None
    )
    condition: str | OutputHandle[str] = connect_field(
        default="",
        description="\n        The filtering condition using pandas query syntax.\n\n        Basic Operators:\n        - Comparison: >, <, >=, <=, ==, !=\n        - Logical: and, or, not\n        - Membership: in, not in\n        \n        Example Conditions:\n        # Basic comparisons\n        age > 30\n        price <= 100\n        status == 'active'\n        \n        See node documentation for more examples.\n        ",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.FilterDicts

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode
import nodetool.nodes.nodetool.list


class FilterDictsByNumber(SingleOutputGraphNode[list[dict]], GraphNode[list[dict]]):
    """
    Filters a list of dictionaries based on numeric values for a specified key.
    list, filter, dictionary, numbers, numeric

    Use cases:
    - Filter dictionaries by numeric comparisons (greater than, less than, equal to)
    - Filter records with even/odd numeric values
    - Filter entries with positive/negative numbers
    """

    FilterDictNumberType: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.list.FilterDictsByNumber.FilterDictNumberType
    )
    values: list[dict] | OutputHandle[list[dict]] = connect_field(
        default=[], description=None
    )
    key: str | OutputHandle[str] = connect_field(default="", description=None)
    filter_type: (
        nodetool.nodes.nodetool.list.FilterDictsByNumber.FilterDictNumberType
    ) = Field(
        default=nodetool.nodes.nodetool.list.FilterDictsByNumber.FilterDictNumberType.GREATER_THAN,
        description=None,
    )
    value: float | OutputHandle[float] | None = connect_field(
        default=None, description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.FilterDictsByNumber

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class FilterDictsByRange(SingleOutputGraphNode[list[dict]], GraphNode[list[dict]]):
    """
    Filters a list of dictionaries based on a numeric range for a specified key.
    list, filter, dictionary, range, between

    Use cases:
    - Filter records based on numeric ranges (e.g., price range, age range)
    - Find entries with values within specified bounds
    - Filter data sets based on numeric criteria
    """

    values: list[dict] | OutputHandle[list[dict]] = connect_field(
        default=[], description=None
    )
    key: str | OutputHandle[str] = connect_field(
        default="", description="The dictionary key to check for the range"
    )
    min_value: float | OutputHandle[float] = connect_field(
        default=0, description="The minimum value (inclusive) of the range"
    )
    max_value: float | OutputHandle[float] = connect_field(
        default=0, description="The maximum value (inclusive) of the range"
    )
    inclusive: bool | OutputHandle[bool] = connect_field(
        default=True,
        description="If True, includes the min and max values in the results",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.FilterDictsByRange

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode
import nodetool.nodes.nodetool.list


class FilterDictsByValue(SingleOutputGraphNode[list[dict]], GraphNode[list[dict]]):
    """
    Filters a list of dictionaries based on their values using various criteria.
    list, filter, dictionary, values

    Use cases:
    - Filter dictionaries by value content
    - Filter dictionaries by value type
    - Filter dictionaries by value patterns
    """

    FilterType: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.list.FilterDictsByValue.FilterType
    )
    values: list[dict] | OutputHandle[list[dict]] = connect_field(
        default=[], description=None
    )
    key: str | OutputHandle[str] = connect_field(
        default="", description="The dictionary key to check"
    )
    filter_type: nodetool.nodes.nodetool.list.FilterDictsByValue.FilterType = Field(
        default=nodetool.nodes.nodetool.list.FilterDictsByValue.FilterType.CONTAINS,
        description="The type of filter to apply",
    )
    criteria: str | OutputHandle[str] = connect_field(
        default="",
        description="The filtering criteria (text to match, type name, or length as string)",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.FilterDictsByValue

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class FilterDictsRegex(SingleOutputGraphNode[list[dict]], GraphNode[list[dict]]):
    """
    Filters a list of dictionaries using regular expressions on specified keys.
    list, filter, regex, dictionary, pattern

    Use cases:
    - Filter dictionaries with values matching complex patterns
    - Search for dictionaries containing emails, dates, or specific formats
    - Advanced text pattern matching across dictionary values
    """

    values: list[dict] | OutputHandle[list[dict]] = connect_field(
        default=[], description=None
    )
    key: str | OutputHandle[str] = connect_field(default="", description=None)
    pattern: str | OutputHandle[str] = connect_field(default="", description=None)
    full_match: bool | OutputHandle[bool] = connect_field(
        default=False, description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.FilterDictsRegex

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class FilterNone(SingleOutputGraphNode[list[Any]], GraphNode[list[Any]]):
    """
    Filters out None values from a list.
    list, filter, none, null

    Use cases:
    - Clean data by removing null values
    - Get only valid entries
    - Remove placeholder values
    """

    values: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.FilterNone

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class FilterNumberRange(SingleOutputGraphNode[list[float]], GraphNode[list[float]]):
    """
    Filters a list of numbers to find values within a specified range.
    list, filter, numbers, range, between

    Use cases:
    - Find numbers within a specific range
    - Filter data points within bounds
    - Implement range-based filtering
    """

    values: list[float] | OutputHandle[list[float]] = connect_field(
        default=[], description=None
    )
    min_value: float | OutputHandle[float] = connect_field(default=0, description=None)
    max_value: float | OutputHandle[float] = connect_field(default=0, description=None)
    inclusive: bool | OutputHandle[bool] = connect_field(default=True, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.FilterNumberRange

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode
import nodetool.nodes.nodetool.list


class FilterNumbers(SingleOutputGraphNode[list[float]], GraphNode[list[float]]):
    """
    Filters a list of numbers based on various numerical conditions.
    list, filter, numbers, numeric

    Use cases:
    - Filter numbers by comparison (greater than, less than, equal to)
    - Filter even/odd numbers
    - Filter positive/negative numbers
    """

    FilterNumberType: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.list.FilterNumbers.FilterNumberType
    )
    values: list[float] | OutputHandle[list[float]] = connect_field(
        default=[], description=None
    )
    filter_type: nodetool.nodes.nodetool.list.FilterNumbers.FilterNumberType = Field(
        default=nodetool.nodes.nodetool.list.FilterNumbers.FilterNumberType.GREATER_THAN,
        description="The type of filter to apply",
    )
    value: float | OutputHandle[float] | None = connect_field(
        default=None,
        description="The comparison value (for greater_than, less_than, equal_to)",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.FilterNumbers

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class FilterRegex(SingleOutputGraphNode[list[str]], GraphNode[list[str]]):
    """
    Filters a list of strings using regular expressions.
    list, filter, regex, pattern, text

    Use cases:
    - Filter strings using complex patterns
    - Extract strings matching specific formats (emails, dates, etc.)
    - Advanced text pattern matching
    """

    values: list[str] | OutputHandle[list[str]] = connect_field(
        default=[], description=None
    )
    pattern: str | OutputHandle[str] = connect_field(
        default="", description="The regular expression pattern to match against."
    )
    full_match: bool | OutputHandle[bool] = connect_field(
        default=False,
        description="Whether to match the entire string or find pattern anywhere in string",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.FilterRegex

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode
import nodetool.nodes.nodetool.list


class FilterStrings(SingleOutputGraphNode[list[str]], GraphNode[list[str]]):
    """
    Filters a list of strings based on various criteria.
    list, filter, strings, text

    Use cases:
    - Filter strings by length
    - Filter strings containing specific text
    - Filter strings by prefix/suffix
    - Filter strings using regex patterns
    """

    FilterType: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.list.FilterStrings.FilterType
    )
    values: list[str] | OutputHandle[list[str]] = connect_field(
        default=[], description=None
    )
    filter_type: nodetool.nodes.nodetool.list.FilterStrings.FilterType = Field(
        default=nodetool.nodes.nodetool.list.FilterStrings.FilterType.CONTAINS,
        description="The type of filter to apply",
    )
    criteria: str | OutputHandle[str] = connect_field(
        default="",
        description="The filtering criteria (text to match or length as string)",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.FilterStrings

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class Flatten(SingleOutputGraphNode[list[Any]], GraphNode[list[Any]]):
    """
    Flattens a nested list structure into a single flat list.
    list, flatten, nested, structure

    Use cases:
    - Convert nested lists into a single flat list
    - Simplify complex list structures
    - Process hierarchical data as a sequence

    Examples:
    [[1, 2], [3, 4]] -> [1, 2, 3, 4]
    [[1, [2, 3]], [4, [5, 6]]] -> [1, 2, 3, 4, 5, 6]
    """

    values: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )
    max_depth: int | OutputHandle[int] = connect_field(default=-1, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Flatten

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class GenerateSequence(
    GraphNode[nodetool.nodes.nodetool.list.GenerateSequence.OutputType]
):
    """
    Iterates over a sequence of numbers.
    list, range, sequence, numbers
    """

    start: int | OutputHandle[int] = connect_field(default=0, description=None)
    stop: int | OutputHandle[int] = connect_field(default=0, description=None)
    step: int | OutputHandle[int] = connect_field(default=1, description=None)

    @property
    def out(self) -> "GenerateSequenceOutputs":
        return GenerateSequenceOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.GenerateSequence

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class GenerateSequenceOutputs(OutputsProxy):
    @property
    def output(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self["output"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class GetElement(SingleOutputGraphNode[Any], GraphNode[Any]):
    """
    Retrieves a single value from a list at a specific index.
    list, get, extract, value

    Use cases:
    - Access a specific element by position
    - Implement array-like indexing
    - Extract the first or last element
    """

    values: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )
    index: int | OutputHandle[int] = connect_field(default=0, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.GetElement

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class Intersection(SingleOutputGraphNode[list[Any]], GraphNode[list[Any]]):
    """
    Finds common elements between two lists.
    list, set, intersection, common

    Use cases:
    - Find elements present in both lists
    - Identify shared items between collections
    - Filter for matching elements
    """

    list1: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )
    list2: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Intersection

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class Length(SingleOutputGraphNode[int], GraphNode[int]):
    """
    Calculates the length of a list.
    list, count, size

    Use cases:
    - Determine the number of elements in a list
    - Check if a list is empty
    - Validate list size constraints
    """

    values: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Length

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class ListRange(SingleOutputGraphNode[list[int]], GraphNode[list[int]]):
    """
    Generates a list of integers within a specified range.
    list, range, sequence, numbers

    Use cases:
    - Create numbered lists
    - Generate index sequences
    - Produce arithmetic progressions
    """

    start: int | OutputHandle[int] = connect_field(default=0, description=None)
    stop: int | OutputHandle[int] = connect_field(default=0, description=None)
    step: int | OutputHandle[int] = connect_field(default=1, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.ListRange

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class MapField(SingleOutputGraphNode[list[Any]], GraphNode[list[Any]]):
    """
    Extracts a specific field from a list of dictionaries.
    list, map, field, extract, pluck

    Use cases:
    - Extract specific fields from a list of dictionaries
    - Transform complex data structures into simple lists
    - Collect values for a particular key across multiple dictionaries
    """

    values: list[dict[str, Any]] | OutputHandle[list[dict[str, Any]]] = connect_field(
        default=[], description=None
    )
    field: str | OutputHandle[str] = connect_field(default="", description=None)
    default: typing.Any | OutputHandle[typing.Any] | None = connect_field(
        default=None, description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.MapField

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class Maximum(SingleOutputGraphNode[float], GraphNode[float]):
    """
    Finds the largest value in a list of numbers.
    list, max, maximum, aggregate, math

    Use cases:
    - Find highest value
    - Get largest number in dataset
    """

    values: list[float] | OutputHandle[list[float]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Maximum

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class Minimum(SingleOutputGraphNode[float], GraphNode[float]):
    """
    Finds the smallest value in a list of numbers.
    list, min, minimum, aggregate, math

    Use cases:
    - Find lowest value
    - Get smallest number in dataset
    """

    values: list[float] | OutputHandle[list[float]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Minimum

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class Product(SingleOutputGraphNode[float], GraphNode[float]):
    """
    Calculates the product of all numbers in a list.
    list, product, multiply, aggregate, math

    Use cases:
    - Multiply all numbers together
    - Calculate compound values
    """

    values: list[float] | OutputHandle[list[float]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Product

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class Randomize(SingleOutputGraphNode[list[Any]], GraphNode[list[Any]]):
    """
    Randomly shuffles the elements of a list.
    list, shuffle, random, order

    Use cases:
    - Randomize the order of items in a playlist
    - Implement random sampling without replacement
    - Create randomized data sets for testing
    """

    values: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Randomize

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class Reverse(SingleOutputGraphNode[list[Any]], GraphNode[list[Any]]):
    """
    Inverts the order of elements in a list.
    list, reverse, invert, flip

    Use cases:
    - Reverse the order of a sequence
    """

    values: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Reverse

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class SaveList(SingleOutputGraphNode[types.TextRef], GraphNode[types.TextRef]):
    """
    Saves a list to a text file, placing each element on a new line.
    list, save, file, serialize

    Use cases:
    - Export list data to a file
    - Create a simple text-based database
    - Generate line-separated output
    """

    values: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )
    name: str | OutputHandle[str] = connect_field(
        default="text.txt",
        description="\n        Name of the output file.\n        You can use time and date variables to create unique names:\n        %Y - Year\n        %m - Month\n        %d - Day\n        %H - Hour\n        %M - Minute\n        %S - Second\n        ",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.SaveList

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class SelectElements(SingleOutputGraphNode[list[Any]], GraphNode[list[Any]]):
    """
    Selects specific values from a list using index positions.
    list, select, index, extract

    Use cases:
    - Pick specific elements by their positions
    - Rearrange list elements
    - Create a new list from selected indices
    """

    values: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )
    indices: list[int] | OutputHandle[list[int]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.SelectElements

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class Slice(SingleOutputGraphNode[list[Any]], GraphNode[list[Any]]):
    """
    Extracts a subset from a list using start, stop, and step indices.
    list, slice, subset, extract

    Use cases:
    - Get a portion of a list
    - Implement pagination
    - Extract every nth element
    """

    values: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )
    start: int | OutputHandle[int] = connect_field(default=0, description=None)
    stop: int | OutputHandle[int] = connect_field(default=0, description=None)
    step: int | OutputHandle[int] = connect_field(default=1, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Slice

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode
import nodetool.nodes.nodetool.list


class Sort(SingleOutputGraphNode[list[Any]], GraphNode[list[Any]]):
    """
    Sorts the elements of a list in ascending or descending order.
    list, sort, order, arrange

    Use cases:
    - Organize data in a specific order
    - Prepare data for binary search or other algorithms
    - Rank items based on their values
    """

    SortOrder: typing.ClassVar[type] = nodetool.nodes.nodetool.list.Sort.SortOrder
    values: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )
    order: nodetool.nodes.nodetool.list.Sort.SortOrder = Field(
        default=nodetool.nodes.nodetool.list.Sort.SortOrder.ASCENDING, description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Sort

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class Sum(SingleOutputGraphNode[float], GraphNode[float]):
    """
    Calculates the sum of a list of numbers.
    list, sum, aggregate, math

    Use cases:
    - Calculate total of numeric values
    - Add up all elements in a list
    """

    values: list[float] | OutputHandle[list[float]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Sum

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode
import nodetool.nodes.nodetool.list


class Transform(SingleOutputGraphNode[list[Any]], GraphNode[list[Any]]):
    """
    Applies a transformation to each element in a list.
    list, transform, map, convert

    Use cases:
    - Convert types (str to int, etc.)
    - Apply formatting
    - Mathematical operations
    """

    TransformType: typing.ClassVar[type] = (
        nodetool.nodes.nodetool.list.Transform.TransformType
    )
    values: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )
    transform_type: nodetool.nodes.nodetool.list.Transform.TransformType = Field(
        default=nodetool.nodes.nodetool.list.Transform.TransformType.TO_STRING,
        description=None,
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Transform

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.nodetool.list
from nodetool.workflows.base_node import BaseNode


class Union(SingleOutputGraphNode[list[Any]], GraphNode[list[Any]]):
    """
    Combines unique elements from two lists.
    list, set, union, combine

    Use cases:
    - Merge lists while removing duplicates
    - Combine collections uniquely
    - Create comprehensive set of items
    """

    list1: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )
    list2: list[Any] | OutputHandle[list[Any]] = connect_field(
        default=[], description=None
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.nodetool.list.Union

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
