# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.openai.text
from nodetool.workflows.base_node import BaseNode


class Embedding(SingleOutputGraphNode[types.NPArray], GraphNode[types.NPArray]):
    """

    Generate vector representations of text for semantic analysis.
    embeddings, similarity, search, clustering, classification

    Uses OpenAI's embedding models to create dense vector representations of text.
    These vectors capture semantic meaning, enabling:
    - Semantic search
    - Text clustering
    - Document classification
    - Recommendation systems
    - Anomaly detection
    - Measuring text similarity and diversity
    """

    EmbeddingModel: typing.ClassVar[type] = (
        nodetool.nodes.openai.text.Embedding.EmbeddingModel
    )

    input: str | OutputHandle[str] = connect_field(default="", description=None)
    model: nodetool.nodes.openai.text.Embedding.EmbeddingModel = Field(
        default=nodetool.nodes.openai.text.Embedding.EmbeddingModel.TEXT_EMBEDDING_3_SMALL,
        description=None,
    )
    chunk_size: int | OutputHandle[int] = connect_field(default=4096, description=None)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.openai.text.Embedding

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.openai.text
from nodetool.workflows.base_node import BaseNode


class Moderation(GraphNode[nodetool.nodes.openai.text.Moderation.OutputType]):
    """

    Check text content for potential policy violations using OpenAI's moderation API.
    moderation, safety, content, filter, policy, harmful, toxic

    Uses OpenAI's moderation models to detect potentially harmful content including:
    - Hate speech
    - Harassment
    - Self-harm content
    - Sexual content
    - Violence
    - Graphic violence

    Returns flagged status and category scores for comprehensive content analysis.
    """

    ModerationModel: typing.ClassVar[type] = nodetool.nodes.openai.text.ModerationModel

    input: str | OutputHandle[str] = connect_field(
        default="", description="The text content to check for policy violations."
    )
    model: nodetool.nodes.openai.text.ModerationModel = Field(
        default=nodetool.nodes.openai.text.ModerationModel.OMNI_MODERATION_LATEST,
        description="The moderation model to use.",
    )

    @property
    def out(self) -> "ModerationOutputs":
        return ModerationOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.openai.text.Moderation

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class ModerationOutputs(OutputsProxy):
    @property
    def flagged(self) -> OutputHandle[bool]:
        return typing.cast(OutputHandle[bool], self["flagged"])

    @property
    def categories(self) -> OutputHandle[dict[str, bool]]:
        return typing.cast(OutputHandle[dict[str, bool]], self["categories"])

    @property
    def category_scores(self) -> OutputHandle[dict[str, float]]:
        return typing.cast(OutputHandle[dict[str, float]], self["category_scores"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.openai.text
from nodetool.workflows.base_node import BaseNode


class WebSearch(SingleOutputGraphNode[str], GraphNode[str]):
    """

    ðŸ” OpenAI Web Search - Searches the web using OpenAI's web search capabilities.

    This node uses an OpenAI model equipped with web search functionality
    (like gpt-4o with search preview) to answer queries based on current web information.
    Requires an OpenAI API key.
    """

    query: str | OutputHandle[str] = connect_field(
        default="", description="The search query to execute."
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.openai.text.WebSearch

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
